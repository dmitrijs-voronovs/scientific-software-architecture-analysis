quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,// In theory the deleted node could also have been scheduled for analysis.; // So remove it from the set of nodes which will be analyzed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp:51,schedul,scheduled,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// In theory, this is combinatorial. In practice, it needs to be bounded; // by a small number of sets for regpressure to be efficient.; // If the assert is hit, we need to implement pruning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:125,efficient,efficient,125,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['efficient'],['efficient']
Energy Efficiency,// In this case we reduced the bound check to a comparison of the form; // (symbol or value with unsigned type) < (negative number); // which is always false. We are handling these cases separately because; // evalBinOpNN can perform a signed->unsigned conversion that turns the; // negative number into a huge positive value and leads to wildly; // inaccurate conclusions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:19,reduce,reduced,19,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// In this case, we can use a refined formula for computing backedge taken; // count. The general formula remains:; // ""End-Start /uceiling Stride"" where ""End = max(RHS,Start)""; // We want to use the alternate formula:; // ""((End - 1) - (Start - Stride)) /u Stride""; // Let's do a quick case analysis to show these are equivalent under; // our precondition that max(RHS,Start) > Start - Stride.; // * For RHS <= Start, the backedge-taken count must be zero.; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((Start - 1) - (Start - Stride)) /u Stride"" which simplies to; // ""Stride - 1 /u Stride"" which is indeed zero for all non-zero values; // of Stride. For 0 stride, we've use umin(1,Stride) above, reducing; // this to the stride of 1 case.; // * For RHS >= Start, the backedge count must be ""RHS-Start /uceil Stride"".; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((RHS - 1) - (Start - Stride)) /u Stride"" reassociates to; // ""((RHS - (Start - Stride) - 1) /u Stride"".; // Our preconditions trivially imply no overflow in that form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:505,reduce,reduces,505,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['reduce'],['reduces']
Energy Efficiency,"// In this polynominal, we may have some zero operands, and we shouldn't; // really charge for those. So how many non-zero coefficients are there?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:84,charge,charge,84,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['charge'],['charge']
Energy Efficiency,// In threadgroup split mode LDS cannot be allocated so no need to wait for; // LDS memory operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:43,allocate,allocated,43,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// In unique continuation lowering, the continuations always return void.; // But we may have implicitly allocated storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:105,allocate,allocated,105,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Increase LiveOutRegsNumUsages for blocks; // producing registers consumed in another; // scheduling region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:92,schedul,scheduling,92,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Increase the SDNodeOrder for the DbgValue here to make sure it is; // inserted after the definition of Val when emitting the instructions; // after ISel. An alternative could be to teach; // ScheduleDAGSDNodes::EmitSchedule to delay the insertion properly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:194,Schedul,ScheduleDAGSDNodes,194,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['Schedul'],['ScheduleDAGSDNodes']
Energy Efficiency,// Increases the number of used scheduler queue slots of every buffered; // resource in the Buffers set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:32,schedul,scheduler,32,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,1,['schedul'],['scheduler']
Energy Efficiency,"// Increments for worksharing loops (LB = LB + ST; UB = UB + ST).; // Used for directives with static scheduling.; // In combined construct, add combined version that use CombLB and CombUB; // base variables for the update",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:102,schedul,scheduling,102,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Independency of collectReferencedValues's idea of reductive power,; // ensure the partial order of IsMoreReduced is enforced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp:63,power,power,63,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,1,['power'],['power']
Energy Efficiency,"// Index of the resources kind that contains this kind.; // Number of resources that may be buffered.; //; // Buffered resources (BufferSize != 0) may be consumed at some indeterminate; // cycle after dispatch. This should be used for out-of-order cpus when; // instructions that use this resource can be buffered in a reservaton; // station.; //; // Unbuffered resources (BufferSize == 0) always consume their resource some; // fixed number of cycles after dispatch. If a resource is unbuffered, then; // the scheduler will avoid scheduling instructions with conflicting resources; // in the same cycle. This is for in-order cpus, or the in-order portion of; // an out-of-order cpus.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:510,schedul,scheduler,510,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,"// Indexed by PSet ID; // InitSetPressure takes into account the register pressure of live-in; // registers. It's not depend on how the loop is scheduled, so it's enough to; // calculate them once at the beginning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:144,schedul,scheduled,144,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Indirect return; emit returned value directly into sret slot.; // This reduces code size, and affects correctness in C++.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:74,reduce,reduces,74,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Init the monitoring system",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFile.cxx:12,monitor,monitoring,12,net/netxng/src/TNetXNGFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFile.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// Initial particle energy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.h:20,energy,energy,20,test/RootShower/RootShower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.h,1,['energy'],['energy']
Energy Efficiency,// Initial value must be a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:27,power,power,27,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,"// Initialize buffer to hold the uncompressed data; // Note that in previous versions we didn't allocate buffers until we verified; // the zip headers; this is no longer beforehand as the buffer lifetime is scoped; // to the TBranch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:96,allocate,allocate,96,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// Initialize data structures for this pass. In particular, clear the; // swap vector and allocate the equivalence class mapping before; // processing each function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:90,allocate,allocate,90,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Initialize register live-range state for scheduling in this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:44,schedul,scheduling,44,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Initialize scheduling itinerary for the specified CPU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:14,schedul,scheduling,14,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,4,['schedul'],['scheduling']
Energy Efficiency,// Initialize state for a scheduling stage. Returns false if the current stage; // should be skipped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:26,schedul,scheduling,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,"// Initialize the critical path length limit, which used by the scheduling; // cost model to determine the value for scheduling an instruction. We use; // a slightly different heuristic for small and large functions. For small; // functions, it's important to use the height/depth of the instruction.; // For large functions, prioritizing by height or depth increases spills.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:64,schedul,scheduling,64,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,2,['schedul'],['scheduling']
Energy Efficiency,"// Initialize the final register residue.; // Any residue that occupies the final by-val arg register must be; // left-justified on AIX. Loads must be a power-of-2 size and cannot be; // larger than the ByValSize. For example: a 7 byte by-val arg requires 4,; // 2 and 1 byte loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,power,power-of-,153,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Insert TLV lowering at the start of the PostPrunePasses, since we want; // it to run before GOT/PLT lowering.; // TODO: Check that before the fixTLVSectionsAndEdges pass, the GOT/PLT build; // pass has done. Because the TLS descriptor need to be allocate in GOT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:249,allocate,allocate,249,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Insert a dbg.value where the linked dbg.assign is and remember to delete; // the dbg.assign later. Demoting to dbg.value isn't necessary for; // correctness but does reduce compile time and memory usage by reducing; // unnecessary function-local metadata. Remember that we've seen a; // dbg.assign for each variable fragment for the untracked store handling; // (after this loop).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:169,reduce,reduce,169,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Insert mul/fmul and llvm.vector.reduce.fadd,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:35,reduce,reduce,35,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Insert over-defined values into their own cache to reduce memory; // overhead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:54,reduce,reduce,54,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Insert pseudo probe to non-cold blocks only. This will reduce IR size as; // well as the binary size while retaining the profile quality.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:58,reduce,reduce,58,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Insert the element into the desired chunk.; // Since NumEltsIn128 is a power of 2 we can use mask instead of modulo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:74,power,power,74,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// Instantiate the selected scheduler for this target, function, and; // optimization level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,schedul,scheduler,28,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduler']
Energy Efficiency,// Instruction is waiting in the scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:33,schedul,scheduler,33,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,1,['schedul'],['scheduler']
Energy Efficiency,// Instruction selection strategy for this Scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:43,Schedul,Scheduler,43,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['Schedul'],['Scheduler']
Energy Efficiency,"// Instructions dispatched to the Scheduler are internally classified based on; // the instruction stage (see Instruction::InstrStage).; //; // An Instruction dispatched to the Scheduler is added to the WaitSet if not; // all its register operands are available, and at least one latency is; // unknown. By construction, the WaitSet only contains instructions that are; // in the IS_DISPATCHED stage.; //; // An Instruction transitions from the WaitSet to the PendingSet if the; // instruction is not ready yet, but the latency of every register read is; // known. Instructions in the PendingSet can only be in the IS_PENDING or; // IS_READY stage. Only IS_READY instructions that are waiting on memory; // dependencies can be added to the PendingSet.; //; // Instructions in the PendingSet are immediately dominated only by; // instructions that have already been issued to the underlying pipelines. In; // the presence of bottlenecks caused by data dependencies, the PendingSet can; // be inspected to identify problematic data dependencies between; // instructions.; //; // An instruction is moved to the ReadySet when all register operands become; // available, and all memory dependencies are met. Instructions that are; // moved from the PendingSet to the ReadySet must transition to the 'IS_READY'; // stage.; //; // On every cycle, the Scheduler checks if it can promote instructions from the; // PendingSet to the ReadySet.; //; // An Instruction is moved from the ReadySet to the `IssuedSet` when it starts; // exection. This event also causes an instruction state transition (i.e. from; // state IS_READY, to state IS_EXECUTING). An Instruction leaves the IssuedSet; // only when it reaches the write-back stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:34,Schedul,Scheduler,34,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,3,['Schedul'],['Scheduler']
Energy Efficiency,// Instrument vector.reduce.and intrinsic.; // Valid (non-poisoned) unset bits in the operand pull down the; // corresponding shadow bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:21,reduce,reduce,21,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Instrument vector.reduce.or intrinsic.; // Valid (non-poisoned) set bits in the operand pull low the; // corresponding shadow bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:21,reduce,reduce,21,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Integer VTs are lowered as a series of ""RISCVISD::TRUNCATE_VECTOR_VL""; // nodes which truncate by one power of two at a time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:105,power,power,105,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// Interface for PROOF monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TProofMonSender.h:23,monitor,monitoring,23,proof/proofplayer/inc/TProofMonSender.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TProofMonSender.h,2,['monitor'],['monitoring']
Energy Efficiency,// Interfaces to the major aspects of target machine information:; //; // -- Instruction opcode and operand information; // -- Pipelines and scheduling information; // -- Stack frame information; // -- Selection DAG lowering information; // -- Call lowering information; //; // N.B. These objects may change during compilation. It's not safe to cache; // them between functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:141,schedul,scheduling,141,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,// Internally track how many things we've allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:42,allocate,allocated,42,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Internally, we store the backend type with an enum to be more memory efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/inc/RooFit/Detail/JSONInterface.h:72,efficient,efficient,72,roofit/jsoninterface/inc/RooFit/Detail/JSONInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/inc/RooFit/Detail/JSONInterface.h,1,['efficient'],['efficient']
Energy Efficiency,"// Interrupt handlers don't save off the VFP regs automatically on ARM,; // so there's some risk when calling out to non-interrupt handler functions; // that the callee might not preserve them. This is easy to diagnose here,; // but can be very challenging to debug.; // Likewise, X86 interrupt handlers may only call routines with attribute; // no_caller_saved_registers since there is no efficient way to; // save and restore the non-GPR state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:390,efficient,efficient,390,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['efficient'],['efficient']
Energy Efficiency,// IntervalPartition ctor - Build a reduced interval partition from an; // existing interval graph. This takes an additional boolean parameter to; // distinguish it from a copy constructor. Always pass in false for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:36,reduce,reduced,36,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,2,['reduce'],['reduced']
Energy Efficiency,"// Intrinsics don't have function bodies that are useful to; // reduce. Additionally, intrinsics may have additional operand; // constraints. But, do drop intrinsics that are not referenced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceFunctions.cpp:64,reduce,reduce,64,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceFunctions.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Invoke the target's selection of scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:36,schedul,scheduler,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Is the constant a known power of 2?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:27,power,power,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['power'],['power']
Energy Efficiency,// Is the operand of a splat vector a constant power of two?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:47,power,power,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['power'],['power']
Energy Efficiency,// Is the scheduled region resource limited vs. latency limited.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:10,schedul,scheduled,10,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduled']
Energy Efficiency,// Is this class generated from a variants if existing classes? Instructions; // are never mapped directly to inferred scheduling classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h:119,schedul,scheduling,119,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h,1,['schedul'],['scheduling']
Energy Efficiency,// IsotopeInfo; /* ------- ReadLine ------- */; /* Reads one line and allocates a string for it */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSElements.cxx:70,allocate,allocates,70,test/periodic/XSElements.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSElements.cxx,1,['allocate'],['allocates']
Energy Efficiency,// Issue a warning if the target is not powerpc and Section is a *coal* section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp:40,power,powerpc,40,interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,1,['power'],['powerpc']
Energy Efficiency,// Issue instructions scheduled for this cycle,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/InOrderIssueStage.cpp:22,schedul,scheduled,22,interpreter/llvm-project/llvm/lib/MCA/Stages/InOrderIssueStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/InOrderIssueStage.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// IssueWidth is the maximum number of instructions that may be scheduled in; // the same per-cycle group. This is meant to be a hard in-order constraint; // (a.k.a. ""hazard""). In the GenericScheduler strategy, no more than; // IssueWidth micro-ops can ever be scheduled in a particular cycle.; //; // In practice, IssueWidth is useful to model any bottleneck between the; // decoder (after micro-op expansion) and the out-of-order reservation; // stations or the decoder bandwidth itself. If the total number of; // reservation stations is also a bottleneck, or if any other pipeline stage; // has a bandwidth limitation, then that can be naturally modeled by adding an; // out-of-order processor resource.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:64,schedul,scheduled,64,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,2,['schedul'],['scheduled']
Energy Efficiency,// It doesn't make sense to generate debug info for PowerPC MMA vector types.; // So we return a safe type here to avoid generating an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:52,Power,PowerPC,52,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// It is cheaper to fully construct the resulting range on stack; // and move it to the freshly allocated buffer if we don't have; // a set like this already.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:96,allocate,allocated,96,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// It is common for the tokens immediately after a /**/ comment to be; // whitespace. Instead of going through the big switch, handle it; // efficiently now. This is safe even in KeepWhitespaceMode because we would; // have already returned above with the comment as a token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:141,efficient,efficiently,141,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// It is generally beneficial to rewrite ""fmov s0, wzr"" to ""movi d0, #0"".; // as movi is more efficient across all cores. Newer cores can eliminate; // fmovs early and there is no difference with movi, but this not true for; // all implementations.; //; // The floating-point version doesn't quite work in rare cases on older; // CPUs, so on those targets we lower this instruction to movi.16b instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp:94,efficient,efficient,94,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,1,['efficient'],['efficient']
Energy Efficiency,// It seems reasonable to assume that we can reduce the effective; // cost of the checks even when we know nothing about the trip; // count. Assume that the outer loop executes at least twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:45,reduce,reduce,45,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['reduce'],['reduce']
Energy Efficiency,// It was a declaration for our prototype. This entry was allocated in the; // beginning. Update the count to match the existing declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp:58,allocate,allocated,58,interpreter/llvm-project/llvm/lib/IR/Module.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Module.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// It would've been a perfect place to use llvm::PointerIntPair, but; // unfortunately NumLowBitsAvailable for clang::Expr had been reduced to 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:132,reduce,reduced,132,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['reduce'],['reduced']
Energy Efficiency,// It's important not to confuse this and the previous function. Delegating; // constructors are the C++0x feature. The constructor delegate optimization; // is used to reduce duplication in the base and complete consturctors where; // they are substantially the same.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:169,reduce,reduce,169,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['reduce'],['reduce']
Energy Efficiency,"// It's possible for a kernarg intrinsic call to appear in a kernel with; // no allocated segment, in which case we do not add the user sgpr; // argument, so just return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:80,allocate,allocated,80,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// It's possible that the number of elements remaining will be legal.; // This can happen with e.g. <7 x float> when <3 x float> is legal.; // This only needs to be separately checked if it's not a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:198,power,power,198,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['power'],['power']
Energy Efficiency,// It's possible we found a scheduling region that only has debug; // instructions. Don't bother scheduling these.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,schedul,scheduling,28,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// It's tempting to preserve nsw on Bump and/or Reduced. However, it's; // usually unsound, e.g.,; //; // X = (-2 +nsw 1) *nsw INT_MAX; // Y = (-2 +nsw 3) *nsw INT_MAX; // =>; // Y = X + 2 * INT_MAX; //; // Neither + and * in the resultant expression are nsw.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:48,Reduce,Reduced,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['Reduce'],['Reduced']
Energy Efficiency,// It's unknown whether a scalable vector has a power-of-2 bitwidth.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:48,power,power-of-,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,// Iterate over each instruction that has been scheduled already. The start; // slot computation depends on whether the previously scheduled instruction; // is a predecessor or successor of the specified instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:47,schedul,scheduled,47,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// Iterate through all the operands of the possible reduction tree and; // gather all the reduced values, sorting them by their value id.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:90,reduce,reduced,90,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Iterates, element-by-element, through the source Reduce list and; // make a copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:52,Reduce,Reduce,52,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Iteratively collect the base of each factor with an add power into the; // outer product, and halve each power in preparation for squaring the; // expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:59,power,power,59,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['power'],['power']
Energy Efficiency,"// Iteratively try to duplicate again. It can happen that a block that is; // duplicated into is still small enough to be duplicated again.; // No need to call markBlockSuccessors in this case, as the blocks being; // duplicated from here on are already scheduled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:254,schedul,scheduled,254,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Iterator to walk set bits in the bitmap. This iterator is a lot uglier; // than it would be, in order to be efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:111,efficient,efficient,111,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,1,['efficient'],['efficient']
Energy Efficiency,// Just allocate enough space up front. We'll shrink it later. Allocate; // enough that we can fit a null terminator without reallocating.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp:8,allocate,allocate,8,interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp,4,"['Allocate', 'allocate']","['Allocate', 'allocate']"
Energy Efficiency,// Just an adaptor to switch the order of argument and have the predicate before; // the zipped inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:11,adapt,adaptor,11,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['adapt'],['adaptor']
Energy Efficiency,"// Just like in the no inference case, this will allocate an appropriately; // sized buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InteractiveModelRunner.cpp:49,allocate,allocate,49,interpreter/llvm-project/llvm/lib/Analysis/InteractiveModelRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InteractiveModelRunner.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Keep a map of the MachineInstr*'s back to the SUnit representing them.; // This is used for updating debug information.; //; // FIXME: Replace this with the existing map in ScheduleDAGInstrs::MISUnitMap,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:176,Schedul,ScheduleDAGInstrs,176,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['Schedul'],['ScheduleDAGInstrs']
Energy Efficiency,"// Keep an ""already allocated"" mapping of section target addresses to sizes.; // Sections whose address mappings aren't specified on the command line will; // allocated around the explicitly mapped sections while maintaining the; // minimum separation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp:20,allocate,allocated,20,interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,2,['allocate'],['allocated']
Energy Efficiency,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:94,reduce,reduce,94,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,6,"['reduce', 'schedul']","['reduce', 'scheduler']"
Energy Efficiency,"// Keep exactly 32-bit imm64, this is zext i32 -> i64 which is; // extremely efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:77,efficient,efficient,77,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Keep increasing II until a valid schedule is found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:36,schedul,schedule,36,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Keep managed variables even if they are not used in device code since; // they need to be allocated by the runtime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:93,allocate,allocated,93,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Keep the ReverseNonLocalDeps map up to date so we can efficiently; // update this when we remove instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,efficient,efficiently,57,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently; // update MemDep when we remove instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:60,efficient,efficiently,60,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Keep the compile time impact low by only adapting the inserted block; // of instructions in the OrigPreHeader. This might result in slightly; // more aliasing between these instructions and those that were already; // present, but it will be much faster when the original PreHeader is; // large.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:44,adapt,adapting,44,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['adapt'],['adapting']
Energy Efficiency,// Keep track of how many bytes we've allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:38,allocate,allocated,38,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['allocate'],['allocated']
Energy Efficiency,// Keep track of objects allocated on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:25,allocate,allocated,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['allocate'],['allocated']
Energy Efficiency,// Keep track of the instructions we localized. We'll do a second pass of; // intra-block localization to further reduce live ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp:114,reduce,reduce,114,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Localizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Keep track of the live range sets allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:37,allocate,allocated,37,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// LANDAU quantile : algorithm from CERNLIB G110 ranlan; // with scale parameter xi; // Converted by Rene Brun from CERNLIB routine ranlan(G110),; // Moved and adapted to QuantFuncMathCore by B. List 29.4.2010",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/QuantFuncMathCore.cxx:160,adapt,adapted,160,math/mathcore/src/QuantFuncMathCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/QuantFuncMathCore.cxx,1,['adapt'],['adapted']
Energy Efficiency,// LDS is allocated in 128 dword blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp:10,allocate,allocated,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,1,['allocate'],['allocated']
Energy Efficiency,// LDS is allocated in 64 dword blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp:10,allocate,allocated,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,1,['allocate'],['allocated']
Energy Efficiency,// LHS and RHS must be cast-expressions. We allow an arbitrary expression; // in the parser and reduce down to just cast-expressions here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:96,reduce,reduce,96,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// LHS is more reduced if it is defined further up the dominance tree. In a; // chain of definitions,; //; // %a = ..; // %b = op %a; // %c = op %b; //; // every use of %b can be replaced by %a, but not by a use of %c. That is, a; // use %c can be replaced in steps first by %b, then by %a, making %a the; // ""more reduced"" choice that skips over more instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp:15,reduce,reduced,15,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,2,['reduce'],['reduced']
Energy Efficiency,"// LLVM to CV regs mapping; /// Iterator class that can traverse the differentially encoded values in; /// DiffLists. Don't use this class directly, use one of the adaptors below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h:164,adapt,adaptors,164,interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,1,['adapt'],['adaptors']
Energy Efficiency,"// LLVM vector reduction intrinsics return a scalar result, but on RISC-V vector; // reduction instructions write the result in the first element of a vector; // register. So when a reduction in a loop uses a scalar phi, we end up with; // unnecessary scalar moves:; //; // loop:; // vfmv.s.f v10, fa0; // vfredosum.vs v8, v8, v10; // vfmv.f.s fa0, v8; //; // This mainly affects ordered fadd reductions, since other types of reduction; // typically use element-wise vectorisation in the loop body. This tries to; // vectorize any scalar phis that feed into a fadd reduction:; //; // loop:; // %phi = phi <float> [ ..., %entry ], [ %acc, %loop ]; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %phi, <vscale x 2 x float> %vec); //; // ->; //; // loop:; // %phi = phi <vscale x 2 x float> [ ..., %entry ], [ %acc.vec, %loop ]; // %phi.scalar = extractelement <vscale x 2 x float> %phi, i64 0; // %acc = call float @llvm.vector.reduce.fadd.nxv4f32(float %x, <vscale x 2 x float> %vec); // %acc.vec = insertelement <vscale x 2 x float> poison, float %acc.next, i64 0; //; // Which eliminates the scalar -> vector -> scalar crossing during instruction; // selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp:681,reduce,reduce,681,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// LM: change to use fNpx; // should we change code to use a root finder ?; // It should be more precise and more efficient",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:114,efficient,efficient,114,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['efficient'],['efficient']
Energy Efficiency,// LNT run (at least on Cyclone) showed reasonably significant gains for; // bi-directional scheduling. 253.perlbmk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp:92,schedul,scheduling,92,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:15,allocate,allocated,15,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,2,['allocate'],['allocated']
Energy Efficiency,// LVLGen should be called after scheduling and register allocation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp:33,schedul,scheduling,33,interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VETargetMachine.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Largest power of two less than or equal to x. As a special case, returns 1; // when x is 0. ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_impl.h:11,power,power,11,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_impl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_impl.h,1,['power'],['power']
Energy Efficiency,"// Last chance saloon. We don't try and solve the full isomorphism; // problem, but try and at least catch the case where two instructions; // *of different types* are round the wrong way. We won't be able to; // efficiently tell, given two ADD instructions, which way around we; // should match them, but given an ADD and a SUB, we can at least infer; // which one is which.; //; // This should allow us to deal with a greater subset of the isomorphism; // problem. It does however change a linear algorithm into a quadratic; // one, so limit the number of probes we do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:213,efficient,efficiently,213,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:119,Schedul,ScheduleData,119,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,"['Schedul', 'schedul']","['ScheduleData', 'scheduling']"
Energy Efficiency,"// Learning Rate Scheduler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:17,Schedul,Scheduler,17,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['Schedul'],['Scheduler']
Energy Efficiency,"// Let's synthesize the alignment argument in case we will need it.; // Since we *really* want to allocate these on stack, this is slightly ugly; // because there might not be a `std::align_val_t` type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:98,allocate,allocate,98,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Lightweight interface adaptor that binds a RooAbsPdf to TFOAM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFoamGenerator.cxx:25,adapt,adaptor,25,roofit/roofitcore/src/RooFoamGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFoamGenerator.cxx,1,['adapt'],['adaptor']
Energy Efficiency,"// Lightweight interface adaptors (caller takes ownership)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:25,adapt,adaptors,25,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['adapt'],['adaptors']
Energy Efficiency,"// Limit for the maximum number of stack slots we should track, past which we; // will ignore any spills. InstrRefBasedLDV gathers detailed information on all; // stack slots which leads to high memory consumption, and in some scenarios; // (such as asan with very many locals) the working set of the function can be; // very large, causing many spills. In these scenarios, it is very unlikely that; // the developer has hundreds of variables live at the same time that they're; // carefully thinking about -- instead, they probably autogenerated the code.; // When this happens, gracefully stop tracking excess spill slots, rather than; // consuming all the developer's memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:202,consumption,consumption,202,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['consumption'],['consumption']
Energy Efficiency,// Limit the number of tasks to MaxTasksPerGroup to limit job scheduling; // overhead on large inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h:62,schedul,scheduling,62,interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,2,['schedul'],['scheduling']
Energy Efficiency,"// Linearize DAG, no scheduling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:21,schedul,scheduling,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['schedul'],['scheduling']
Energy Efficiency,"// Linux kernels prior to 4.1 will sometimes locate the heap of a PIE binary; // relatively close to the stack (they are only guaranteed to be 128MiB; // apart). This results in crashes if we happen to heap-allocate more than; // 128MiB before we reach our stack high-water mark.; //; // To avoid these crashes, ensure that we have sufficient virtual memory; // pages allocated before we start running.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:207,allocate,allocate,207,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// List of the values that were reduced in other trees as part of gather; // nodes and thus requiring extract if fully vectorized in other trees.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,reduce,reduced,32,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Live ranges pass through a number of stages as we try to allocate them.; // Some of the stages may also create new live ranges:; //; // - Region splitting.; // - Per-block splitting.; // - Local splitting.; // - Spilling.; //; // Ranges produced by one of the stages skip the previous stages when they are; // dequeued. This improves performance because we can skip interference checks; // that are unlikely to give any results. It also guarantees that the live; // range splitting algorithm terminates, something that is otherwise hard to; // ensure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:60,allocate,allocate,60,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,1,['allocate'],['allocate']
Energy Efficiency,"// Lo/Hi may have been newly allocated, if so, add nodeid's as relevant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp:29,allocate,allocated,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,3,['allocate'],['allocated']
Energy Efficiency,"// LoCmp = lo(op1) < lo(op2) // Always unsigned comparison; // HiCmp = hi(op1) < hi(op2) // Signedness depends on operands; // dest = hi(op1) == hi(op2) ? LoCmp : HiCmp;; // NOTE: on targets without efficient SELECT of bools, we can always use; // this identity: (B1 ? B2 : B3) --> (B1 & B2)|(!B1&B3)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:199,efficient,efficient,199,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Load are scheduled for latency even if there instruction itinerary; // is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:12,schedul,scheduled,12,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Loading in vector unit is slightly more expensive.; // This is actually only true for the LD1R and co instructions,; // but anyway for the fast mode this number does not matter and; // for the greedy mode the cost of the cross bank copy will; // offset this number.; // FIXME: Should be derived from the scheduling model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp:307,schedul,scheduling,307,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// LocallyStreamingFunctions must insert the SMSTART in the correct; // position, so we use Glue to ensure no instructions can be scheduled; // between the chain of:; // t0: ch,glue = EntryNode; // t1: res,ch,glue = CopyFromReg; // ...; // tn: res,ch,glue = CopyFromReg t(n-1), ..; // t(n+1): ch, glue = SMSTART t0:0, ...., tn:2; // ^^^^^^; // This will be the new Chain/Root node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:130,schedul,scheduled,130,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Look for a push node. Iterates instead of recurses to reduce stack usage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp:57,reduce,reduce,57,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Look for an instruction of the form p' = op(p), which uses and defines; // two virtual registers that get allocated to the same physical register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:109,allocate,allocated,109,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Look for non-tied explicit vreg uses that have an active COPY; // instruction that defines the physical register allocated to them.; // Replace the vreg with the source of the active COPY.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:116,allocate,allocated,116,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Look for something like this; // PredBB; // / \; // Div Rem; //; // If the Rem and Din blocks share a unique predecessor, and all; // paths from PredBB go to either RemBB or DivBB, and execution of RemBB; // and DivBB will always reach the Div/Rem, we can hoist Div to PredBB.; // If we have a DivRem operation we can also hoist Rem. By hoisting both; // ops to the same block, we reduce code size and allow the DivRem to; // issue sooner. Without a DivRem op, this transformation is; // unprofitable because we would end up performing an extra Mul+Sub on; // the Rem path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:384,reduce,reduce,384,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Look up the analysis usage from the pass instance (different instances; // of the same pass can produce different results), but unique the; // resulting object to reduce memory usage. This helps to greatly reduce; // memory usage when we have many instances of only a few pass types; // (e.g. instcombine, simplifycfg, etc...) which tend to share a fixed set; // of dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:166,reduce,reduce,166,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// Loop over logicals -- it is much more efficient that way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:41,efficient,efficient,41,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['efficient'],['efficient']
Energy Efficiency,// Loop through the frame references and allocate for them as necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:41,allocate,allocate,41,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['allocate'],['allocate']
Energy Efficiency,// LoopBodyMBB: Allocate and probe by means of a volatile compare.; // J LoopTestMBB,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:16,Allocate,Allocate,16,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// Lower FP selects into a CMP/AND/ANDN/OR sequence when the necessary SSE ops; // are available or VBLENDV if AVX is available.; // Otherwise FP cmovs get lowered into a less efficient branch sequence later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:176,efficient,efficient,176,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Lower VECTOR_SHUFFLE into VSHF.; //; // This mostly consists of converting the shuffle indices in Indices into a; // BUILD_VECTOR and adding it as an operand to the resulting VSHF. There is; // also code to eliminate unused operands of the VECTOR_SHUFFLE. For example,; // if the type is v8i16 and all the indices are less than 8 then the second; // operand is unused and can be replaced with anything. We choose to replace it; // with the used operand since this reduces the number of instructions overall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:467,reduce,reduces,467,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Lower a non-power of 2 store into multiple pow-2 stores.; // E.g. split an i24 store into an i16 store + i8 store.; // We do this by first extending the stored value to the next largest power; // of 2 type, and then using truncating stores to store the components.; // By doing this, likewise with G_LOAD, generate an extend that can be; // artifact-combined away instead of leaving behind extracts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:15,power,power,15,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,['power'],['power']
Energy Efficiency,// Lower dynamic stack allocation to _alloca call for Cygwin/Mingw targets.; // Calls to _alloca are needed to probe the stack when allocating more than 4k; // bytes in one go. Touching the stack at 4K increments is necessary to ensure; // that the guard pages used by the OS virtual memory manager are allocated in; // correct sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:303,allocate,allocated,303,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['allocate'],['allocated']
Energy Efficiency,// Lower floating point store/load to integer store/load to reduce the number; // of patterns in tablegen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:60,reduce,reduce,60,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Lower generic MASSV routines to PowerPC subtarget-specific entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:35,Power,PowerPC,35,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Lower priority means schedule further down. For bottom-up scheduling, lower; // priority SUs are scheduled before higher priority SUs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:24,schedul,schedule,24,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,6,['schedul'],"['schedule', 'scheduled', 'scheduling']"
Energy Efficiency,// Lower range metadata from 0 to N to assert zext to an integer of nearest; // floor power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:86,power,power,86,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['power'],['power']
Energy Efficiency,// Lowers ISD::BUILD_VECTOR into appropriate SelectionDAG nodes for the; // backend.; //; // Lowers according to the following rules:; // - Constant splats are legal as-is as long as the SplatBitSize is a power of; // 2 less than or equal to 64 and the value fits into a signed 10-bit; // immediate; // - Constant splats are lowered to bitconverted BUILD_VECTORs if SplatBitSize; // is a power of 2 less than or equal to 64 and the value does not fit into a; // signed 10-bit immediate; // - Non-constant splats are legal as-is.; // - Non-constant non-splats are lowered to sequences of INSERT_VECTOR_ELT.; // - All others are illegal and must be expanded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:205,power,power,205,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,2,['power'],['power']
Energy Efficiency,"// MC efficiency monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:17,monitor,monitoring,17,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// MI will become a KILL, don't considers it in scheduling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp:48,schedul,scheduling,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// MS x64 ABI requirement: ""Any argument that doesn't fit in 8 bytes, or is; // not 1, 2, 4, or 8 bytes, must be passed by reference.""; // However, non-power-of-two bit-precise integers will be passed as 1, 2, 4,; // or 8 bytes anyway as long is it fits in them, so we don't have to check; // the power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:152,power,power-of-two,152,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,2,['power'],"['power', 'power-of-two']"
Energy Efficiency,"// MSVC always allocates fields in the tail-padding of a base class; // subobject, even if they're POD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h:15,allocate,allocates,15,interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,1,['allocate'],['allocates']
Energy Efficiency,// MSVC/link.exe seems to align symbols to the next-power-of-2; // up to 32 bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp:52,power,power-of-,52,interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Machine instruction info.; // Two CFG edges are related if they leave the same block, or enter the same; // block. The transitive closure of an edge under this relation is a; // LiveBundle. It represents a set of CFG edges where the live FP stack; // registers must be allocated identically in the x87 stack.; //; // A LiveBundle is usually all the edges leaving a block, or all the edges; // entering a block, but it can contain more edges if critical edges are; // present.; //; // The set of live FP registers in a LiveBundle is calculated by bundleCFG,; // but the exact mapping of FP registers to stack slots is fixed later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp:272,allocate,allocated,272,interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FloatingPoint.cpp,1,['allocate'],['allocated']
Energy Efficiency,// MachineBasicBlocks are allocated and owned by MachineFunction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:26,allocate,allocated,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['allocate'],['allocated']
Energy Efficiency,// MachineInstrs are pool-allocated and owned by MachineFunction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:26,allocate,allocated,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['allocate'],['allocated']
Energy Efficiency,// Maintain an efficient lookup of params we have seen so far.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:15,efficient,efficient,15,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Make a new scheduling region, i.e. all existing ScheduleData is not; // in the new region yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,schedul,scheduling,14,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Schedul', 'schedul']","['ScheduleData', 'scheduling']"
Energy Efficiency,// Make data dependencies from the FirstSU also dependent on the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:105,schedul,scheduled,105,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Make sure one of the select arms is a power-of-2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:41,power,power-of-,41,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Make sure that CutRange() also considers the variables not selected by; // SelectVars() in RooAbsData::reduce().; //; // Covers JIRA issue ROOT-8040.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx:106,reduce,reduce,106,roofit/roofitcore/test/testRooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// Make sure that SmallSize is a power of two, round up if not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:33,power,power,33,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,1,['power'],['power']
Energy Efficiency,"// Make sure that the failed-module structure has been allocated in; // the importing instance, and propagate the pointer to the newly-created; // instance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:55,allocate,allocated,55,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Make sure that the number of chunks does not change as we reduce.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp:61,reduce,reduce,61,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Make sure that the scheduling region contains all; // instructions of the bundle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,schedul,scheduling,22,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Make sure that we reprocess all operands now that we reduced their; // use counts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:56,reduce,reduced,56,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,1,['reduce'],['reduced']
Energy Efficiency,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:39,allocate,allocated,39,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,4,['allocate'],['allocated']
Energy Efficiency,// Make sure the extended qualifier info is allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:44,allocate,allocated,44,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Make sure the offset is inside the object, or we might fail to; // allocate an emergency spill slot. (An out-of-range access is UB, but; // it could show up anyway.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:70,allocate,allocate,70,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Make sure the unique query tag is available as TNamed object in the; // input list so that it can be used in TSelectors for monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:127,monitor,monitoring,127,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['monitor'],['monitoring']
Energy Efficiency,// Make sure this is inserted after any VALU ops that may have been; // scheduled in between.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp:72,schedul,scheduled,72,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Make sure this isn't a vector of 1 element. The perf win from using; // MOVMSK diminishes with less elements in the reduction, but it is; // generally better to get the comparison over to the GPRs as soon as; // possible to reduce the number of vector ops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:227,reduce,reduce,227,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Make sure to attach to the process (and wait for the sigstop to be; // delivered and for the process to continue) before we write to the counter; // file descriptor. Attaching to the process before writing to the socket; // ensures that the subprocess at most has blocked on the read call. If we; // attach afterwards, the subprocess might exit before we get to the attach; // call due to effects like scheduler contention, introducing transient; // failures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:405,schedul,scheduler,405,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Make sure we allocate in-order, to get the cheapest registers first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:16,allocate,allocate,16,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Make sure we don't affect potential future NoRerun CGSCC adaptors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:60,adapt,adaptors,60,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['adapt'],['adaptors']
Energy Efficiency,// Make sure we've allocated the Common pointer first. We do this before; // VisitTemplateDecl so that getCommonPtr() can be used during initialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:19,allocate,allocated,19,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Make the FirstSU also dependent on the dependencies of the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:102,schedul,scheduled,102,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:218,Schedul,ScheduleDAGInstrs,218,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['Schedul'],['ScheduleDAGInstrs']
Energy Efficiency,// Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid; // unnecessary illegal types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:49,power,power-of-,49,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['power'],['power-of-']
Energy Efficiency,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:689,allocate,allocate,689,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Manually destroy all the blocks. They are almost all harmless,; // but primitive arrays might have an InitMap* heap allocated and; // that needs to be freed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:119,allocate,allocated,119,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h,1,['allocate'],['allocated']
Energy Efficiency,"// Manually set up the operand list. This node type is special in that it's; // always stack allocated and SelectionDAG does not manage its operands.; // TODO: This should either (a) not be in the SDNode hierarchy, or (b) not; // be so special.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:93,allocate,allocated,93,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['allocate'],['allocated']
Energy Efficiency,// Manually specify the child process for remote execution. This overrides; // the simulated remote execution that allocates address space for child; // execution. The child process will be executed and will communicate with; // lli via stdin/stdout pipes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:115,allocate,allocates,115,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['allocate'],['allocates']
Energy Efficiency,// Map all uses of llvm.coro.begin to the allocated frame pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:42,allocate,allocated,42,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,2,['allocate'],['allocated']
Energy Efficiency,// Map each SU to its summary of pressure changes. This array is updated for; // liveness during bottom-up scheduling. Top-down scheduling may proceed but; // has no affect on the pressure diffs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:107,schedul,scheduling,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduling']
Energy Efficiency,"// MapReduce; // Redefinition of the MapReduce classes of the base class, to adapt them to; // TProcessExecutor's logic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/ROOT/TProcessExecutor.hxx:77,adapt,adapt,77,core/multiproc/inc/ROOT/TProcessExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/ROOT/TProcessExecutor.hxx,1,['adapt'],['adapt']
Energy Efficiency,"// MapReduce; // The trailing return types check at compile time that func is compatible with the type of the arguments.; // A static_assert check in TExecutorCRTP<SubC>::Reduce is used to check that redfunc is compatible with the type returned by func",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TExecutorCRTP.hxx:171,Reduce,Reduce,171,core/base/inc/ROOT/TExecutorCRTP.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TExecutorCRTP.hxx,1,['Reduce'],['Reduce']
Energy Efficiency,"// MapReduce; // the late return types also check at compile-time whether redfunc is compatible with func,; // other than checking that func is compatible with the type of arguments.; // a static_assert check in TExecutor::Reduce is used to check that redfunc is compatible with the type returned by func",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx:223,Reduce,Reduce,223,core/imt/inc/ROOT/TExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx,1,['Reduce'],['Reduce']
Energy Efficiency,"// MapReduce; // the late return types also check at compile-time whether redfunc is compatible with func,; // other than checking that func is compatible with the type of arguments.; // a static_assert check in TSequentialExecutor::Reduce is used to check that redfunc is compatible with the type returned by func",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TSequentialExecutor.hxx:233,Reduce,Reduce,233,core/base/inc/ROOT/TSequentialExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TSequentialExecutor.hxx,1,['Reduce'],['Reduce']
Energy Efficiency,"// MapReduce; //; // We need to reimplement the MapReduce interfaces to allow for parallel reduction, defined in; // this class but not in the base class.; //; // the late return types also check at compile-time whether redfunc is compatible with func,; // other than checking that func is compatible with the type of arguments.; // a static_assert check in TThreadExecutor::Reduce is used to check that redfunc is compatible with the type returned by func",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx:375,Reduce,Reduce,375,core/imt/inc/ROOT/TThreadExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx,1,['Reduce'],['Reduce']
Energy Efficiency,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:362,allocate,allocate,362,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Mark the entire block as allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:28,allocate,allocated,28,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['allocate'],['allocated']
Energy Efficiency,// Mark the registers allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:22,allocate,allocated,22,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Mark this as an allocated normal function, and leave the rest alone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:19,allocate,allocated,19,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Mark variable as allocated:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:20,allocate,allocated,20,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Markup element types to be allocated by the tokenizer.; // Do not confuse with .type field in TGHtmlElement",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:30,allocate,allocated,30,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['allocate'],['allocated']
Energy Efficiency,// Mask+1 is not a power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:19,power,power,19,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// Match (binop (reduce (extract_subvector V, 0),; // (extract_vector_elt V, sizeof(SubVec)))); // into a reduction of one more element from the original vector V.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:17,reduce,reduce,17,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Match a multiply with a disguised negated-power-of-2 and convert to a; // an equivalent shift-left amount.; // Example: (X * MulC) + Op1 --> Op1 - (X << log2(-MulC)),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:45,power,power-of-,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,// Match an 'is positive' or 'is negative' comparison of remainder by a; // constant power-of-2 value:; // (X % pow2C) sgt/slt 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,power,power-of-,85,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Match canonical forms of min/max. We are not using ValueTracking's; // more powerful matchSelectPattern() because it may rely on instruction flags; // such as ""nsw"". That would be incompatible with the current hashing; // mechanism that may remove flags to increase the likelihood of CSE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:79,power,powerful,79,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['power'],['powerful']
Energy Efficiency,"// Match icmp ult (add %arg, C01), C1 (C1 == C01 << 1; powers of two)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:55,power,powers,55,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['power'],['powers']
Energy Efficiency,"// Match lowering of @llvm.vector.reduce.and. Turn; /// %vec_ne = icmp ne <8 x i8> %lhs, %rhs; /// %scalar_ne = bitcast <8 x i1> %vec_ne to i8; /// %res = icmp <pred> i8 %scalar_ne, 0; ///; /// into; ///; /// %lhs.scalar = bitcast <8 x i8> %lhs to i64; /// %rhs.scalar = bitcast <8 x i8> %rhs to i64; /// %res = icmp <pred> i64 %lhs.scalar, %rhs.scalar; ///; /// for <pred> in {ne, eq}.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,reduce,reduce,34,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Match the following IR pattern:; // %x.lowbits = and i8 %x, %lowbitmask; // %x.lowbits.are.zero = icmp eq i8 %x.lowbits, 0; // %x.biased = add i8 %x, %bias; // %x.biased.highbits = and i8 %x.biased, %highbitmask; // %x.roundedup = select i1 %x.lowbits.are.zero, i8 %x, i8 %x.biased.highbits; // Define:; // %alignment = add i8 %lowbitmask, 1; // Iff 1. an %alignment is a power-of-two (aka, %lowbitmask is a low bit mask); // and 2. %bias is equal to either %lowbitmask or %alignment,; // and 3. %highbitmask is equal to ~%lowbitmask (aka, to -%alignment); // then this pattern can be transformed into:; // %x.offset = add i8 %x, %lowbitmask; // %x.roundedup = and i8 %x.offset, %highbitmask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:375,power,power-of-two,375,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// Match the mathematical pattern A - (A / B) * B, where A and B can be; // arbitrary expressions. Also match zext (trunc A to iB) to iY, which is used; // for URem with constant power-of-2 second operands.; // It's not always easy, as A and B can be folded (imagine A is X / 2, and B is; // 4, A / B becomes X / 8).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:179,power,power-of-,179,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Match x86_64-*, i[3-9]86-*, powerpc-*, powerpc64-*, arm-*, thumb-*,; // armv[0-9]-*, thumbv[0-9]-*, armv5te-*, or armv6t2-*. The CPUType is a magic; // number from /usr/include/mach/machine.h. It is ok to reproduce the; // specific constants here because they are implicitly part of the Darwin ABI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:31,power,powerpc,31,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['power'],['powerpc']
Energy Efficiency,"// Match:; // mov t, x; // mov x, y; // mov y, t; //; // =>; //; // mov t, x (t is potentially dead and move eliminated); // v_swap_b32 x, y; //; // Returns next valid instruction pointer if was able to create v_swap_b32.; //; // This shall not be done too early not to prevent possible folding which may; // remove matched moves, and this should preferably be done before RA to; // release saved registers and also possibly after RA which can insert copies; // too.; //; // This is really just a generic peephole that is not a canonical shrinking,; // although requirements match the pass placement and it reduces code size too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp:607,reduce,reduces,607,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Matched reduce(ext(A)),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,reduce,reduce,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Matched reduce.add(ext(mul(ext(A), ext(B))); // Note that the extend opcodes need to all match, or if A==B they will have; // been converted to zext(mul(sext(A), sext(A))) as it is known positive,; // which is equally fine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,reduce,reduce,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Matched reduce.add(mul()),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,reduce,reduce,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Matched reduce.add(mul(ext(A), ext(B))), where the two ext may be of; // different sizes. We take the largest type as the ext to reduce, and add; // the remaining cost as, for example reduce(mul(ext(ext(A)), ext(B))).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,reduce,reduce,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,3,['reduce'],['reduce']
Energy Efficiency,"// Max out the number of statically allocated elements in DefinedRegsSet, as; // this prevents fallback to std::set::count() operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:36,allocate,allocated,36,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Memory accesses should only be reduced and can not be increased since AA; // just might return better results as a result of some transformations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:34,reduce,reduced,34,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Memory allocated by class without pointers and list elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/inc/TStructNode.h:10,allocate,allocated,10,graf3d/gviz3d/inc/TStructNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/inc/TStructNode.h,1,['allocate'],['allocated']
Energy Efficiency,"// Memory is allocated from a BumpPtrAllocator, no need to delete it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h:13,allocate,allocated,13,interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h,1,['allocate'],['allocated']
Energy Efficiency,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:32,Power,PowerPC,32,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,1,['Power'],['PowerPC']
Energy Efficiency,// Memory was allocated with BumpPtr allocator and is not freed here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:14,allocate,allocated,14,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Merge multiple continuous token deletions into one big deletion so that; // the number of replacements can be reduced. This makes computing affected; // ranges more efficient when we run reformat on the changed code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:113,reduce,reduced,113,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,2,"['efficient', 'reduce']","['efficient', 'reduced']"
Energy Efficiency,"// Merge sequences of 1-character nodes; // This greatly reduce the total number of nodes,; // and therefore the size of the index.; // When the tree gets serialized, we only have 5 bytes to store the; // size of a name. Overlong names (>32 characters) are therefore; // kep into separate nodes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp:57,reduce,reduce,57,interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// MicroOpBufferSize is the number of micro-ops that the processor may buffer; // for out-of-order execution.; //; // ""0"" means operations that are not ready in this cycle are not considered; // for scheduling (they go in the pending queue). Latency is paramount. This; // may be more efficient if many instructions are pending in a schedule.; //; // ""1"" means all instructions are considered for scheduling regardless of; // whether they are ready in this cycle. Latency still causes issue stalls,; // but we balance those stalls against other heuristics.; //; // ""> 1"" means the processor is out-of-order. This is a machine independent; // estimate of highly machine specific characteristics such as the register; // renaming pool and reorder buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:199,schedul,scheduling,199,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,4,"['efficient', 'schedul']","['efficient', 'schedule', 'scheduling']"
Energy Efficiency,"// Microsoft's link.exe doesn't support alignments greater than 32 bytes for; // common symbols, so symbols with greater alignment requirements cannot be; // common.; // Other COFF linkers (ld.bfd and LLD) support arbitrary power-of-two; // alignments for common symbols via the aligncomm directive, so this; // restriction only applies to MSVC environments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:224,power,power-of-two,224,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// Might need to reduce it to shared_ptr and STL collection.s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:17,reduce,reduce,17,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// Minor canonicalization of the accumulated shuffle mask to make it easier; // to match below. All this does is detect masks with sequential pairs of; // elements, and shrink them to the half-width mask. It does this in a loop; // so it will reduce the size of the mask to the minimal width mask which; // performs an equivalent shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:243,reduce,reduce,243,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['reduce'],['reduce']
Energy Efficiency,// Model data dependencies between instructions being scheduled and the; // ExitSU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:54,schedul,scheduled,54,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Modifier flags to be combined with schedule algorithms,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:38,schedul,schedule,38,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['schedul'],['schedule']
Energy Efficiency,"// Monitor good slaves",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:3,Monitor,Monitor,3,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['Monitor'],['Monitor']
Energy Efficiency,"// Monitor good workers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:3,Monitor,Monitor,3,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,2,['Monitor'],['Monitor']
Energy Efficiency,"// Monitor the performance (on TEST sample) versus number of trees",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:3,Monitor,Monitor,3,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['Monitor'],['Monitor']
Energy Efficiency,"// Monitor the socket",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:3,Monitor,Monitor,3,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['Monitor'],['Monitor']
Energy Efficiency,"// Monitoring for query performances using monitoring system (e.g. Monalisa, SQL, ...); //; // We support multiple specifications separated by ',' or '|' or '\' (the latter need; // top be escaped three times in the regular experession), e.g.; // ProofServ.Monitoring: Monalisa bla bla bla,; // +ProofServ.Monitoring: SQL blu blu blu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx:3,Monitor,Monitoring,3,proof/proofplayer/src/TPerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx,4,"['Monitor', 'monitor']","['Monitoring', 'monitoring']"
Energy Efficiency,"// More generally we can also handle non-constant power of 2 patterns such as; // shl/shr(Pow2, X), (X & -X), etc... by transforming:; // ctpop(Pow2OrZero) --> icmp ne X, 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:50,power,power,50,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['power'],['power']
Energy Efficiency,// More than one return type? Reduce it down to size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:30,Reduce,Reduce,30,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:143,allocate,allocated,143,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// Most bug reports are cached at the location where they occurred.; // With leaks, we want to unique them by the location where they were; // allocated, and only report a single path. To do this, we need to find; // the allocation site of a piece of tracked memory, which we do via a; // call to GetAllocationSite. This will walk the ExplodedGraph backwards.; // Note that this is *not* the trimmed graph; we are guaranteed, however,; // that all ancestor nodes that represent the allocation site have the; // same SourceLocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp:143,allocate,allocated,143,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Most markup uses this class. Some markup extends this class with; // additional information, but most use it as is, at the very least.; //; // If the markup doesn't have arguments (the ""count"" field of; // TGHtmlElement is 0) then the extra ""argv"" field of this class; // is not allocated and should not be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:282,allocate,allocated,282,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['allocate'],['allocated']
Energy Efficiency,"// Move all alloca's of zero byte objects to the entry block and merge them; // together. Note that we only do this for alloca's, because malloc should; // allocate and return a unique pointer, even for a zero byte allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:156,allocate,allocate,156,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Move an i32 or i64 value in a GPR to an f64 value in an FPR.; // FIXME: When direct register moves are implemented (see PowerISA 2.07),; // those should be used instead of moving via a stack slot when the; // subtarget permits.; // FIXME: The code here is sloppy for the 4-byte case. Can use a 4-byte; // stack slot and 4-byte store/load sequence. Or just sext the 4-byte; // case to 8 bytes which produces tighter code but wastes stack space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:123,Power,PowerISA,123,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['Power'],['PowerISA']
Energy Efficiency,"// Move the def index to the end of the previous region, to reflect; // that the def could theoretically have been scheduled at the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:115,schedul,scheduled,115,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Move the floating-point value in SrcReg into an integer destination; // register, and return the register (or zero if we can't handle it).; // FIXME: When direct register moves are implemented (see PowerISA 2.07),; // those should be used instead of moving via a stack slot when the; // subtarget permits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:201,Power,PowerISA,201,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['Power'],['PowerISA']
Energy Efficiency,"// Move the previously applied mappings (whether explicitly specified on the; // command line, or implicitly set by RuntimeDyld) into the already-allocated; // map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp:146,allocate,allocated,146,interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Move the scheduled instruction(s) to their dedicated places, if not; // there yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,schedul,scheduled,12,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Move unary shuffles with identical masks after a vector binop:; // VBinOp (shuffle A, Undef, Mask), (shuffle B, Undef, Mask)); // --> shuffle (VBinOp A, B), Undef, Mask; // This does not require type legality checks because we are creating the; // same types of operations that are in the original sequence. We do have to; // restrict ops like integer div that have immediate UB (eg, div-by-zero); // though. This code is adapted from the identical transform in instcombine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:425,adapt,adapted,425,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['adapt'],['adapted']
Energy Efficiency,// MultiKeywordSelector objects are not allocated with new because they have a; // variable size array (for parameter types) at the end of them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:40,allocate,allocated,40,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Multiple register uses are combined in the same SUnit. For example,; // we could have a set of glued nodes with all their defs consumed by; // another set of glued nodes. Register pressure tracking sees this as; // a single use, so to keep pressure balanced we reduce the defs.; //; // We can't tell (without more book-keeping) if this results from; // glued nodes or duplicate operands. As long as we don't reduce; // NumRegDefsLeft to zero, we handle the common cases well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:264,reduce,reduce,264,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// Multiplication of a power of two plus/minus one can be done more; // cheaply as shift+add/sub. For now, this is true unilaterally. If; // future CPUs have a cheaper MADD instruction, this may need to be; // gated on a subtarget feature. For Cyclone, 32-bit MADD is 4 cycles and; // 64-bit is 5 cycles, so this is always a win.; // More aggressively, some multiplications N0 * C can be lowered to; // shift+add+shift if the constant C = A * B where A = 2^N + 1 and B = 2^M,; // e.g. 6=3*2=(2+1)*2, 45=(1+4)*(1+8); // TODO: lower more cases.; // TrailingZeroes is used to test if the mul can be lowered to; // shift+add+shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:23,power,power,23,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// Must be a multiple of NumBytes (NumBytes is a power of 2),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:49,power,power,49,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['power'],['power']
Energy Efficiency,// Must be allocated the same register as specified value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h:11,allocate,allocated,11,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,1,['allocate'],['allocated']
Energy Efficiency,"// Mutexes to synchronize installing error handlers and calling error handlers.; // Do not use ManagedStatic, or that may allocate memory while attempting to; // report an OOM.; //; // This usage of std::mutex has to be conditionalized behind ifdefs because; // of this script:; // compiler-rt/lib/sanitizer_common/symbolizer/scripts/build_symbolizer.sh; // That script attempts to statically link the LLVM symbolizer library with the; // STL and hide all of its symbols with 'opt -internalize'. To reduce size, it; // cuts out the threading portions of the hermetic copy of libc++ that it; // builds. We can remove these ifdefs if that script goes away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:122,allocate,allocate,122,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,2,"['allocate', 'reduce']","['allocate', 'reduce']"
Energy Efficiency,"// N.B.: wait_for_child is identically defined in RooFit::MultiProcess, but we copy it here to reduce module; // interdependencies. It also requires an extra include:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp:95,reduce,reduce,95,roofit/roofitZMQ/test/test_ZMQ.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// NDEBUG; /// Count of predecessors of any block within the chain which have not; /// yet been scheduled. In general, we will delay scheduling this chain; /// until those predecessors are scheduled (or we find a sufficiently good; /// reason to override this heuristic.) Note that when forming loop chains,; /// blocks outside the loop are ignored and treated as if they were already; /// scheduled.; ///; /// Note: This field is reinitialized multiple times - once for each loop,; /// and then once for the function as a whole.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:96,schedul,scheduled,96,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,4,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"// NDEBUG; /// Insert a newly allocated node into the DAG.; ///; /// Handles insertion into the all nodes list and CSE map, as well as; /// verification and other common operations when a new node is allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:30,allocate,allocated,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['allocate'],['allocated']
Energy Efficiency,// NDEBUG; /// bu_ls_rr_sort - Priority function for bottom up register pressure; // reduction scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:95,schedul,scheduler,95,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// NOLINT: allocated memory now used by environment variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootx.cxx:11,allocate,allocated,11,rootx/src/rootx.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootx.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// NOTE: The alignment in the directive is a power of 2 value, the assembler; // may internally end up wanting an alignment in bytes.; // FIXME: Diagnose overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp:45,power,power,45,interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,3,['power'],['power']
Energy Efficiency,"// NOTE: The logic below is mostly geared towards LV, which calls it with; // vectors with 2 elements. We might want to improve that, if other; // users show up.; // Nontemporal vector loads/stores can be directly lowered to LDNP/STNP, if; // the vector can be halved so that each half fits into a register. That's; // the case if the element type fits into a register and the number of; // elements is a power of 2 > 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h:405,power,power,405,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,1,['power'],['power']
Energy Efficiency,"// NOTE: The symbols are all allocated out of a bump pointer allocator,; // we don't need to free them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:29,allocate,allocated,29,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// NOTE: We use the watcher instance as a RAII object to discard the handles; // for the directory in case of an error. Hence, this is early allocated,; // with the state being written directly to the watcher.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp:141,allocate,allocated,141,interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/windows/DirectoryWatcher-windows.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:276,allocate,allocates,276,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// NOTE: we now use the upper-bit of the fNevBufSize to see if we have serialized any of the; // optional IOBits. If that bit is set, we immediately read out the IOBits; to replace this; // (minimal) safeguard against corruption, we will set aside the upper-bit of fIOBits to do; // the same thing (the fact this bit is reserved is tested in the unit tests). If there is; // someday a need for more than 7 IOBits, we'll widen the field using the same trick.; //; // We like to keep this safeguard because we immediately will allocate a buffer based on; // the value of fNevBufSize -- and would like to avoid wildly inappropriate allocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:525,allocate,allocate,525,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['allocate'],['allocate']
Energy Efficiency,// Need to allocate on the dynamic memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:11,allocate,allocate,11,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Need to allocate the RVec if it is the first time the value is being created.; // See ""semantics of reading non-trivial objects"" in RNTuple's Architecture.md for details; // on the element construction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:11,allocate,allocate,11,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// Need to track reduced vals, they may be changed during vectorization of; // subvectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,reduce,reduced,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Needs the block to be scheduled inside; // TODO: find a way to compute it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:25,schedul,scheduled,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"// Negative power of 2 must be IntMin. It's possible to be able to; // prove negative / power of 2 without actually having known bits, so; // just get the value by hand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:12,power,power,12,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,2,['power'],['power']
Energy Efficiency,// New Access should not have more power than template access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:35,power,power,35,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['power'],['power']
Energy Efficiency,"// New file. If the file is writable create a new copy of the; // TMapFile which will now be allocated on the memory mapped heap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:93,allocate,allocated,93,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// NewMI may have dead implicit defs (E.g. EFLAGS for MOV<bits>r0 on X86).; // We need to remember these so we can add intervals once we insert; // NewMI into SlotIndexes.; //; // We also expect to have tied implicit-defs of super registers originating; // from SUBREG_TO_REG, such as:; // $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi; // undef %0.sub_32bit = MOV32r0 implicit-def dead $eflags, implicit-def %0; //; // The implicit-def of the super register may have been reduced to; // subregisters depending on the uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:487,reduce,reduced,487,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['reduce'],['reduced']
Energy Efficiency,// NewWidth might be greater than OrigWidth if OrigWidth is not a power of; // two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:66,power,power,66,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,2,['power'],['power']
Energy Efficiency,"// Next power in variable i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:8,power,power,8,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['power'],['power']
Energy Efficiency,"// Nilpotent means X op X === 0, so reduce weights modulo 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:36,reduce,reduce,36,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// No GC matches. Find a place to allocate a new GC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:34,allocate,allocate,34,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['allocate'],['allocate']
Energy Efficiency,// No Gro variable was allocated. Simply emit the call to; // get_return_object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:23,allocate,allocated,23,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['allocate'],['allocated']
Energy Efficiency,// No arguments to reduce,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceArguments.cpp:19,reduce,reduce,19,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceArguments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceArguments.cpp,1,['reduce'],['reduce']
Energy Efficiency,// No implementation for these ops for PowerPC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,Power,PowerPC,39,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// No need to allocate a matching input constraint since the constraint it's; // matching to has already been allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:14,allocate,allocate,14,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,4,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// No need to allocate data for non-schedulable instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,allocate,allocate,14,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['allocate', 'schedul']","['allocate', 'schedulable']"
Energy Efficiency,"// No need to allocate inscan exit block, in simd mode it is selected in the; // codegen for the scan directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:14,allocate,allocate,14,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,// No need to allocate memory and copy if the string has already been stored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/API.cpp:14,allocate,allocate,14,interpreter/llvm-project/clang/lib/ExtractAPI/API.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/API.cpp,1,['allocate'],['allocate']
Energy Efficiency,// No need to allocate space on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp:14,allocate,allocate,14,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16FrameLowering.cpp,2,['allocate'],['allocate']
Energy Efficiency,// No need to allocate static string literals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h:14,allocate,allocate,14,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,1,['allocate'],['allocate']
Energy Efficiency,"// No need to schedule PHIs, insertelement, extractelement and extractvalue; // instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,schedul,schedule,14,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// No one sane will ever try to calculate such huge exponents, but if we; // need this, we stop on UINT64_MAX / 2 because we need to exit the loop; // below when the power of 2 exceeds our Exponent, and we want it to be; // 1u << 31 at most to not deal with unsigned overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:166,power,power,166,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['power'],['power']
Energy Efficiency,// No other 'expermental.vector.reduce.*'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:32,reduce,reduce,32,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// No physical registers are allocated for instructions that are optimized; // in hardware. For example, zero-latency data-dependency breaking; // instructions don't consume physical registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:29,allocate,allocated,29,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['allocate'],['allocated']
Energy Efficiency,// No pre-allocated free block was large enough. Allocate a new memory region.; // Note that all sections get allocated as read-write. The permissions will; // be updated later based on memory group.; //; // FIXME: It would be useful to define a default allocation size (or add; // it as a constructor parameter) to minimize the number of allocations.; //; // FIXME: Initialize the Near member for each memory group to avoid; // interleaving.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:10,allocate,allocated,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,3,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,// No register need be allocated for this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:23,allocate,allocated,23,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// No special alignment.; // Note: for PPC32 SVR4ABI, we can still generate stackless; // code if all local vars are reg-allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:121,allocate,allocated,121,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// No the bin contents has to be reduced, as it was filled twice!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:33,reduce,reduced,33,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,9,['reduce'],['reduced']
Energy Efficiency,"// No valid Schedule Class Desc for schedClass, should be; // Pseudo/PostRAPseudo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:12,Schedul,Schedule,12,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['Schedul'],['Schedule']
Energy Efficiency,"// Node allocation functions.; //; // Node allocator is like a slab memory allocator: it allocates blocks of; // memory in sizes that are multiples of the size of a node. Each block has; // the same size. Nodes are allocated from the currently active block, and; // when it becomes full, a new one is created.; // There is a mapping scheme between node id and its location in a block,; // and within that block is described in the header file.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:89,allocate,allocates,89,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,2,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,// Node to Index from ScheduleDAGTopologicalSort,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:22,Schedul,ScheduleDAGTopologicalSort,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['Schedul'],['ScheduleDAGTopologicalSort']
Energy Efficiency,// Nodes are allocated sequentially. Edges for a node are stored together.; // The end of this Node's edges is the beginning of the next node's edges.; // An extra node was allocated to hold the end pointer for the last real; // node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h:13,allocate,allocated,13,interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,2,['allocate'],['allocated']
Energy Efficiency,// Non power of two memory access is never legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:7,power,power,7,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,1,['power'],['power']
Energy Efficiency,// Non-power of two alignment. This is not widely supported by assemblers.; // FIXME: Parameterize this based on MAI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:7,power,power,7,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,1,['power'],['power']
Energy Efficiency,"// Non-pseudo instructions that get changed for direct object; // only based on operand values.; // If this list of instructions get much longer we will move; // the check to a function call. Until then, this is more efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp:217,efficient,efficient,217,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsMCCodeEmitter.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Non-virtual adjustment might result in a pointer outside the allocated; // object, e.g. if the final overrider class is laid out after the virtual; // base that declares a method in the most derived class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:64,allocate,allocated,64,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Non-virtual adjustment might result in a pointer outside the allocated; // object, e.g. if the final overrider class is laid out after the virtual; // base that declares a method in the most derived class.; // FIXME: Update the code that emits this adjustment in thunks prologues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:64,allocate,allocated,64,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Non-zero Bytes indicates that we need to zero-fill everything. Otherwise,; // only the space allocated by CPV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:96,allocate,allocated,96,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,1,['allocate'],['allocated']
Energy Efficiency,// None of the adjustments above should have reduced the sum of factor powers; // below our mininum of '4'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:45,reduce,reduced,45,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,"['power', 'reduce']","['powers', 'reduced']"
Energy Efficiency,"// Noop unless the page source has a task scheduler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:42,schedul,scheduler,42,tree/ntuple/v7/src/RClusterPool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx,2,['schedul'],['scheduler']
Energy Efficiency,"// Normally we use ""Symbols:"" and ""DynamicSymbols:"" to describe contents of; // symbol tables. We also build and emit corresponding string tables; // implicitly. But sometimes it is important to preserve positions and virtual; // addresses of allocatable sections, e.g. for creating program headers.; // Generally we are trying to reduce noise in the YAML output. Because; // of that we do not print non-allocatable versions of such sections and; // assume they are placed at the end.; // We also dump symbol tables when the Size field is set. It happens when they; // are empty, which should not normally happen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp:331,reduce,reduce,331,interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Not allocated yet,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp:7,allocate,allocated,7,interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:71,reduce,reduce,71,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Not register pressure reduce patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,reduce,reduce,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Not scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:7,schedul,scheduled,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// Note for overrides: You must ensure for all element unordered-atomic; // memory intrinsics that all power-of-2 element sizes up to, and; // including, the return value of this method have a corresponding; // runtime lib call. These runtime lib call definitions can be found; // in RuntimeLibcalls.h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:103,power,power-of-,103,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,1,['power'],['power-of-']
Energy Efficiency,// Note that -1 is chosen to make clear() efficiently implementable with; // memset and because it's not a valid pointer value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:42,efficient,efficiently,42,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,1,['efficient'],['efficiently']
Energy Efficiency,"// Note that correctness does not rely on us adding things in; // their actual order of layout; it's just somewhat more efficient; // for the builder.; // With that in mind, add ""early"" C++ data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:120,efficient,efficient,120,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Note that it is legal to allocate a zero-length array, and we; // can never fold the check away because the length should always; // come from a cookie.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:28,allocate,allocate,28,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Note that it is not safe to speculate into a malloc'd region because; // malloc may return null.; // For GEPs, determine if the indexing lands within the allocated object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:157,allocate,allocated,157,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Note that it is safe to allocate CallExpr on the stack here because; // there are 0 arguments (i.e., nothing is allocated using ASTContext's; // allocator).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:27,allocate,allocate,27,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// Note that small stack changes could be implemented more efficiently; // with a few pop instructions instead of the 8-9 instructions now; // required.; // Select the best opcode to adjust SP based on the offset size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:59,efficient,efficiently,59,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Note that stalls will be negative for bottom-up scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:51,schedul,scheduling,51,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Note that the dstor for the contents of APSIntSet will never be called,; // so we iterate over the set and invoke the dstor for each APSInt. This; // frees an aux. memory allocated to represent very large constants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:174,allocate,allocated,174,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Note that the meanings of the ""object"" are slightly different in the; // following contexts:; // c1: llvm::getObjectSize(); // c2: llvm.objectsize() intrinsic; // c3: isObjectSmallerThan(); // c1 and c2 share the same meaning; however, the meaning of ""object"" in c3; // refers to the ""entire object"".; //; // Consider this example:; // char *p = (char*)malloc(100); // char *q = p+80;; //; // In the context of c1 and c2, the ""object"" pointed by q refers to the; // stretch of memory of q[0:19]. So, getObjectSize(q) should return 20.; //; // However, in the context of c3, the ""object"" refers to the chunk of memory; // being allocated. So, the ""object"" has 100 bytes, and q points to the middle; // the ""object"". In case q is passed to isObjectSmallerThan() as the 1st; // parameter, before the llvm::getObjectSize() is called to get the size of; // entire object, we should:; // - either rewind the pointer q to the base-address of the object in; // question (in this case rewind to p), or; // - just give up. It is up to caller to make sure the pointer is pointing; // to the base address the object.; //; // We go for 2nd option for simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:630,allocate,allocated,630,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Note that we lie to shouldClusterMemOps about the size of the; // cluster. When shouldClusterMemOps is called from the machine; // scheduler it limits the size of the cluster to avoid increasing; // register pressure too much, but this pass runs after register; // allocation so there is no need for that kind of limit.; // We also lie about the Offset and OffsetIsScalable parameters,; // as they aren't used in the SIInstrInfo implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp:134,schedul,scheduler,134,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Note this is backward to how you would expect. We create; // add(reduce(load + 16), reduce(load + 0)) so that the; // add(reduce(load+16), X) is combined into VADDVA(X, load+16)), leaving; // the X as VADDV(load + 0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:68,reduce,reduce,68,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['reduce'],['reduce']
Energy Efficiency,"// Note, VecElemTy is a power of 2, but might be less than one byte. For; // example, we can vectorize 2 x <2 x i4> to <4 x i4>, and in this case; // VecElemTy would be i4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:24,power,power,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['power'],['power']
Energy Efficiency,"// Note, first register is allocated in the beginning of function already,; // allocate remained amount of registers we need.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:27,allocate,allocated,27,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// Note: EvaluatedStmt contains an APValue, which usually holds; // resources not allocated from the ASTContext. We need to do some; // work to avoid leaking those, but we do so in VarDecl::evaluateValue; // where we can detect whether there's anything to clean up or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:82,allocate,allocated,82,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Note: Not byref as it's a POD and otherwise it's too easy to call; // G.setSanitizerMetadata(G2.getSanitizerMetadata()), and the argument becomes; // dangling when the backing storage allocates the metadata for `G`, as the; // storage is shared between `G1` and `G2`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:187,allocate,allocates,187,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['allocate'],['allocates']
Energy Efficiency,"// Note: Proxy-helper needs to ""embrace"" the entire; // streaming of this STL container if the container; // is a set/multiset/map/multimap (what we do not; // know here).; // For vector/list/deque Allocate == Resize; // and Commit == noop.; // TODO: Exception safety a la TPushPop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:198,Allocate,Allocate,198,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,// Note: The TypeSourceInfos for the arguments are allocated after the; // TypeTraitExpr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:51,allocate,allocated,51,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['allocate'],['allocated']
Energy Efficiency,"// Note: This may cause an object to be allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:40,allocate,allocated,40,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Note: This will allocate an object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:19,allocate,allocate,19,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['allocate'],['allocate']
Energy Efficiency,// Note: We leave the subreg number around a little longer in case of defs.; // This is so that the register freeing logic in allocateInstruction can still; // recognize this as subregister defs. The code there will clear the number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:126,allocate,allocateInstruction,126,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['allocate'],['allocateInstruction']
Energy Efficiency,"// Note: We need to release the buffer here to avoid double delete.; // The memory of a TBufferFile is allocated with new[], so we can let; // TMemBlock delete it, as its destructor calls ""delete [] fBuffer;""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx:103,allocate,allocated,103,io/io/src/TMemFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Note: We now have pp[ndx] is null.; // Allocate memory to read into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:42,Allocate,Allocate,42,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,4,['Allocate'],['Allocate']
Energy Efficiency,"// Note: the following code, and the part restoring previous position; // is by far the most expensive operation of the Scheduler.; // Do not update CurrentTop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:120,Schedul,Scheduler,120,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['Schedul'],['Scheduler']
Energy Efficiency,"// Note: we leave out here the check for whether the calculated value is zero to reduce complexity, which; // RooNLLVar does do at this (equivalent) point. Instead, we check whether the offset is zero when; // subtracting it in evaluations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/LikelihoodWrapper.cxx:81,reduce,reduce,81,roofit/roofitcore/src/TestStatistics/LikelihoodWrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/LikelihoodWrapper.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// Note: we need to find a way to reduce the complexity of; // this often executed condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:34,reduce,reduce,34,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['reduce'],['reduce']
Energy Efficiency,// Nothing to delete as all the objects are allocated in stable bump pointer; // allocators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:44,allocate,allocated,44,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Notifies the scheduler that a new cycle just started.; //; // This method notifies the scheduler that a new cycle started.; // This method is also responsible for notifying listeners about instructions; // state changes, and processor resources freed by the scheduler.; // Instructions that transitioned to the 'Executed' state are automatically; // moved to the next stage (i.e. RetireStage).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/ExecuteStage.h:16,schedul,scheduler,16,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/ExecuteStage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/ExecuteStage.h,3,['schedul'],['scheduler']
Energy Efficiency,"// Notify the monitoring system",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFile.cxx:14,monitor,monitoring,14,net/netxng/src/TNetXNGFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFile.cxx,2,['monitor'],['monitoring']
Energy Efficiency,"// Notify the scheduler of the region, even if we may skip scheduling; // it. Perhaps it still needs to be bundled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,schedul,scheduler,14,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,// Notify the scheduling strategy after updating the DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,schedul,scheduling,14,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// Notify the scheduling strategy before updating the DAG.; // This sets the scheduled node's ReadyCycle to CurrCycle. When updateQueues; // runs, it can then use the accurate ReadyCycle time to determine whether; // newly released nodes can move to the readyQ.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,schedul,scheduling,14,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"// Now `FixItsForVariable` gets further reduced: a variable is in; // `FixItsForVariable` iff it can be fixed and all its group mates can be; // fixed.; // Fix-its of bounds-safe overloads of `D` are shared by parameters of `D`.; // That is, when fixing multiple parameters in one step, these fix-its will; // be applied only once (instead of being applied per parameter).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:40,reduce,reduced,40,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Now allocate the exception object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:7,allocate,allocate,7,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Now schedule the parent walk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:7,schedul,schedule,7,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Now that all active lanes have read the element in the; // Reduce list, shuffle over the value from the remote lane.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:62,Reduce,Reduce,62,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Now that we are done with loop unrolling, be it either by LoopVectorizer,; // or LoopUnroll passes, some variable-offset GEP's into alloca's could have; // become constant-offset, thus enabling SROA and alloca promotion. Do so.; // NOTE: we are very late in the pipeline, and we don't have any LICM; // or SimplifyCFG passes scheduled after us, that would cleanup; // the CFG mess this may created if allowed to modify CFG, so forbid that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:328,schedul,scheduled,328,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['schedul'],['scheduled']
Energy Efficiency,// Now that we have emitted all the records we will emit the index. But; // first; // backpatch the forward reference so that the reader can skip the records; // efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:162,efficient,efficiently,162,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Now that we know if -debug is specified, we can use it.; // Note that if ReadResponseFiles == true, this must be done before the; // memory allocated for the expanded command line is free()d below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:143,allocate,allocated,143,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Now that we know which registers need to be saved and restored, allocate; // stack slots for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:67,allocate,allocate,67,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Now the chunk_state is clear, and we have more input. If there's more than; // a single chunk (so, definitely not the root chunk), hash the largest whole; // subtree we can, with the full benefits of SIMD (and maybe in the future,; // multi-threading) parallelism. Two restrictions:; // - The subtree has to be a power-of-2 number of chunks. Only subtrees along; // the right edge can be incomplete, and we don't know where the right edge; // is going to be until we get to finalize().; // - The subtree must evenly divide the total number of chunks up until this; // point (if total is not 0). If the current incomplete subtree is only; // waiting for 1 more chunk, we can't hash a subtree of 4 chunks. We have; // to complete the current subtree first.; // Because we might need to break up the input to form powers of 2, or to; // evenly divide what we already have, this part runs in a loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:316,power,power-of-,316,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,2,['power'],"['power-of-', 'powers']"
Energy Efficiency,// Now try symbolic BE count and more powerful methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,power,powerful,38,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['power'],['powerful']
Energy Efficiency,// Now try to find enough space in the reglist to allocate NumBytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:50,allocate,allocate,50,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Now try to reduce the number of functions in the module to something small.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:14,reduce,reduce,14,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Now try to reduce the number of global variable initializers in the; // module to something small.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:14,reduce,reduce,14,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,schedul,schedule,14,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,['schedul'],['schedule']
Energy Efficiency,"// Now we dont have to look for it in the local buffer; // if it's async, we expect that the communication library; // will handle it more efficiently than we can do here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:139,efficient,efficiently,139,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,1,['efficient'],['efficiently']
Energy Efficiency,// Now we have Block of SUs == Block of MI.; // We do the final schedule for the instructions inside the block.; // The property that all the SUs of the Block are grouped together as MI; // is used for correct reg usage tracking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:64,schedul,schedule,64,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Now we know that all argument loads are using addresses in parameter space; // and we can finally remove the old instructions in generic AS. Instructions; // scheduled for removal should be processed in reverse order so the ones; // closest to the load are deleted first. Otherwise they may still be in use.; // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will; // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by; // the BitCast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:161,schedul,scheduled,161,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Now we know that each predecessor of this block has a value in; // AvailablePreds, sort them for efficient access as we're walking the preds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:100,efficient,efficient,100,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Now we need to sort the powers according to least `control; // variable'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:27,power,powers,27,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['power'],['powers']
Energy Efficiency,"// Now we're ready to do the pass 2 code generation, which will emit the; // reduced set of parameter variables we've just worked out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:77,reduce,reduced,77,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Now, look at each merge-eligible global in turn.; // Keep track of the sets we already encountered to which we added the; // current global.; // Each element matches the same-index element in UsedGlobalSets.; // This lets us efficiently tell whether a set has already been expanded to; // include the current global.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:228,efficient,efficiently,228,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Num of schedulable unscheduled blocks reading the register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:10,schedul,schedulable,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['schedul'],['schedulable']
Energy Efficiency,"// NumAttrs in AttributedStmt is set when creating an empty; // AttributedStmt in AttributedStmt::CreateEmpty, since it is needed; // to allocate the right amount of space for the trailing Attr *.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:137,allocate,allocate,137,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,1,['allocate'],['allocate']
Energy Efficiency,// NumBuckets is always a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FoldingSet.cpp:26,power,power,26,interpreter/llvm-project/llvm/lib/Support/FoldingSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FoldingSet.cpp,1,['power'],['power']
Energy Efficiency,"// NumConcatenated, Length and CharByteWidth are set by the empty; // ctor since they are needed to allocate storage for the trailing objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp:100,allocate,allocate,100,interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp,1,['allocate'],['allocate']
Energy Efficiency,// NumElements should be power of 2 or equal to 3.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp:25,power,power,25,interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,1,['power'],['power']
Energy Efficiency,// NumElements should be power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/AArch64.cpp:25,power,power,25,interpreter/llvm-project/clang/lib/CodeGen/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/AArch64.cpp,2,['power'],['power']
Energy Efficiency,// NumEvenDrops is the power of two stride of the elements. Another way of; // thinking about it is that we need to drop the even elements this many; // times to get the original input.; // First we need to zero all the dropped bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,power,power,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// NumRegDefsLeft is zero when enough uses of this node have been scheduled; // to cover the number of registers defined (they are all live).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:66,schedul,scheduled,66,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,3,['schedul'],['scheduled']
Energy Efficiency,"// Number of allocated chunks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveChunkManager.h:13,allocate,allocated,13,graf3d/eve/inc/TEveChunkManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveChunkManager.h,2,['allocate'],['allocated']
Energy Efficiency,// Number of buckets (always a power of 2).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderMapTypes.h:31,power,power,31,interpreter/llvm-project/clang/include/clang/Lex/HeaderMapTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderMapTypes.h,1,['power'],['power']
Energy Efficiency,// Number of bytes to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:22,allocate,allocate,22,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// Number of effective sessions running on the machines allocated to this session",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:56,allocate,allocated,56,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['allocate'],['allocated']
Energy Efficiency,// Number of instructions and the number of vaddr/vdata dword transfers; // should be reduced.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp:86,reduce,reduced,86,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Number of micro opcodes dispatched.; // This field is often set to the total number of micro-opcodes specified by; // the instruction descriptor of IR.; // The only exception is when IR declares a number of micro opcodes; // which exceeds the processor DispatchWidth, and - by construction - it; // requires multiple cycles to be fully dispatched. In that particular case,; // the dispatch logic would generate more than one dispatch event (one per; // cycle), and each event would declare how many micro opcodes are effectively; // been dispatched to the schedulers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:559,schedul,schedulers,559,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['schedul'],['schedulers']
Energy Efficiency,// Number of physical register allocated for this instruction. There is one; // entry per register file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:31,allocate,allocated,31,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['allocate'],['allocated']
Energy Efficiency,"// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our us",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1214,efficient,efficient,1214,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// OK, now we have the first iteration,; // next: calculate the Sigmas (Widths) for the second (adaptive) iteration; // based on the output of the first iteration; // these Sigmas will be stored in histo called fSigmaHist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx:96,adapt,adaptive,96,tmva/tmva/src/KDEKernel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// OK, we've collected all parts in the pending list. Allocate; // the location (register or stack slot) for the indirect pointer.; // (This duplicates the usual i64 calling convention rules.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:54,Allocate,Allocate,54,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,1,['Allocate'],['Allocate']
Energy Efficiency,"// OR-ing shadow offset if more efficient (at least on x86) if the offset; // is a power of two, but on ppc64 and loongarch64 we have to use add since; // the shadow offset is not necessarily 1/8-th of the address space. On; // SystemZ, we could OR the constant in a single instruction, but it's more; // efficient to load it once and use indexed addressing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:32,efficient,efficient,32,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,3,"['efficient', 'power']","['efficient', 'power']"
Energy Efficiency,"// Objects are proportional to allocated memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/inc/TStructNode.h:31,allocate,allocated,31,graf3d/gviz3d/inc/TStructNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/inc/TStructNode.h,1,['allocate'],['allocated']
Energy Efficiency,// Obtain the register file descriptor from the scheduling model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.cpp:48,schedul,scheduling,48,interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Obtain the scheduling class information from the instruction; // and instruments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp:14,schedul,scheduling,14,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Occupancy target at the beginning of function scheduling cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:49,schedul,scheduling,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,"// Ok, now we know that all of the PHI nodes are missing entries for some; // basic blocks. Start by sorting the incoming predecessors for efficient; // access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:139,efficient,efficient,139,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Okay, all the short cuts are exhausted. We must compute it. The following; // is a classical Babylonian method for computing the square root. This code; // was adapted to APInt from a wikipedia article on such computations.; // See http://www.wikipedia.org/ and go to the page named; // Calculate_an_integer_square_root.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:163,adapt,adapted,163,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// Okay, now that we have reduced the list of passes which are causing the; // failure, see if we can pin down which functions are being; // miscompiled... first build a list of all of the non-external functions in; // the program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:26,reduce,reduced,26,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Okay, this node is full. Split it in half, moving WidthFactor children to; // a newly allocated interior node.; // Create the new node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:89,allocate,allocated,89,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:66,schedul,scheduled,66,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// Okay, we found a user that we cannot reduce.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:40,reduce,reduce,40,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Old Motorola PowerPC,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:16,Power,PowerPC,16,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['Power'],['PowerPC']
Energy Efficiency,"// On 32-bit PowerPC systems running SUSE Linux, gcc is configured as a; // 64-bit compiler which defaults to ""-m32"", hence ""powerpc64-suse-linux"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:13,Power,PowerPC,13,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// On AArch64, scalar signed division by constants power-of-two are; // normally expanded to the sequence ADD + CMP + SELECT + SRA.; // The OperandValue properties many not be same as that of previous; // operation; conservatively assume OP_None.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:51,power,power-of-two,51,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// On COFF, it's important to reduce the alignment down to 1 to prevent the; // linker from inserting padding before the start of the names section or; // between names entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:30,reduce,reduce,30,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// On ELF platforms, we're further restricted in that we can't; // increase the alignment of any variable which might be emitted; // into a shared library, and which is exported. If the main; // executable accesses a variable found in a shared-lib, the main; // exe actually allocates memory for and exports the symbol ITSELF,; // overriding the symbol found in the library. That is, at link; // time, the observed alignment of the variable is copied into the; // executable binary. (A COPY relocation is also generated, to copy; // the initial data from the shadowed variable in the shared-lib; // into the location in the main binary, before running code.); //; // And thus, even though you might think you are defining the; // global, and allocating the memory for the global in your object; // file, and thus should be able to set the alignment arbitrarily,; // that's not actually true. Doing so can cause an ABI breakage; an; // executable might have already been built with the previous; // alignment of the variable, and then assuming an increased; // alignment will be incorrect.; // Conservatively assume ELF if there's no parent pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:275,allocate,allocates,275,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// On PowerPC and AIX, a function call is encoded as a branch to 0.; // On other PowerPC platforms (ELF), a function call is encoded as; // a branch to self. Do not add a label for these cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:6,Power,PowerPC,6,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,2,['Power'],['PowerPC']
Energy Efficiency,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:6,Power,PowerPC,6,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,"['Power', 'Reduce']","['PowerPC', 'Reduce']"
Energy Efficiency,"// On Thumb1, the DAG above may be further combined if z is a power of 2; // (z == 2 ^ K).; // CMOV (SUBS x, y), z, !=, (SUBS x, y):1 ->; // t1 = (USUBO (SUB x, y), 1); // t2 = (USUBO_CARRY (SUB x, y), t1:0, t1:1); // Result = if K != 0 then (SHL t2:0, K) else t2:0; //; // This also handles the special case of comparing against zero; it's; // essentially, the same pattern, except there's no SUBS:; // CMOV x, z, !=, (CMPZ x, 0) ->; // t1 = (USUBO x, 1); // t2 = (USUBO_CARRY x, t1:0, t1:1); // Result = if K != 0 then (SHL t2:0, K) else t2:0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:62,power,power,62,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// On X86, vector signed division by constants power-of-two are; // normally expanded to the sequence SRA + SRL + ADD + SRA.; // The OperandValue properties may not be the same as that of the previous; // operation; conservatively assume OP_None.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:47,power,power-of-two,47,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// On most AVRs, we can use an offset up to 62 for load/store with; // displacement (63 for byte values, 62 for word values). However, the; // ""reduced tiny"" cores don't support load/store with displacement. So for; // them, we force an offset of 0 meaning that any positive offset will require; // adjusting the frame pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp:144,reduce,reduced,144,interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRRegisterInfo.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// On some targets such as PowerPC, some of the builtins are defined with custom; // type descriptors for target-dependent types. These descriptors are decoded in; // other functions, but it may be useful to be able to fall back to default; // descriptor decoding to define builtins mixing target-dependent and target-; // independent types. This function allows decoding one type descriptor with; // default decoding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,Power,PowerPC,27,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:429,allocate,allocated,429,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// On v8, we have particularly efficient implementations of atomic fences; // if they can be combined with nearby atomic loads and stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:31,efficient,efficient,31,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// One more or less than a power of 2 can use SLLI+ADD/SUB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:27,power,power,27,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,1,['power'],['power']
Energy Efficiency,// One-character token consumption.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptToken.cpp:23,consumption,consumption,23,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptToken.cpp,1,['consumption'],['consumption']
Energy Efficiency,// Only 16-bit integer constants can be represented in compares for; // PowerPC. Others will be materialized into a register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:72,Power,PowerPC,72,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// Only accept power of 2 values beteen RVVBitsPerBlock and 65536 that; // at least MinVLen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:15,power,power,15,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,2,['power'],['power']
Energy Efficiency,// Only allocate objects on the default stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:8,allocate,allocate,8,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,4,['allocate'],['allocate']
Energy Efficiency,// Only apply the candidate the Oracle selected to keep that is the most; // reduced. Candidates with less reductive power can be interpreted as an; // intermediate step that is immediately replaced with the more reduced; // one. The number of shouldKeep() calls must be independent of the result; // of previous shouldKeep() calls to keep the total number of calls; // in-sync with what countOperands() has computed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp:77,reduce,reduced,77,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,3,"['power', 'reduce']","['power', 'reduced']"
Energy Efficiency,"// Only called if a task scheduler is set. No-op be default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:25,schedul,scheduler,25,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['schedul'],['scheduler']
Energy Efficiency,// Only check for dependence if there are resources available to; // schedule this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:69,schedul,schedule,69,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,1,['schedul'],['schedule']
Energy Efficiency,// Only check the domination rule when requested. Once all passes have been; // adapted this option can go away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:80,adapt,adapted,80,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// Only cluster instruction pair that have the same opcode, and they are; // clusterable according to PowerPC specification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:102,Power,PowerPC,102,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Only consider allocations via new, to reduce unnecessary metadata,; // since those are the only allocations that will be targeted initially.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:41,reduce,reduce,41,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Only consider candidates that are ""more reduced"" than the original; // value. This explicitly also rules out candidates with the same; // reduction power. This is to ensure that repeated invocations of this; // pass eventually reach a fixpoint without switch back and forth; // between two opportunities with the same reductive power.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp:43,reduce,reduced,43,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,3,"['power', 'reduce']","['power', 'reduced']"
Energy Efficiency,// Only copy scheduled successors. Cut them from old node's successor; // list and move them over.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:13,schedul,scheduled,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,4,['schedul'],['scheduled']
Energy Efficiency,"// Only display towers with higher energy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveCaloData.h:35,energy,energy,35,graf3d/eve/inc/TEveCaloData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveCaloData.h,2,['energy'],['energy']
Energy Efficiency,"// Only do this if removing the zero vector reduces the depth, otherwise; // the critical path will increase with the final unpack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,reduce,reduces,44,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Only for power of two types to be sure that bitcast works well,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,power,power,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,"// Only handle binary operators (including two-operand getelementptr) with; // one-use here. As with the cast case above, it may be possible to relax the; // one-use constraint, but that needs be examined carefully since it may not; // reduce the total number of instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:236,reduce,reduce,236,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Only handle power-of-two sized elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:15,power,power-of-two,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['power'],['power-of-two']
Energy Efficiency,// Only handle simple values that are a power of two bytes in size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:40,power,power,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['power'],['power']
Energy Efficiency,// Only handle vector types which are a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:40,power,power,40,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['power'],['power']
Energy Efficiency,// Only keep a power of two factor for non-inbounds,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:15,power,power,15,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['power'],['power']
Energy Efficiency,// Only load and stores instructions can have variable vector length on Power.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:72,Power,Power,72,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['Power'],['Power']
Energy Efficiency,// Only multiples that are a power of 2 will hold after truncation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:29,power,power,29,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['power'],['power']
Energy Efficiency,"// Only pay attention to the requested length if it is larger than our default; // page size. If it is, we allocate an entire chunk for it. This is to; // support gigantic tokens, which almost certainly won't happen. :)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:107,allocate,allocate,107,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Only power of two alignments are supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:8,power,power,8,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,1,['power'],['power']
Energy Efficiency,// Only reduce register pressure when pressure is high.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:8,reduce,reduce,8,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Only scheduling top-down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:8,schedul,scheduling,8,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Only support _BitInt elements with byte-sized power of 2 NumBits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,power,power,49,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,4,['power'],['power']
Energy Efficiency,// Only widen to the next power of 2 to keep consistency with EVT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:26,power,power,26,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['power'],['power']
Energy Efficiency,"// OpenCL 1.1 6.5.2: ""Variables allocated in the __local address space inside; // a kernel function cannot be initialized.""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,allocate,allocated,32,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// OpenCL v1.2 s6.5.3: The __constant or constant address space name is; // used to describe variables allocated in global memory and which are; // accessed inside a kernel(s) as read-only variables. As such, variables; // in constant address space cannot have local storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:103,allocate,allocated,103,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['allocate'],['allocated']
Energy Efficiency,"// OpenMP 4.5, 2.7.1 Loop Construct, Description.; // If the static schedule kind is specified or if the ordered clause is; // specified, and if no monotonic modifier is specified, the effect will; // be as if the monotonic modifier was specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:68,schedul,schedule,68,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// OpenMP 5.0, 2.11.3 allocate Directive, Restrictions.; // allocate directives that appear in a target region must specify an; // allocator clause unless a requires directive with the dynamic_allocators; // clause is present in the same compilation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:22,allocate,allocate,22,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// OpenMP 5.0, 2.11.4 allocate Clause, Restrictions.; // allocate clauses that appear on a target construct or on constructs in a; // target region must specify an allocator expression unless a requires; // directive with the dynamic_allocators clause is present in the same; // compilation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:22,allocate,allocate,22,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// OpenMP 5.0, 2.9.2 Worksharing-Loop Construct, Desription.; // If the static schedule kind is specified or if the ordered clause is; // specified, and if the nonmonotonic modifier is not specified, the effect is; // as if the monotonic modifier is specified. Otherwise, unless the monotonic; // modifier is specified, the effect is as if the nonmonotonic modifier is; // specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:79,schedul,schedule,79,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// OpenMP 5.1, 2.11.4 Worksharing-Loop Construct, Description.; // If the static schedule kind is specified or if the ordered clause is; // specified, and if the nonmonotonic modifier is not specified, the; // effect is as if the monotonic modifier is specified. Otherwise, unless; // the monotonic modifier is specified, the effect is as if the; // nonmonotonic modifier is specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:81,schedul,schedule,81,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// OpenMP [2.11.3, allocate Directive, Description]; // allocator is an expression of omp_allocator_handle_t type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:19,allocate,allocate,19,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// OpenMP [2.11.4 allocate Clause, Description]; // allocator is an expression of omp_allocator_handle_t type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,allocate,allocate,18,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1017,allocate,allocate,1017,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// OpenMP [2.7.1, Restrictions, p. 3]; // Only one schedule clause can appear on a loop directive.; // OpenMP 4.5 [2.10.4, Restrictions, p. 106]; // At most one defaultmap clause can appear on the directive.; // OpenMP 5.0 [2.12.5, target construct, Restrictions]; // At most one device clause can appear on the directive.; // OpenMP 5.1 [2.11.3, order clause, Restrictions]; // At most one order clause may appear on a construct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:51,schedul,schedule,51,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// OpenMP, 2.11.3 allocate Directive, Restrictions, C / C++; // If a list item has a static storage type, the allocator expression in the; // allocator clause must be a constant expression that evaluates to one of; // the predefined memory allocator values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,allocate,allocate,18,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// OpenMP, 2.11.4 allocate Clause, Restrictions.; // For task, taskloop or target directives, allocation requests to memory; // allocators with the trait access set to thread result in unspecified; // behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,allocate,allocate,18,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// OpenMP, 2.12.5 target Construct; // Memory allocators that do not appear in a uses_allocators clause cannot; // appear as an allocator in an allocate clause or be used in the target; // region unless a requires directive with the dynamic_allocators clause; // is present in the same compilation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:144,allocate,allocate,144,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// OpenMP, 2.7.1, Loop Construct, Restrictions; // The nonmonotonic modifier can only be specified with schedule(dynamic) or; // schedule(guided).; // OpenMP 5.0 does not have this restriction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:104,schedul,schedule,104,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['schedul'],['schedule']
Energy Efficiency,// Optimize C ? 8 : 0 -> zext(setcc(C)) << 3. Likewise for any pow2/0.; // This is efficient for any integer data type (including i8/i16) and; // shift amount.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:83,efficient,efficient,83,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Optimize Cond ? cst+1 : cst -> zext(setcc(C)+cst. This is efficient; // for any integer data type, including i8/i16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,efficient,efficient,61,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Optimize cases that will turn into an LEA instruction. This requires; // an i32 or i64 and an efficient multiplier (1, 2, 3, 4, 5, 8, 9).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:97,efficient,efficient,97,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Optimize; // 1) (icmp eq/ne (and X, C0), (shift X, C1)); // or; // 2) (icmp eq/ne X, (rotate X, C1)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Then:; // If C1 is a power of 2, then the rotate and shift+and versions are; // equivilent, so we can interchange them depending on target preference.; // Otherwise, if we have the shift+and version we can interchange srl/shl; // which inturn affects the constant C0. We can use this to get better; // constants again determined by target preference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:277,power,power,277,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,"// Optional monitor for zip time profiling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:12,monitor,monitor,12,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// Optionally, also disable the upper (x86_64) SSE registers to reduce frontend; // decoder load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:64,reduce,reduce,64,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Order such that start index comes first (this reduces mov's),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:49,reduce,reduces,49,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Otherwise allocate a large enough buffer in the pool, memcpy the data; // into it, and return an ArrayRef to that. Do not touch existing pool; // allocations, as existing clients may be holding a pointer which must; // not be invalidated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MappedBlockStream.cpp:13,allocate,allocate,13,interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MappedBlockStream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MappedBlockStream.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Otherwise just return the size of the allocated buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:41,allocate,allocated,41,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['allocate'],['allocated']
Energy Efficiency,"// Otherwise, allocate in the default order, using LR first because saving it; // allows a shorter epilogue sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:14,allocate,allocate,14,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Otherwise, allocate just the number of bytes required to store; // the bitfield.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:14,allocate,allocate,14,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Otherwise, allocate new heap space (unless we were the same size)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp:14,allocate,allocate,14,interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// Otherwise, allocate something new.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp:14,allocate,allocate,14,interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Otherwise, allocate the number of bytes required for the bitmap; // based on the number of conditions. Must be at least 1-byte long.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:14,allocate,allocate,14,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Otherwise, allocate this object in the named value stack, outside of linear; // memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:14,allocate,allocate,14,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Otherwise, just use the general rule.; //; // The PPC64 ABI passes some arguments in integer registers, even to variadic; // functions. To allow va_list to use the simple ""void*"" representation,; // variadic calls allocate space in the argument area for the integer argument; // registers, and variadic functions spill their integer argument registers to; // this area in their prologues. When aggregates smaller than a register are; // passed this way, they are passed in the least significant bits of the; // register, which means that after spilling on big-endian targets they will; // be right-aligned in their argument slot. This is uncommon; for a variety of; // reasons, other big-endian targets don't end up right-aligning aggregate; // types this way, and so right-alignment only applies to fundamental types.; // So on PPC64, we must force the use of right-alignment even for aggregates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:217,allocate,allocate,217,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Otherwise, this is target-dependent and based on the size and; // alignment of the ivar.; // If the size of the ivar is not a power of two, give up. We don't; // want to get into the business of doing compare-and-swaps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:129,power,power,129,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['power'],['power']
Energy Efficiency,"// Otherwise, use the TOC. 'TOCEntry' is a label used to reference the; // storage allocated in the TOC which contains the address of; // 'MOSymbol'. Said TOC entry will be synthesized later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:83,allocate,allocated,83,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Otherwise, we can't handle this case efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:40,efficient,efficiently,40,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Otherwise, we have to go to the filesystem. We can always just use; // 'stat' here, but (for files) the client is asking whether the file exists; // because it wants to turn around and *open* it. It is more efficient to; // do ""open+fstat"" on success than it is to do ""stat+open"".; //; // Because of this, check to see if the file exists with 'open'. If the; // open succeeds, use fstat to get the stat info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:210,efficient,efficient,210,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Otherwise, we need to reduce the AvailableOut set by things which are no; // longer in our AvailableIn",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:25,reduce,reduce,25,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Our binary search tree differs from a typical BST in that ours can have; // up to three values in each leaf. The pivot selection above doesn't take; // that into account, which means the tree might require more nodes and be; // less efficient. We compensate for this here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:236,efficient,efficient,236,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Our hint wasn't enough to satisfy the entire directory. Allocate; // remaining pages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp:59,Allocate,Allocate,59,interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Output results and fill monitor ntuple",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodRuleFit.cxx:27,monitor,monitor,27,tmva/tmva/src/MethodRuleFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodRuleFit.cxx,2,['monitor'],['monitor']
Energy Efficiency,// Output the mapping from ScheduleClass to ResourcesIdx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DFAPacketizerEmitter.cpp:27,Schedul,ScheduleClass,27,interpreter/llvm-project/llvm/utils/TableGen/DFAPacketizerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DFAPacketizerEmitter.cpp,1,['Schedul'],['ScheduleClass']
Energy Efficiency,// Overlapping correct location. Allocate NewLocNo now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:33,Allocate,Allocate,33,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// Overrides set - we are in testing, the following does not need to be; // efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:76,efficient,efficient,76,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// P2 (power-of-2) algorithm: all histogram have limits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h:7,power,power-of-,7,hist/hist/src/TH1Merger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h,1,['power'],['power-of-']
Energy Efficiency,// PICBase can be allocated by TII.getGlobalBaseReg(&MF).; // In DAGISEL the code that initialize it generated by the CGBR pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp:18,allocate,allocated,18,interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// PPC ELFABIv2 DWARF Definition ""Table 2.26. Mappings of Common Registers"".; // vs0 ~ vs31 is mapping to 32 - 63,; // vs32 ~ vs63 is mapping to 77 - 108.; // And this mapping applies to all OSes which run on powerpc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:209,power,powerpc,209,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,1,['power'],['powerpc']
Energy Efficiency,// PPC128HexFPConstant - PowerPC 128-bit in hexadecimal format (16 bytes),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:25,Power,PowerPC,25,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// PPC970 Instruction Flags. These flags describe the characteristics of the; // PowerPC 970 (aka G5) dispatch groups and how they are formed out of; // raw machine instructions.; /// PPC970_First - This instruction starts a new dispatch group, so it will; /// always be the first one in the group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:81,Power,PowerPC,81,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,1,['Power'],['PowerPC']
Energy Efficiency,// PPC: powerpc,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h:8,power,powerpc,8,interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,1,['power'],['powerpc']
Energy Efficiency,// PPCLE: powerpc (little endian),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h:10,power,powerpc,10,interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,1,['power'],['powerpc']
Energy Efficiency,// PTX ABI requires all scalar argument/return values to have; // bit-size as a power of two of at least 32 bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.h:80,power,power,80,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXUtilities.h,1,['power'],['power']
Energy Efficiency,"// Pad to a power-of-2 vector, split+apply and extract the original vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,power,power-of-,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Parameter accessed by any or unknown offset, represented as FullSet by; // StackSafety, is handled as the parameter for which we have no; // StackSafety info at all. So drop it to reduce summary size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:183,reduce,reduce,183,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Parse ReduceMean",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/ParseReduce.cxx:9,Reduce,ReduceMean,9,tmva/sofie_parsers/src/ParseReduce.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/ParseReduce.cxx,1,['Reduce'],['ReduceMean']
Energy Efficiency,"// Parse ReduceProd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/ParseReduce.cxx:9,Reduce,ReduceProd,9,tmva/sofie_parsers/src/ParseReduce.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/ParseReduce.cxx,1,['Reduce'],['ReduceProd']
Energy Efficiency,"// Parse ReduceSum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/ParseReduce.cxx:9,Reduce,ReduceSum,9,tmva/sofie_parsers/src/ParseReduce.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/ParseReduce.cxx,1,['Reduce'],['ReduceSum']
Energy Efficiency,"// Parse ReduceSumsquare",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/ParseReduce.cxx:9,Reduce,ReduceSumsquare,9,tmva/sofie_parsers/src/ParseReduce.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/ParseReduce.cxx,1,['Reduce'],['ReduceSumsquare']
Energy Efficiency,"// Partially shrink 64-bit shifts to 32-bit if reduced to 16-bit.; //; // i16 (trunc (srl i64:x, K)), K <= 16 ->; // i16 (trunc (srl (i32 (trunc x), K)))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:47,reduce,reduced,47,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Particle charge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbParticle.h:12,charge,charge,12,test/periodic/NdbParticle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbParticle.h,1,['charge'],['charge']
Energy Efficiency,// Pass 3: Merge cold nodes to reduce code size,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:31,reduce,reduce,31,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Pass through DAG gathering a list of exports and removing barrier edges; // creating dependencies on exports. Freeing exports of successor edges; // allows more scheduling freedom, and nothing should be order dependent; // on exports. Edges will be added later to order the exports.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp:164,schedul,scheduling,164,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Pattern-match combinations for which more efficient representations exist.; // [Reg, DW_OP_plus_uconst, Offset] --> [DW_OP_breg, Offset].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:45,efficient,efficient,45,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// PendingMem contains all blocks of memory (subblocks of AllocatedMem); // which have not yet had their permissions applied, but have been given; // out to the user. FreeMem contains all block of memory, which have; // neither had their permissions applied, nor been given out to the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:58,Allocate,AllocatedMem,58,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,1,['Allocate'],['AllocatedMem']
Energy Efficiency,"// Perform context disambiguation after inlining, since that would reduce the; // amount of additional cloning required to distinguish the allocation; // contexts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:67,reduce,reduce,67,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Perform target-specific adjustments to the latency of a schedule; // dependency.; // If a pair of operands is associated with the schedule dependency, DefOpIdx; // and UseOpIdx are the indices of the operands in Def and Use, respectively.; // Otherwise, either may be -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:59,schedul,schedule,59,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,2,['schedul'],['schedule']
Energy Efficiency,"// Performance monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx:15,monitor,monitoring,15,proof/proof/src/TVirtualPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx,1,['monitor'],['monitoring']
Energy Efficiency,// Phase 1:; // 1.1: Run pre-prune passes; // 1.2: Prune graph; // 1.3: Run post-prune passes; // 1.4: Allocate memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h:103,Allocate,Allocate,103,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,1,['Allocate'],['Allocate']
Energy Efficiency,// Phase 2a: Loop carried dependency with V_PERM; // Schedule VPerm & DS_WRITE as closely as possible to the VMEM_READ they; // depend on. Interleave MFMA to keep XDL unit busy throughout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:53,Schedul,Schedule,53,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Phase 2b: Loop carried dependency without V_PERM; // Schedule DS_WRITE as closely as possible to the VMEM_READ they depend on.; // Interleave MFMA to keep XDL unit busy throughout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:56,Schedul,Schedule,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// Phase 2c: Loop carried dependency with V_PERM, VMEM_READs are; // ultimately used by two DS_WRITE; // Schedule VPerm & DS_WRITE as closely as possible to the VMEM_READ they; // depend on. Interleave MFMA to keep XDL unit busy throughout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:105,Schedul,Schedule,105,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// PhysReg is available, allocate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:25,allocate,allocate,25,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Pick the best node to schedule taking all constraints into; // consideration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:25,schedul,schedule,25,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Pick the largest power of 2 unroll count that won't result in too many; // strided loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:20,power,power,20,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['power'],['power']
Energy Efficiency,// Pick the next node to schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:25,schedul,schedule,25,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Pick the next power of 2, or a multiple of 64 over 128.; // Whichever is smaller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:17,power,power,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['power'],['power']
Energy Efficiency,"// Pick the pt of the muons with a pt greater than 10, an eta between -2 and 2 and a negative charge; // or the ones with a pt > 20, outside the eta range -2:2 and with positive charge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/test/vecops_rvec.cxx:94,charge,charge,94,math/vecops/test/vecops_rvec.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/test/vecops_rvec.cxx,2,['charge'],['charge']
Energy Efficiency,// Placeholder until allocate clause supports align modifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:21,allocate,allocate,21,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Pointer to the owning basic block.; // Operands are allocated by an ArrayRecycler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:55,allocate,allocated,55,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['allocate'],['allocated']
Energy Efficiency,"// Polynomial kernel of form (z.x + theta)^n; // it should be noted that the power is currently only integer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVKernelFunction.cxx:77,power,power,77,tmva/tmva/src/SVKernelFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVKernelFunction.cxx,1,['power'],['power']
Energy Efficiency,// Pool-allocate MachineFunction-lifetime and IR objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:8,allocate,allocate,8,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['allocate'],['allocate']
Energy Efficiency,// Populate MayLiveAcrossBlocks in case the use block is allocated before; // the def block (removing the vreg uses).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:57,allocate,allocated,57,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Populate the VRX map (VR to extension-type).; // Go over all the formal parameters of the function. If a given parameter; // P is sign- or zero-extended, locate the virtual register holding that; // parameter and create an entry in the VRX map indicating the type of ex-; // tension (and the source type).; // This is a bit complicated to do accurately, since the memory layout in-; // formation is necessary to precisely determine whether an aggregate para-; // meter will be passed in a register or in memory. What is given in MRI; // is the association between the physical register that is live-in (i.e.; // holds an argument), and the virtual register that this value will be; // copied into. This, by itself, is not sufficient to map back the virtual; // register to a formal parameter from Function (since consecutive live-ins; // from MRI may not correspond to consecutive formal parameters from Func-; // tion). To avoid the complications with in-memory arguments, only consi-; // der the initial sequence of formal parameters that are known to be; // passed via registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:466,meter,meter,466,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,1,['meter'],['meter']
Energy Efficiency,// Populate the non-atomic reduction using the elementwise reduction function.; // This loads the elements from the global and private variables and reduces; // them before storing back the result to the global variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:149,reduce,reduces,149,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Position of first ^ (power)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLatex.cxx:24,power,power,24,graf2d/graf/src/TLatex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLatex.cxx,1,['power'],['power']
Energy Efficiency,"// Position within this element. TODO: more efficient?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:44,efficient,efficient,44,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,2,['efficient'],['efficient']
Energy Efficiency,// Post-RA scheduling is enabled with; // TargetSubtargetInfo.enablePostRAScheduler(). This flag can be used to; // override the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:11,schedul,scheduling,11,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// PostGenericScheduler::tryCandidate end; // Add powerpc post ra specific heuristic only when TryCand isn't selected or; // selected as node order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:50,power,powerpc,50,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,1,['power'],['powerpc']
Energy Efficiency,"// Potential optimisation: reduce number of branches using partial specialisation of; // helper functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx:27,reduce,reduce,27,core/meta/src/TEnum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx,1,['reduce'],['reduce']
Energy Efficiency,// Pow2Num will be the largest number of elements in OG such that the sum; // of sizes of stores 0...Pow2Num-1 will be a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:121,power,power,121,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,1,['power'],['power']
Energy Efficiency,"// Power PDF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooPowerSum.h:3,Power,Power,3,roofit/roofit/inc/RooPowerSum.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooPowerSum.h,1,['Power'],['Power']
Energy Efficiency,"// Power doesn't support testing whether a value is 'normal'. Test the rest; // first, and test if it's 'not not-normal' with expected sign.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,Power,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['Power']
Energy Efficiency,// Power of 2 is a shift. Negated power of 2 is a shift and a negate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:3,Power,Power,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,2,"['Power', 'power']","['Power', 'power']"
Energy Efficiency,// Power of 2 test:; // isPow2OrZero : ctpop(X) u< 2; // isPow2 : ctpop(X) == 1; // NotPow2OrZero: ctpop(X) u> 1; // NotPow2 : ctpop(X) != 1; // If we know any bit of X can be folded to:; // IsPow2 : X & (~Bit) == 0; // NotPow2 : X & (~Bit) != 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Power,Power,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Power'],['Power']
Energy Efficiency,// Power of the most significant digit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:3,Power,Power,3,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['Power'],['Power']
Energy Efficiency,// Power of two is closed under multiplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Power,Power,3,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Power'],['Power']
Energy Efficiency,// PowerPC,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Power,PowerPC,3,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,2,['Power'],['PowerPC']
Energy Efficiency,// PowerPC Windows,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// PowerPC backend has opcode STW/STW8 for instruction ""stw"" to deal with; // 32bit and 64bit instruction selection. They are clusterable pair though; // they are different opcode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// PowerPC default behaviour here is ""instruction number 1st priority"".; // If LsrNoInsnsCost is set, call default implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC does not have BRCOND which requires SetCC,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC does not have FP_TO_UINT on 32-bit implementations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC does not have ROTR,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC does not have Select,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC does not have [U|S]INT_TO_FP,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC does not support direct load/store of condition registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC does not support scalar condition selects on vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC doesn't have preinc load/store instructions for vectors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC has an i16 but no i8 (or i1) SEXTLOAD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC has better expansions for funnel shifts than the generic; // TargetLowering::expandFunnelShift.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC has no SREM/UREM instructions unless we are on P9; // On P9 we may use a hardware instruction to compute the remainder.; // When the result of both the remainder and the division is required it is; // more efficient to compute the remainder from the result of the division; // rather than use the remainder instruction. The instructions are legalized; // directly because the DivRemPairsPass performs the transformation at the IR; // level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,"['Power', 'efficient']","['PowerPC', 'efficient']"
Energy Efficiency,// PowerPC has pre-inc load and store's.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// PowerPC only support small, medium and large code model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// PowerPC specific version of setSpecialOperandAttr that copies Flags to MI; // and clears nuw, nsw, and exact flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,1,['Power'],['PowerPC']
Energy Efficiency,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,"['Power', 'efficient']","['PowerPC', 'efficient']"
Energy Efficiency,// PowerPC turns FP_TO_SINT into FCTIWZ and some load/stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC uses ADDC/ADDE/SUBC/SUBE to propagate carry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC wants to optimize integer setcc a bit,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC wants to turn select_cc of FP into fsel when possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Power,PowerPC,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// PowerPC-32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:3,Power,PowerPC-,3,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['Power'],['PowerPC-']
Energy Efficiency,// PowerPC-64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:3,Power,PowerPC-,3,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['Power'],['PowerPC-']
Energy Efficiency,"// Powers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:3,Power,Powers,3,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['Power'],['Powers']
Energy Efficiency,"// Pre-allocate enough space (35=kMaxDigits)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:7,allocate,allocate,7,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,4,['allocate'],['allocate']
Energy Efficiency,// Pre-allocate map entries. This prevents any iterator/reference; // invalidation in the next loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:7,allocate,allocate,7,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Pre-allocate storage for the structured initializer list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:7,allocate,allocate,7,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Pre-compilation inliner based on context-sensitive profile.; // The PreInliner estimates inline decision using hotness from profile; // and cost estimation from machine code size. It helps merges context; // profile globally and achieves better post-inine profile quality, which; // otherwise won't be possible for ThinLTO. It also reduce context profile; // size by only keep context that is estimated to be inlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.h:335,reduce,reduce,335,interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.h,1,['reduce'],['reduce']
Energy Efficiency,// PreRA instruction scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:21,schedul,scheduling,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,3,['schedul'],['scheduling']
Energy Efficiency,// Precalculate the number of lits this variable contributes to in the; // operand. If there is a single lit (consecutive range of bits) we can use a; // destructive sequence on APInt that reduces memory allocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeEmitterGen.cpp:189,reduce,reduces,189,interpreter/llvm-project/llvm/utils/TableGen/CodeEmitterGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeEmitterGen.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Predicate tail-folded loops are efficient even when the loop; // iteration count is low. However, setting the epilogue policy to; // `CM_ScalarEpilogueNotAllowedLowTripLoop` prevents vectorizing loops; // with runtime checks. It's more effective to let; // `areRuntimeChecksProfitable` determine if vectorization is beneficial; // for the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:35,efficient,efficient,35,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Prefer SmallVector with zero inline storage over std::vector. IndexedMaps; // can grow very large and SmallVector grows more efficiently as long as T; // is trivially copyable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IndexedMap.h:128,efficient,efficiently,128,interpreter/llvm-project/llvm/include/llvm/ADT/IndexedMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IndexedMap.h,1,['efficient'],['efficiently']
Energy Efficiency,// Prefer bottom scheduling when heuristics are silent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:17,schedul,scheduling,17,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Prefer the candidate with the lesser depth, but only if one of them has; // depth greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:116,schedul,scheduled,116,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// Prefer the candidate with the lesser height, but only if one of them has; // height greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:118,schedul,scheduled,118,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// Prefer to reduce vector widths for 16-bit vectors before lowering, to; // get more vector shift opportunities, since we'll get those when; // expanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:13,reduce,reduce,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Prepares TopRPTracker for top down scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:38,schedul,scheduling,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Prevent copy or move, instructions are allocated once and cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:42,allocate,allocated,42,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,1,['allocate'],['allocated']
Energy Efficiency,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:373,schedul,scheduler,373,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Print 'x' for indexed form.; // FIXME: Currently for PowerPC memory operands are always loaded; // into a register, so we never get an update or indexed form.; // This is bad even for offset forms, since even if we know we; // have a value in -16(r1), we will generate a load into r<n>; // and then load from 0(r<n>). Until that issue is fixed,; // tolerate 'U' and 'X' but don't output anything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:56,Power,PowerPC,56,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Print aliases in topological order, that is, for each alias a = b,; // b must be printed before a.; // This is because on some targets (e.g. PowerPC) linker expects aliases in; // such an order to generate correct TOC information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:144,Power,PowerPC,144,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// Print any scheduling class that has at least one cluster that does not; // match the checked-in data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:13,schedul,scheduling,13,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Print reduced file to STDOUT,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp:9,reduce,reduced,9,interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Print sections, symbol names and addresses, and any edges for the; // associated blocks at the 'PostPrune' phase of JITLink (after; // dead-stripping, but before addresses are allocated in the target; // address space. See llvm/docs/JITLink.rst).; //; // Experiment with adding the 'printGraph' pass at other points in the; // pipeline. E.g. PrePrunePasses, PostAllocationPasses, and; // PostFixupPasses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp:179,allocate,allocated,179,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin/LLJITWithObjectLinkingLayerPlugin.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Prints a row representing an instruction, along with scheduling info and; // point coordinates (measurements).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:56,schedul,scheduling,56,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Prior to P10, PowerPC does not have BSWAP, but we can use vector BSWAP; // instruction xxbrd to speed up scalar BSWAP64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:17,Power,PowerPC,17,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// Process all TruncInst in the Worklist, for each instruction:; // 1. Check if it dominates an eligible expression graph to be reduced.; // 2. Create a reduced expression graph and replace the old one with it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:128,reduce,reduced,128,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,2,['reduce'],['reduced']
Energy Efficiency,"// Process each argument in list and construct reduced; // expression to be returned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:47,reduce,reduced,47,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['reduce'],['reduced']
Energy Efficiency,// Process scheduling regions top-down so that scheduler states can be; // transferrred over scheduling boundaries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:11,schedul,scheduling,11,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,3,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,// Process the SVE callee-saves to determine what space needs to be; // allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:72,allocate,allocated,72,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Processor descriptions; // Scheduler machine model,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:30,Schedul,Scheduler,30,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['Schedul'],['Scheduler']
Energy Efficiency,// Profitably converting to branches need to reduce the loop's critical path; // by at least some threshold (absolute gain of GainCycleThreshold cycles and; // relative gain of 12.5%).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:45,reduce,reduce,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Program became non-reduced, so this chunk appears to be interesting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp:22,reduce,reduced,22,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Properties might be computed, which means the property value could; // theoretically change between calls even in commonly-observed cases like; // this:; //; // if (foo.prop) { // ok, it's nonnull here...; // [bar doStuffWithNonnullVal:foo.prop]; // ...but what about; // here?; // }; //; // If the property is nullable-annotated, a naive analysis would lead to many; // false positives despite the presence of probably-correct nil-checks. To; // reduce the false positive rate, we maintain a history of the most recently; // observed property value. For each property access, if the prior value has; // been constrained to be not nil then we will conservatively assume that the; // next access can be inferred as nonnull.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:450,reduce,reduce,450,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Provide an ordered list of schedule DAG mutations for the machine; // pipeliner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:30,schedul,schedule,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['schedul'],['schedule']
Energy Efficiency,// Provide an ordered list of schedule DAG mutations for the post-RA; // scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:30,schedul,schedule,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,2,['schedul'],"['schedule', 'scheduler']"
Energy Efficiency,// Provide custom new/delete as we will only allocate space for a name; // if we need one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h:45,allocate,allocate,45,interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,1,['allocate'],['allocate']
Energy Efficiency,"// Provided ahead of time in pass 2, to indicate which parameters are being; // assigned to what. This vector contains an entry for each call to; // allocParam expected during code gen (which we counted up in pass 1), and; // indicates the number of the parameter variable that should be returned, or; // -1 if this call shouldn't allocate a parameter variable at all.; //; // We rely on the recursive code generation working identically in passes 1; // and 2, so that the same list of calls to allocParam happen in the same; // order. That guarantees that the parameter numbers recorded in pass 1 will; // match the entries in this vector that store what EmitterBase::EmitBuiltinCG; // decided to do about each one in pass 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:331,allocate,allocate,331,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Prune list computed above to only include values defined in the exporting; // module. We do this after the above insertion since we may hit the same; // ref/call target multiple times in above loop, and it is more efficient to; // avoid a set lookup each time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:217,efficient,efficient,217,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Pull subvector inserts into undef through VZEXT_MOVL by making it an; // insert into a zero vector. This helps get VZEXT_MOVL closer to; // scalar_to_vectors where 256/512 are canonicalized to an insert and a; // 128-bit scalar_to_vector. This reduces the number of isel patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:247,reduce,reduces,247,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Push-Pop Acceleration (PPX) hint is used to indicate that the POP reads the; // value written by the PUSH from the stack. The processor tracks these marked; // instructions internally and fast-forwards register data between matching PUSH; // and POP instructions, without going through memory or through the training; // loop of the Fast Store Forwarding Predictor (FSFP). Instead, a more efficient; // memory-renaming optimization can be used.; //; // The PPX hint is purely a performance hint. Instructions with this hint have; // the same functional semantics as those without. PPX hints set by the; // compiler that violate the balancing rule may turn off the PPX optimization,; // but they will not affect program semantics.; //; // Hence, PPX is used for balanced spill/reloads (Exceptions and setjmp/longjmp; // are not considered).; //; // PUSH2 and POP2 are instructions for (respectively) pushing/popping 2; // GPRs at a time to/from the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:392,efficient,efficient,392,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Put all exports together in a block.; // The block will naturally end up being scheduled last,; // thus putting exports at the end of the schedule, which; // is better for performance.; // However we must ensure, for safety, the exports can be put; // together in the same block without any other instruction.; // This could happen, for example, when scheduling after regalloc; // if reloading a spilled register from memory using the same; // register than used in a previous export.; // If that happens, do not regroup the exports.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:82,schedul,scheduled,82,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,3,['schedul'],"['schedule', 'scheduled', 'scheduling']"
Energy Efficiency,// Put allocated group as last group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:7,allocate,allocated,7,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,1,['allocate'],['allocated']
Energy Efficiency,// Put in one group all instructions with no users in this scheduling region; // (we'd want these groups be at the end).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:59,schedul,scheduling,59,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,// Put the non-pipelined instruction as early as possible in the schedule,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:65,schedul,schedule,65,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Queue jobs to process NumInitialTasks chunks in parallel using; // ChunkThreadPool. When the tasks are added to the pool, parse the; // original module from OriginalBC with a fresh LLVMContext object. This; // ensures that the cloned module of each task uses an independent; // LLVMContext object. If a task reduces the input, serialize the result; // back in the corresponding Result element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp:311,reduce,reduces,311,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Quickly determine whether we have a pointer to an alloca. It's possible; // to skip null checks, and some alignment checks, for these pointers. This; // can reduce compile-time significantly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:160,reduce,reduce,160,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Quote ""For unsigned lhs, the value of LHS << RHS is the value of LHS *; // 2^RHS, reduced modulo maximum value of the return type plus 1.""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:85,reduce,reduced,85,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// R e d u c i n g , A p p e n d i n g a n d M e r g i n g; // -------------------------------------------------------------; // The reduce() function returns a new dataset which is a subset of the original",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:133,reduce,reduce,133,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['reduce'],['reduce']
Energy Efficiency,// R.End points to the boundary instruction but the; // schedule doesn't include it,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:56,schedul,schedule,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// RBP is not included in the callee saved register block. After pushing RBP,; // everything is 16 byte aligned. Everything we allocate before an outgoing; // call must also be 16 byte aligned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:127,allocate,allocate,127,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// REDZONE: If the stack size is less than 128 bytes, we don't need; // to actually allocate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:84,allocate,allocate,84,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// ROOT-7647: res is allocated with `safemalloc` by colormap_asimage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:21,allocate,allocated,21,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,1,['allocate'],['allocated']
Energy Efficiency,// RP after scheduling the current region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:12,schedul,scheduling,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,// RP before scheduling the current region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:13,schedul,scheduling,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,// RVV has native FP_ROUND & FP_EXTEND conversions where the element type; // sizes are within one power-of-two of each other. Therefore conversions; // between vXf16 and vXf64 must be lowered as sequences which convert via; // vXf32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:99,power,power-of-two,99,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['power'],['power-of-two']
Energy Efficiency,// RVV has native int->float & float->int conversions where the; // element type sizes are within one power-of-two of each other. Any; // wider distances between type sizes have to be lowered as sequences; // which progressively narrow the gap in stages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:102,power,power-of-two,102,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['power'],['power-of-two']
Energy Efficiency,"// RVV only has truncates which operate from SEW*2->SEW, so lower arbitrary; // truncates as a series of ""RISCVISD::TRUNCATE_VECTOR_VL"" nodes which; // truncate by one power of two at a time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:168,power,power,168,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// R_SExpr is the result type for a traversal.; // A copy or non-destructive rewrite returns a newly allocated term.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h:101,allocate,allocated,101,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,1,['allocate'],['allocated']
Energy Efficiency,// Ranges that have been reserved in executor and already allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MapperJITLinkMemoryManager.h:58,allocate,allocated,58,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MapperJITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MapperJITLinkMemoryManager.h,1,['allocate'],['allocated']
Energy Efficiency,// Ranges that have been reserved in executor but not yet allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MapperJITLinkMemoryManager.h:58,allocate,allocated,58,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MapperJITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MapperJITLinkMemoryManager.h,1,['allocate'],['allocated']
Energy Efficiency,"// Re-assemble i64 arguments split up in SelectionDAGBuilder's; // visitInlineAsm / GetRegistersForValue functions.; //; // Note: This function was copied from, and is essentially identical; // to ARMISelDAGToDAG::SelectInlineAsm. It is very unfortunate that; // such hacking-up is necessary; a rethink of how inline asm operands; // are handled may be in order to make doing this more sane.; //; // TODO: fix inline asm support so I can simply tell it that 'i64'; // inputs to asm need to be allocated to the IntPair register type,; // and have that work. Then, delete this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:493,allocate,allocated,493,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:950,reduce,reduced,950,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Re-schedule loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:6,schedul,schedule,6,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Re-schedule stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:6,schedul,schedule,6,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Read Performance Monitoring Counters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:20,Monitor,Monitoring,20,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Monitor'],['Monitoring']
Energy Efficiency,"// ReadyCycle was been bumped up to the CurrCycle when this node was; // scheduled, but CurrCycle may have been eagerly advanced immediately after; // scheduling, so may now be greater than ReadyCycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:73,schedul,scheduled,73,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"// Rearrange the loop to be in schedule order. Note that the schedule may; // contain instructions that are not owned by the loop block (InstrChanges and; // friends), so we gracefully handle unowned instructions and delete any; // instructions that weren't in the schedule.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:31,schedul,schedule,31,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,3,['schedul'],['schedule']
Energy Efficiency,// Reassociate fsub/fadd sequences to create more fadd instructions and; // reduce dependency chains:; // ((X - Y) + Z) - Op1 --> (X + Z) - (Y + Op1),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:76,reduce,reduce,76,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Reassociate sub/add sequences to create more add instructions and; // reduce dependency chains:; // ((X - Y) + Z) - Op1 --> (X + Z) - (Y + Op1),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:73,reduce,reduce,73,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Recognize the following pattern:; //; // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask); //; // where bitmask is a mask that clears the upper bits of AndVT. The; // number of bits in bitmask must be a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:212,power,power,212,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,// Recomputing the order from scratch is likely more efficient than applying; // updates one-by-one for too many updates. The current cut-off is arbitrarily; // chosen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:53,efficient,efficient,53,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Record (on GFX10.3 and later) occurences of; // v_cmp_* SGPR, IMM, VGPR; // s_and_saveexec_b32 EXEC_SGPR_DEST, SGPR; // to be replaced with; // s_mov_b32 EXEC_SGPR_DEST, exec_lo; // v_cmpx_* IMM, VGPR; // to reduce pipeline stalls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp:211,reduce,reduce,211,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Record also values for monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:26,monitor,monitoring,26,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// Record how this instance was actually allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:41,allocate,allocated,41,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,3,['allocate'],['allocated']
Energy Efficiency,// Record the entry position so that we can jump back here and efficiently; // skip the whole block in case we lazy-load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:63,efficient,efficiently,63,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Record the original order of instructions before scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:52,schedul,scheduling,52,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,"// Records if a region is not yet scheduled, or schedule has been reverted,; // or we generally desire to reschedule it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:34,schedul,scheduled,34,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"// Records might actually allocate memory themselves, but they; // are allocated using a BumpPtrAllocator. Call their desctructors; // here manually so they are properly freeing their resources.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:26,allocate,allocate,26,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// Records the current number of allocated slots in the GOT; // (This would be equivalent to GOTEntries.size() were it not for relocations; // that consume more than one slot),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:33,allocate,allocated,33,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,1,['allocate'],['allocated']
Energy Efficiency,"// Red - CastColor; // Green - TypeColor; // Bold Green - DeclKindNameColor, UndeserializedColor; // Yellow - AddressColor, LocationColor; // Blue - CommentColor, NullColor, IndentColor; // Bold Blue - AttrColor; // Bold Magenta - StmtColor; // Cyan - ValueKindColor, ObjectKindColor; // Bold Cyan - ValueColor, DeclNameColor; // Decl kind names (VarDecl, FunctionDecl, etc)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTDumperUtils.h:23,Green,Green,23,interpreter/llvm-project/clang/include/clang/AST/ASTDumperUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTDumperUtils.h,2,['Green'],['Green']
Energy Efficiency,"// Reduce + OnPartialResult",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx:3,Reduce,Reduce,3,tree/dataframe/test/dataframe_callbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce - Perform Reduction Transformation on scalar\packed FP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce G to its entry block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce Hessenberg to real Schur form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixDEigen.cxx:3,Reduce,Reduce,3,math/matrix/src/TMatrixDEigen.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixDEigen.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce MangledName to [(<redirection>)].,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce across the upper and lower 32 lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce add-carry of bools to logic:; // ((zext BoolX) + (zext BoolY)) >> 1 --> zext (BoolX && BoolY),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce all of the unrolled parts into a single vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce broadcast source vector to lowest 128-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce element = LocalReduceList[i],MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,3,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce exclLVBranches to only those depending exclusively on exclLVservers; // Attention: counting loop, since erasing from container",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:3,Reduce,Reduce,3,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce exclLVServers to only those serving exclusively exclLVBranches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:3,Reduce,Reduce,3,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce false anti-dependencies to let the target's out-of-order execution; // engine do its thing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce high half, using low half result as initial value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce indent level for bodies of namespaces which were compacted,; // but only if their content was indented in the first place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce iset/nset to actual dependents of this PDF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx:3,Reduce,Reduce,3,roofit/roofitcore/src/RooAddHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce it to a constant now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce low half.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce maps if they grow huge.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce multiplies for difference-of-squares by factoring:; // (X * X) - (Y * Y) --> (X + Y) * (X - Y),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce operators",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/RModelParser_ONNX.cxx:3,Reduce,Reduce,3,tmva/sofie_parsers/src/RModelParser_ONNX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie_parsers/src/RModelParser_ONNX.cxx,2,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce pdfNSet to actual dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:3,Reduce,Reduce,3,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce placeholder expressions here. Note that this rejects the; // use of pseudo-object l-values in this position.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce projData: take out fitCat (component) columns and entries that don't match selected slice; // Construct cut string to only select projection data event that match the current slice; // Make cut string to exclude rows from projection data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx:3,Reduce,Reduce,3,roofit/roofitcore/src/RooSimultaneous.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce redzone size for small size objects, e.g. int, char[1]. MinRZ is; // at least 32 bytes, optimize when SizeInBytes is less than or equal to; // half of MinRZ.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce size by 1 as addasl itself can be removed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the LMUL of our slidedown and vmv.x.s to the smallest LMUL which; // contains our index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce the code after globalopt and ipsccp. Both can open up significant; // simplification opportunities, and both can propagate functions through; // function pointers. When this happens, we often have to resolve varargs; // calls, etc, so let instcombine do this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce the dataset with the RooCompositeDataStore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx:3,Reduce,Reduce,3,roofit/roofitcore/test/testRooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the list of Named Metadata nodes. We keep this as a list of; // names to avoid having to convert back and forth every time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the list of operands to named metadata nodes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the list of passes which causes the optimizer to crash...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce the max[] field to N for columns that have ""width=N""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:3,Reduce,Reduce,3,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the maximum schedule region size by the size of the; // previous scheduling run.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,"['Reduce', 'schedul']","['Reduce', 'schedule', 'scheduling']"
Energy Efficiency,"// Reduce the number of bins for this axis to the number of bins having a label.; // Works only for the given axis passed in the option; // The method will remove only the extra bins existing after the last ""labeled"" bin.; // Note that if there are ""un-labeled"" bins present between ""labeled"" bins they will not be removed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:3,Reduce,Reduce,3,hist/hist/src/TProfileHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the number of buckets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,3,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the number of cr-logical ops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the number of edges from a very conservative set; // to an aesthetically pleasing subset that conveys the; // necessary information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the number of instructions duplicated when optimizing strictly for; // size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce the number of reallocations, with a bit of hysteresis. The; // number here is chosen so the first allocation will more-than-likely not; // allocate more than 1K.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/Utility.h:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/include/llvm/Demangle/Utility.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/Utility.h,2,"['Reduce', 'allocate']","['Reduce', 'allocate']"
Energy Efficiency,"// Reduce the priority of this result by one, to give it a slight; // advantage over other results whose names don't match so closely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the profitability of splitting induction registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the result of transformation eagerly within each task.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce the risk of the files or sockets being closed after the; // end of 'main' (or more exactly before the library start being; // unloaded).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:3,Reduce,Reduce,3,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce the set of vectors by summing its equally-indexed components",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:3,Reduce,Reduce,3,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce the shift amount and add zeros to the LSBs so it will match LUI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce the shift amount and add zeros to the LSBs so it will match; // LUI, then shift left with SLLI.UW to clear the upper 32 set bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce to Hessenberg form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixDEigen.cxx:3,Reduce,Reduce,3,math/matrix/src/TMatrixDEigen.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixDEigen.cxx,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce to original width if needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['Reduce'],['Reduce']
Energy Efficiency,// Reduce to the alloca case:; // Create an alloca and replace all uses of the arg with it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce total size by 2 if original tfr can be deleted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce unroll count to be modulo of TripCount for partial unrolling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce unroll count to be the largest power-of-two factor of; // the original count which satisfies the threshold limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,2,"['Reduce', 'power']","['Reduce', 'power-of-two']"
Energy Efficiency,// Reduce v2i64 to v4i32 if we don't need the upper bits or are known zero.; // TODO: Move to DAGCombine/SimplifyDemandedBits?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce width of sign operand, we only need the highest bit.; //; // fcopysign f64:x, f64:y ->; // fcopysign f64:x, (extract_vector_elt (bitcast f64:y to v2f32), 1); // TODO: In some cases it might make sense to go all the way to f16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce within each pair of rows (i.e. 32 lanes).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Reduce within each row of 16 lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:3,Reduce,Reduce,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce ymin by half an order of magnitude",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:3,Reduce,Reduce,3,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,2,['Reduce'],['Reduce']
Energy Efficiency,"// Reduce; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TSequentialExecutor.hxx:3,Reduce,Reduce,3,core/base/inc/ROOT/TSequentialExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TSequentialExecutor.hxx,3,['Reduce'],['Reduce']
Energy Efficiency,// ReduceList: thread local Reduce list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:3,Reduce,ReduceList,3,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,8,['Reduce'],"['Reduce', 'ReduceList']"
Energy Efficiency,"// ReduceList: thread local Reduce list.; // At the stage of the computation when this function is called, partially; // aggregated values reside in the first lane of every active warp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:3,Reduce,ReduceList,3,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,2,['Reduce'],"['Reduce', 'ReduceList']"
Energy Efficiency,// ReduceToLwp = true/false - reduce to LWP/SWP instruction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:3,Reduce,ReduceToLwp,3,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,2,"['Reduce', 'reduce']","['ReduceToLwp', 'reduce']"
Energy Efficiency,"// ReduceType, OpCodes, ReduceFunction,; // OpInfo(TransferOperands),; // ImmField(Shift, LBound, HBound, ImmFieldPosition)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:3,Reduce,ReduceType,3,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,2,['Reduce'],"['ReduceFunction', 'ReduceType']"
Energy Efficiency,"// Reduced Chi^2 w.r.t data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooChi2MCSModule.h:3,Reduce,Reduced,3,roofit/roofit/inc/RooChi2MCSModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooChi2MCSModule.h,1,['Reduce'],['Reduced']
Energy Efficiency,"// Reduced tiny cores don't support load/store with displacement. However,; // they do support postincrement. So we'll simply adjust the pointer before; // and after and use postincrement to load multiple registers.; // Add offset. The offset can be 0 when expanding this instruction from the; // more specific LDWRdPtr instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:3,Reduce,Reduced,3,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,1,['Reduce'],['Reduced']
Energy Efficiency,"// Reduces colordepth of an image. (See TASImage::Vectorize)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/inc/TImage.h:3,Reduce,Reduces,3,graf2d/graf/inc/TImage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/inc/TImage.h,1,['Reduce'],['Reduces']
Energy Efficiency,"// Reduces the fraction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGraphPolargram.cxx:3,Reduce,Reduces,3,graf2d/graf/src/TGraphPolargram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGraphPolargram.cxx,1,['Reduce'],['Reduces']
Energy Efficiency,"// Reducing the width of a volatile load is illegal. For atomics, we may be; // able to reduce the width provided we never widen again. (see D66309)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:88,reduce,reduce,88,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Reference to allocated memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:16,allocate,allocated,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Reference to zero-allocated memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,allocate,allocated,21,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// References:; //; // 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; // An adaptive algorithm for numerical integration over; // an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; // 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; // integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217.; //to be changed later",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx:84,adapt,adaptive,84,math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,2,['adapt'],['adaptive']
Energy Efficiency,"// Refine monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:10,monitor,monitoring,10,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,2,['monitor'],['monitoring']
Energy Efficiency,// Reg is used by MI. Return the new register MI should use to adhere to the; // schedule. Insert phis as necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:81,schedul,schedule,81,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['schedule']
Energy Efficiency,// RegAllocator might allocate FramePointer and NegSizeReg in the same phyreg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:22,allocate,allocate,22,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,// RegionEndIdx is the slot index of the last non-debug instruction in the; // scheduling region. So we may have RegionBeginIdx == RegionEndIdx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:79,schedul,scheduling,79,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Regions returned by malloc() are represented by SymbolicRegion objects; // within HeapSpaceRegion. Of course, free() can work on memory allocated; // outside the current function, so UnknownSpaceRegion is also a; // possibility here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:139,allocate,allocated,139,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Register callbacks to schedule sanitizer passes at the appropriate part; // of the pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:25,schedul,schedule,25,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// Register numbers can represent physical registers, virtual registers, and; // sometimes stack slots. The unsigned values are divided into these ranges:; //; // 0 Not a register, can be used as a sentinel.; // [1;2^30) Physical registers assigned by TableGen.; // [2^30;2^31) Stack slots. (Rarely used.); // [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.; //; // Further sentinels can be allocated from the small negative integers.; // DenseMapInfo<unsigned> uses -1u and -2u.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h:406,allocate,allocated,406,interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h,2,['allocate'],['allocated']
Energy Efficiency,"// Register numbers can represent physical registers, virtual registers, and; // sometimes stack slots. The unsigned values are divided into these ranges:; //; // 0 Not a register, can be used as a sentinel.; // [1;2^30) Physical registers assigned by TableGen.; // [2^30;2^31) Stack slots. (Rarely used.); // [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.; //; // Further sentinels can be allocated from the small negative integers.; // DenseMapInfo<unsigned> uses -1u and -2u.; /// Return the size in bits of a register from class RC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:406,allocate,allocated,406,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"// Register pressure is considered 'CRITICAL' if it is approaching a value; // that would reduce the wave occupancy for the execution unit. When; // register pressure is 'CRITICAL', increasing SGPR and VGPR pressure both; // has the same cost, so we don't need to prefer one over the other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:90,reduce,reduce,90,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Register pressure tracking is imprecise. This can happen. But we try; // hard not to let it happen because it likely results in poor scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:136,schedul,scheduling,136,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Register unit functions.; //; // Fixed interference occurs when MachineInstrs use physregs directly; // instead of virtual registers. This typically happens when passing; // arguments to a function call, or when instructions require operands in; // fixed registers.; //; // Each physreg has one or more register units, see MCRegisterInfo. We; // track liveness per register unit to handle aliasing registers more; // efficiently.; /// Return the live range for register unit \p Unit. It will be computed if; /// it doesn't exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:420,efficient,efficiently,420,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['efficient'],['efficiently']
Energy Efficiency,// Registers in the sequence are allocated contiguously so we can just; // use register number to pick one of three round-robin temps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:33,allocate,allocated,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Registers that may be reserved when RA doesn't allocate enough; // registers to plan for the case where an indirect branch ends up; // being needed during branch relaxation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h:50,allocate,allocate,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,1,['allocate'],['allocate']
Energy Efficiency,"// Regmasks are not accounted for in the scheduling graph, so we need; // to explicitly check for dependencies caused by them. They should only; // appear on calls, so it's not too pessimistic to reject all regmask; // dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:41,schedul,scheduling,41,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Reject alignments that aren't either a power of two or zero, for ML.exe; // compatibility. Alignment of zero is silently rounded up to one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:42,power,power,42,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['power'],['power']
Energy Efficiency,"// Reject alignments that aren't either a power of two or zero,; // for gas compatibility. Alignment of zero is silently rounded; // up to one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:42,power,power,42,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['power'],['power']
Energy Efficiency,"// Release all DAG roots for scheduling, not including EntrySU/ExitSU.; //; // Nodes with unreleased weak edges can still be roots.; // Release top roots in forward order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,schedul,scheduling,29,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Release allocated memory ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:11,allocate,allocated,11,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Release any allocated I/O buffers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:15,allocate,allocated,15,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['allocate'],['allocated']
Energy Efficiency,// Release bottom roots in reverse order so the higher priority nodes appear; // first. This is more natural and slightly more efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:127,efficient,efficient,127,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Release dependent instructions for scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:38,schedul,scheduling,38,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Releases previously allocated physical registers from the register file(s).; // This method is called from `invalidateRegisterMapping()`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h:23,allocate,allocated,23,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,1,['allocate'],['allocated']
Energy Efficiency,"// Remainder interval. Don't try splitting again, spill if it doesn't; // allocate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:74,allocate,allocate,74,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Remember that we allocated this memory,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:20,allocate,allocated,20,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Remember the registers that are used in different stages. The index is; // the iteration, or stage, that the instruction is scheduled in. This is; // a map between register names in the original block and the names created; // in each stage of the pipelined loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:127,schedul,scheduled,127,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// RemoteLaneToThread: Copy over a Reduce list from a remote lane in; // the warp using shuffle instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:35,Reduce,Reduce,35,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Remove instructions inside unreachable blocks. This prevents the; // instcombine code from having to deal with some bad special cases, and; // reduces use counts of instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:146,reduce,reduces,146,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Remove leading and trailing spaces from the given string. Return; // a new string allocated with new[].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlUri.cxx:85,allocate,allocated,85,gui/guihtml/src/TGHtmlUri.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlUri.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Remove memory defs directly if they don't produce results, but only; // queue other dead instructions for later removal. They may have been; // used as memory locations that have been cached by BatchAA. Removing; // them here may lead to newly created instructions to be allocated at the; // same address, yielding stale cache entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:274,allocate,allocated,274,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Remove objects scheduled for removal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:18,schedul,scheduled,18,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['schedul'],['scheduled']
Energy Efficiency,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:56,consumption,consumption,56,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['consumption'],['consumption']
Energy Efficiency,// Remove the original WaterList entry; we want subsequent insertions in; // this vicinity to go after the one we're about to insert. This; // considerably reduces the number of times we have to move the same CPE; // more than once and is also important to ensure the algorithm terminates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:156,reduce,reduces,156,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,3,['reduce'],['reduces']
Energy Efficiency,"// Remove the set of columns that are already scheduled for being loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:46,schedul,scheduled,46,tree/ntuple/v7/src/RClusterPool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx,1,['schedul'],['scheduled']
Energy Efficiency,"// Remove this object from the output list and schedule it for distruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:47,schedul,schedule,47,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['schedul'],['schedule']
Energy Efficiency,"// RemoveDIs: if we're using the new debug-info format, allocate a; // DPValue directly instead of a dbg.value intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:56,allocate,allocate,56,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// RemoveUnusedGlobalValue - Loop over all of the uses of the specified; // GlobalValue, looking for the constant pointer ref that may be pointing to; // it. If found, check to see if the constant pointer ref is safe to; // destroy, and if so, nuke it. This will reduce the reference count on the; // global value, which might make it deader.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:263,reduce,reduce,263,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Rename relocation sections associated to the allocated sections.; // For example, if we rename .text to .prefix.text, we also rename; // .rel.text to .rel.prefix.text.; //; // Dynamic relocation sections (SHT_REL[A] with SHF_ALLOC) are handled; // above, e.g., .rela.plt is renamed to .prefix.rela.plt, not; // .rela.prefix.plt since GNU objcopy does so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp:48,allocate,allocated,48,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Replace ((add A, B) != 0) with (A != -B) if A or B is; // efficiently invertible, or if the add has just this one use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:61,efficient,efficiently,61,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Replace (setcc eq (and x, C)) with (setcc ne (and x, C))) to generate; // BEXTI, where C is power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:95,power,power,95,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// Replace any non temporal load over 256-bit with a series of 256 bit loads; // and a scalar/vector load less than 256. This way we can utilize 256-bit; // loads and reduce the amount of load instructions generated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:167,reduce,reduce,167,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Replace definitions of weak symbols for which symbols already exist by; // declarations. This reduces the amount of emitted symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp:97,reduce,reduces,97,interpreter/cling/lib/Interpreter/BackendPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Replace sret attribute with noalias. This reduces register pressure by; // avoiding a register copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:45,reduce,reduces,45,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Replace the variable that was just assigned with the last active; // variable for efficient removal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:85,efficient,efficient,85,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Replace uses of ith variable with a constantexpr to the corresponding; // field of the instance that will be allocated by AMDGPUMachineFunction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:112,allocate,allocated,112,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Replace uses of module scope variable from kernel functions that; // allocate the module scope variable, otherwise leave them unchanged; // Record on each kernel whether the module scope global is used by it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:72,allocate,allocate,72,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Represent a single object allocated on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:29,allocate,allocated,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"// Represents stack ids in this context, recorded as indices into the; // StackIds vector in the summary index, which in turn holds the full 64-bit; // stack ids. This reduces memory as there are in practice far fewer unique; // stack ids than stack id references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:168,reduce,reduces,168,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,2,['reduce'],['reduces']
Energy Efficiency,"// Require that the total load bit width is a legal integer type.; // For example, <8 x i8> --> i64 is a legal integer on a 64-bit target.; // But <16 x i8> --> i128 is not, so the backend probably can't reduce it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:204,reduce,reduce,204,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Resamples OpsNum in case the number of operands was reduced. This; // happens with X86.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:55,reduce,reduced,55,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Reserve a section id. We'll allocate the section later; // once we know the total size,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:31,allocate,allocate,31,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Reserve entries in the vector for each of the SUnits we are creating. This; // ensure that reallocation of the vector won't happen, so SUnit*'s won't get; // invalidated.; // FIXME: Multiply by 2 because we may clone nodes during scheduling.; // This is a temporary workaround.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:233,schedul,scheduling,233,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Reserve null register - it shall never be allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:45,allocate,allocated,45,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Reserve resources for the scheduled instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:29,schedul,scheduled,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Reserve special purpose registers.; //; // EXEC_LO and EXEC_HI could be allocated and used as regular register, but; // this seems likely to result in bugs, so I'm marking them as reserved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:75,allocate,allocated,75,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Reserve the base register if we need to allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYRegisterInfo.cpp:43,allocate,allocate,43,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYRegisterInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Reserve the base register if we need to both realign the stack and; // allocate variable-sized objects at runtime. This should test the; // same conditions as MipsFrameLowering::hasBP().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:74,allocate,allocate,74,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Reset member only if memory was allocated successfully,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp:35,allocate,allocated,35,interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Reset the MI position corresponding to the register pressure. This allows; // schedulers to move instructions above the RegPressureTracker's; // CurrPos. Since the pressure is computed before CurrPos, the iterator; // position changes while pressure does not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:81,schedul,schedulers,81,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,1,['schedul'],['schedulers']
Energy Efficiency,// Reset the base value of the first factor to the new expression tree.; // We'll remove all the factors with the same power in a second pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:119,power,power,119,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['power'],['power']
Energy Efficiency,"// Reshuffle to get only unique values.; // If some of the scalars are duplicated in the vectorization; // tree entry, we do not vectorize them but instead generate a; // mask for the reuses. But if there are several users of the; // same entry, they may have different vectorization factors.; // This is especially important for PHI nodes. In this case, we; // need to adapt the resulting instruction for the user; // vectorization factor and have to reshuffle it again to take; // only unique elements of the vector. Without this code the; // function incorrectly returns reduced vector instruction with; // the same elements, not with the unique ones.; // block:; // %phi = phi <2 x > { .., %entry} {%shuffle, %block}; // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>; // ... (use %2); // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}; // br %block",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:370,adapt,adapt,370,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['adapt', 'reduce']","['adapt', 'reduced']"
Energy Efficiency,// Resource pressure distribution. There is an element for every processor; // resource declared by the scheduling model. Quantities are number of cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:104,schedul,scheduling,104,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,1,['schedul'],['scheduling']
Energy Efficiency,// Restore links previous scheduling variant has overridden.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:26,schedul,scheduling,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Restore the monitor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:15,monitor,monitor,15,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// Restrict local memory usage so that we don't drastically reduce occupancy,; // unless it is already significantly reduced.; // TODO: Have some sort of hint or other heuristics to guess occupancy based; // on other factors..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:60,reduce,reduce,60,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,// Restrict this fold only for single-use 'and' (PR10267).; // ((%x & C) == 0) --> %x u< (-C) iff (-C) is power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:106,power,power,106,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,// Retry function scheduling if we found resulting occupancy and it is; // lower than used for other scheduling passes. This will give more freedom; // to schedule low register pressure blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:18,schedul,scheduling,18,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,3,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,// Return 0 as there is no viable power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,power,power,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and; // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of; // writing this) is:; // With C as a power of 2 and C != 0 and C != INT_MIN:; // AddAnd:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq and(add(A, C), ~(C + C)), 0); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne and(add(A, C), ~(C + C)), 0); // ABS:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq Abs(A), C); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne Abs(A), C); //; // @param LogicOp the logic op; // @param SETCC0 the first of the SETCC nodes; // @param SETCC0 the second of the SETCC nodes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:186,power,power,186,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['power'],['power']
Energy Efficiency,// Return false if this function info was already allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:50,allocate,allocated,50,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// Return negative, zero, or positive, if LHS is less than, equal to, or greater; // than RHS, respectively. A three-way result allows recursive comparisons to be; // more efficient.; // If the max analysis depth was reached, return std::nullopt, assuming we do; // not know if they are equivalent for sure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:172,efficient,efficient,172,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Return number of strings in the pool. The empty string is allocated; // at the slot zero. We substract 1 to indicate the number of non empty; // strings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVStringPool.h:61,allocate,allocated,61,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVStringPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVStringPool.h,1,['allocate'],['allocated']
Energy Efficiency,"// Return reduced token with suffix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:10,reduce,reduced,10,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['reduce'],['reduced']
Energy Efficiency,// Return the cycle of the earliest scheduled instruction in the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:36,schedul,scheduled,36,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Return the cycle of the latest scheduled instruction in the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:34,schedul,scheduled,34,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Return the non-redundant list of WriteProcRes used by the given sched class.; // The scheduling model for LLVM is such that each instruction has a certain; // number of uops which consume resources which are described by WriteProcRes; // entries. Each entry describe how many cycles are spent on a specific ProcRes; // kind.; // For example, an instruction might have 3 uOps, one dispatching on P0; // (ProcResIdx=1) and two on P06 (ProcResIdx = 7).; // Note that LLVM additionally denormalizes resource consumption to include; // usage of super resources by subresources. So in practice if there exists a; // P016 (ProcResIdx=10), then the cycles consumed by P0 are also consumed by; // P06 (ProcResIdx = 7) and P016 (ProcResIdx = 10), and the resources consumed; // by P06 are also consumed by P016. In the figure below, parenthesized cycles; // denote implied usage of superresources by subresources:; // P0 P06 P016; // uOp1 1 (1) (1); // uOp2 1 (1); // uOp3 1 (1); // =============================; // 1 3 3; // Eventually we end up with three entries for the WriteProcRes of the; // instruction:; // {ProcResIdx=1, Cycles=1} // P0; // {ProcResIdx=7, Cycles=3} // P06; // {ProcResIdx=10, Cycles=3} // P016; //; // Note that in this case, P016 does not contribute any cycles, so it would; // be removed by this function.; // FIXME: Merge this with the equivalent in llvm-mca.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:88,schedul,scheduling,88,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,2,"['consumption', 'schedul']","['consumption', 'scheduling']"
Energy Efficiency,"// Return the number of 32-bit words loaded by LDM or stored by STM. If this; // can't be easily determined return 0 (missing MachineMemOperand).; //; // FIXME: The current MachineInstr design does not support relying on machine; // mem operands to determine the width of a memory access. Instead, we expect; // the target to provide this information based on the instruction opcode and; // operands. However, using MachineMemOperand is the best solution now for; // two reasons:; //; // 1) getNumMicroOps tries to infer LDM memory width from the total number of MI; // operands. This is much more dangerous than using the MachineMemOperand; // sizes because CodeGen passes can insert/remove optional machine operands. In; // fact, it's totally incorrect for preRA passes and appears to be wrong for; // postRA passes as well.; //; // 2) getNumLDMAddresses is only used by the scheduling machine model and any; // machine model that calls this should handle the unknown (zero size) case.; //; // Long term, we should require a target hook that verifies MachineMemOperand; // sizes during MC lowering. That target hook should be local to MC lowering; // because we can't ensure that it is aware of other MI forms. Doing this will; // ensure that MachineMemOperands are correctly propagated through all passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:877,schedul,scheduling,877,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Return the number of allocated TopoSigs. The first TopoSig representing; // leaf registers is allocated number 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h:24,allocate,allocated,24,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.h,2,['allocate'],['allocated']
Energy Efficiency,"// Return the value in the inclusive range [Lo,Hi] that is aligned to the; // highest power of two. Note that the result is well defined for all inputs; // including corner cases like:; // - if Lo == Hi, return that value; // - if Lo == 0, return 0 (even though the ""- 1"" below underflows; // - if Lo > Hi, return 0 (as if the range wrapped around)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:86,power,power,86,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,1,['power'],['power']
Energy Efficiency,"// Return true if its desirable to perform the following transform:; // (fmul C, (uitofp Pow2)); // -> (bitcast_to_FP (add (bitcast_to_INT C), Log2(Pow2) << mantissa)); // (fdiv C, (uitofp Pow2)); // -> (bitcast_to_FP (sub (bitcast_to_INT C), Log2(Pow2) << mantissa)); //; // This is only queried after we have verified the transform will be bitwise; // equals.; //; // SDNode *N : The FDiv/FMul node we want to transform.; // SDValue FPConst: The Float constant operand in `N`.; // SDValue IntPow2: The Integer power of 2 operand in `N`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:512,power,power,512,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['power'],['power']
Energy Efficiency,// Return true if right should be scheduled with higher priority than left.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:34,schedul,scheduled,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:57,schedul,schedule,57,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Return true if this SUnit uses a CopyFromReg node marked as a VRegCycle. This; // means a node that defines the VRegCycle has not been scheduled yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:138,schedul,scheduled,138,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Return true if we can prove that, whenever Neg and Pos are both in the; // range [0, EltSize), Neg == (Pos == 0 ? 0 : EltSize - Pos). This means that; // for two opposing shifts shift1 and shift2 and a value X with OpBits bits:; //; // (or (shift1 X, Neg), (shift2 X, Pos)); //; // reduces to a rotate in direction shift2 by Pos or (equivalently) a rotate; // in direction shift1 by Neg. The range [0, EltSize) means that we only need; // to consider shift amounts with defined behavior.; //; // The IsRotate flag should be set when the LHS of both shifts is the same.; // Otherwise if matching a general funnel shift, it should be clear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:285,reduce,reduces,285,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Return whether @p LHS is ""more reduced"" that @p RHS. That is, whether; // @p RHS should be preferred over @p LHS in a reduced output. This is a; // partial order, a Value may not be preferable over another.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp:34,reduce,reduced,34,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,2,['reduce'],['reduced']
Energy Efficiency,// ReturnValue should be valid as long as the coroutine's return type; // is not void. The assertion could help us to reduce the check later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:118,reduce,reduce,118,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Returns a sequence of increasing powers of two corresponding to all the; // Execution flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h:36,power,powers,36,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/CodeTemplate.h,1,['power'],['powers']
Energy Efficiency,// Returns an LLVM function to call for initializing loop bounds using OpenMP; // static scheduling depending on `type`. Only i32 and i64 are supported by the; // runtime. Always interpret integers as unsigned similarly to; // CanonicalLoopInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:89,schedul,scheduling,89,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Returns number of allocated slots,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:21,allocate,allocated,21,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Returns one of the source operands if the shuffle can be reduced to a; // MOVQ, copying the lower 64-bits and zero-extending to the upper 64-bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,reduce,reduced,60,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Returns product of matrix diagonal elements in d1 and d2. d1 is a mantissa and d2; // an exponent for powers of 2. If matrix is in diagonal or triangular-matrix form this; // will be the determinant.; // Based on Bowler, Martin, Peters and Wilkinson in HACLA",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBase.cxx:105,power,powers,105,math/matrix/src/TDecompBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBase.cxx,1,['power'],['powers']
Energy Efficiency,"// Returns the bandwidth for the adaptive KDE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:33,adapt,adaptive,33,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// Returns the bandwidth for the non adaptive KDE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:37,adapt,adaptive,37,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,2,['adapt'],['adaptive']
Energy Efficiency,"// Returns the bandwidths for the adaptive KDE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:34,adapt,adaptive,34,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// Returns the index of the WebAssembly local to which the stack object; // FrameIndex in MF should be allocated, or std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.h:103,allocate,allocated,103,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.h,1,['allocate'],['allocated']
Energy Efficiency,// Returns true if MI can be reduced to lwp/swp instruction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:29,reduce,reduced,29,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Returns true if scheduling should be reverted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:19,schedul,scheduling,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,// Returns true if the dispatch logic couldn't dispatch a full group due to; // unavailable scheduler and/or LS resources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:92,schedul,scheduler,92,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,"// Returns true if the mask matches consecutive bytes, and the first byte; // begins at a power of 2 byte offset from 0th byte",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:90,power,power,90,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// Returns true if the new schedule may result in more spilling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:27,schedul,schedule,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['schedule']
Energy Efficiency,// Returns true if this strategy should be applied to a ScheduleDAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:56,Schedul,ScheduleDAG,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['Schedul'],['ScheduleDAG']
Energy Efficiency,// Returns whether addrx+offset LLVM extension form should be used to reduce; // debug_addr size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:70,reduce,reduce,70,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,1,['reduce'],['reduce']
Energy Efficiency,// Returns whether novel exprloc addrx+offset encodings should be used to; // reduce debug_addr size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:78,reduce,reduce,78,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,1,['reduce'],['reduce']
Energy Efficiency,// Revert if this region's schedule would cause a drop in occupancy or; // spilling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:27,schedul,schedule,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Revert scheduling if we have dropped occupancy or there is some other; // reason that the original schedule is better.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:10,schedul,scheduling,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,// Reverting optimal scheduling in favour of occupancy with basic block(s); // having dense global memory access can potentially hurt performance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:21,schedul,scheduling,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Rewrite uses that have been scheduled already to use the new; // Phi register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:31,schedul,scheduled,31,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Right now we always allocate spill slots that are of the same; // size as the value we're about to spill (the size of spillee can; // vary since we spill vectors of pointers too). At some point we; // can consider allowing spills of smaller values to larger slots; // (i.e. change the '==' in the assert below to a '>=').,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:23,allocate,allocate,23,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// RooAbsData::reduce arguments",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooGlobalFunc.h:15,reduce,reduce,15,roofit/roofitcore/inc/RooGlobalFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooGlobalFunc.h,2,['reduce'],['reduce']
Energy Efficiency,// Round MaxBitWidth up to the next power-of-two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,power,power-of-two,36,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// Round the bins to the next power of 2; take into account the possible inflation; // of the range",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:30,power,power,30,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['power'],['power']
Energy Efficiency,// Round the number of bits to the next power of two bits,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:40,power,power,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['power'],['power']
Energy Efficiency,// Round the number of elements to the next power of two elements,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:44,power,power,44,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['power'],['power']
Energy Efficiency,"// Round up EVT to have power-of-2 elements, and keep checking if it; // qualifies for HVX, dividing it in half after each step.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:24,power,power-of-,24,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['power'],['power-of-']
Energy Efficiency,// Round up to a power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,power,power,17,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['power'],['power']
Energy Efficiency,// Round up to the next power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:24,power,power,24,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['power'],['power']
Energy Efficiency,// Run constant folding to see if we can reduce the condition to a simple; // constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:41,reduce,reduce,41,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Run passes after prolog-epilog insertion and before the second instruction; // scheduling pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp:82,schedul,scheduling,82,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetMachine.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Run register allocation and passes that are tightly coupled with it,; // including phi elimination and scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:106,schedul,scheduling,106,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['schedul'],['scheduling']
Energy Efficiency,// Run the argument-move pass immediately after the ScheduleDAG scheduler; // so that we can fix up the ARGUMENT instructions before anything else; // sees them in the wrong place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:52,Schedul,ScheduleDAG,52,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,2,"['Schedul', 'schedul']","['ScheduleDAG', 'scheduler']"
Energy Efficiency,// Run the register coloring pass to reduce the total number of registers.; // This runs after stackification so that it doesn't consider registers; // that become stackified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:37,reduce,reduce,37,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// RuntimeDyld clients often want to handle the memory management of; // what gets placed where. For JIT clients, this is the subset of; // JITMemoryManager required for dynamic loading of binaries.; //; // FIXME: As the RuntimeDyld fills out, additional routines will be needed; // for the varying types of objects to be allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h:322,allocate,allocated,322,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h,1,['allocate'],['allocated']
Energy Efficiency,"// S a m e w i t h c u s t o m c o n f i g u r a t i o n; // -----------------------------------------------------------; // Construct a custom configuration which uses the adaptive Gauss-Kronrod technique; // for closed 1D integrals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:173,adapt,adaptive,173,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['adapt'],['adaptive']
Energy Efficiency,"// SDDbgValues are allocated by a BumpPtrAllocator, which means the destructor; // may not be called; therefore all member arrays must also be allocated by; // that BumpPtrAllocator, to ensure that they are correctly freed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h:19,allocate,allocated,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,2,['allocate'],['allocated']
Energy Efficiency,// SMSTART and SMSTOP are also scheduling barriers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:31,schedul,scheduling,31,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// SU->BotReadyCycle was set to CurrCycle when it was scheduled. However,; // CurrCycle may have advanced since then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,schedul,scheduled,54,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// SU->TopReadyCycle was set to CurrCycle when it was scheduled. However,; // CurrCycle may have advanced since then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,schedul,scheduled,54,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:132,allocate,allocated,132,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Same as above, but for return values, so only allocate for R3 and R4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:49,allocate,allocate,49,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Sample array of input points from both pdfs; // Note that returned arrays have optional buffers zones below and above range ends; // to reduce cyclical effects and have been cyclically rotated so that bin containing; // zero value is at position zero. Example:; //; // original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; // add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; // rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; //; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:139,reduce,reduce,139,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['reduce'],['reduce']
Energy Efficiency,// Sanity check: the map should point to the same data as the Pattern.; // Both strings are allocated in the pool using insertStrRef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:92,allocate,allocated,92,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Save original instruction order before scheduling for possible revert.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:42,schedul,scheduling,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Scale scheduled micro-ops for comparing with the critical resource.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:9,schedul,scheduled,9,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Scale the actual allocated slab size based on the number of slabs; // allocated. Every GrowthDelay slabs allocated, we double; // the allocated size to reduce allocation frequency, but saturate at; // multiplying the slab size by 2^30.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:20,allocate,allocated,20,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,5,"['allocate', 'reduce']","['allocated', 'reduce']"
Energy Efficiency,// Scaled count of micro-ops left to schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:37,schedul,schedule,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['schedule']
Energy Efficiency,// Scan for MFMA long latency instructions and try to add a dependency; // of available SALU instructions to give them a chance to fill MFMA; // shadow. That is desirable to fill MFMA shadow with SALU instructions; // rather than VALU to prevent power consumption bursts and throttle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:246,power,power,246,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,2,"['consumption', 'power']","['consumption', 'power']"
Energy Efficiency,"// Scan the function's instructions looking for frame index references.; // For each, ask the target if it wants a virtual base register for it; // based on what we can tell it about where the local will end up in the; // stack frame. If it wants one, re-use a suitable one we've previously; // allocated, or if there isn't one that fits the bill, allocate a new one; // and ask the target to create a defining instruction for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:295,allocate,allocated,295,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// Scan the operand list, checking to see if there are any common factors; // between operands. Consider something like A*A+A*B*C+D. We would like to; // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.; // To efficiently find this, we count the number of times a factor occurs; // for any ADD operands that are MULs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:193,reduce,reduces,193,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,"['efficient', 'reduce']","['efficiently', 'reduces']"
Energy Efficiency,"// Scan through looking for adjacent LDS operations with constant offsets from; // the same base register. We rely on the scheduler to do the hard work of; // clustering nearby loads, and assume these are all adjacent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:122,schedul,scheduler,122,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Scene bounding box center sphere (green) and",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:37,green,green,37,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['green'],['green']
Energy Efficiency,"// Schedule ""replace all uses with"" to happen after materializing is; // done. It is not safe to do it now, since ValueMapper may be holding; // pointers to constants that will get deleted if RAUW runs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule PushPop Optimization before expansion of Pseudo instruction,; // ensuring return instruction is detected correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule a region: possibly reorder instructions.; // This invalidates the original region iterators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule aggressively for latency in PostRA mode. We don't check for; // acyclic latency during PostRA, and highly out-of-order processors will; // skip PostRA scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,"['Schedul', 'schedul']","['Schedule', 'scheduling']"
Energy Efficiency,// Schedule algorithms,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule analysis pass that is managed by a new manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule analysis pass that is managed by the same pass manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule as far as possible in the direction of no choice. This is most; // efficient, but also provides the best heuristics for CriticalPSets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,6,"['Schedul', 'efficient']","['Schedule', 'efficient']"
Energy Efficiency,// Schedule as many instructions in each cycle as possible. So don't make an; // instruction available unless it is ready in the current cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule consisting of MachineInstr* is considered 'detached'; // and already interleaved with debug values,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule deferred processing of TRefArray into proxy list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:3,Schedul,Schedule,3,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule each sequence of instructions not interrupted by a label; // or anything else that effectively needs to shut down scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,"['Schedul', 'schedul']","['Schedule', 'scheduling']"
Energy Efficiency,// Schedule for deletion at the end of pass run.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule for real now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule glue operand right above N.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule high latencies early so you can hide them better.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule known to have excess register pressure. Be more conservative in; // increasing ILP and preserving VGPRs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule low latency instructions as top as possible.; // Order of priority is:; // . Low latency instructions which do not depend on other low latency; // instructions we haven't waited for; // . Other instructions which do not depend on low latency instructions; // we haven't waited for; // . Low latencies; // . All other instructions; // Goal is to get: low latency instructions - independent instructions; // - (eventually some more low latency instructions); // - instructions that depend on the first low latency instructions.; // If in the block there is a lot of constant loads, the SGPR usage; // could go quite high, thus above the arbitrary limit of 60 will encourage; // use the already loaded constants (in order to release some SGPRs) before; // loading more.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule physical register definitions close to their use. This is; // motivated by microarchitectures that can fuse cmp+jump macro-ops. But as; // long as shortening physreg live ranges is generally good, we can defer; // creating a subtarget hook.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule something valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule tasks for workers based on the currently estimated processing speeds; // Update performances; // slstat->fStatus was updated before;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerUnit.cxx:3,Schedul,Schedule,3,proof/proofplayer/src/TPacketizerUnit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerUnit.cxx,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule the destruction of TROOT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:3,Schedul,Schedule,3,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LL/SC block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LR/SC block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule the expansion of AtomicPseudos at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LL/SC block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule the instruction for execution on the hardware.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/ExecuteStage.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule this ASAP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,// Schedule type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,2,['Schedul'],['Schedule']
Energy Efficiency,"// Schedule zero-latency TokenFactor below any nodes that may increase the; // schedule height. Otherwise, ancestors of the TokenFactor may appear to; // have false stalls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:3,Schedul,Schedule,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,2,"['Schedul', 'schedul']","['Schedule', 'schedule']"
Energy Efficiency,// ScheduleDAGMI initializes SchedImpl's per-region policy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Schedul,ScheduleDAGMI,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Schedul'],['ScheduleDAGMI']
Energy Efficiency,// Scheduler sends regions from the end of the block upwards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:3,Schedul,Scheduler,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['Schedul'],['Scheduler']
Energy Efficiency,// Scheduler was unable to issue all the ready instructions because some; // pipeline resources were unavailable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:3,Schedul,Scheduler,3,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['Schedul'],['Scheduler']
Energy Efficiency,// Scheduling Class Index. It is used to query the scheduling model for the; // MCSchedClassDesc object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,2,"['Schedul', 'schedul']","['Scheduling', 'scheduling']"
Energy Efficiency,"// Scheduling LoopVersioningLICM when inlining is over, because after that; // we may see more accurate aliasing. Reason to run this late is that too; // early versioning may prevent further inlining due to increase of code; // size. Other optimizations which runs later might get benefit of no-alias; // assumption in clone loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['Schedul'],['Scheduling']
Energy Efficiency,// Scheduling Unit for current insn in the packet,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['Schedul'],['Scheduling']
Energy Efficiency,// Scheduling Unit for current insn in the packet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['Schedul'],['Scheduling']
Energy Efficiency,// Scheduling an instruction may have made pending instructions available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Schedul'],['Scheduling']
Energy Efficiency,// Scheduling an instruction that uses a VReg whose postincrement has not yet; // been scheduled will induce a copy. Model this as an extra cycle of latency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,4,"['Schedul', 'schedul']","['Scheduling', 'scheduled']"
Energy Efficiency,// Scheduling for ILP in low register pressure mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Schedul'],['Scheduling']
Energy Efficiency,// Scheduling for VLIW targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Schedul'],['Scheduling']
Energy Efficiency,// Scheduling for both latency and register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Schedul'],['Scheduling']
Energy Efficiency,// Scheduling for lowest register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Schedul'],['Scheduling']
Energy Efficiency,// Scheduling stages for this strategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['Schedul'],['Scheduling']
Energy Efficiency,"// Scheduling this node will trigger a wait,; // thus propagate to other instructions that they do not need to wait either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['Schedul'],['Scheduling']
Energy Efficiency,// Scheduling unit for candidate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Schedul,Scheduling,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['Schedul'],['Scheduling']
Energy Efficiency,"// Scoreboard to track function unit usage. Scoreboard[0] is a; // mask of the FUs in use in the cycle currently being; // schedule. Scoreboard[1] is a mask for the next cycle. The; // Scoreboard is used as a circular buffer with the current cycle; // indicated by Head.; //; // Scoreboard always counts cycles in forward execution order. If used by a; // bottom-up scheduler, then the scoreboard cycles are the inverse of the; // scheduler's cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:123,schedul,schedule,123,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,3,['schedul'],"['schedule', 'scheduler']"
Energy Efficiency,"// Scratch is allocated in 256 dword per wave blocks for the entire; // wavefront. When viewed from the perspective of an arbitrary workitem, this; // is 4-byte aligned.; //; // Only 4-byte alignment is really needed to access anything. Transformations; // on the pointer value itself may rely on the alignment / known low bits of; // the pointer. Set this to something above the minimum to avoid needing; // dynamic realignment in common cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:14,allocate,allocated,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['allocate'],['allocated']
Energy Efficiency,// Scratch is allocated in 64-dword or 256-dword blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp:14,allocate,allocated,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Scratch space. Allocated here to avoid repeated malloc calls in; // selectOrSplit().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:18,Allocate,Allocated,18,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,1,['Allocate'],['Allocated']
Energy Efficiency,"// ScratchReg is not R0, so use it as the base register. It is; // already set to the old SP, so we can use the offsets directly.; // Now that the stack frame has been allocated, save all the necessary; // registers using ScratchReg as the base address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:168,allocate,allocated,168,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1008,reduce,reduced,1008,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Search for the smallest integer type with free casts to and from; // Op's type. For expedience, just check power-of-2 integer types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:110,power,power-of-,110,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Search up and down at the same time, because we don't know if the new; // instruction is above or below the existing scheduling region.; // Ignore debug info (and other ""AssumeLike"" intrinsics) so that's not counted; // against the budget. Otherwise debug info could affect codegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:120,schedul,scheduling,120,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Second pass scheduler.; // Let Target optionally insert this pass by itself at some other; // point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:15,schedul,scheduler,15,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['schedul'],['scheduler']
Energy Efficiency,"// See TClass:New; // returns a TClass::ObjectPtr which remembers if the object was allocated; // via a TStreamerInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:84,allocate,allocated,84,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['allocate'],['allocated']
Energy Efficiency,// See if BotCand is still valid (because we previously scheduled from Top).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,schedul,scheduled,56,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// See if the comparison instruction can be converted into something more; // efficient. E.g., on Lanai register-register instructions can set the flag; // register, obviating the need for a separate compare.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h:78,efficient,efficient,78,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.h,1,['efficient'],['efficient']
Energy Efficiency,// See if this reduces to a PSHUFD which is no more expensive and can; // combine with more operations. Note that it has to at least flip the; // dwords as otherwise it would have been removed as a no-op.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:15,reduce,reduces,15,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduces']
Energy Efficiency,// See if this virtual register has already been allocated to a physical; // register or spilled to a stack slot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:49,allocate,allocated,49,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['allocate'],['allocated']
Energy Efficiency,// See if we can do this more efficiently with a blend shuffle with a; // rematerializable vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,efficient,efficiently,30,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// See if we can further relax some instructions to cut down on the number of; // nop bytes required for code alignment. The actual win is in reducing; // instruction count, not number of bytes. Modern X86-64 can easily end up; // decode limited. It is often better to reduce the number of instructions; // (i.e. eliminate nops) even at the cost of increasing the size and; // complexity of others.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:269,reduce,reduce,269,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['reduce'],['reduce']
Energy Efficiency,// See if we can just steal the extra info already allocated for the; // instruction. We can do this whenever the pre- and post-instruction symbols; // are the same (including null).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:51,allocate,allocated,51,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// See if we can re-use foldSelectShuffle, getting it to reduce the size of; // the shuffle into a nicer order, as it can ignore the order of the shuffles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:57,reduce,reduce,57,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Select constant vector splats whose value is a power of 2.; //; // In addition to the requirements of selectVSplat(), this function returns; // true and sets Imm if:; // * The splat value is the same width as the elements of the vector; // * The splat value is a power of two.; //; // This function looks through ISD::BITCAST nodes.; // TODO: This might not be appropriate for big-endian MSA since BITCAST is; // sometimes a shuffle in big-endian mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:50,power,power,50,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,2,['power'],['power']
Energy Efficiency,// Select the message schedule based on the round.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_portable.c:22,schedul,schedule,22,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_portable.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_portable.c,1,['schedul'],['schedule']
Energy Efficiency,"// Select the scheduler, or set the default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,schedul,scheduler,14,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Send messages off immediately to reduce latency",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:36,reduce,reduce,36,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// Send multiple GET requests with a single range of bytes; // Adapted from original version by Wang Lu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx:63,Adapt,Adapted,63,net/net/src/TS3WebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx,1,['Adapt'],['Adapted']
Energy Efficiency,"// Send packets off immediately to reduce latency",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:35,reduce,reduce,35,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// Sending monitoring data to a SQL DB",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSQLMonitoring.h:11,monitor,monitoring,11,net/net/inc/TSQLMonitoring.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSQLMonitoring.h,1,['monitor'],['monitoring']
Energy Efficiency,"// Serializing loads here may result in excessive register pressure, and; // TokenFactor places arbitrary choke points on the scheduler. SD scheduling; // could recover a bit by hoisting nodes upward in the chain by recognizing; // they are side-effect free or do not alias. The optimizer should really; // avoid this case by converting large object/array copies to llvm.memcpy; // (MaxParallelChains should always remain as failsafe).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:126,schedul,scheduler,126,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,"// Set MFFS and MTFSF as scheduling boundary to avoid unexpected code motion; // across them, since some FP operations may change content of FPSCR.; // TODO: Model FPSCR in PPC instruction definitions and remove the workaround",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,schedul,scheduling,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Set high zeros of C2 to allow matching negated power-of-2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:50,power,power-of-,50,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Set isVRegCycle for a node with only live in opers and live out uses. Also; // set isVRegCycle for its CopyFromReg operands.; //; // This is only relevant for single-block loops, in which case the VRegCycle; // node is likely an induction variable in which the operand and target virtual; // registers should be coalesced (e.g. pre/post increment values). Setting the; // isVRegCycle flag helps the scheduler prioritize other uses of the same; // CopyFromReg so that this node becomes the virtual register ""kill"". This; // avoids interference between the values live in and out of the block and; // eliminates a copy inside the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:402,schedul,scheduler,402,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Set it as not done, main thread will take charge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:45,charge,charge,45,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,5,['charge'],['charge']
Energy Efficiency,"// Set momentum and energy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h:20,energy,energy,20,math/physics/inc/TLorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h,1,['energy'],['energy']
Energy Efficiency,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:653,efficient,efficient,653,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Set of available Analysis. This information is used while scheduling; // pass. If a pass requires an analysis which is not available then; // the required analysis pass is scheduled to run before the pass itself is; // scheduled to run.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:61,schedul,scheduling,61,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,3,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"// Set of resources available on the subtarget.; //; // There is an instance of ResourceState for every resource declared by the; // target scheduling model.; //; // Elements of this vector are ordered by resource kind. In particular,; // resource units take precedence over resource groups.; //; // The index of a processor resource in this vector depends on the value of; // its mask (see the description of field ResourceState::ResourceMask). In; // particular, it is computed as the position of the most significant bit set; // (MSB) in the mask plus one (since we want to ignore the invalid resource; // descriptor at index zero).; //; // Example (little endian):; //; // Resource | Mask | MSB | Index; // ---------+---------+---------+-------; // A | 0b00001 | 0b00001 | 1; // | | |; // B | 0b00100 | 0b00100 | 3; // | | |; // C | 0b10010 | 0b10000 | 5; //; //; // The same index is also used to address elements within vector `Strategies`; // and vector `Resource2Groups`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:140,schedul,scheduling,140,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['schedul'],['scheduling']
Energy Efficiency,// Set of unavailable scheduler buffer resources. This is used internally to; // speedup `canBeDispatched()` queries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:22,schedul,scheduler,22,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['schedul'],['scheduler']
Energy Efficiency,"// Set scheduler function as piecewise function with given steps",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:7,schedul,scheduler,7,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,2,['schedul'],['scheduler']
Energy Efficiency,// Set scheduling for taskloop,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:7,schedul,scheduling,7,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Set the amount of LDS used in bytes in the metadata. This is an optional; // advisory record for logging etc; wave dispatch actually uses the rsrc1; // register for the shader stage to determine the amount of LDS to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.h:219,allocate,allocate,219,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.h,1,['allocate'],['allocate']
Energy Efficiency,"// Set the byval flag for CCAssignFn callbacks that don't know about; // inalloca. This way we can know how many bytes we should've allocated; // and how many bytes a callee cleanup function will pop. If we port; // inalloca to more targets, we'll have to add custom inalloca handling in; // the various CC lowering callbacks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:132,allocate,allocated,132,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Set the byval flag for CCAssignFn callbacks that don't know about; // inalloca. This way we can know how many bytes we should've allocated; // and how many bytes a callee cleanup function will pop. If we port; // inalloca to more targets, we'll have to add custom inalloca handling; // in the various CC lowering callbacks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:132,allocate,allocated,132,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// Set the byval flag for CCAssignFn callbacks that don't know about; // preallocated. This way we can know how many bytes we should've; // allocated and how many bytes a callee cleanup function will pop. If we; // port preallocated to more targets, we'll have to add custom; // preallocated handling in the various CC lowering callbacks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:140,allocate,allocated,140,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Set the byval flag for CCAssignFn callbacks that don't know about; // preallocated. This way we can know how many bytes we should've; // allocated and how many bytes a callee cleanup function will pop. If; // we port preallocated to more targets, we'll have to add custom; // preallocated handling in the various CC lowering callbacks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:140,allocate,allocated,140,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['allocate'],['allocated']
Energy Efficiency,// Set the hasPhysRegDefs only for physreg defs that have a use within; // the scheduling region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:79,schedul,scheduling,79,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Set the initial TargetOccupnacy to the maximum occupancy that we can; // achieve for this function. This effectively sets a lower bound on the; // 'Critical' register limits in the scheduler.; // Allow for lower occupancy targets if kernel is wave limited or memory; // bound, and using the relaxed occupancy feature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:184,schedul,scheduler,184,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Set the insert point to the beginning of the basic block if the entry; // should not be scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:91,schedul,scheduled,91,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Set the lifetime intrinsic to cover the whole alloca. This reduces the; // set of assumptions we need to make about the lifetime. Without this we; // would need to ensure that we can track the lifetime pointer to a; // constant offset from the alloca, and would still need to change the; // size to include the extra alignment we use for the untagging to make; // the size consistent.; //; // The check for standard lifetime below makes sure that we have exactly; // one set of start / end in any execution (i.e. the ends are not; // reachable from each other), so this will not cause any problems.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:62,reduce,reduces,62,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Set the member only if TheTable was successfully allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp:52,allocate,allocated,52,interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Set the number of used sgprs in the metadata. This is an optional advisory; // record for logging etc; wave dispatch actually uses the rsrc1 register for; // the shader stage to determine the number of sgprs to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.cpp:214,allocate,allocate,214,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.cpp,3,['allocate'],['allocate']
Energy Efficiency,// Set the number of used vgprs in the metadata. This is an optional advisory; // record for logging etc; wave dispatch actually uses the rsrc1 register for; // the shader stage to determine the number of vgprs to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.h:214,allocate,allocate,214,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.h,2,['allocate'],['allocate']
Energy Efficiency,// Set the number of used vgprs in the metadata. This is an optional; // advisory record for logging etc; wave dispatch actually uses the rsrc1; // register for the shader stage to determine the number of vgprs to; // allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.cpp:218,allocate,allocate,218,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Set the symbol's state to Allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:29,Allocate,Allocated,29,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['Allocate'],['Allocated']
Energy Efficiency,"// Set the total number for monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:28,monitor,monitoring,28,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,2,['monitor'],['monitoring']
Energy Efficiency,"// Set the value of a scale factor to modify the bandwidth by. The default value for this is unity.; // Modification of 'normal' bandwidths is useful when the data are not 'normally distributed',; // otherwise one expects little departure from that behavior. Note that both the normal and adaptive; // bandwidth selections are modified by this factor. Useful for systematic studies.; // ***********; // *IMPORTANT* The kernel is proportional to 1/widthScaleFactor.; // ***********",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h:289,adapt,adaptive,289,roofit/roofit/inc/Roo2DKeysPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h,1,['adapt'],['adaptive']
Energy Efficiency,// Set to true to update the pointer in the dest Reduce list to a; // newly created element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:49,Reduce,Reduce,49,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Sets User option for fixed or adaptive iteration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:33,adapt,adaptive,33,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['adapt'],['adaptive']
Energy Efficiency,// Setup for scheduling a region. Returns false if the current region should; // be skipped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:13,schedul,scheduling,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduling']
Energy Efficiency,// Setup for scheduling the region and check whether it should be skipped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:13,schedul,scheduling,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Setup the register pressure trackers for the top scheduled and bottom; // scheduled regions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,schedul,scheduled,52,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduled']
Energy Efficiency,// Setup to track possible reductions corresponding to the provided; // rerolling scale. Only reductions with a number of non-PHI instructions; // that is divisible by the scale are considered. Three instructions sets; // are filled in:; // - A set of all possible instructions in eligible reductions.; // - A set of all PHIs in eligible reductions; // - A set of all reduced values (last instructions) in eligible; // reductions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:368,reduce,reduced,368,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Shadow allocate GPRs and stack space even though we pass in a VR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,allocate,allocate,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Shadow allocate register and its stack shadow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,allocate,allocate,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Shift amount is modulo the bitwidth. For powers of two we have; // SA % BW == SA & (BW - 1).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:44,power,powers,44,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,1,['power'],['powers']
Energy Efficiency,// Shift amount of a 64 bit shift cannot be a highest allocated register; // if also at the end of the allocation block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:54,allocate,allocated,54,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['allocate'],['allocated']
Energy Efficiency,// Should we model this differently? We can allocate a fixed number of; // elements with zeros in the last one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:44,allocate,allocate,44,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Show only charged and massive particles...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.cxx:13,charge,charged,13,test/RootShower/RootShower.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.cxx,1,['charge'],['charged']
Energy Efficiency,"// Shrink the subtree_len until it evenly divides the count so far. We know; // that subtree_len itself is a power of 2, so we can use a bitmasking; // trick instead of an actual remainder operation. (Note that if the caller; // consistently passes power-of-2 inputs of the same size, as is hopefully; // typical, this loop condition will always fail, and subtree_len will; // always be the full length of the input.); //; // An aside: We don't have to shrink subtree_len quite this much. For; // example, if count_so_far is 1, we could pass 2 chunks to; // compress_subtree_to_parent_node. Since we'll get 2 CVs back, we'll still; // get the right answer in the end, and we might get to use 2-way SIMD; // parallelism. The problem with this optimization, is that it gets us; // stuck always hashing 2 chunks. The total number of chunks will remain; // odd, and we'll never graduate to higher degrees of parallelism. See; // https://github.com/BLAKE3-team/BLAKE3/issues/69.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:109,power,power,109,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,2,['power'],"['power', 'power-of-']"
Energy Efficiency,// Shrinking the storage requires extra temporary memory.; // Destroying clang first reduces peak memory usage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:85,reduce,reduces,85,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Shutdown the monitor writers, if any",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx:16,monitor,monitor,16,proof/proofplayer/src/TPerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx,1,['monitor'],['monitor']
Energy Efficiency,// Simon Tatham's linked list merge sort algorithm; // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:73,green,greenend,73,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['green'],['greenend']
Energy Efficiency,"// Simple greedy algorithm.; // If this is replaced with something smarter, it must preserve the property; // that the first object is always at the offset 0 in the stack frame (for; // StackProtectorSlot), or handle stack protector in some other way.; // Sort objects by size (largest first) to reduce fragmentation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:296,reduce,reduce,296,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Simple heuristic so that we don't allocate a very large; // initializer with many empty entries at the end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:37,allocate,allocate,37,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Simple wrapper class to abstract away from the details of memory management.; // SExprs are allocated in pools, and deallocated all at once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h:95,allocate,allocated,95,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h,1,['allocate'],['allocated']
Energy Efficiency,"// Simple wrapper to separate, time-wise, the call to the; // TROOT destructor and the actual free-ing of the memory.; //; // Since the interpreter implementation (currently TCling) is; // loaded via dlopen by libCore, the destruction of its global; // variable (i.e. in particular clang's) is scheduled before; // those in libCore so we need to schedule the call to the TROOT; // destructor before that *but* we want to make sure the memory; // stay around until libCore itself is unloaded so that code; // using gROOT can 'properly' check for validity.; //; // The order of loading for is:; // libCore.so; // libRint.so; // ... anything other library hard linked to the executable ...; // ... for example libEvent; // libCling.so; // ... other libraries like libTree for example ....; // and the destruction order is (of course) the reverse.; // By default the unloading of the dictionary, does use; // the service of the interpreter ... which of course; // fails if libCling is already unloaded by that information; // has not been registered per se.; //; // To solve this problem, we now schedule the destruction; // of the TROOT object to happen _just_ before the; // unloading/destruction of libCling so that we can; // maximize the amount of clean-up we can do correctly; // and we can still allocate the TROOT object's memory; // statically.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:294,schedul,scheduled,294,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,4,"['allocate', 'schedul']","['allocate', 'schedule', 'scheduled']"
Energy Efficiency,"// Simplify comparisons of related pointers using a powerful, recursive; // GEP-walk when we have target data available..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:52,power,powerful,52,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['power'],['powerful']
Energy Efficiency,"// Since MMX types are special and don't usually play with other vector types,; // it's better to handle them early to be sure we emit efficient code by; // avoiding store-load conversions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:135,efficient,efficient,135,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Since SCEVs are immutable, ScalarEvolution allocates operand; // arrays with its SCEVAllocator, so this class just needs a simple; // pointer rather than a more elaborate vector-like data structure.; // This also avoids the need for a non-trivial destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:46,allocate,allocates,46,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['allocate'],['allocates']
Energy Efficiency,"// Since indirect call does not have CalleeName, check conservatively if; // callsite in the profile is a callsite location. This is to reduce num of; // false positive since otherwise all the indirect call samples will be; // reported as mismatching.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:136,reduce,reduce,136,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Since the last iteration, the todolist have been augmented by calls; // to addConstraints, addLinks, and co.; // Update the network energy starting at this new frontier.; // The call to ::update will add the nodes that changed into the todolist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:135,energy,energy,135,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,1,['energy'],['energy']
Energy Efficiency,// Since the max shift amount is a power of 2 we can subtract 1 to make a; // mask that covers the bits needed to represent all shift amounts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:35,power,power,35,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,2,['power'],['power']
Energy Efficiency,"// Since this is a fixed size buffer, use a stack allocated buffer. This; // yields measurable performance increase over the repeated heap allocations; // when serializing many independent records via writeOneSymbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolSerializer.h:50,allocate,allocated,50,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolSerializer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/SymbolSerializer.h,1,['allocate'],['allocated']
Energy Efficiency,// Since vectorization tree is being built recursively this assertion; // ensures that the tree entry has all operands set before reaching; // this code. Couple of exceptions known at the moment are extracts; // where their second (immediate) operand is not added. Since; // immediates do not affect scheduler behavior this is considered; // okay.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:300,schedul,scheduler,300,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Since we need to extend alloca with additional memory to locate; // redzones, and OldSize is number of allocated blocks with; // ElementSize size, get allocated memory size in bytes by; // OldSize * ElementSize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:106,allocate,allocated,106,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// Since we only want to allocate a fresh function type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the function type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:25,allocate,allocate,25,interpreter/llvm-project/llvm/lib/IR/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// Since we only want to allocate a fresh struct type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the struct type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:25,allocate,allocate,25,interpreter/llvm-project/llvm/lib/IR/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// Since we only want to allocate a fresh target type in case none is found; // and we don't want to perform two lookups (one for checking if existent and; // one for inserting the newly allocated one), here we instead lookup based on; // Key and update the reference to the target type in-place to a newly; // allocated one if not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:25,allocate,allocate,25,interpreter/llvm-project/llvm/lib/IR/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// Since we're going to pull this into a shift, the constant value must be; // a power of 2. If we got a multiply, then we need to check this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:81,power,power,81,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['power'],['power']
Energy Efficiency,// Sink all the child loops whose headers are no longer in the loop set to; // the parent (or to be top level loops). We reach into the loop and directly; // update its subloop vector to make this batch update efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:210,efficient,efficient,210,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// SizeBytes and VecElemBits are powers of 2, so they divide evenly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:33,power,powers,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['power'],['powers']
Energy Efficiency,"// Skip complex cases such as when different fragments of a variable have; // been split into different allocas. Skipping in this case means falling; // back to using a list of defs (which could reduce coverage, but is no; // less correct).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:195,reduce,reduce,195,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Skip consecutive spaces efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:27,efficient,efficiently,27,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Skip elements which have not been allocated memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:37,allocate,allocated,37,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,3,['allocate'],['allocated']
Energy Efficiency,// Skip empty scheduling regions (0 or 1 schedulable instructions).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,schedul,scheduling,14,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,4,['schedul'],"['schedulable', 'scheduling']"
Energy Efficiency,// Skip empty scheduling regions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600Packetizer.cpp:14,schedul,scheduling,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600Packetizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600Packetizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Skip if this is a function with the amdgpu_cs_chain or; // amdgpu_cs_chain_preserve calling convention and this is a scratch register.; // We never need to allocate a spill for these because we don't even need to; // restore the inactive lanes for them (they're scratchier than the usual; // scratch registers).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp:159,allocate,allocate,159,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Skip one register if the first unallocated register has an even register; // number and there are still argument registers available which have not been; // allocated yet. RegNum is actually an index into ArgRegs, which means we; // need to skip a register if RegNum is odd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp:160,allocate,allocated,160,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCCallingConv.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Skipping the check for SP writes in the base implementation. The reason it; // was added was apparently due to compile time concerns.; //; // TODO: Do we really want this barrier? It triggers unnecessary hazard nops; // but is probably avoidable.; // Copied from base implementation.; // Terminators and labels can't be scheduled around.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:323,schedul,scheduled,323,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// So far only supports PowerPC and X86.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:24,Power,PowerPC,24,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// So far, all branch instructions in Wasm take an I32 condition.; // The default TargetLowering::getSetCCResultType returns the pointer size,; // which would be useful to reduce instruction counts when testing; // against 64-bit pointers/values if at some point Wasm supports that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:172,reduce,reduce,172,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Solving an equation q(x) = 0 with coefficients in modular arithmetic; // is really solving a set of equations q(x) = kR for k = 0, 1, 2, ...,; // and R = 2^BitWidth.; // Since we're trying not only to find exact solutions, but also values; // that ""wrap around"", such a set will always have a solution, i.e. an x; // that satisfies at least one of the equations, or such that |q(x)|; // exceeds kR, while |q(x-1)| for the same k does not.; //; // We need to find a value k, such that Ax^2 + Bx + C = kR will have a; // positive solution n (in the above sense), and also such that the n; // will be the least among all solutions corresponding to k = 0, 1, ...; // (more precisely, the least element in the set; // { n(k) | k is such that a solution n(k) exists }).; //; // Consider the parabola (over real numbers) that corresponds to the; // quadratic equation. Since A > 0, the arms of the parabola will point; // up. Picking different values of k will shift it up and down by R.; //; // We want to shift the parabola in such a way as to reduce the problem; // of solving q(x) = kR to solving shifted_q(x) = 0.; // (The interesting solutions are the ceilings of the real number; // solutions.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:1042,reduce,reduce,1042,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Some assemblers don't support non-power of two alignments, so we always; // emit alignments as a power of two if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:37,power,power,37,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,2,['power'],['power']
Energy Efficiency,"// Some documentation says that this is not necessary on Evergreen,; // but experimentation has show that we need to allocate 1 extra; // sub-entry for the first non-WQM push.; // +1 For the push operation.; // +1 Extra space required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp:117,allocate,allocate,117,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Some monitoring systems (TXSocketHandler) need to know this",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:8,monitor,monitoring,8,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,2,['monitor'],['monitoring']
Energy Efficiency,// Some stats for scheduling inside blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:18,schedul,scheduling,18,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,// Some targets support efficient element stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,efficient,efficient,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Some useful objects to reduce the number of function arguments needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h:26,reduce,reduce,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h,1,['reduce'],['reduce']
Energy Efficiency,// Some vector comparison predicates cost extra instructions.; // TODO: Should we invert this and assume worst case cmp costs; // and reduce for particular predicates?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:134,reduce,reduce,134,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:255,efficient,efficiently,255,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['efficient'],['efficiently']
Energy Efficiency,"// Sort anchors by offset so that we can find the closest relocation; // efficiently. For a zero size symbol, ensure that its start anchor precedes; // its end anchor. For two symbols with anchors at the same offset, their; // order does not matter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp:73,efficient,efficiently,73,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_riscv.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Sort by descending size order so that we allocate the most important; // sets first.; // Tie-break equivalent sizes by sorting chains requiring fixups before; // those without fixups. The logic here is that we should look at the; // chains that we cannot change before we look at those we can,; // so the parity counter is updated and we know what color we should; // change them to!; // Final tie-break with instruction order so pass output is stable (i.e. not; // dependent on malloc'd pointer values).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:44,allocate,allocate,44,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Sort checkers for efficient collection.; // FIXME: Alphabetical sort puts 'experimental' in the middle.; // Would it be better to name it '~experimental' or something else; // that's ASCIIbetically last?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:21,efficient,efficient,21,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Sort on byte position; captures might not be allocated in order,; // and unions can do funny things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:48,allocate,allocated,48,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Sort signature entries by length, let longer signature insert first, to; // make it more possible to reuse table entries, that can reduce ~10% table; // size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp:134,reduce,reduce,134,interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/RISCVVEmitter.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Sort the global constants to make access more efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:49,efficient,efficient,49,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Sort the instructions by the number of available choices for scheduling,; // least to most. Use the number of critical resources as the tie breaker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:64,schedul,scheduling,64,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Sort the reduced values by number of same/alternate opcode and/or pointer; // operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:12,reduce,reduced,12,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Sort the stores by their index, making it efficient to do a lookup with a; // binary search.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:45,efficient,efficient,45,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Sort values by the total number of values kinds to start the reduction; // from the longest possible reduced values sequences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:104,reduce,reduced,104,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Space allocated for zText",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:9,allocate,allocated,9,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['allocate'],['allocated']
Energy Efficiency,"// Special case i386/ppc ObjC data structures in magic sections:; // The issue is that the old ObjC object format did some strange; // contortions to avoid real linker symbols. For instance, the; // ObjC class data structure is allocated statically in the executable; // that defines that class. That data structures contains a pointer to; // its superclass. But instead of just initializing that part of the; // struct to the address of its superclass, and letting the static and; // dynamic linkers do the rest, the runtime works by having that field; // instead point to a C-string that is the name of the superclass.; // At runtime the objc initialization updates that pointer and sets; // it to point to the actual super class. As far as the linker; // knows it is just a pointer to a string. But then someone wanted the; // linker to issue errors at build time if the superclass was not found.; // So they figured out a way in mach-o object format to use an absolute; // symbols (.objc_class_name_Foo = 0) and a floating reference; // (.reference .objc_class_name_Bar) to cause the linker into erroring when; // a class was missing.; // The following synthesizes the implicit .objc_* symbols for the linker; // from the ObjC data structures generated by the front end.; // special case if this data blob is an ObjC class definition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:228,allocate,allocated,228,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Special case power of 2 reductions where the scalar type isn't changed; // by type legalization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:16,power,power,16,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,2,['power'],['power']
Energy Efficiency,"// Special case uaddo X, 1 overflowed if the addition result is 0.; // The general case (X + C) < C is not necessarily beneficial. Although we; // reduce the live range of X, we may introduce the materialization of; // constant C, especially when the setcc result is used by branch. We have; // no compare with constant and branch instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:147,reduce,reduce,147,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Special case: X+1 has a carry out if X+1==0. This may reduce the live; // range of X. We assume comparing with 0 is cheap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:57,reduce,reduce,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Special case: shuffle(concat(A,B)) can be more efficiently represented; // as concat(shuffle(A,B),UNDEF) if the shuffle doesn't set any of the high; // half vector elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,efficient,efficiently,50,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Special case: uaddo X, 1 overflowed if X+1 is 0. This potential reduces; // the live range of X. We assume comparing with 0 is cheap.; // The general case (X + C) < C is not necessarily beneficial. Although we; // reduce the live range of X, we may introduce the materialization of; // constant C.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:67,reduce,reduces,67,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['reduce'],"['reduce', 'reduces']"
Energy Efficiency,// Spill callee-saved SGPRs into physical VGPR lanes.; // TODO: This is to ensure the CFIs are static for efficient frame; // unwinding in the debugger. Spilling them into virtual VGPR lanes; // involve regalloc to allocate the physical VGPRs and that might; // cause intermediate spill/split of such liveranges for successful; // allocation. This would result in broken CFI encoding unless the; // regalloc aware CFI generation to insert new CFIs along with the; // intermediate spills is implemented. There is no such support; // currently exist in the LLVM compiler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp:106,efficient,efficient,106,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp,2,"['allocate', 'efficient']","['allocate', 'efficient']"
Energy Efficiency,// Spill each interfering vreg allocated to PhysReg or an alias.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:31,allocate,allocated,31,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Split MemSize into two, P2HalfMemSize is largest power of two smaller; // then MemSize. e.g. 8 = 4 + 4 , 6 = 4 + 2, 3 = 2 + 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:52,power,power,52,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,1,['power'],['power']
Energy Efficiency,"// Split a vector type into two parts. The first part is a power of two vector.; // The second part is whatever is left over, and is a scalar if it would; // otherwise be a 1-vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:59,power,power,59,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// Split the SP adjustment to reduce the offsets of callee saved spill.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:30,reduce,reduce,30,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// Splits LHS into Base + Index and, if succeeds, calls; // allocateCandidatesAndFindBasis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:60,allocate,allocateCandidatesAndFindBasis,60,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['allocate'],['allocateCandidatesAndFindBasis']
Energy Efficiency,// Splitting the edge can reduce the number of PHI entries we have.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:26,reduce,reduce,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Stack objects that should be allocated to locals are hoisted to WebAssembly; // locals when they are first used. However for those without uses, we hoist; // them here. It would be nice if there were some hook to do this when they; // are added to the MachineFrameInfo, but that's not the case right now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:32,allocate,allocated,32,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Stack space is allocated for all arguments starting from [%fp+BIAS+128].,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:18,allocate,allocated,18,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Stalled for 4 cycles but still can't schedule any other instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp:40,schedul,schedule,40,interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Stalls generated by the scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:27,schedul,scheduler,27,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,// Stalls provides an cycle offset at which SU will be scheduled. It will be; // negative for bottom-up scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:55,schedul,scheduled,55,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:12,schedul,scheduler,12,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,4,"['Schedul', 'schedul']","['ScheduleNodeTopDown', 'scheduled', 'scheduler']"
Energy Efficiency,// Start actual scheduling here. This function is called by the base; // MachineScheduler after all regions have been recorded by; // GCNScheduleDAGMILive::schedule().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:16,schedul,scheduling,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// Start processing results of the queued tasks. We wait for the first; // task in the queue to finish. If it reduced a chunk, we parse the; // result and exit the loop.; // Otherwise we will try to schedule a new task, if; // * no other pending job reduced a chunk and; // * we have not reached the end of the chunk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp:110,reduce,reduced,110,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,3,"['reduce', 'schedul']","['reduced', 'schedule']"
Energy Efficiency,"// Start value must not be signmask for signed division, so simply being a; // power of two is not sufficient, and it has to be a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:79,power,power,79,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,// Starting from kernel 4.9 memory allocated with mmap is counted against; // RLIMIT_DATA. Sanitizers need to allocate tens of terabytes for shadow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:35,allocate,allocated,35,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// Stash the allocated frame pointer in the continuation storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:13,allocate,allocated,13,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// State internal to DAG building.; // -------------------------------; /// Defs, Uses - Remember where defs and uses of each register are as we; /// iterate upward through the instructions. This is allocated here instead; /// of inside BuildSchedGraph to avoid the need for it to be initialized and; /// destructed for each block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:199,allocate,allocated,199,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['allocate'],['allocated']
Energy Efficiency,// State of the top and bottom scheduled instruction boundaries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:31,schedul,scheduled,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduled']
Energy Efficiency,// State specific to the current scheduling region.; // ------------------------------------------------; /// The block in which to insert instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:33,schedul,scheduling,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['schedul'],['scheduling']
Energy Efficiency,"// Statement attributes are a bit different from declarations. With; // declarations, each attribute is added to the declaration as it is; // processed, and so you can look on the Decl * itself to see if there is a; // conflicting attribute. Statement attributes are processed as a group; // because AttributedStmt needs to tail-allocate all of the attribute nodes; // at once. This means we cannot check whether the statement already contains; // an attribute to check for the conflict. Instead, we need to check whether; // the given list of semantic attributes contain any conflicts. It is assumed; // this code will be executed in the context of a function with parameters:; // Sema &S, const SmallVectorImpl<const Attr *> &C. The code will be within a; // loop which loops over the container C with a loop variable named A to; // represent the current attribute to check for conflicts.; //; // FIXME: it would be nice not to walk over the list of potential attributes; // to apply to the statement more than once, but statements typically don't; // have long lists of attributes on them, so re-walking the list should not; // be an expensive operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:329,allocate,allocate,329,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Statically allocated symbol,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:14,allocate,allocated,14,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['allocate'],['allocated']
Energy Efficiency,// Step 1.1: Get the address for the src element in the Reduce list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:56,Reduce,Reduce,56,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,2,['Reduce'],['Reduce']
Energy Efficiency,// Step 1.2: Create a temporary to store the element in the destination; // Reduce list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:76,Reduce,Reduce,76,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// Step 3.1: Modify reference in dest Reduce list as needed.; // Modifying the reference in Reduce list to point to the newly; // created element. The element is live in the current function; // scope and that of functions it invokes (i.e., reduce_function).; // RemoteReduceData[i] = (void*)&RemoteElem",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:38,Reduce,Reduce,38,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,2,['Reduce'],['Reduce']
Energy Efficiency,"// Storage for the VfsRootFile structure has been already allocated by sqlite, so we use placement new",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:58,allocate,allocated,58,tree/dataframe/src/RSqliteDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Storage for the parameter adapters. Since the base class erases the type; // of the parameters, we have to own the storage for the parameters here, and; // have the base class store type-erased pointers into this tuple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h:29,adapt,adapters,29,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,1,['adapt'],['adapters']
Energy Efficiency,// Store all the allocated start addresses in the header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/COFFEmitter.cpp:17,allocate,allocated,17,interpreter/llvm-project/llvm/lib/ObjectYAML/COFFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/COFFEmitter.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Store pointers to the arguments in a locally allocated launch_args.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:48,allocate,allocated,48,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Store the control value, so we can sort array of powers; // later on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:52,power,powers,52,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['power'],['powers']
Energy Efficiency,// Store the extent of the allocated object(s).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:27,allocate,allocated,27,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Store the powers in powers array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:13,power,powers,13,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,2,['power'],['powers']
Energy Efficiency,"// Stores pair (first: index of the store into Stores array ref, address of; // which taken as base, second: sorted set of pairs {index, dist}, which are; // indices of stores in the set and their store location distances relative to; // the base address).; // Need to store the index of the very first store separately, since the set; // may be reordered after the insertion and the first store may be moved. This; // container allows to reduce number of calls of getPointersDiff() function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:439,reduce,reduce,439,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Strength-reduce the shift into an 'and'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:12,reduce,reduce,12,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Strip cast operations from a pointer value.; // Note that stripPointerCastsSameRepresentation can strip off getelementptr; // inbounds with zero offset. To guarantee that the result isn't poison, the; // stripped pointer is checked as it has to be pointing into an allocated; // object or be null `null` to ensure `inbounds` getelement pointers with a; // zero offset could not produce poison.; // It can strip off addrspacecast that do not change bit representation as; // well. We believe that such addrspacecast is equivalent to no-op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:268,allocate,allocated,268,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Strip the common prefix (if it is more than just ""/"" or ""C:\"") from; // current directory and FileName for a more space-efficient encoding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:123,efficient,efficient,123,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:48,schedul,scheduler,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,// Stub Arm/Thumb follows instruction set state at relocation site.; // TODO: We may reduce them at relaxation time and reuse freed slots.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp:85,reduce,reduce,85,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Subtract out the size of the callee saved registers. This is how much stack; // each funclet will allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:101,allocate,allocate,101,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Support Loadsizes greater or equal to 8bits and only power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:56,power,power,56,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['power'],['power']
Energy Efficiency,"// Suppose Stride is a power of two, and Start/End are unsigned; // integers. Let UMAX be the largest representable unsigned; // integer.; //; // By the preconditions of this function, we know; // ""(Start + Stride * N) >= End"", and this doesn't overflow.; // As a formula:; //; // End <= (Start + Stride * N) <= UMAX; //; // Subtracting Start from all the terms:; //; // End - Start <= Stride * N <= UMAX - Start; //; // Since Start is unsigned, UMAX - Start <= UMAX. Therefore:; //; // End - Start <= Stride * N <= UMAX; //; // Stride * N is a multiple of Stride. Therefore,; //; // End - Start <= Stride * N <= UMAX - (UMAX mod Stride); //; // Since Stride is a power of two, UMAX + 1 is divisible by Stride.; // Therefore, UMAX mod Stride == Stride - 1. So we can write:; //; // End - Start <= Stride * N <= UMAX - Stride - 1; //; // Dropping the middle term:; //; // End - Start <= UMAX - Stride - 1; //; // Adding Stride - 1 to both sides:; //; // (End - Start) + (Stride - 1) <= UMAX; //; // In other words, the addition doesn't have unsigned overflow.; //; // A similar proof works if we treat Start/End as signed values.; // Just rewrite steps before ""End - Start <= Stride * N <= UMAX"" to; // use signed max instead of unsigned max. Note that we're trying; // to prove a lack of unsigned overflow in either case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:23,power,power,23,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['power'],['power']
Energy Efficiency,// Swap entries are allocated in a vector for better performance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:20,allocate,allocated,20,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Swift's async context is directly before FP, so allocate an extra; // 8 bytes for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:51,allocate,allocate,51,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// System-reserved register; // On PPC64, r13 is the thread pointer. Never allocate this register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:75,allocate,allocate,75,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,// TBB generation code in this constant island pass has not been adapted to; // deal with speculation barriers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:65,adapt,adapted,65,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// TGLBoundingBox::Vertices() & TGLBoundingBox::FaceVertices() return; // const & vectors so this *should* all be efficient...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:114,efficient,efficient,114,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:302,schedul,scheduled,302,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// TODO : Allocate function manager for this pass, other wise required set; // may be inserted into previous function manager; // Give pass a chance to prepare the stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:10,Allocate,Allocate,10,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// TODO avoid frequent (de)allocations by holding on to allocated buffers in RColumnBuf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:56,allocate,allocated,56,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['allocate'],['allocated']
Energy Efficiency,// TODO(jingyue): Consider willNotOverflowSignedAdd and; // willNotOverflowUnsignedAdd to reduce the number of invocations of; // computeKnownBits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:90,reduce,reduce,90,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['reduce'],['reduce']
Energy Efficiency,// TODO: Adapt to the extra input from the PHINode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:9,Adapt,Adapt,9,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['Adapt'],['Adapt']
Energy Efficiency,"// TODO: Add a mechanism to frame lowering that will allow us to indicate; // that we'd prefer this slot be allocated towards the bottom of the frame; // (i.e. near the stack pointer after allocating the frame). Every; // funclet needs a copy of this slot in its (mostly empty) frame, and the; // offset from the bottom of this and each funclet's frame must be the; // same, so the size of funclets' (mostly empty) frames is dictated by; // how far this slot is from the bottom (since they allocate just enough; // space to accommodate holding this slot at the correct offset).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:108,allocate,allocated,108,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// TODO: Allow shuffles that contain undefs in the mask?; // That is legal, but it reduces undef knowledge.; // TODO: Allow arbitrary shuffles by shuffling after binop?; // That might be legal, but we have to deal with poison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:83,reduce,reduces,83,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['reduce'],['reduces']
Energy Efficiency,// TODO: Can we reduce the code duplication between this and the related; // rotate matching code under visitSelect and visitTrunc?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:16,reduce,reduce,16,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['reduce'],['reduce']
Energy Efficiency,// TODO: Check if we can remove a check for non-power-2 number of; // scalars after full support of non-power-2 vectorization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:48,power,power-,48,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['power'],['power-']
Energy Efficiency,"// TODO: Consider adding a switch that strips possibly unimportant content,; // such as comments, to reduce the size of repro files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:101,reduce,reduce,101,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,1,['reduce'],['reduce']
Energy Efficiency,// TODO: Could check if it's legal with the reduced or original memory size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:44,reduce,reduced,44,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['reduce'],['reduced']
Energy Efficiency,"// TODO: Currently fixed-order recurrences are modeled as chains of; // first-order recurrences. If there are no users of the intermediate; // recurrences in the chain, the fixed order recurrence should be modeled; // directly, enabling more efficient codegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:242,efficient,efficient,242,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['efficient'],['efficient']
Energy Efficiency,// TODO: Extract AvailableAttrs from AttributeSetNode and store them here.; // This will allow an efficient implementation of addAttribute and; // removeAttribute for enum attrs.; /// Private implementation pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h:98,efficient,efficient,98,interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,1,['efficient'],['efficient']
Energy Efficiency,"// TODO: For future when we relpace the bump allocation with slab.; //; //Out << ""Allocated memory: "" << C.getAllocatedMemory();; //Out << ""Side table allocated memory: "" << C.getSideTableAllocatedMemory();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClangInternalState.cpp:82,Allocate,Allocated,82,interpreter/cling/lib/Interpreter/ClangInternalState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClangInternalState.cpp,2,"['Allocate', 'allocate']","['Allocated', 'allocated']"
Energy Efficiency,// TODO: Handle non-power-of-two types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:20,power,power-of-two,20,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['power'],['power-of-two']
Energy Efficiency,// TODO: Handle the power function forms some day.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:20,power,power,20,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['power'],['power']
Energy Efficiency,"// TODO: If either operand is a single element and the multiply is known to; // be non-wrapping, round the result min and max value to the appropriate; // multiple of that element. If wrapping is possible, at least adjust the; // range according to the greatest power-of-two factor of the single element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:262,power,power-of-two,262,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// TODO: If the x86 backend knew how to convert a bool vector mask back to an; // XMM register mask efficiently, we could transform all x86 masked intrinsics; // to LLVM masked intrinsics and remove the x86 masked intrinsic defs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:100,efficient,efficiently,100,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,['efficient'],['efficiently']
Energy Efficiency,"// TODO: Implement DPP Strategy and switch based on immediate strategy; // operand. For now, for all the cases (default, Iterative and DPP we use; // iterative approach by default.); // To reduce the VGPR using iterative approach, we need to iterate; // over all the active lanes. Lowering consists of ComputeLoop,; // which iterate over only active lanes. We use copy of EXEC register; // as induction variable and every active lane modifies it using bitset0; // so that we will get the next active lane for next iteration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:189,reduce,reduce,189,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// TODO: In ""large"" mode, a pointer to a BitVector is used, leading to an; // unnecessary level of indirection. It would be more efficient to use a; // pointer to memory containing size, allocation size, and the array of bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:129,efficient,efficient,129,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,1,['efficient'],['efficient']
Energy Efficiency,// TODO: Is this a good transform for vectors? Wider types may reduce; // throughput. Should this transform be limited (even for scalars) by using; // shouldChangeType()?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:63,reduce,reduce,63,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// TODO: Is this true? kill flag appears to work OK below; // Register kill flags have been cleared by the time we get to this; // pass, but it is safe to assume that all uses of this register; // occur in the same basic block as its definition, because; // it is illegal for the scheduler to schedule them in; // different blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp:280,schedul,scheduler,280,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp,2,['schedul'],"['schedule', 'scheduler']"
Energy Efficiency,"// TODO: It may be better to default to latency-oriented scheduling, however; // LLVM's current latency-oriented scheduler can't handle physreg definitions; // such as SystemZ has with CC, so set this to the register-pressure; // scheduler, because it can.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:57,schedul,scheduling,57,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,3,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,"// TODO: It would potentially be better to schedule copy propagation after; // expanding pseudos (in addPreEmitPass2). However, performing copy; // propagation after the machine outliner (which runs after addPreEmitPass); // currently leads to incorrect code-gen, where copies to registers within; // outlined functions are removed erroneously.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:43,schedul,schedule,43,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// TODO: Ownership might change with an attempt to store the allocated; // memory, not only through deallocation. Check for attempted stores as; // well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:61,allocate,allocated,61,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,// TODO: Probably okay to remove after audit; here to reduce change size; // in initial enablement patch for scalable vectors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:54,reduce,reduce,54,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,3,['reduce'],['reduce']
Energy Efficiency,// TODO: Reduce the weight by exploiting nsw/nuw?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:9,Reduce,Reduce,9,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// TODO: Remove this work-around after fixing the scheduler and enable the; // assert above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:50,schedul,scheduler,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// TODO: Remove this work-around, enable the assert for Bug 457939; // after fixing the scheduler. Also, the Shader Compiler code is; // independent of target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:88,schedul,scheduler,88,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// TODO: Sdiv check for not exact for some reason.; // If there's no wider mulhi, there's only a better expansion for powers of; // two.; // TODO: Should really know for each vector element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:118,power,powers,118,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['power'],['powers']
Energy Efficiency,"// TODO: SelectionDAG has several alternative expansions to port which may; // be more reasonble depending on the available instructions. If a target; // has sitofp, does not have CTLZ, or can efficiently use f64 as an; // intermediate type, this is probably worse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:193,efficient,efficiently,193,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// TODO: Should also attempt to reduce RP of SGPRs and AGPRs; // Attempt to reduce RP of VGPR by sinking trivially rematerializable; // instructions. Returns true if we were able to sink instruction(s).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:32,reduce,reduce,32,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,2,['reduce'],['reduce']
Energy Efficiency,"// TODO: There might be another oppurtunity to leverage SCEV's reasoning; // here. If we kept track of the min of dominanting exits so far, we could; // discharge exits with EC >= MDEC. This is less powerful than the existing; // transform (since later exits aren't considered), but potentially more; // powerful for any case where SCEV can prove a >=u b, but neither a == b; // or a >u b. Such a case is not currently known.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:199,power,powerful,199,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,2,['power'],['powerful']
Energy Efficiency,"// TODO: These just exist to reduce test diff, we can drop them if we like.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:29,reduce,reduce,29,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// TODO: These transforms should not require the 'hasOneUse' restriction, but; // there are regressions on multiple targets without it. We can end up with a; // mess of scalar and vector code if we reduce only part of the DAG to scalar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:198,reduce,reduce,198,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduce']
Energy Efficiency,// TODO: This can be implemented more efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:38,efficient,efficiently,38,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,2,['efficient'],['efficiently']
Energy Efficiency,// TODO: This can probably be removed once target code is audited. This; // is here purely to reduce patch size and review complexity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:94,reduce,reduce,94,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:454,efficient,efficiently,454,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// TODO: This could be more efficient by bulk changing the operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:28,efficient,efficient,28,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// TODO: This is a specific form of a much more general pattern.; // We could detect a select with any binop identity constant, or we; // could use SimplifyBinOp to see if either arm of the select reduces.; // But that needs to be done carefully and/or while removing potential; // reverse canonicalizations as in InstCombiner::foldSelectIntoOp().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:197,reduce,reduces,197,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// TODO: This is a workaround to avoid the unmodelled liveness computed with; // whole-wave virtual registers when allocated together with the regular VGPR; // virtual registers. Presently, the liveness computed during the regalloc is; // only uniform (or single lane aware) and it doesn't take account of the; // divergent control flow that exists for our GPUs. Since the WWM registers; // can modify inactive lanes, the wave-aware liveness should be computed for; // the virtual registers to accurately plot their interferences. Without; // having the divergent CFG for the function, it is difficult to implement the; // wave-aware liveness info. Until then, we conservatively extend the liveness; // of the wwm registers into the entire function so that they won't be reused; // without first spilling/splitting their liveranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp:115,allocate,allocated,115,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// TODO: This is likely to induce unwanted autoparsing, those are reduced; // by the caching of the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TClassEdit.cxx:66,reduce,reduced,66,core/foundation/src/TClassEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TClassEdit.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// TODO: Though vector loads usually perform well on AArch64, in some targets; // they may wake up the FP unit, which raises the power consumption. Perhaps; // they could be used with no holds barred (-O3).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:129,power,power,129,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,2,"['consumption', 'power']","['consumption', 'power']"
Energy Efficiency,// TODO: Use vfwcvt to reduce register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:23,reduce,reduce,23,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// TODO: We could also reduce to 16 bits, but that's more target-dependent.; // Some targets like it, some don't, some only like it under certain; // conditions/processor versions, etc.; // A TL hook might be needed for this.; // Don't combine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:23,reduce,reduce,23,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['reduce'],['reduce']
Energy Efficiency,// TODO: We don't do TRE if dynamic allocas are used.; // Dynamic allocas allocate stack space which should be; // deallocated before new iteration started. That is; // currently not implemented.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:74,allocate,allocate,74,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,1,['allocate'],['allocate']
Energy Efficiency,// TODO: We may also be able to support negative powers of 2 here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,power,powers,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['powers']
Energy Efficiency,"// TODO: We need to invalidate the lock stack as well. This is tricky; // to implement correctly and efficiently though, because the effects; // of mutex escapes on lock order may be fairly varied.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:101,efficient,efficiently,101,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// TODO: We should use an AA to create an (optimistic and callback; // call-aware) call graph. For now we stick to simple patterns that; // are less powerful, basically the worst fixpoint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:149,power,powerful,149,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['power'],['powerful']
Energy Efficiency,// TODO: be more precise about which GEP operands we can reduce (e.g. array; // indexes),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperands.cpp:57,reduce,reduce,57,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperands.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// TODO: change this treatment to keep track of all values so that the threshold; // for adaptive sampling is counted for all distributions and not just the; // first one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:89,adapt,adaptive,89,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,1,['adapt'],['adaptive']
Energy Efficiency,// TODO: handle the case where XElemTy is not byte-sized or not a power of 2; // or a complex datatype.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:66,power,power,66,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['power'],['power']
Energy Efficiency,"// TODO: merge these two routines. For the moment, we display the best; // result obtained by *either* implementation. This is a bit unfair since no; // caller actually gets the full power at the moment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:183,power,power,183,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['power'],['power']
Energy Efficiency,"// TODO: remove this early return once the false positives for constant->bool; // in templates, macros, etc, are reduced or removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:113,reduce,reduced,113,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// TODO: this is an ugly hack.. adapt this to new framework",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:32,adapt,adapt,32,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['adapt'],['adapt']
Energy Efficiency,"// TODO: ugly hack.. adapt to new framework",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TransformationHandler.cxx:21,adapt,adapt,21,tmva/tmva/src/TransformationHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TransformationHandler.cxx,1,['adapt'],['adapt']
Energy Efficiency,"// TODO: when we have SSE, these could be more efficient, by using movd/movq.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,efficient,efficient,47,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// TProcessExecutor is in charge of checking the signatures for incompatibilities:; // we trust that decltype(redfunc(std::vector<decltype(func(args[0]))>)) == decltype(args[0]); // TODO document somewhere that fReducedResult must have a default ctor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/TMPWorkerExecutor.h:26,charge,charge,26,core/multiproc/inc/TMPWorkerExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/TMPWorkerExecutor.h,1,['charge'],['charge']
Energy Efficiency,"// TTabCom adapter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx:11,adapt,adapter,11,core/textinput/src/Getline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx,1,['adapt'],['adapter']
Energy Efficiency,"// Tab completion handler / TTabCom adapter; // Config values:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx:36,adapt,adapter,36,core/textinput/src/Getline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx,1,['adapt'],['adapter']
Energy Efficiency,// Take the exclusive capability to reduce further warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:36,reduce,reduce,36,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Target may have not allocated this yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:23,allocate,allocated,23,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Target-independent instructions do not have an implicit-use of EXEC, even; // when they operate on VGPRs. Treating EXEC modifications as scheduling; // boundaries prevents incorrect movements of such instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:140,schedul,scheduling,140,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// TaskGroup has a relatively high overhead, so we want to reduce; // the number of spawn() calls. We'll create up to 1024 tasks here.; // (Note that 1024 is an arbitrary number. This code probably needs; // improving to take the number of available cores into account.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h:59,reduce,reduce,59,interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,1,['reduce'],['reduce']
Energy Efficiency,"// Tell MFI whether any base registers were allocated. PEI will only; // want to use the local block allocations from this pass if there were any.; // Otherwise, PEI can do a bit better job of getting the alignment right; // without a hole at the start since it knows the alignment of the stack; // at the start of local allocation, and this pass doesn't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:44,allocate,allocated,44,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Tell the caller to allocate to this newly freed physical register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:22,allocate,allocate,22,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Tell the outside world about the result of the scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:50,schedul,scheduling,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Template alias so that all Instruction storing alignment use the same; // definiton.; // Valid alignments are powers of two from 2^0 to 2^MaxAlignmentExponent =; // 2^32. We store them as Log2(Alignment), so we need 6 bits to encode the 33; // possible values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:113,power,powers,113,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['power'],['powers']
Energy Efficiency,// Template argument PassT of PassInstrumentation::runBeforePass could be two; // kinds: (1) a regular pass inherited from PassInfoMixin (happen when; // creating a adaptor pass for a regular pass); (2) a type-erased PassConcept; // created from (1). Here we want to make case (1) skippable unconditionally; // since they are regular passes. We call PassConcept::isRequired to decide; // for case (2).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h:165,adapt,adaptor,165,interpreter/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h,1,['adapt'],['adaptor']
Energy Efficiency,"// Template class for a map translating uint32_t into arbitrary types.; // The map will act like an indexed set: upon insertion of a new object,; // it will automatically assign a new index to it. Index of 0 is treated; // as invalid and is never allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h:247,allocate,allocated,247,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,1,['allocate'],['allocated']
Energy Efficiency,"// Temporary option to allow experimenting with MachineScheduler as a post-RA; // scheduler. Targets can ""properly"" enable this with; // substitutePass(&PostRASchedulerID, &PostMachineSchedulerID).; // Targets can return true in targetSchedulesPostRAScheduling() and; // insert a PostRA scheduling pass wherever it wants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:82,schedul,scheduler,82,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,// Terminators and labels can't be scheduled around.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:35,schedul,scheduled,35,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,3,['schedul'],['scheduled']
Energy Efficiency,"// Test scalar arguments for conversion. B has been validated earlier to be a; // negative power of two and thus is guaranteed to have one or more contiguous; // ones starting from the MSB followed by zero or more contiguous zeros. D has; // been validated earlier to be a shifted set of one or more contiguous ones.; // In order to match, B leading ones and D leading zeros should be equal. The; // predicate that B be a negative power of 2 prevents the condition of there; // ever being zero leading ones. Thus 0 == 0 cannot occur. The predicate that; // D always be a shifted mask prevents the condition of D equaling 0. This; // prevents matching the condition where B contains the maximum number of; // leading one bits (-1) and D contains the maximum number of leading zero; // bits (0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:91,power,power,91,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['power'],['power']
Energy Efficiency,"// Thankfully, these are efficiently composable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:25,efficient,efficiently,25,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['efficient'],['efficiently']
Energy Efficiency,"// The %fn_context is allocated like below (from --print-after=sjljehprepare):; // %fn_context = alloca { i8*, i64, [4 x i64], i8*, i8*, [5 x i8*] }; //; // This `[5 x i8*]` is jmpbuf, so jmpbuf[1] is FI+72.; // First `i64` is callsite, so callsite is FI+8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:22,allocate,allocated,22,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The 'and' mask must be composed of power-of-2 constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,power,power-of-,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:137,schedul,scheduler,137,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// The AIX `power` alignment rules apply the natural alignment of the; // ""first member"" if it is of a floating-point data type (or is an aggregate; // whose recursively ""first"" member or element is such a type). The alignment; // associated with these types for subsequent members use an alignment value; // where the floating-point data type is considered to have 4-byte alignment.; //; // For the purposes of the foregoing: vtable pointers, non-empty base classes,; // and zero-width bit-fields count as prior members; members of empty class; // types marked `no_unique_address` are not considered to be prior members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:12,power,power,12,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['power'],['power']
Energy Efficiency,"// The AccessSets are allocated via a BumpPtrAllocator, we call; // the destructor manually.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:22,allocate,allocated,22,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The CSR spill slots have not been allocated yet, so estimateStackSize; // won't include them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:37,allocate,allocated,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The ELF ABI requires us to allocate 160 bytes of stack space for the; // callee, with any outgoing stack arguments being placed above that. It; // seems better to make that area a permanent feature of the frame even if; // we're using a frame pointer. Similarly, 64-bit XPLINK requires 96 bytes; // of stack space for the register save area.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:30,allocate,allocate,30,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// The FunctionInfo objects are allocated via a BumpPtrAllocator, we call; // the destructor manually.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:32,allocate,allocated,32,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['allocate'],['allocated']
Energy Efficiency,// The GenericScheduler that we use defaults to scheduling bottom up only.; // We want to schedule from both the top and the bottom and so we set; // OnlyBottomUp to false.; // We want to do bi-directional scheduling since it provides a more balanced; // schedule leading to better performance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp:48,schedul,scheduling,48,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.cpp,4,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// The I/O allocated just enough memory to hold the; // current set of ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:11,allocate,allocated,11,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency,// The IV bump is a power of two. Log_2(IV bump) is the shift amount.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:20,power,power,20,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['power'],['power']
Energy Efficiency,"// The LS of a function parameter / return value can only be a power; // of 2, starting from 8 bits, up to 128.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:63,power,power,63,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['power'],['power']
Energy Efficiency,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:109,schedul,schedule,109,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"// The MSVC linker always inserts padding when linking incrementally. We; // cope with that by aligning each struct to its size, which must be a power; // of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:145,power,power,145,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['power'],['power']
Energy Efficiency,"// The MachineScheduler can increase register usage, so we use more high; // registers and end up with more T2 instructions that cannot be converted to; // T1 instructions. At least until we do better at converting to thumb1; // instructions, on cortex-m at Oz where we are size-paranoid, don't use the; // Machine scheduler, relying on the DAG register pressure scheduler instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:315,schedul,scheduler,315,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,2,['schedul'],['scheduler']
Energy Efficiency,// The PiYG color scheme has green and red for missing right and left; // respectively.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.cpp:29,green,green,29,interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.cpp,1,['green'],['green']
Energy Efficiency,// The PowerPC target isn't yet aware of offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:7,Power,PowerPC,7,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// The Rewriter may not be used from this point on.; // Loop-invariant instructions in the preheader that aren't used in the; // loop may be sunk below the loop to reduce register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:164,reduce,reduce,164,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// The Roo2DKeys options available are:; // a = select an adaptive bandwidth [default]; // n = select a normal bandwidth; // m = mirror kernel contributions at edges [fold gaussians back into the x,y plane]; // d = print debug statements [useful for development only; default is off]; // v = print verbose debug statements [useful for development only; default is off]; // vv = print ludicrously verbose debug statements [useful for development only; default is off]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h:58,adapt,adaptive,58,roofit/roofit/inc/Roo2DKeysPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h,1,['adapt'],['adaptive']
Energy Efficiency,// The SSE4A EXTRQ instruction can efficiently extend the first 2 lanes; // to 64-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,efficient,efficiently,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// The Uses array is sorted, so all the uses for a given User; // are next to each other in the list.; // To help reduce the number of CSE recomputations, process all; // the uses of this user that we can find this way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:114,reduce,reduce,114,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['reduce'],['reduce']
Energy Efficiency,// The VLIW Scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:12,Schedul,Scheduler,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,1,['Schedul'],['Scheduler']
Energy Efficiency,"// The abstract attributes are allocated via the BumpPtrAllocator Allocator,; // thus we cannot delete them. We can, and want to, destruct them though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:31,allocate,allocated,31,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The actions to be performed on the Remote Reduce list is dependent; // on the algorithm version.; //; // if (AlgoVer==0) || (AlgoVer==1 && (LaneId < Offset)) || (AlgoVer==2 &&; // LaneId % 2 == 0 && Offset > 0):; // do the reduction value aggregation; //; // The thread local variable Reduce list is mutated in place to host the; // reduced data, which is the aggregated value produced from local and; // remote lanes.; //; // Note that AlgoVer is expected to be a constant integer known at compile; // time.; // When AlgoVer==0, the first conjunction evaluates to true, making; // the entire predicate true during compile time.; // When AlgoVer==1, the second conjunction has only the second part to be; // evaluated during runtime. Other conjunctions evaluates to false; // during compile time.; // When AlgoVer==2, the third conjunction has only the second part to be; // evaluated during runtime. Other conjunctions evaluates to false; // during compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:45,Reduce,Reduce,45,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,3,"['Reduce', 'reduce']","['Reduce', 'reduced']"
Energy Efficiency,// The additions here are ordered so that the definitely short strings are; // added first so we won't exceed the small size. We append the; // much longer FS string at the end so that we only heap allocate at most; // one time.; // Extract prefer-vector-width attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp:198,allocate,allocate,198,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// The aliasing and non-aliasing maps reduce independently of each; // other, but share a common BarrierChain. Check if the; // newBarrierChain is above the former one. If it is not, it may; // introduce a loop to use newBarrierChain, so keep the old one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:38,reduce,reduce,38,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// The allocaInst allocates the memory in private address space. This need; // to be addrspacecasted to point to the address space of cos pointer type.; // In OpenCL 2.0 this is generic, while in 1.2 that is private.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:18,allocate,allocates,18,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// The allocateMappedMemory may allocate much more memory than we need. In; // this case, we store the unused memory as a free memory block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:7,allocate,allocateMappedMemory,7,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,2,['allocate'],"['allocate', 'allocateMappedMemory']"
Energy Efficiency,"// The allocated data lives above the 160 bytes allocated for the standard; // frame, plus any outgoing stack arguments. We don't know how much that; // amounts to yet, so emit a special ADJDYNALLOC placeholder.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:7,allocate,allocated,7,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,['allocate'],['allocated']
Energy Efficiency,// The allocated region symbol tracked by the main analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:7,allocate,allocated,7,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,2,['allocate'],['allocated']
Energy Efficiency,// The allocator allocates chunks of 32 bytes for each node. The fact that; // each node takes 32 bytes in memory is used for fast translation between; // the node id and the node address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:17,allocate,allocates,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,1,['allocate'],['allocates']
Energy Efficiency,"// The amdgpu-unsafe-fp-atomics attribute enables generation of unsafe; // floating point atomic instructions. May generate more efficient code,; // but may not respect rounding and denormal modes, and may give incorrect; // results for certain memory destinations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:129,efficient,efficient,129,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// The arena used to allocate this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h:21,allocate,allocate,21,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,1,['allocate'],['allocate']
Energy Efficiency,"// The async context lives directly before the frame pointer, and we; // allocate a second slot to preserve stack alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:73,allocate,allocate,73,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// The backend has peephole optimizations for powers of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp:46,power,powers,46,interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp,1,['power'],['powers']
Energy Efficiency,"// The basic algorithm here is:; // 1. Mark registers of def operands as free; // 2. Allocate registers to use operands and place reload instructions for; // registers displaced by the allocation.; //; // However we need to handle some corner cases:; // - pre-assigned defs and uses need to be handled before the other def/use; // operands are processed to avoid the allocation heuristics clashing with; // the pre-assignment.; // - The ""free def operands"" step has to come last instead of first for tied; // operands and early-clobbers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:85,Allocate,Allocate,85,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// The below check is quadratic. Check we're not going to do too many tests.; // FIXME: Even though this will always have worst-case quadratic time, we; // could put effort into minimizing the average time by putting stores that; // have been shown to dominate at least one load at the beginning of the; // Stores array, making subsequent dominance checks more likely to succeed; // early.; //; // The threshold here is fairly large because global->local demotion is a; // very powerful optimization should it fire.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:478,power,powerful,478,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['power'],['powerful']
Energy Efficiency,// The below methods are protected to encourage subclasses to provide a more; // type-safe API.; /// reserve - Increase the number of buckets such that adding the; /// EltCount-th node won't cause a rebucket operation. reserve is permitted; /// to allocate more space than requested by EltCount.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:248,allocate,allocate,248,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['allocate'],['allocate']
Energy Efficiency,"// The bitfield is allocated starting at the next offset aligned; // appropriately for T', with length n bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:19,allocate,allocated,19,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The block Predecessors and Successors must be all registered; // before fastSchedule().; // Fast schedule with no particular requirement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:100,schedul,schedule,100,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['schedul'],['schedule']
Energy Efficiency,"// The branch to process is obtained when the task starts to run.; // This way, since branches are sorted, we make sure that branches; // leading to big tasks are processed first. If we assigned the; // branch at task creation time, the scheduler would not necessarily; // respect our sorting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:237,schedul,scheduler,237,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['schedul'],['scheduler']
Energy Efficiency,"// The call is deallocating a value we previously allocated, so remove it; // from the next state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:50,allocate,allocated,50,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The call to the custom handler is being treated as a special one as the; // callee is responsible for saving and restoring all the registers; // (including caller saved registers) it needs to modify. This is; // done to reduce the impact of instrumentation on the code being; // instrumented/profiled.; // NOTE: R14, R15 and R28 are reserved for PLT handling. These registers; // are in the Def list of the Hexagon::PS_call_instrprof_custom and; // therefore will be handled appropriately duing register allocation.; // TODO: It may be a good idea to add a separate pseudo instruction for; // static relocation which doesn't need to reserve r14, r15 and r28.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:223,reduce,reduce,223,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// The calling convention for passing SVE tuples states that in the event; // we cannot allocate enough registers for the tuple we should still leave; // any remaining registers unallocated. However, when we call the; // CCAssignFn again we want it to behave as if all remaining registers are; // allocated. This will force the code to pass the tuple indirectly in; // accordance with the PCS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp:88,allocate,allocate,88,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// The check for the single predecessor is not the best that can be; // done. But it protects efficiently against cases like when SI's; // home block has two successors, Succ and Succ1, and Succ1 predecessor; // of Succ. Then SI can't be replaced by SIOpd because the use that gets; // replaced can be reached on either path. So the uniqueness check; // guarantees that the path all uses of SI (outside SI's parent) are on; // is disjoint from all other paths out of SI. But that information; // is more expensive to compute, and the trade-off here is in favor; // of compile-time. It should also be noticed that we check for a single; // predecessor and not only uniqueness. This to handle the situation when; // Succ and Succ1 points to the same basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:94,efficient,efficiently,94,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// The clone should not delete any objects allocated by SetAddress().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:43,allocate,allocated,43,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// The comparison function we use for std::sort to order our local; // stack symbols. The current algorithm is to use an estimated; // ""density"". This takes into consideration the size and number of; // uses each object has in order to roughly minimize code size.; // So, for example, an object of size 16B that is referenced 5 times; // will get higher priority than 4 4B objects referenced 1 time each.; // It's not perfect and we may be able to squeeze a few more bytes out of; // it (for example : 0(esp) requires fewer bytes, symbols allocated at the; // fringe end can have special consideration, given their size is less; // important, etc.), but the algorithmic complexity grows too much to be; // worth the extra gains we get. This gets us pretty close.; // The final order leaves us with objects with highest priority going; // at the end of our list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:539,allocate,allocated,539,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The compiler can reduce this expression to a constant iff we pass an; // empty DebugLoc. Thankfully, the debug location doesn't have any bearing; // on the subclass data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:20,reduce,reduce,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['reduce'],['reduce']
Energy Efficiency,// The consumer optionally consumes LoopProducer in the same iteration; // (because the producer is scheduled at an earlier cycle than the consumer); // or the initial value. To facilitate this we create an illegal block here; // by embedding a phi in the middle of the block. We will fix this up; // immediately prior to pruning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:100,schedul,scheduled,100,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// The copy does not own any object allocated by SetAddress().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:36,allocate,allocated,36,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// The copy does not own any object allocated by SetAddress().; // FIXME: We do too much here, br may not be a top-level branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:36,allocate,allocated,36,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// The cost is actually exactly the same for mov+fmov vs. adrp+ldr;; // however the mov+fmov sequence is always better because of the reduced; // cache pressure. The timings are still the same if you consider; // movw+movk+fmov vs. adrp+ldr (it's one instruction longer, but the; // movw+movk is fused). So we limit up to 2 instrdduction at most.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:134,reduce,reduced,134,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['reduce'],['reduced']
Energy Efficiency,// The cost of a register definition is equivalent to the number of; // physical registers that are allocated at register renaming stage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:100,allocate,allocated,100,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The current block being scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:27,schedul,scheduled,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['scheduled']
Energy Efficiency,"// The current fix would qualify ""ns1::ns2::Green"" as; // ""ns1::ns2::Color::Green"".; //; // Get the EndLoc of the replacement by moving 1 character backward (; // to exclude the last '::').; //; // ns1::ns2::Green;; // ^ ^^; // BeginLoc |EndLoc of the qualifier; // new EndLoc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:44,Green,Green,44,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,3,['Green'],['Green']
Energy Efficiency,"// The current register file is too small. This may occur if the number of; // microarchitectural registers in register file #0 was changed by the; // users via flag -reg-file-size. Alternatively, the scheduling model; // specified a too small number of registers for this register file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:201,schedul,scheduling,201,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// The data contains the terminator: we'll drain the data up; // to the end of the terminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:43,drain,drain,43,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['drain'],['drain']
Energy Efficiency,"// The default adaptive strategy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:15,adapt,adaptive,15,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// The default implementation reduces to just comparison, since comparison; // is required by the API, even if no widening is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h:30,reduce,reduces,30,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,1,['reduce'],['reduces']
Energy Efficiency,"// The element representing the type has been already finalized. If; // the type is an aggregate type, its members have been already added.; // As the type is local, its level will be changed.; // FIXME: Currently the algorithm used to scope lambda functions is; // incorrect. Before we allocate the type at this scope, check if is; // already allocated in other scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:287,allocate,allocate,287,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,4,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// The element type being allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:26,allocate,allocated,26,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The expected latency of the critical path in this scheduled zone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:53,schedul,scheduled,53,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"// The first time we see a live range, don't try to split or spill.; // Wait until the second time, when all smaller ranges have been allocated.; // This gives a better picture of the interference to split around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:134,allocate,allocated,134,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The fixup is always 24-bits, so go ahead and allocate the space; // in the table so all our relative position calculations work OK even; // before we fully resolve the real value here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:48,allocate,allocate,48,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['allocate'],['allocate']
Energy Efficiency,// The following code is dependent on the order in which the DbgValues are; // constructed in ScheduleDAGInstrs::buildSchedGraph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:94,Schedul,ScheduleDAGInstrs,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,1,['Schedul'],['ScheduleDAGInstrs']
Energy Efficiency,"// The following code is ported from AArch64ISelLowering.; // Multiplication of a power of two plus/minus one can be done more; // cheaply as shift+add/sub. For now, this is true unilaterally. If; // future CPUs have a cheaper MADD instruction, this may need to be; // gated on a subtarget feature. For Cyclone, 32-bit MADD is 4 cycles and; // 64-bit is 5 cycles, so this is always a win.; // More aggressively, some multiplications N0 * C can be lowered to; // shift+add+shift if the constant C = A * B where A = 2^N + 1 and B = 2^M,; // e.g. 6=3*2=(2+1)*2.; // TODO: consider lowering more cases, e.g. C = 14, -6, -14 or even 45; // which equals to (1+2)*16-(1+2).; // TrailingZeroes is used to test if the mul can be lowered to; // shift+add+shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp:82,power,power,82,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,1,['power'],['power']
Energy Efficiency,"// The following interface to AA is fashioned after DAGCombiner::isAlias and; // operates with MachineMemOperand offset with some important assumptions:; // - LLVM fundamentally assumes flat address spaces.; // - MachineOperand offset can *only* result from legalization and cannot; // affect queries other than the trivial case of overlap checking.; // - These offsets never wrap and never step outside of allocated objects.; // - There should never be any negative offsets here.; //; // FIXME: Modify API to hide this math from ""user""; // Even before we go to AA we can reason locally about some memory objects. It; // can save compile time, and possibly catch some corner cases not currently; // covered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:407,allocate,allocated,407,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The following loop iterates over all instructions in the basic block,; // and performs 2 operations:; // 1. Insert a CSDB at this location if needed.; // 2. Expand the SpeculationSafeValuePseudo if the current instruction is; // one.; //; // The insertion of the CSDB is done as late as possible (i.e. just before; // the use of a masked register), in the hope that that will reduce the; // total number of CSDBs in a block when there are multiple masked registers; // in the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:379,reduce,reduce,379,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['reduce'],['reduce']
Energy Efficiency,// The following stack frame objects are always referenced relative to $sp:; // 1. Outgoing arguments.; // 2. Pointer to dynamically allocated stack space.; // 3. Locations for callee-saved registers.; // 4. Locations for eh data registers.; // 5. Locations for ISR saved Coprocessor 0 registers 12 & 14.; // Everything else is referenced relative to whatever register; // getFrameRegister() returns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:133,allocate,allocated,133,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The following stack frame objects are always; // referenced relative to $sp:; // 1. Outgoing arguments.; // 2. Pointer to dynamically allocated stack space.; // 3. Locations for callee-saved registers.; // Everything else is referenced relative to whatever register; // getFrameRegister() returns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp:137,allocate,allocated,137,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16RegisterInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The following transforms are done irrespective of the number of uses; // for the expression ""1.0/sqrt(X)"".; // 1) 1.0/sqrt(X) * X -> X/sqrt(X); // 2) X * 1.0/sqrt(X) -> X/sqrt(X); // We always expect the backend to reduce X/sqrt(X) to sqrt(X), if it; // has the necessary (reassoc) fast-math-flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:218,reduce,reduce,218,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['reduce'],['reduce']
Energy Efficiency,// The function type was not found. Allocate one and update FunctionTypes; // in-place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:36,Allocate,Allocate,36,interpreter/llvm-project/llvm/lib/IR/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// The gep was in charge of making sure the offsets are scaled correctly; // - calculate that factor so it can be applied by hand,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:18,charge,charge,18,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,1,['charge'],['charge']
Energy Efficiency,"// The goal here is to find all of the non-phi values reachable from this phi,; // and to do the same for all of the phis reachable from this phi, as doing so; // is necessary anyway in order to get the values for this phi. We do this using; // Tarjan's algorithm with Nuutila's improvements to find the strongly connected; // components of the phi graph rooted in this phi:; // * All phis in a strongly connected component will have the same reachable; // non-phi values. The SCC may not be the maximal subgraph for that set of; // reachable values, but finding out that isn't really necessary (it would; // only reduce the amount of memory needed to store the values).; // * Tarjan's algorithm completes components in a bottom-up manner, i.e. it; // never completes a component before the components reachable from it have; // been completed. This means that when we complete a component we have; // everything we need to collect the values reachable from that component.; // * We collect both the non-phi values reachable from each SCC, as that's what; // we're ultimately interested in, and all of the reachable values, i.e.; // including phis, as that makes invalidateValue easier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:614,reduce,reduce,614,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:43,efficient,efficient,43,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// The hazard recognizer that runs as part of the post-ra scheduler does not; // guarantee to be able handle all hazards correctly. This is because if there; // are multiple scheduling regions in a basic block, the regions are scheduled; // bottom up, so when we begin to schedule a region we don't know what; // instructions were emitted directly before it.; //; // Here we add a stand-alone hazard recognizer pass which can handle all; // cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:58,schedul,scheduler,58,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,4,['schedul'],"['schedule', 'scheduled', 'scheduler', 'scheduling']"
Energy Efficiency,"// The implementation for this class is in CGException.h and; // CGException.cpp; the definition is here because it's used as a; // member of CodeGenFunction.; /// The start of the scope-stack buffer, i.e. the allocated pointer; /// for the buffer. All of these pointers are either simultaneously; /// null or simultaneously valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/EHScopeStack.h:210,allocate,allocated,210,interpreter/llvm-project/clang/lib/CodeGen/EHScopeStack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/EHScopeStack.h,1,['allocate'],['allocated']
Energy Efficiency,// The implementation of this function is adapted from X86FastISel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp:42,adapt,adapted,42,interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86InstructionSelector.cpp,1,['adapt'],['adapted']
Energy Efficiency,// The indexList's nodes are all allocated in the BumpPtrAllocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp:33,allocate,allocated,33,interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SlotIndexes.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The initial design was for MaxPSets=4, but that requires PSet partitions,; // which are not yet implemented. (PSet partitions are equivalent PSets given; // the register classes actually in use within the scheduling region.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:208,schedul,scheduling,208,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,1,['schedul'],['scheduling']
Energy Efficiency,// The initial value of SizeAccum should always be a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:53,power,power,53,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,1,['power'],['power']
Energy Efficiency,"// The inlined atomics only function on iN types, where N is a power of 2. We; // need to make sure (via temporaries if necessary) that all incoming values; // are compatible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:63,power,power,63,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['power'],['power']
Energy Efficiency,"// The input operands all must have the same type, and we know the result; // type is valid. Convert this to a buildvector which extracts all the; // input elements.; // TODO: If the input elements are power-two vectors, we could convert this to; // a new CONCAT_VECTORS node with elements that are half-wide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:202,power,power-two,202,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['power'],['power-two']
Energy Efficiency,"// The instruction vectors are allocated using a BumpPtrAllocator, we need to; // manually destroy them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:31,allocate,allocated,31,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:422,reduce,reduce,422,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['reduce'],['reduce']
Energy Efficiency,// The interference is overlapping somewhere we wanted to use IntvIn. That; // means we need to create a local interval that can be allocated a; // different register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:132,allocate,allocated,132,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The interference is overlapping somewhere we wanted to use IntvOut. That; // means we need to create a local interval that can be allocated a; // different register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:133,allocate,allocated,133,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:133,schedul,scheduled,133,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,4,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"// The largest power of 2 that divides both A and B.; //; // Replace ""-Value"" by ""1+~Value"" in the following commented code to avoid; // MSVC warning C4146; // return (A | B) & -(A | B);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:15,power,power,15,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,1,['power'],['power']
Energy Efficiency,// The largest size that we're still considering making subvectors of.; // Always a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:84,power,power,84,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['power'],['power']
Energy Efficiency,"// The latency of dependence chains leading into this zone.; // For each node scheduled bottom-up: DLat = max DLat, N.Depth.; // For each cycle scheduled: DLat -= 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:78,schedul,scheduled,78,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduled']
Energy Efficiency,"// The ldr must happen after a floating point instruction. To prevent the; // post-ra scheduler to mess with the order, we create a bundle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:86,schedul,scheduler,86,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// The line in which we collect the resulting reconstructed output.; // To reduce special cases in the algorithm, the first level of the line; // contains a single null token that has the reconstructed incoming; // lines as children.; // In the end, we stich the lines together so that each subsequent line; // is a child of the last token of the previous line. This is necessary; // in order to format the overall expression as a single logical line -; // if we created separate lines, we'd format them with their own top-level; // indent depending on the semantic structure, which is not desired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:75,reduce,reduce,75,interpreter/llvm-project/clang/lib/Format/Macros.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h,1,['reduce'],['reduce']
Energy Efficiency,"// The live virtual register requesting allocation was spilled, so tell; // the caller not to allocate anything during this round.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:94,allocate,allocate,94,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// The llvm.amdgcn.module.lds instance is implicitly used by all kernels; // that might call a function which accesses a field within it. This is; // presently approximated to 'all kernels' if there are any such functions; // in the module. This implicit use is redefined as an explicit use here so; // that later passes, specifically PromoteAlloca, account for the required; // memory without any knowledge of this transform.; // An operand bundle on llvm.donothing works because the call instruction; // survives until after the last pass that needs to account for LDS. It is; // better than inline asm as the latter survives until the end of codegen. A; // totally robust solution would be a function with the same semantics as; // llvm.donothing that takes a pointer to the instance and is lowered to a; // no-op after LDS is allocated, but that is not presently necessary.; // This intrinsic is eliminated shortly before instruction selection. It; // does not suffice to indicate to ISel that a given global which is not; // immediately used by the kernel must still be allocated by it. An; // equivalent target specific intrinsic which lasts until immediately after; // codegen would suffice for that, but one would still need to ensure that; // the variables are allocated in the anticpated order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:830,allocate,allocated,830,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,3,['allocate'],['allocated']
Energy Efficiency,"// The loaded class version is not the same as the version of the code; // which was used to allocate this array. The best we can do is use; // the TVirtualStreamerInfo to try to free up some of the allocated memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:93,allocate,allocate,93,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// The loaded class version is not the same as the version of the code; // which was used to allocate this object. The best we can do is use; // the TVirtualStreamerInfo to try to free up some of the allocated memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:93,allocate,allocate,93,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// The loop value hasn't yet been scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:34,schedul,scheduled,34,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// The loop value is another phi, which has been scheduled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:49,schedul,scheduled,49,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// The loop value is another phi, which has not been scheduled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:53,schedul,scheduled,53,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:15,schedul,scheduler,15,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['schedul'],['scheduler']
Energy Efficiency,"// The manipulations performed when we're looking through an insertvalue or; // an extractvalue would happen at the front of the RetPath list, so since; // we have to copy it anyway it's more efficient to create a reversed copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:192,efficient,efficient,192,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,1,['efficient'],['efficient']
Energy Efficiency,// The maximum VF is for the smallest element width with LMUL=8.; // VF must be a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,power,power,82,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// The maximum number of cycles monitored by the Scoreboard. This; // value is determined based on the target itineraries to ensure; // that all hazards can be tracked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:32,monitor,monitored,32,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,1,['monitor'],['monitored']
Energy Efficiency,"// The maximum number of memoization entries to store.; // 10k has been experimentally found to give a good trade-off; // of performance vs. memory consumption by running matcher; // that match on every statement over a very large codebase.; //; // FIXME: Do some performance optimization in general and; // revisit this number; also, put up micro-benchmarks that we can; // optimize this on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:148,consumption,consumption,148,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['consumption'],['consumption']
Energy Efficiency,// The maximum size of a chain created by the algorithm. The size is bounded; // so that the algorithm can efficiently process extremely large instances.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:107,efficient,efficiently,107,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// The method here to extract the awaiter decl is not precise.; // This is intentional. Since it is hard to perform the analysis in the; // frontend due to the complexity of C++'s type systems.; // And we prefer to perform such analysis in the middle end since it is; // easier to implement and more powerful.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:300,power,powerful,300,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['power'],['powerful']
Energy Efficiency,"// The minimal size of the left-most redzone (header).; // At least 4 pointer sizes, power of 2, and >= Granularity.; // The resulting FrameSize should be multiple of MinHeaderSize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:85,power,power,85,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,1,['power'],['power']
Energy Efficiency,// The most important heuristic is scheduling the critical path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:35,schedul,scheduling,35,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// The name is too already used, just free it so we can allocate a new name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ValueSymbolTable.cpp:56,allocate,allocate,56,interpreter/llvm-project/llvm/lib/IR/ValueSymbolTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ValueSymbolTable.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// The named return value optimization: allocate this variable in the; // return slot, so that we can elide the copy when returning this; // variable (C++0x [class.copy]p34).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:40,allocate,allocate,40,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// The new element; //int nByte; // How many bytes to allocate; //int i; // Loop counter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:54,allocate,allocate,54,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['allocate'],['allocate']
Energy Efficiency,// The number of bytes allocated (for the vtable plus the byte array) after; // the address point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:23,allocate,allocated,23,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,1,['allocate'],['allocated']
Energy Efficiency,// The number of bytes allocated (for the vtable plus the byte array) before; // the address point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:23,allocate,allocated,23,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,1,['allocate'],['allocated']
Energy Efficiency,// The number of elements is at offset sizeof(size_t) relative to; // the allocated pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:74,allocate,allocated,74,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The number of parts is a power of 2. Repeatedly bisect the value using; // EXTRACT_ELEMENT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:28,power,power,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['power'],['power']
Energy Efficiency,// The number of parts is not a power of 2. Split off and copy the tail.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:32,power,power,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['power'],['power']
Energy Efficiency,// The number of spaces in front of the token or broken part of the token.; // This will be adapted when aligning tokens.; // Can be negative to retain information about the initial relative offset; // of the lines in a block comment. This is used when aligning trailing; // comments. Uncompensated negative offset is truncated to 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.h:92,adapt,adapted,92,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.h,1,['adapt'],['adapted']
Energy Efficiency,"// The number of uOps for load / store multiple are determined by the number; // registers.; //; // On Cortex-A8, each pair of register loads / stores can be scheduled on the; // same cycle. The scheduling for the first load / store must be done; // separately by assuming the address is not 64-bit aligned.; //; // On Cortex-A9, the formula is simply (#reg / 2) + (#reg % 2). If the address; // is not 64-bit aligned, then AGU would take an extra cycle. For VFP / NEON; // load / store multiple, the formula is (#reg / 2) + (#reg % 2) + 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:158,schedul,scheduled,158,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"// The object was allocated using code for the same class version; // as is loaded now. We may proceed without worry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:18,allocate,allocated,18,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['allocate'],['allocated']
Energy Efficiency,"// The offset likely isn't legal, we want to allocate a virtual base register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp:45,allocate,allocate,45,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,// The offset likely isn't legal; we want to allocate a virtual base register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp:45,allocate,allocate,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// The option is unused. Choose Local strategy only for in-order cores. When; // scheduling model is unspecified, use MinInstrCount strategy as more; // generic one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:81,schedul,scheduling,81,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// The order in which base class subobjects are allocated is unspecified,; // so may differ from declaration order. In particular, Itanium ABI will; // allocate a primary base first.; // Since we exclude empty subobjects, the objects are not overlapping and; // their offsets are unique.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:48,allocate,allocated,48,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// The order in which branches appear in ImmBranches is approximately their; // order within the function body. By visiting later branches first, we reduce; // the distance between earlier forward branches and their targets, making it; // more likely that the cbn?z optimization, which can only apply to forward; // branches, will succeed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:149,reduce,reduce,149,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// The ordering of the SDNodes. It roughly corresponds to the ordering of the; // original LLVM instructions.; // This is used for turning off scheduling, because we'll forgo; // the normal scheduling algorithms and output the instructions according to; // this ordering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:143,schedul,scheduling,143,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,2,['schedul'],['scheduling']
Energy Efficiency,"// The original algorithm expected a working space array WK of length IWK; // with IWK Length ( >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2).; // Here, this array is allocated dynamically",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx:174,allocate,allocated,174,math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,1,['allocate'],['allocated']
Energy Efficiency,// The output register value when the predicate is false is an implicit; // register operand tied to the first def. The tie makes the register; // allocator ensure the FalseReg is allocated the same register as operand 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:180,allocate,allocated,180,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The output register value when the predicate is false is an implicit; // register operand tied to the first def.; // The tie makes the register allocator ensure the FalseReg is allocated the; // same register as operand 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:180,allocate,allocated,180,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The pointer expression will, in many cases, be an opaque void*.; // In these cases, discard the computed alignment and use the; // formal alignment of the allocated type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:158,allocate,allocated,158,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The private segment wave byte offset is the last of the system SGPRs. We; // initially assumed it was allocated, and may have used it. It shouldn't harm; // anything to disable it if we know the stack isn't used here. We may still; // have emitted code reading it to initialize scratch, but if that's unused; // reading garbage should be OK.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp:105,allocate,allocated,105,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The processor keeps the definition of `RegID` together with register; // `RenameAs`. Since this partial write is not renamed, no physical; // register is allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:157,allocate,allocated,157,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The prolog code of the callee may store up to 8 GPR argument registers to; // the stack, allowing va_start to index over them in memory if its varargs.; // Because we cannot tell if this is needed on the caller side, we have to; // conservatively assume that it is needed. As such, make sure we have at; // least enough stack space for the caller to store the 8 GPRs.; // FIXME: On ELFv2, it may be unnecessary to allocate the parameter area.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:417,allocate,allocate,417,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['allocate'],['allocate']
Energy Efficiency,// The register pressure must be reduced.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:33,reduce,reduced,33,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['reduce'],['reduced']
Energy Efficiency,// The register-offset variant of LDRD mandates that the register; // allocated to RegOffset is not reused in any of the remaining operands.; // This restriction is currently not enforced. Therefore emitting this; // variant is explicitly avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:70,allocate,allocated,70,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The register-offset variant of STRD mandates that the register; // allocated to RegOffset is not reused in any of the remaining operands.; // This restriction is currently not enforced. Therefore emitting this; // variant is explicitly avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:70,allocate,allocated,70,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The registers in AVs are ordered according to the lexical order of; // the corresponding register cells. This means that the range of regis-; // ters in AVs that match a prefix of length L+1 will be contained in; // the range that matches a prefix of length L. This means that we can; // keep narrowing the search space as the prefix length goes up. This; // helps reduce the overall complexity of the search.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:368,reduce,reduce,368,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// The regular method converting a 64-bit integer to float roughly consists of; // 2 steps: normalization and rounding. In fact, after normalization, the; // conversion from a 64-bit integer to a float is essentially the same as the; // one from a 32-bit integer. The only difference is that it has more; // trailing bits to be rounded. To leverage the native 32-bit conversion, a; // 64-bit integer could be preprocessed and fit into a 32-bit integer then; // converted into the correct float number. The basic steps for the unsigned; // conversion are illustrated in the following pseudo code:; //; // f32 uitofp(i64 u) {; // i32 hi, lo = split(u);; // // Only count the leading zeros in hi as we have native support of the; // // conversion from i32 to f32. If hi is all 0s, the conversion is; // // reduced to a 32-bit one automatically.; // i32 shamt = clz(hi); // Return 32 if hi is all 0s.; // u <<= shamt;; // hi, lo = split(u);; // hi |= (lo != 0) ? 1 : 0; // Adjust rounding bit in hi based on lo.; // // convert it as a 32-bit integer and scale the result back.; // return uitofp(hi) * 2^(32 - shamt);; // }; //; // The signed one follows the same principle but uses 'ffbh_i32' to count its; // sign bits instead. If 'ffbh_i32' is not available, its absolute value is; // converted instead followed by negation based its sign bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:803,reduce,reduced,803,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// The remaining GPRs hold either the beginning of variable-argument; // data, or the beginning of an aggregate passed by value (usually; // byval). Either way, we allocate stack slots adjacent to the data; // provided by our caller, and store the unallocated registers there.; // If this is a variadic function, the va_list pointer will begin with; // these values; otherwise, this reassembles a (byval) structure that; // was split between registers and memory.; // Return: The frame index registers were stored into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:164,allocate,allocate,164,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// The rest of these methods are helpers that redirect to one of the above; // core methods.; /// Allocate space for a sequence of objects without constructing them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h:98,Allocate,Allocate,98,interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,1,['Allocate'],['Allocate']
Energy Efficiency,// The restriction on `FoundRHS` be lifted easily -- it exists only to; // reduce the compile time impact of this optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:75,reduce,reduce,75,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// The result type is legal, but the input type is illegal. If splitting; // ends up with the result type of each half still being legal, just; // do that. If, however, that would result in an illegal result type,; // we can try to get more clever with power-two vectors. Specifically,; // split the input type, but also widen the result element size, then; // concatenate the halves and truncate again. For example, consider a target; // where v8i8 is legal and v8i32 is not (ARM, which doesn't have 256-bit; // vectors). To perform a ""%res = v8i8 trunc v8i32 %in"" we do:; // %inlo = v4i32 extract_subvector %in, 0; // %inhi = v4i32 extract_subvector %in, 4; // %lo16 = v4i16 trunc v4i32 %inlo; // %hi16 = v4i16 trunc v4i32 %inhi; // %in16 = v8i16 concat_vectors v4i16 %lo16, v4i16 %hi16; // %res = v8i8 trunc v8i16 %in16; //; // Without this transform, the original truncate would end up being; // scalarized, which is pretty much always a last resort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:253,power,power-two,253,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['power'],['power-two']
Energy Efficiency,"// The scheduled instruction occurs before the scheduled Phi, and the; // Phi is not loop carried.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:7,schedul,scheduled,7,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,2,['schedul'],['scheduled']
Energy Efficiency,// The scheduling region got new instructions at the lower end (or it is a; // new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // It is seldom that this needs to be done a second time after adding the; // initial bundle to the region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:7,schedul,scheduling,7,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// The segment writer will be in charge of updating these contents.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp:33,charge,charge,33,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,1,['charge'],['charge']
Energy Efficiency,// The sensibility of this algorithm relies on the fact that we never; // have a legal non-power-of-2 vector size without having the power of 2; // also be legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:91,power,power-of-,91,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,2,['power'],"['power', 'power-of-']"
Energy Efficiency,// The shadow memory space is dynamically allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:42,allocate,allocated,42,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The shift amount (operand 2) of a funnel shift is modulo the bitwidth,; // so only the low bits of the shift amount are demanded if the bitwidth is; // a power-of-2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:157,power,power-of-,157,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['power'],['power-of-']
Energy Efficiency,// The size of our partial emission must be a power of two less than; // Size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:46,power,power,46,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,1,['power'],['power']
Energy Efficiency,"// The stack probing code for the dynamically allocated outgoing arguments; // area assumes that the stack is probed at the top - either by the prologue; // code, which issues a probe if `hasVarSizedObjects` return true, or by the; // most recent variable-sized object allocation. Changing the condition here; // may need to be followed up by changes to the probe issuing logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:46,allocate,allocated,46,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The stackFrames dictionary substantially reduces size of the output file by; // avoiding repeating the entire call stack of function names for each entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-converter.cpp:44,reduce,reduces,44,interpreter/llvm-project/llvm/tools/llvm-xray/xray-converter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-converter.cpp,1,['reduce'],['reduces']
Energy Efficiency,// The store does not cover the full allocated stack slot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp:37,allocate,allocated,37,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// The strategy assumes that we can efficiently load power-of-two widths.; // The routine chops the vector into the largest vector loads with the same; // element type or scalar loads and then recombines it to the widen vector; // type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:36,efficient,efficiently,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,"['efficient', 'power']","['efficiently', 'power-of-two']"
Energy Efficiency,// The strategy assumes that we can efficiently store power-of-two widths.; // The routine chops the vector into the largest vector stores with the same; // element type or scalar stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:36,efficient,efficiently,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,2,"['efficient', 'power']","['efficiently', 'power-of-two']"
Energy Efficiency,// The stream sizes should be re-allocated as a stable pointer and the stream; // map should have each of its entries allocated as a separate stable pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp:33,allocate,allocated,33,interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFBuilder.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// The string we're trying to insert isn't a substring of the next node,; // but matches up to a point. Split the node.; //; // For example, say we ended our search at a node n and we're trying to; // insert ABD. Then we'll create a new node s for AB, reduce n to just; // representing C, and insert a new leaf node l to represent d. This; // allows us to ensure that if n was a leaf, it remains a leaf.; //; // | ABC ---split---> | AB; // n s; // C / \ D; // n l; // The node s from the diagram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SuffixTree.cpp:252,reduce,reduce,252,interpreter/llvm-project/llvm/lib/Support/SuffixTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SuffixTree.cpp,1,['reduce'],['reduce']
Energy Efficiency,// The struct type was not found. Allocate one and update AnonStructTypes; // in-place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:34,Allocate,Allocate,34,interpreter/llvm-project/llvm/lib/IR/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// The sum of a non-negative number and a power of two is not zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:42,power,power,42,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,"// The symbol doesn't have to freed (e.g.: we aren't sure if, how and where; // 'fromPtr' was allocated:; // void Haha(int *ptr) {; // ptr = realloc(ptr, 67);; // // ...; // }; // ).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:94,allocate,allocated,94,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The symbol table. This is an open addressed hash table. The size of the; // hash table is always a power of 2.; // Each slot in the hash table consists of a pair of offset_type values. The; // first value is the offset of the symbol's name in the constant pool. The; // second value is the offset of the CU vector in the constant pool.; // If both values are 0, then this slot in the hash table is empty. This is ok; // because while 0 is a valid constant pool index, it cannot be a valid index; // for both a string and a CU vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFGdbIndex.cpp:102,power,power,102,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFGdbIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFGdbIndex.cpp,1,['power'],['power']
Energy Efficiency,"// The symbolizer ownership is moved into symbolizeAndFilterStackFrames so; // that it is freed automatically at the end, when it is no longer used. This; // reduces peak memory since it won't be live while also mapping the raw; // profile into records afterwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:158,reduce,reduces,158,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// The table will grow when the number of entries reach 3/4 of the number of; // buckets. To guarantee that ""InitSize"" number of entries can be inserted; // in the table without growing, we allocate just what is needed here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp:190,allocate,allocate,190,interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,1,['allocate'],['allocate']
Energy Efficiency,// The target type was not found. Allocate one and update TargetExtTypes; // in-place.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:34,Allocate,Allocate,34,interpreter/llvm-project/llvm/lib/IR/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"// The template type parameter comes from an inner template (e.g.,; // the template parameter list of a member template inside the; // template we are instantiating). Create a new template type; // parameter with the template ""level"" reduced by one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:234,reduce,reduced,234,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// The temporary array to store the powers in. We don't need to; // initialize this array however.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:36,power,powers,36,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['power'],['powers']
Energy Efficiency,"// The terminator was seen and the remaining data drained --; // we got what we came for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:50,drain,drained,50,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['drain'],['drained']
Energy Efficiency,"// The toolchain has reduced allowed dwarf version, so we can't enable; // -gembed-source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:21,reduce,reduced,21,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['reduce'],['reduced']
Energy Efficiency,// The top of the unsafe stack after all unsafe static allocas are; // allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:71,allocate,allocated,71,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// The trickiest case to handle is when we have large blocks. Because of this,; // this code is optimized assuming that large blocks happen. This does not; // significantly pessimize the small block case. This uses LargeBlockInfo to; // make it efficient to get the index of various operations in the block.; // Walk the use-def list of the alloca, getting the locations of all stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:245,efficient,efficient,245,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['efficient'],['efficient']
Energy Efficiency,// The types must match the reduced type too,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:28,reduce,reduced,28,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// The unzip cache does not consume memory by itself, it just allocates in advance; // mem blocks which are then picked as they are by the baskets.; // Hence there is no good reason to limit it too much",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:62,allocate,allocates,62,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['allocate'],['allocates']
Energy Efficiency,// The value should be equal to PseudoProbeReservedId::Last + 1 which is; // defined in SampleProfileProbe.h. The header file is not included here to; // reduce the dependency from MC to IPO.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h:154,reduce,reduce,154,interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h,1,['reduce'],['reduce']
Energy Efficiency,// The vector type is legal but the element type is not. This implies; // that the vector is a power-of-two in length and that the element; // type does not have a strange size (eg: it is not i1).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:95,power,power-of-two,95,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['power'],['power-of-two']
Energy Efficiency,// The vscale_range indicates vscale is a power-of-two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:42,power,power-of-two,42,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// The way the PLT relocations normally work is that the linker allocates; // the; // PLT and this relocation makes a PC-relative call into the PLT. The PLT; // entry will then jump to an address provided by the GOT. On first call,; // the; // GOT address will point back into PLT code that resolves the symbol. After; // the first call, the GOT entry points to the actual function.; //; // For local functions we're ignoring all of that here and just replacing; // the PLT32 relocation type with PC32, which will translate the relocation; // into a PC-relative call directly to the function. For external symbols we; // can't be sure the function will be within 2^32 bytes of the call site, so; // we need to create a stub, which calls into the GOT. This case is; // equivalent to the usual PLT implementation except that we use the stub; // mechanism in RuntimeDyld (which puts stubs at the end of the section); // rather than allocating a PLT section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:64,allocate,allocates,64,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// The width of the type must be a power of 2 and greater than 8-bits.; // Otherwise the load cannot be represented in LLVM IR.; // Moreover, if we shifted with a non-8-bits multiple, the slice; // will be across several bytes. We do not support that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,power,power,35,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,// Then obtain the scheduling class information from the instruction.; // Allow InstrumentManager to override and use a different SchedClassID,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:19,schedul,scheduling,19,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Then re-insert them according to the given schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:46,schedul,schedule,46,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// There are 4 additional tail-allocated arrays at the end of the class:; // 1. Contains list of pseudo variables with the default initialization for; // each non-firstprivate variables. Used in codegen for initialization of; // lastprivate copies.; // 2. List of helper expressions for proper generation of assignment operation; // required for lastprivate clause. This list represents private variables; // (for arrays, single array element).; // 3. List of helper expressions for proper generation of assignment operation; // required for lastprivate clause. This list represents original variables; // (for arrays, single array element).; // 4. List of helper expressions that represents assignment operation:; // \code; // DstExprs = SrcExprs;; // \endcode; // Required for proper codegen of final assignment performed by the; // lastprivate clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:31,allocate,allocated,31,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['allocate'],['allocated']
Energy Efficiency,"// There are four ways to lower s_mul_u64:; //; // 1. If all the operands are uniform, then we lower it as it is.; //; // 2. If the operands are divergent, then we have to split s_mul_u64 in 32-bit; // multiplications because there is not a vector equivalent of s_mul_u64.; //; // 3. If the cost model decides that it is more efficient to use vector; // registers, then we have to split s_mul_u64 in 32-bit multiplications.; // This happens in splitScalarSMULU64() in SIInstrInfo.cpp .; //; // 4. If the cost model decides to use vector registers and both of the; // operands are zero-extended/sign-extended from 32-bits, then we split the; // s_mul_u64 in two 32-bit multiplications. The problem is that it is not; // possible to check if the operands are zero-extended or sign-extended in; // SIInstrInfo.cpp. For this reason, here, we replace s_mul_u64 with; // s_mul_u64_u32_pseudo if both operands are zero-extended and we replace; // s_mul_u64 with s_mul_i64_i32_pseudo if both operands are sign-extended.; // If the cost model decides that we have to use vector registers, then; // splitScalarSMulPseudo() (in SIInstrInfo.cpp) split s_mul_u64_u32/; // s_mul_i64_i32_pseudo in two vector multiplications. If the cost model; // decides that we should use scalar registers, then s_mul_u64_u32_pseudo/; // s_mul_i64_i32_pseudo is lowered as s_mul_u64 in expandPostRAPseudo() in; // SIInstrInfo.cpp .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:326,efficient,efficient,326,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// There are multiple solutions if we are comparing against -1 and the LHS; // of the ashr is not a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:100,power,power,100,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,"// There are some benefits to schedule the ADDI as early as possible post ra; // to avoid stalled by vector instructions which take up all the hw units.; // And ADDI is usually used to post inc the loop indvar, which matters the; // performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:30,schedul,schedule,30,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// There are some benefits to schedule the ADDI before the load to hide the; // latency, as RA may create a true dependency between the load and addi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:30,schedul,schedule,30,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,// There are thre cases of division and remainder: Dividing with a register; // needs a divide instruction. A divisor which is a power of two constant; // can be implemented with a sequence of shifts. Any other constant needs a; // multiply and shifts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:129,power,power,129,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['power'],['power']
Energy Efficiency,"// There are two types of string tables that can exist, dynamic and not dynamic.; // In the dynamic case the string table is allocated. Changing a dynamic string; // table would mean altering virtual addresses and thus the memory image. So; // dynamic string tables should not have an interface to modify them or; // reconstruct them. This type lets us reconstruct a string table. To avoid; // this class being used for dynamic string tables (which has happened) the; // classof method checks that the particular instance is not allocated. This; // then agrees with the makeSection method used to construct most sections.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h:125,allocate,allocated,125,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h,2,['allocate'],['allocated']
Energy Efficiency,"// There aren't really 64-bit registers, but pairs of 32-bit ones and only a; // limited number of native 64-bit operations. Shrinking an operation to fit; // in a single 32-bit register should always be helpful. As currently used,; // this is much less general than the name suggests, and is only used in; // places trying to reduce the sizes of loads. Shrinking loads to < 32-bits is; // not profitable, and may actually be harmful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:327,reduce,reduce,327,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// There can be awkward padding in after a non-power of two vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:47,power,power,47,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['power'],['power']
Energy Efficiency,"// There is a token to return.; // It is common for the tokens immediately after a // comment to be; // whitespace (indentation for the next line). Instead of going through; // the big switch, handle it efficiently now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:203,efficient,efficiently,203,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// There is an external 'errno' variable.; // Use its memory region.; // The memory region for an 'errno'-like variable is allocated in system; // space by MemRegionManager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:123,allocate,allocated,123,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// There is no export clause, we can schedule one as soon as its ready",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp:37,schedul,schedule,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// There is one case where CALLSEQ_START..CALLSEQ_END can be nested, which; // is during the lowering of a call with a byval argument which produces; // a call to memcpy. For the O32 case, this causes the caller to allocate; // stack space for the reserved argument area for the callee, then recursively; // again for the memcpy call. In the NEWABI case, this doesn't occur as those; // ABIs mandate that the callee allocates the reserved argument area. We do; // still produce nested CALLSEQ_START..CALLSEQ_END with zero space though.; //; // If the callee has a byval argument and memcpy is used, we are mandated; // to already have produced a reserved argument area for the callee for O32.; // Therefore, the reserved argument area can be reused for both calls.; //; // Other cases of calling memcpy cannot have a chain with a CALLSEQ_START; // present, as we have yet to hook that node onto the chain.; //; // Hence, the CALLSEQ_START and CALLSEQ_END nodes can be eliminated in this; // case. GCC does a similar trick, in that wherever possible, it calculates; // the maximum out going argument area (including the reserved area), and; // preallocates the stack space on entrance to the caller.; //; // FIXME: We should do the same for efficiency and space.; // Note: The check on the calling convention below must match; // MipsABIInfo::GetCalleeAllocdArgSizeInBytes().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:215,allocate,allocate,215,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,2,['allocate'],"['allocate', 'allocates']"
Energy Efficiency,"// There is several possibilities to distinguish:; // 1) Reg is not input to any instruction in the block, but is output of one; // 2) 1) + read in the block and not needed after it; // 3) 1) + read in the block but needed in another block; // 4) Reg is input of an instruction but another block will read it too; // 5) Reg is input of an instruction and then rewritten in the block.; // result is not read in the block (implies used in another block); // 6) Reg is input of an instruction and then rewritten in the block.; // result is read in the block and not needed in another block; // 7) Reg is input of an instruction and then rewritten in the block.; // result is read in the block but also needed in another block; // LiveInRegs will contains all the regs in situation 4, 5, 6, 7; // We want LiveOutRegs to contain only Regs whose content will be read after; // in another block, and whose content was written in the current block,; // that is we want it to get 1, 3, 5, 7; // Since we made the MIs of a block to be packed all together before; // scheduling, then the LiveIntervals were correct, and the RPTracker was; // able to correctly handle 5 vs 6, 2 vs 3.; // (Note: This is not sufficient for RPTracker to not do mistakes for case 4); // The RPTracker's LiveOutRegs has 1, 3, (some correct or incorrect)4, 5, 7; // Comparing to LiveInRegs is not sufficient to differentiate 4 vs 5, 7; // The use of findDefBetween removes the case 4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:1056,schedul,scheduling,1056,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// There is some ambiguity in what initializer should be used, if the; // descriptor's subexpression is non-trivial: it can be the entire; // subexpression (which is what has been done so far), or it can be; // the extender's value itself, if all corresponding extenders have the; // exact value of the initializer (i.e. require offset of 0).; // To reduce the number of initializers, merge such special cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:350,reduce,reduce,350,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,1,['reduce'],['reduce']
Energy Efficiency,// There may be no physical register assigned if only some register; // classes were already allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:93,allocate,allocated,93,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// These alignment values are specified in powers of two, so alignment =; // 2^n. The minimum alignment is 2^4 = 16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp:43,power,powers,43,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,1,['power'],['powers']
Energy Efficiency,// These are patterns matched by the PowerPC to reassociate FMA and FSUB to; // reduce register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:37,Power,PowerPC,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,2,"['Power', 'reduce']","['PowerPC', 'reduce']"
Energy Efficiency,// These are patterns matched by the PowerPC to reassociate FMA chains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:37,Power,PowerPC,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,1,['Power'],['PowerPC']
Energy Efficiency,// These are patterns used to reduce the length of dependence chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:30,reduce,reduce,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,1,['reduce'],['reduce']
Energy Efficiency,// These are somewhat magic numbers justified by comparing the; // output of llvm-mca for our various supported scheduler models; // and basing it off the worst case scenario.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:112,schedul,scheduler,112,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// These functions are considered entrypoints into the current module, i.e. they; // are allowed to be called from outside the current module. This is different; // from isEntryFunctionCC, which is only true for functions that are entered by; // the hardware. Module entry points include all entry functions but also; // include functions that can be called from other functions inside or outside; // the current module. Module entry functions are allowed to allocate LDS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:459,allocate,allocate,459,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['allocate'],['allocate']
Energy Efficiency,"// These functions reduces the possible job states to the subset given above; // in EGridJobStatus, for detailed status information query the specific; // implementation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TGridJobStatus.h:19,reduce,reduces,19,net/net/inc/TGridJobStatus.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TGridJobStatus.h,1,['reduce'],['reduces']
Energy Efficiency,"// These methods allow access to the raw bitset underlying; // this object, breaking type safety. They are necessary for; // efficient interaction with TTree / TBranch / TBasket, but left; // private to prevent users from interacting with the raw bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx:125,efficient,efficient,125,tree/tree/inc/ROOT/TIOFeatures.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx,1,['efficient'],['efficient']
Energy Efficiency,"// These nodes match the semantics of the corresponding RVV vector reduction; // instructions. They produce a vector result which is the reduction; // performed over the second vector operand plus the first element of the; // third vector operand. The first operand is the pass-thru operand. The; // second operand is an unconstrained vector type, and the result, first, and; // third operand's types are expected to be the corresponding full-width; // LMUL=1 type for the second operand:; // nxv8i8 = vecreduce_add nxv8i8, nxv32i8, nxv8i8; // nxv2i32 = vecreduce_add nxv2i32, nxv8i32, nxv2i32; // The different in types does introduce extra vsetvli instructions but; // similarly it reduces the number of registers consumed per reduction.; // Also has a mask and VL operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:684,reduce,reduces,684,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['reduce'],['reduces']
Energy Efficiency,// These operations with a uniform value i.e. SGPR are idempotent.; // Reduced value will be same as given sgpr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:71,Reduce,Reduced,71,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Reduce'],['Reduced']
Energy Efficiency,// These platforms may prefer less; // inlining to reduce binary size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:51,reduce,reduce,51,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,// These values are set when the size of the schedule window is limited; // due to chain dependences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:45,schedul,schedule,45,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// They are power-of-two, so which bit is set?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:12,power,power-of-two,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// They must be created in power-of-2 autobin mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:27,power,power-of-,27,hist/hist/src/TH1Merger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx,1,['power'],['power-of-']
Energy Efficiency,// This allows the latency-based scheduler to notice high latency instructions; // without a target itinerary. The choice of number here has more to do with; // balancing scheduler heuristics than with the actual machine latency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:33,schedul,scheduler,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,2,['schedul'],['scheduler']
Energy Efficiency,"// This array is used as a medium to transfer, one reduce element at a time,; // the data from the first lane of every warp to lanes in the first warp; // in order to perform the final step of a reduction in a parallel region; // (reduction across warps). The array is placed in NVPTX __shared__ memory; // for reduced latency, as well as to have a distinct copy for concurrently; // executing target regions. The array is declared with common linkage so; // as to be shared across compilation units.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:51,reduce,reduce,51,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,// This attribute requires an integer argument which is a constant power of; // two between 1 and 4096 inclusive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:67,power,power,67,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,1,['power'],['power']
Energy Efficiency,"// This block handles the swap of a small and a non-owning vector; // It is more efficient to first move the non-owning vector, hence the 2 cases",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:81,efficient,efficient,81,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['efficient'],['efficient']
Energy Efficiency,"// This can happen if the declaration is merely mergeable and not; // actually redeclarable (we looked for redeclarations earlier).; //; // FIXME: We should be able to detect this more efficiently, without; // pulling in all of the members of CanonDef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:185,efficient,efficiently,185,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// This class contains all the info necessary for running the provided; // interesting-ness test, as well as the most reduced module and its; // respective filename.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/TestRunner.h:118,reduce,reduced,118,interpreter/llvm-project/llvm/tools/llvm-reduce/TestRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/TestRunner.h,1,['reduce'],['reduced']
Energy Efficiency,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:22,Schedul,ScheduleDAGInstrs,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,2,"['Schedul', 'schedul']","['ScheduleDAGInstrs', 'schedule']"
Energy Efficiency,"// This code deals with branches which hold C arrays of variable size. It can happen that the buffers; // associated to those is re-allocated. As a result the value of the pointer can change therewith; // leaving associated to the branch of the output tree an invalid pointer.; // With this code, we set the value of the pointer in the output branch anew when needed.; // Nota bene: the extra "",0"" after the invocation of SetAddress, is because that method returns void and; // we need an int for the expander list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:132,allocate,allocated,132,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,2,['allocate'],['allocated']
Energy Efficiency,"// This copy is a liveout value. It is likely coalesced, so reduce the; // latency so not to penalize the def.; // FIXME: need target specific adjustment here?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:60,reduce,reduce,60,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['reduce'],['reduce']
Energy Efficiency,// This could be made more efficient; I'm going for obviously correct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:27,efficient,efficient,27,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['efficient'],['efficient']
Energy Efficiency,// This does not need to be efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:28,efficient,efficient,28,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,2,['efficient'],['efficient']
Energy Efficiency,"// This end message was for the saved monitor; // Deactivate it if we are done with it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:38,monitor,monitor,38,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// This function can be performance-critical, so we rely on the power-of-2; // knowledge that we have about the mask sizes to replace div/rem ops with; // bit-masks and shifts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:64,power,power-of-,64,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// This function converts loops with t2LoopEnd and t2LoopEnd instructions into; // a single t2LoopEndDec instruction. To do that it needs to make sure that LR; // will be valid to be used for the low overhead loop, which means nothing else; // is using LR (especially calls) and there are no superfluous copies in the; // loop. The t2LoopEndDec is a branching terminator that produces a value (the; // decrement) around the loop edge, which means we need to be careful that they; // will be valid to allocate without any spilling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:500,allocate,allocate,500,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// This function does not list all associative and commutative operations, but; // only those worth feeding through the machine combiner in an attempt to; // reduce the critical path. Mostly, this means floating-point operations,; // because they have high latencies(>=5) (compared to other operations, such as; // and/or, which are also associative and commutative, but have low latencies).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:158,reduce,reduce,158,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// This function is copied and adapted from NamedDecl::printQualifiedName(); // By matching each part individually we optimize in a couple of ways:; // - We can exit early on the first failure.; // - We can skip inline/anonymous namespaces without another pass.; // - We print one name at a time, reducing the chance of overflowing the; // inlined space of the SmallString.; // First, match the name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:31,adapt,adapted,31,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// This function is used for scheduling, and the nop wanted here is the type; // that terminates dispatch groups on the POWER cores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:29,schedul,scheduling,29,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,"['POWER', 'schedul']","['POWER', 'scheduling']"
Energy Efficiency,// This has already been allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp:25,allocate,allocated,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// This implements a set of registers that serves as a filter: can filter other; // sets by passing through elements not in the filter and blocking those that; // are. Any filter implicitly includes the full set of physical registers upon; // creation, thus filtering them all out. The filter itself as a set only grows,; // and needs to be as efficient as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:344,efficient,efficient,344,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['efficient'],['efficient']
Energy Efficiency,// This increases the cost associated with multiplication and division; // to 64 times what the baseline arithmetic cost is. The arithmetic; // instruction cost was arbitrarily chosen to reduce the desirability; // of emitting arithmetic instructions that are emulated in software.; // TODO: Investigate the performance impact given specialized lowerings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h:187,reduce,reduce,187,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiTargetTransformInfo.h,1,['reduce'],['reduce']
Energy Efficiency,"// This input window is used to make the dragging smoother when using; // highly complicated shaped windows (like labels and semitransparent; // icons), for some obscure reason most of the motion events get lost; // while the pointer is over the shaped window.; //fInput = gVirtualX->CreateWindow(fParent->GetId(), 0, 0, fWidth,; // fHeight, 0, 0, 0, 0, &wattr, 0);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx:355,watt,wattr,355,gui/gui/src/TGDNDManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx,1,['watt'],['wattr']
Energy Efficiency,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:411,efficient,efficiently,411,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// This is a physical register dependency and it's impossible or; // expensive to copy the register. Make sure nothing that can; // clobber the register is scheduled between the predecessor and; // this node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:156,schedul,scheduled,156,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['schedul'],['scheduled']
Energy Efficiency,// This is a private struct used by `User` to track the co-allocated descriptor; // section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp:59,allocate,allocated,59,interpreter/llvm-project/llvm/lib/IR/User.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/User.cpp,1,['allocate'],['allocated']
Energy Efficiency,// This is a similar pattern used for checking if a value is a power-of-2:; // (A - 1) & A --> 0 (if A is a power-of-2 or 0),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:63,power,power-of-,63,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['power'],['power-of-']
Energy Efficiency,"// This is already a power of 2, but we still need to split this in half.; //; // Assume we're being asked to decompose an unaligned load.; // TODO: If this requires multiple splits, handle them all at once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:21,power,power,21,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['power'],['power']
Energy Efficiency,"// This is essentially a reduced version of hasFP for entry functions. Since the; // stack pointer is known 0 on entry to kernels, we never really need an FP; // register. We may need to initialize the stack pointer depending on the frame; // properties, which logically overlaps many of the cases where an ordinary; // function would require an FP.; // Also used for chain functions. While not technically entry functions, chain; // functions may need to set up a stack pointer in some situations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:25,reduce,reduced,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// This is only used by the isel schedulers, and is needed only to prevent; // compiler from crashing when list-ilp is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:33,schedul,schedulers,33,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['schedul'],['schedulers']
Energy Efficiency,// This is permitted only within a call to std::allocator<T>::allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:62,allocate,allocate,62,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocate']
Energy Efficiency,// This is potentially target specific. We've chosen the largest type; // because G_TRUNC is usually free. One potential catch with this is that; // some targets have a reduced number of larger registers than smaller; // registers and this choice potentially increases the live-range for the; // larger value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:169,reduce,reduced,169,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['reduce'],['reduced']
Energy Efficiency,// This is really weird but for some magic scheduling regions twice; // gives performance improvement,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:43,schedul,scheduling,43,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// This is the amount of stack a funclet needs to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:50,allocate,allocate,50,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,2,['allocate'],['allocate']
Energy Efficiency,// This is the case that the vector is power of two so was evenly split.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:39,power,power,39,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// This is the index of the first element of the VectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:109,power,power,109,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// This is the index of the first element of the vectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:109,power,power,109,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['power'],['power']
Energy Efficiency,// This is the limit of processor resource usage at which the; // scheduler should try to look for other instructions (not using the; // critical resource).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:66,schedul,scheduler,66,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// This is the marker algorithm from ""Simple and Efficient Construction of; // Static Single Assignment Form""; // The simple, non-marker algorithm places phi nodes at any join; // Here, we place markers, and only place phi nodes if they end up necessary.; // They are only necessary if they break a cycle (IE we recursively visit; // ourselves again), or we discover, while getting the value of the operands,; // that there are two or more definitions needing to be merged.; // This still will leave non-minimal form in the case of irreducible control; // flow, where phi nodes may be in cycles with themselves, but unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:49,Efficient,Efficient,49,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['Efficient'],['Efficient']
Energy Efficiency,"// This is the maximum instruction encoded size for gfx10. With a known; // subtarget, it can be reduced to 8 bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUMCAsmInfo.cpp:97,reduce,reduced,97,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUMCAsmInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUMCAsmInfo.cpp,1,['reduce'],['reduced']
Energy Efficiency,// This is the native endianness case that is most common and optimized for; // efficient lookups. Here we just grab pointers to the native data and; // use ArrayRef objects to allow efficient read only access.; // Read the address offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp:80,efficient,efficient,80,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,2,['efficient'],['efficient']
Energy Efficiency,// This is the non native endianness case that is not common and not; // optimized for lookups. Here we decode the important tables into local; // storage and then set the ArrayRef objects to point to these swapped; // copies of the read only data so lookups can be as efficient as possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp:269,efficient,efficient,269,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// This is the number of extra spills inserted for callee-save GPRs which; // would not otherwise be used by the function. When greater than zero it; // guaranteees that it is possible to scavenge a register to hold the; // address of a stack slot. On Thumb1, the register must be a valid operand; // to tSTRi, i.e. r4-r7. For other subtargets, this is any GPR, i.e. r4-r11; // or lr.; //; // If we don't insert a spill, we instead allocate an emergency spill; // slot, which can be used by scavenging to spill an arbitrary register.; //; // We currently don't try to figure out whether any specific instruction; // requires scavening an additional register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:432,allocate,allocate,432,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// This is the only case where we need to produce an extension warning:; // the only other way we can succeed is if we find a dynamic allocation,; // and we will have warned when we allocated it in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:182,allocate,allocated,182,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocated']
Energy Efficiency,// This is the stage for the scheduled instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:29,schedul,scheduled,29,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// This is the start of an vector that was scalarized into an unknown number; // of components. It doesn't matter how many there are. Allocate one of the; // notional 8 byte aligned registers which map onto the argument stack, and; // shadow the register lost to alignment requirements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:134,Allocate,Allocate,134,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,// This is the value in the atomic operation we need to combine in order to; // reduce the number of atomic operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:80,reduce,reduce,80,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// This isn't particularly efficient, but is only for error-recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:27,efficient,efficient,27,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// This limits the maximum size of an RVec<char> to ~4GB but we don't expect this to ever be a problem,; // and we prefer the smaller Size_T to reduce the size of each RVec object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:144,reduce,reduce,144,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['reduce'],['reduce']
Energy Efficiency,// This load needs splitting into power of 2 sized loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:34,power,power,34,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['power'],['power']
Energy Efficiency,"// This load needs splitting into power of 2 sized loads.; //; // Our strategy here is to generate anyextending loads for the smaller; // types up to next power-2 result type, and then combine the two larger; // result values together, before truncating back down to the non-pow-2; // type.; // E.g. v1 = i24 load =>; // v2 = i32 zextload (2 byte); // v3 = i32 load (1 byte); // v4 = i32 shl v3, 16; // v5 = i32 or v4, v2; // v1 = i24 trunc v5; // By doing this we generate the correct truncate which should get; // combined away as an artifact with a matching extend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:34,power,power,34,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,['power'],"['power', 'power-']"
Energy Efficiency,"// This loop iterates through the list of reduce elements and copies,; // element by element, from a remote lane in the warp to RemoteReduceList,; // hosted on the thread's stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:42,reduce,reduce,42,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// This macro helps reduce the amount of indirection done through Optional; // below, since the usual case upon returning a std::nullopt Optional is to; // return std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/MarkupFilter.cpp:20,reduce,reduce,20,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/MarkupFilter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/MarkupFilter.cpp,1,['reduce'],['reduce']
Energy Efficiency,// This manager is powered by the TokenBuffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h:19,power,powered,19,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h,1,['power'],['powered']
Energy Efficiency,"// This memory allocator is extremely fast, but it doesn't call dtors; // for allocated objects. That means you can't use STL containers; // (such as std::vector) with this allocator. But it pays off --; // the demangler is 3x faster with this allocator compared to one with; // STL containers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangle.h:78,allocate,allocated,78,interpreter/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangle.h,1,['allocate'],['allocated']
Energy Efficiency,"// This message was for the base monitor in recursive case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:33,monitor,monitor,33,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// This method attempts to fold trees of add(ext(load p), shl(ext(load p+4)); // into a single load of twice the size, that we extract the bottom part and top; // part so that the shl can use a shll2 instruction. The two loads in that; // example can also be larger trees of instructions, which are identical except; // for the leaves which are all loads offset from the LHS, including; // buildvectors of multiple loads. For example the RHS tree could be; // sub(zext(buildvec(load p+4, load q+4)), zext(buildvec(load r+4, load s+4))); // Whilst it can be common for the larger loads to replace LDP instructions; // (which doesn't gain anything on it's own), the larger loads can help create; // more efficient code, and in buildvectors prevent the need for ld1 lane; // inserts which can be slower than normal loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:702,efficient,efficient,702,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// This method updates the register mappings inserting a new register; // definition. This method is also responsible for updating the number of; // allocated physical registers in each register file modified by the write.; // No physical regiser is allocated if this write is from a zero-idiom.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h:149,allocate,allocated,149,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,2,['allocate'],['allocated']
Energy Efficiency,// This must be a power-of-2 type for a bitmasking transform to be valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:18,power,power-of-,18,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['power'],['power-of-']
Energy Efficiency,// This only depends on powers of 2 because we use bit tricks to figure out; // the bit offset we need to shift to get the target element. A general; // expansion could emit division/multiply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:24,power,powers,24,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,['power'],['powers']
Energy Efficiency,"// This only works for powers of 2, fallback to shifts if it fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:23,power,powers,23,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['power'],['powers']
Energy Efficiency,"// This op may have been separated from it's ADRP companion by the localizer; // or some other code motion pass. Given that many CPUs will try to; // macro fuse these operations anyway, select this into a MOVaddr pseudo; // which will later be expanded into an ADRP+ADD pair after scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:281,schedul,scheduling,281,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// This optimisation attempts to reduce the number of overlapping lifetimes of; // VCCR values by replacing uses of old VCCR values with VPNOTs. For example,; // this replaces; // %A:vccr = (something); // %B:vccr = VPNOT %A; // %Foo = (some op that uses %B); // %Bar = (some op that uses %A); // With; // %A:vccr = (something); // %B:vccr = VPNOT %A; // %Foo = (some op that uses %B); // %TMP2:vccr = VPNOT %B; // %Bar = (some op that uses %A)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:33,reduce,reduce,33,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// This pass converts a legalized DAG into a LoongArch-specific DAG, ready; // for instruction scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:95,schedul,scheduling,95,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// This pass converts a legalized DAG into a RISCV-specific DAG, ready; // for instruction scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:91,schedul,scheduling,91,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// This pass hoists common computations across branches sharing common; // dominator. The primary goal is to reduce the code size, and in some; // cases reduce critical path (by exposing more ILP).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:109,reduce,reduce,109,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,2,['reduce'],['reduce']
Energy Efficiency,// This register class doesn't allocate k0 for masked vector operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:31,allocate,allocate,31,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// This routine performs a basic correctness check. This routine should only; // be called when we know that 'IR' is not in the scheduler's instruction; // queues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:128,schedul,scheduler,128,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,"// This schedule is only representable if ProducerStage == ConsumerStage+1.; // In addition, Consumer's cycle must be scheduled after Producer in the; // rescheduled loop. This is enforced by the pipeliner's ASAP and ALAP; // functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:8,schedul,schedule,8,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"// This scheduler implements a different scheduling algorithm than; // GenericScheduler.; //; // There are several specific architecture behaviours that can't be modelled; // for GenericScheduler:; // . When accessing the result of an SGPR load instruction, you have to wait; // for all the SGPR load instructions before your current instruction to; // have finished.; // . When accessing the result of an VGPR load instruction, you have to wait; // for all the VGPR load instructions previous to the VGPR load instruction; // you are interested in to finish.; // . The less the register pressure, the best load latencies are hidden; //; // Moreover some specifities (like the fact a lot of instructions in the shader; // have few dependencies) makes the generic scheduler have some unpredictable; // behaviours. For example when register pressure becomes high, it can either; // manage to prevent register pressure from going too high, or it can; // increase register pressure even more than if it hadn't taken register; // pressure into account.; //; // Also some other bad behaviours are generated, like loading at the beginning; // of the shader a constant in VGPR you won't need until the end of the shader.; //; // The scheduling problem for SI can distinguish three main parts:; // . Hiding high latencies (texture sampling, etc); // . Hiding low latencies (SGPR constant loading, etc); // . Keeping register usage low for better latency hiding and general; // performance; //; // Some other things can also affect performance, but are hard to predict; // (cache usage, the fact the HW can issue several instructions from different; // wavefronts if different types, etc); //; // This scheduler tries to solve the scheduling problem by dividing it into; // simpler sub-problems. It divides the instructions into blocks, schedules; // locally inside the blocks where it takes care of low latencies, and then; // chooses the order of the blocks by taking care of high latencies.; // Dividing the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:8,schedul,scheduler,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,3,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,// This scope can be safely ignored and eliminating it will reduce the; // size of the debug information. Be sure to collect any variable and scope; // information from the this scope or any of its children and collapse them; // into the parent scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:60,reduce,reduce,60,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// This stage works under the assumption that the Pipeline will eventually; // execute a retire stage. We don't need to check if pipelines and/or; // schedulers have instructions to process, because those instructions are; // also tracked by the retire control unit. That means,; // RetireControlUnit::hasWorkToComplete() is responsible for checking if there; // are still instructions in-flight in the out-of-order backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/ExecuteStage.h:150,schedul,schedulers,150,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/ExecuteStage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/ExecuteStage.h,1,['schedul'],['schedulers']
Energy Efficiency,"// This still will detect consecutive loads, but we might have ""holes""; // in some cases. It is ok for non-power-2 vectorization and may produce; // better results. It should not affect current vectorization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:107,power,power-,107,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['power'],['power-']
Energy Efficiency,// This table must be sorted by WideOpc as a main criterion and; // ReduceType as a sub-criterion (when wide opcodes are the same).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:68,Reduce,ReduceType,68,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['Reduce'],['ReduceType']
Energy Efficiency,"// This test will crash if the cached normalization sets are not reset; // correctly after servers are redirected. This is a reduced version of a code; // provided in the ROOT forum that originally unveiled this problem:; // https://root-forum.cern.ch/t/problems-with-2d-simultaneous-fit/48249/4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx:125,reduce,reduced,125,roofit/roofitcore/test/testRooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx,1,['reduce'],['reduced']
Energy Efficiency,// This transform would reduce the quality of msan diagnostics.; // Disable this transform under MemorySanitizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:24,reduce,reduce,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// This type is used to propagate information about the owner of a register,; // and the cost of allocating it in the PRF. Register cost is defined as the; // number of physical registers consumed by the PRF to allocate a user; // register.; //; // For example: on X86 BtVer2, a YMM register consumes 2 128-bit physical; // registers. So, the cost of allocating a YMM register in BtVer2 is 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h:211,allocate,allocate,211,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,1,['allocate'],['allocate']
Energy Efficiency,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:54,reduce,reduce,54,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['reduce'],['reduce']
Energy Efficiency,// This will be allocated by the last member of the aggregate,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp:16,allocate,allocated,16,interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallingConv.cpp,1,['allocate'],['allocated']
Energy Efficiency,// This will hold the smallest this offset among overridees of MD.; // This implies that an offset of a non-virtual base will dominate an offset; // of a virtual base to potentially reduce the number of thunks required; // in the derived classes that inherit this method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:182,reduce,reduce,182,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,1,['reduce'],['reduce']
Energy Efficiency,// This will reset the GlobalResolutions optional once done with it to; // reduce peak memory before importing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:75,reduce,reduce,75,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Though the reachability checks above could be made more generic,; // perhaps as part of ScheduleDAGInstrs::addEdge(), since such edges are valid,; // the extra computation cost makes it less interesting in general cases.; // Create a single weak edge between the adjacent instrs. The only effect is; // to cause bottom-up scheduling to heavily prioritize the clustered instrs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:91,Schedul,ScheduleDAGInstrs,91,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,2,"['Schedul', 'schedul']","['ScheduleDAGInstrs', 'scheduling']"
Energy Efficiency,// Thread local Reduce list used to host the values of data to be reduced.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:16,Reduce,Reduce,16,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,2,"['Reduce', 'reduce']","['Reduce', 'reduced']"
Energy Efficiency,// ThreadCopy: Make a copy of a Reduce list on the thread's stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:32,Reduce,Reduce,32,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// Thumb1 cores will generally not benefit from post-ra scheduling,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:56,schedul,scheduling,56,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Tie breaker.; // To avoid scheduling indeterminism, we need a tie breaker; // for the case when cost is identical for two nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:29,schedul,scheduling,29,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Tighten the stat. errors of the model, and kick bin 0, so the gammas have to adapt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx:80,adapt,adapt,80,roofit/histfactory/test/testHistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testHistFactory.cxx,1,['adapt'],['adapt']
Energy Efficiency,"// Tiny core has a single thread, so back-to-back scheduling is enabled by; // default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:50,schedul,scheduling,50,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// To bring the Physical VGPRs in the highest range allocated for CSR SGPR; // spilling into the lowest available range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h:52,allocate,allocated,52,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"// To determine what the conversion from the result of calling the; // conversion function to the type we're eventually trying to; // convert to (ToType), we need to synthesize a call to the; // conversion function and attempt copy initialization from it. This; // makes sure that we get the right semantics with respect to; // lvalues/rvalues and the type. Fortunately, we can allocate this; // call on the stack and we don't need its arguments to be; // well-formed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:378,allocate,allocate,378,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['allocate'],['allocate']
Energy Efficiency,// To emit type record using Codeview MCStreamer adapter,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:49,adapt,adapter,49,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['adapt'],['adapter']
Energy Efficiency,"// To match the canonical windows frame layout, reverse the list of; // callee saved registers to get them laid out by PrologEpilogInserter; // in the right order. (PrologEpilogInserter allocates stack objects top; // down. Windows canonical prologs store higher numbered registers at; // the top, thus have the CSI array start from the highest registers.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:186,allocate,allocates,186,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// To minimize code size in Thumb2, we prefer the usage of low regs (lower; // cost per use) so we can use narrow encoding. By default, caller-saved; // registers (e.g. lr, r12) are always allocated first, regardless of; // their cost per use. When optForMinSize, we prefer the low regs even if; // they are CSR because usually push/pop can be folded into existing ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp:189,allocate,allocated,189,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// To reduce code size, we compactify common instructions into a few bits; // in the opcode-indexed table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp:6,reduce,reduce,6,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// To reduce compilation time, we check MRI->hasOneNonDBGUser when inserting; // loads. It should be checked when processing uses of the load, since; // uses can be removed during peephole.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:6,reduce,reduce,6,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,// To reduce generated source code size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherEmitter.cpp:6,reduce,reduce,6,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherEmitter.cpp,1,['reduce'],['reduce']
Energy Efficiency,// To save space we do not create any separate string table.; // We use already allocated string patches and accelerator entries:; // enumerate them in natural order and assign offsets.; // ASSUMPTION: strings should be stored into .debug_str/.debug_line_str; // sections in the same order as they were assigned offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:80,allocate,allocated,80,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,1,['allocate'],['allocated']
Energy Efficiency,// To support EH funclets we allocate an UnwindHelp object,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:29,allocate,allocate,29,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// To support specializing recursive functions, it is important to propagate; // constant arguments because after a first iteration of specialisation, a; // reduced example may look like this:; //; // define internal void @RecursiveFn(i32* arg1) {; // %temp = alloca i32, align 4; // store i32 2 i32* %temp, align 4; // call void @RecursiveFn.1(i32* nonnull %temp); // ret void; // }; //; // Before a next iteration, we need to propagate the constant like so; // which allows further specialization in next iterations.; //; // @funcspec.arg = internal constant i32 2; //; // define internal void @someFunc(i32* arg1) {; // call void @otherFunc(i32* nonnull @funcspec.arg); // ret void; // }; //; // See if there are any new constant values for the callers of \p F via; // stack variables and promote them to global variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:157,reduce,reduced,157,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// To unify the loop exits, we need a list of the exiting blocks as; // well as exit blocks. The functions for locating these lists both; // traverse the entire loop body. It is more efficient to first; // locate the exiting blocks and then examine their successors to; // locate the exit blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp:183,efficient,efficient,183,interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// To use guards for proving predicates, we need to scan every instruction in; // relevant basic blocks, and not just terminators. Doing this is a waste of; // time if the IR does not actually contain any calls to; // @llvm.experimental.guard, so do a quick check and remember this beforehand.; //; // This pessimizes the case where a pass that preserves ScalarEvolution wants; // to _add_ guards to the module when there weren't any before, and wants; // ScalarEvolution to optimize based on those guards. For now we prefer to be; // efficient in lieu of being smart in that rather obscure case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:535,efficient,efficient,535,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Todo(1): The cmpxchg case is pretty costly so matching `BLSI(X)`, `X &; // -X` and some other provable power of 2 patterns that we can use CTZ on; // may be profitable.; // Todo(2): It may be possible in some cases to prove that Shl(C, X) is; // non-zero even where C != 1. Likewise LShr(C, X) and AShr(C, X) may also; // be provably a non-zero power of 2.; // Todo(3): ROTL and ROTR patterns on a power of 2 C should also be; // transformable to bittest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:106,power,power,106,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['power'],['power']
Energy Efficiency,"// TokenFactor operands are considered zero latency, and some schedulers; // (e.g. Top-Down list) may rely on the fact that operand latency is nonzero; // whenever node latency is nonzero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:62,schedul,schedulers,62,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['schedulers']
Energy Efficiency,// Top-Level entry points for the schedule() driver...; /// Apply each ScheduleDAGMutation step in order. This allows different; /// instances of ScheduleDAGMI to perform custom DAG postprocessing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:34,schedul,schedule,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,3,"['Schedul', 'schedul']","['ScheduleDAGMI', 'ScheduleDAGMutation', 'schedule']"
Energy Efficiency,"// Top-Level entry points for the schedule() driver...; /// Call ScheduleDAGInstrs::buildSchedGraph with register pressure tracking; /// enabled. This sets up three trackers. RPTracker will cover the entire DAG; /// region, TopTracker and BottomTracker will be initialized to the top and; /// bottom of the DAG region without covereing any unscheduled instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:34,schedul,schedule,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,"['Schedul', 'schedul']","['ScheduleDAGInstrs', 'schedule']"
Energy Efficiency,"// Torture Power complex - complex; //; // Important note on the following tests. The operation of raising a complex; // number to a power does not yet a single value, but rather an infinite; // number of values, particularly if the number is non rational.; // For a real number a, you can define a^(b+ic) by writing a = e^(ln a):; //; // b+ic (ln a)(b+ic) (b ln a) + i(c ln a); // a = e = e; //; // (b ln a); // = e ( cos (c ln a) + i sin (c ln a) ); //; // b; // = a ( cos (c ln a) + i sin (c ln a) ).; //; // Now, if a is a complex number instead of a real number, there is no; // single value to ""ln a"": there are lots of different complex numbers z; // for which e^z = a, and for any such complex number z, you could define; // a^(b+ic) to be e^(z(b+ic)) and use the above technique to calculate it.; //; // In fact, the same thing is true even when a is a real number. The; // expression a^(b+ic) has many possible values (infinite except when b; // and c are both rational numbers), because instead of doing the calculation; // writing a = e^(ln a), you could also do it by writing a = e^(ln a + 2pi i); // or by writing a = e^(ln a + 4 pi i), or a = e^(ln a + 6 pi i), and so on.; // Each of these equalities is true (in fact e^(2pi n i)=1 for integer n).; //; // When a is real it is more ""natural"" to use the ordinary real-valued; // logarithm ln a rather than than something like ln a + 2 pi i.; // Technically, this value is called the principal value. This is what; // the formula up above gives you. Unfortunately this alone does not; // guarantees that the inverse operation brings you back where you; // started from.; //; // When a is not real there is no one natural choice of logarithm to prefer; // over any other, so in those cases we have to say that an expression like; // a^(b+ic) has many different values.; //; // This is because in these tests we exclude from the error output the; // results where we ended up very far from the initial value, and the; // difference is more",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/ctorture.cxx:11,Power,Power,11,test/ctorture.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/ctorture.cxx,2,"['Power', 'power']","['Power', 'power']"
Energy Efficiency,"// Torture Power complex - real",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/ctorture.cxx:11,Power,Power,11,test/ctorture.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/ctorture.cxx,1,['Power'],['Power']
Energy Efficiency,"// Torture Power real - complex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/ctorture.cxx:11,Power,Power,11,test/ctorture.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/ctorture.cxx,1,['Power'],['Power']
Energy Efficiency,"// Total Energy loss by particles into the detector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h:9,Energy,Energy,9,test/RootShower/MyDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h,1,['Energy'],['Energy']
Energy Efficiency,"// Total Energy loss into the detector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyParticle.h:9,Energy,Energy,9,test/RootShower/MyParticle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyParticle.h,1,['Energy'],['Energy']
Energy Efficiency,"// Total allocated memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/inc/TStructNode.h:9,allocate,allocated,9,graf3d/gviz3d/inc/TStructNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/inc/TStructNode.h,1,['allocate'],['allocated']
Energy Efficiency,"// Total charge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbParticleList.h:9,charge,charge,9,test/periodic/NdbParticleList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbParticleList.h,1,['charge'],['charge']
Energy Efficiency,"// Touch the block then extend it. This is done on the opposite side of; // static probe where we allocate then touch, to avoid the need of probing the; // tail of the static alloca. Possible scenarios are:; //; // + ---- <- ------------ <- ------------- <- ------------ +; // | |; // [free probe] -> [page alloc] -> [alloc probe] -> [tail alloc] + -> [dyn probe] -> [page alloc] -> [dyn probe] -> [tail alloc] +; // | |; // + <- ----------- <- ------------ <- ----------- <- ------------ +; //; // The property we want to enforce is to never have more than [page alloc] between two probes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:98,allocate,allocate,98,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Track if the operand must be marked as used. If the operand is set to; // Score 1 explicitly (because of non power-of-2 unique scalars, we may; // want to reestimate the operands again on the following iterations).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:112,power,power-of-,112,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['power'],['power-of-']
Energy Efficiency,// Track memory allocated by alloca,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h:16,allocate,allocated,16,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Interpreter.h,1,['allocate'],['allocated']
Energy Efficiency,// Track register pressure so the scheduler can try to decrease; // pressure once register usage is above the threshold defined by; // SIRegisterInfo::getRegPressureSetLimit(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:34,schedul,scheduler,34,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Track the allocated value in the checker state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:13,allocate,allocated,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Track the high watermark on the worklist as it is only relevant for; // promoted allocas. We will reset it to this point if the alloca is not in; // fact scheduled for promotion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:157,schedul,scheduled,157,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Track the reduced values in case if they are replaced by extractelement; // because of the vectorization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,reduce,reduced,13,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Tracks the usage of a scheduler's queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:25,schedul,scheduler,25,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,1,['schedul'],['scheduler']
Energy Efficiency,// Transform (X & ~Y) == 0 --> (X & Y) != 0; // and (X & ~Y) != 0 --> (X & Y) == 0; // if A is a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,power,power,97,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,"// Transform IEEE Floats:; // (fmul C, (uitofp Pow2)); // -> (bitcast_to_FP (add (bitcast_to_INT C), Log2(Pow2) << mantissa)); // (fdiv C, (uitofp Pow2)); // -> (bitcast_to_FP (sub (bitcast_to_INT C), Log2(Pow2) << mantissa)); //; // The rationale is fmul/fdiv by a power of 2 is just change the exponent, so; // there is no need for more than an add/sub.; //; // This is valid under the following circumstances:; // 1) We are dealing with IEEE floats; // 2) C is normal; // 3) The fmul/fdiv add/sub will not go outside of min/max exponent bounds.; // TODO: Much of this could also be used for generating `ldexp` on targets the; // prefer it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:266,power,power,266,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,"// Transform all of the components into components similar to what the; // parser uses.; // FIXME: It would be slightly more efficient in the non-dependent case to; // just map FieldDecls, rather than requiring the rebuilder to look for; // the fields again. However, __builtin_offsetof is rare enough in; // template code that we don't care.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:125,efficient,efficient,125,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['efficient'],['efficient']
Energy Efficiency,// Transform managed variables to pointers to managed variables in device code.; // Each use of the original managed variable is replaced by a load from the; // transformed managed variable. The transformed managed variable contains; // the address of managed memory which will be allocated by the runtime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:281,allocate,allocated,281,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Transition should not contain processor indices already assigned to; // InstRWs in this scheduling class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp:91,schedul,scheduling,91,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Transverse energy squared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h:14,energy,energy,14,math/physics/inc/TLorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h,1,['energy'],['energy']
Energy Efficiency,"// Transverse energy w.r.t. given axis squared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h:14,energy,energy,14,math/physics/inc/TLorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h,1,['energy'],['energy']
Energy Efficiency,"// Transverse energy w.r.t. given axis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h:14,energy,energy,14,math/physics/inc/TLorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h,1,['energy'],['energy']
Energy Efficiency,"// Transverse energy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h:14,energy,energy,14,math/physics/inc/TLorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h,1,['energy'],['energy']
Energy Efficiency,"// Treat all globals in explicit sections as small, except for the standard; // large sections of .lbss, .ldata, .lrodata. This reduces the risk of linking; // together small and large sections, resulting in small references to large; // data sections. The code model attribute overrides this above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp:128,reduce,reduces,128,interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// Treat the start of the IT block as a scheduling boundary, but schedule; // t2IT along with all instructions following it.; // FIXME: This is a big hammer. But the alternative is to add all potential; // true and anti dependencies to IT block instructions as implicit operands; // to the t2IT instruction. The added compile time and complexity does not; // seem worth it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:40,schedul,scheduling,40,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// Tries to lower a BUILD_VECTOR composed of extract-extract chains that can be; // reasoned to be a permutation of a vector by indices in a non-constant vector.; // (build_vector (extract_elt V, (extract_elt I, 0)),; // (extract_elt V, (extract_elt I, 1)),; // ...; // ->; // (vpermv I, V); //; // TODO: Handle undefs; // TODO: Utilize pshufb and zero mask blending to support more efficient; // construction of vectors with constant-0 elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:383,efficient,efficient,383,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// True if arguments should be allocated at negative offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:31,allocate,allocated,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['allocate'],['allocated']
Energy Efficiency,// True if the previous pipeline Stage was unable to dispatch a full group of; // opcodes because scheduler buffers (or LS queues) were unavailable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:98,schedul,scheduler,98,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,"// True if the subtarget should run MachineScheduler after aggressive; // coalescing. This currently replaces the SelectionDAG scheduler with the; // ""source"" order scheduler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h:127,schedul,scheduler,127,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,2,['schedul'],['scheduler']
Energy Efficiency,"// True if this write has been eliminated at register renaming stage.; // Example: a register move doesn't consume scheduler/pipleline resources if; // it is eliminated at register renaming stage. It still consumes; // decode bandwidth, and ROB entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:115,schedul,scheduler,115,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['schedul'],['scheduler']
Energy Efficiency,// Truncate operations may prevent the merge of the SETCC instruction; // and the arithmetic instruction before it. Attempt to truncate the operands; // of the arithmetic instruction and use a reduced bit-width instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:193,reduce,reduced,193,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Truncate them to 1/2 the element size.; //; // This assumes the number of elements is a power of two; any vector that; // isn't should be widened, not split.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:91,power,power,91,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['power'],['power']
Energy Efficiency,// Truncates a RVV integer vector by one power-of-two. Carries both an extra; // mask and VL operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:41,power,power-of-two,41,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['power'],['power-of-two']
Energy Efficiency,// Try first to see if the Target has its own way of selecting a scheduler,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:65,schedul,scheduler,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Try schedule def + use closer when Sethi-Ullman numbers are the same.; // e.g.; // t1 = op t2, c1; // t3 = op t4, c2; //; // and the following instructions are both ready.; // t2 = op c3; // t4 = op c4; //; // Then schedule t2 = op first.; // i.e.; // t4 = op c4; // t2 = op c3; // t1 = op t2, c1; // t3 = op t4, c2; //; // This creates more short live intervals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:7,schedul,schedule,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,4,['schedul'],['schedule']
Energy Efficiency,"// Try to account for the following special case:; // 1. ScaleReg is an inductive variable;; // 2. We use it with non-zero offset;; // 3. IV's increment is available at the point of memory instruction.; //; // In this case, we may reuse the IV increment instead of the IV Phi to; // achieve the following advantages:; // 1. If IV step matches the offset, we will have no need in the offset;; // 2. Even if they don't match, we will reduce the overlap of living IV; // and IV increment, that will potentially lead to better register; // assignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:432,reduce,reduce,432,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Try to allocate a VGPR at the end of the argument list, or if no argument; // VGPRs are left allocating a stack slot.; // If \p Mask is is given it indicates bitfield position in the register.; // If \p Arg is given use it with new ]p Mask instead of allocating new.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:10,allocate,allocate,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// Try to allocate a contiguous block of registers, each of the correct; // size to hold one member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp:10,allocate,allocate,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CallingConvention.cpp,2,['allocate'],['allocate']
Energy Efficiency,// Try to allocate sufficient stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:10,allocate,allocate,10,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Try to compute scheduling information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:18,schedul,scheduling,18,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Try to convert a scalar binop with an extracted vector element to a vector; // binop. This is intended to reduce potentially expensive register moves.; // TODO: Check if both operands are extracted.; // TODO: How to prefer scalar/vector ops with multiple uses of the extact?; // TODO: Generalize this, so it can be called from visitINSERT_VECTOR_ELT().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:109,reduce,reduce,109,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Try to convert expressions of the form x < k ? k : x (and similar forms); // into more efficient bit operations, which is possible when k is 0 or -1; // On ARM and Thumb-2 which have flexible operand 2 this will result in; // single instructions. On Thumb the shift and the bit operation will be two; // instructions.; // Only allow this transformation on full-width (32-bit) operations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:90,efficient,efficient,90,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Try to convert x ** (1/4) and x ** (3/4) into square roots.; // x ** (1/2) is canonicalized to sqrt, so we do not bother with that case.; // TODO: This could be extended (using a target hook) to handle smaller; // power-of-2 fractional exponents.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:217,power,power-of-,217,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Try to eliminate a power-of-2 mask constant by converting to a signbit; // test in a narrow type that we can truncate to with no cost. Examples:; // (i32 X & 32768) == 0 --> (trunc X to i16) >= 0; // (i32 X & 32768) != 0 --> (trunc X to i16) < 0; // TODO: This conservatively checks for type legality on the source and; // destination types. That may inhibit optimizations, but it also; // allows setcc->shift transforms that may be more beneficial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:22,power,power-of-,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,// Try to fall back to the itinerary model if the scheduling model doesn't; // have a scheduling table. Note the default does not have a table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:50,schedul,scheduling,50,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,2,['schedul'],['scheduling']
Energy Efficiency,// Try to find a single predecessor that would be interesting for the; // scheduler in the top-most region of MBB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:74,schedul,scheduler,74,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Try to match 'zext (trunc A to iB) to iY', which is used; // for URem with constant power-of-2 second operands. Make sure the size of; // the operand A matches the size of the whole expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,power,power-of-,87,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['power'],['power-of-']
Energy Efficiency,// Try to reduce 32-bit instruction into 16-bit instruction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Try to reduce code,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Try to reduce index size from 64 bit (default for GEP); // to 32. It is essential for VF 16. If the index can't be reduced to 32, the; // operation will use 16 x 64 indices which do not fit in a zmm and needs; // to split. Also check that the base pointer is the same for all lanes,; // and that there's at most one variable index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"// Try to reduce the amount of global metadata (particularly debug info),; // by dropping global named metadata that anchors them",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Try to reduce the include name the same way we tried to include it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp:10,reduce,reduce,10,interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Try to reduce the pass list again. This covers additional cases; // we failed to reduce earlier, because of more complex pass dependencies; // triggering the crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,2,['reduce'],['reduce']
Energy Efficiency,// Try to reduce to tADDrSPi.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Try to reduce to the lo-reg only version first. Why there are two; // versions of the instruction is a mystery.; // It would be nice to just have two entries in the main table that; // are prioritized, but the table assumes a unique entry for each; // source insn opcode. So for now, we hack a local entry record to use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Try to regroup reduced values so that it gets more profitable to try to; // reduce them. Values are grouped by their value ids, instructions - by; // instruction op id and/or alternate op id, plus do extra analysis for; // loads (grouping them by the distabce between pointers) and cmp; // instructions (grouping them by the predicate).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,reduce,reduced,18,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"// Try to remove as much code from the loop header as possible,; // to reduce amount of IR that will have to be duplicated. However,; // do not perform speculative hoisting the first time as LICM; // will destroy metadata that may not need to be destroyed if run; // after loop rotation.; // TODO: Investigate promotion cap for O1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:71,reduce,reduce,71,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['reduce'],['reduce']
Energy Efficiency,// Try to replace current group with allocated one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h:37,allocate,allocated,37,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/ArrayList.h,1,['allocate'],['allocated']
Energy Efficiency,// Try to schedule SGPR initializations as early as possible in the MBB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp:10,schedul,schedule,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Try to schedule another instruction for the next 4 cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp:10,schedul,schedule,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Try to schedule uses near definitions to generate .cur.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:10,schedul,schedule,10,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Try to solve variant scheduling classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:24,schedul,scheduling,24,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,2,['schedul'],['scheduling']
Energy Efficiency,"// Try to squeeze into the single slot. If it won't fit, allocate a copied; // vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h:57,allocate,allocate,57,interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,1,['allocate'],['allocate']
Energy Efficiency,"// Try to take over the state from a single predecessor, if it has been; // scheduled. If this is not possible, we are done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:76,schedul,scheduled,76,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Try to transform:; // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.; // mul x, (2^N + 1) --> add (shl x, N), x; // mul x, (2^N - 1) --> sub (shl x, N), x; // Examples: x * 33 --> (x << 5) + x; // x * 15 --> (x << 4) - x; // x * -33 --> -((x << 5) + x); // x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4); // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.; // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M)); // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M)); // Examples: x * 0x8800 --> (x << 15) + (x << 11); // x * 0xf800 --> (x << 16) - (x << 11); // x * -0x8800 --> -((x << 15) + (x << 11)); // x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,power,power-of-,42,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,"['power', 'reduce']","['power-of-', 'reduces']"
Energy Efficiency,// Try to use a shuffle reduction for power of two vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:38,power,power,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power']
Energy Efficiency,// Try to use leading zeros of the dividend to reduce the multiplier and; // avoid expensive fixups.; // TODO: Support vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:47,reduce,reduce,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Try to widen vector elements until the element type is a power of two and; // promote it to a legal type later on, for example:; // <3 x i8> -> <4 x i8> -> <4 x i32>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:60,power,power,60,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['power'],['power']
Energy Efficiency,"// Try unmerging GEPs to reduce liveness interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:25,reduce,reduce,25,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Try unscheduling up to the point where it's safe to schedule; // this node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:55,schedul,schedule,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Trying to reduce IndexSize to 32 bits for vector 16.; // By default the IndexSize is equal to pointer size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:13,reduce,reduce,13,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Two to the power of half-word-size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:14,power,power,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['power'],['power']
Energy Efficiency,// Type is already a power of 2. The default action is to split.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:21,power,power,21,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['power'],['power']
Energy Efficiency,// Type to be allocated; // Get the number of elements being allocated by the array...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:14,allocate,allocated,14,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// Types for recording sets of variable fragments that overlap. For a given; // local variable, we record all other fragments of that variable that could; // overlap it, to reduce search time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:173,reduce,reduce,173,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['reduce'],['reduce']
Energy Efficiency,// UDT allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeIndexDiscovery.cpp:7,allocate,allocated,7,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeIndexDiscovery.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeIndexDiscovery.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Unbundle instructions after the post-RA scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:43,schedul,scheduler,43,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// Unconditionally try to reduce latency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:26,reduce,reduce,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Under Power Management extensions, the cycle-count is:; // mrc p15, #0, <Rt>, c9, c13, #0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:9,Power,Power,9,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Power'],['Power']
Energy Efficiency,"// Under the Itanium C++ ABI, memory for the exception object is allocated by; // the runtime with no ability for the compiler to request additional; // alignment. Warn if the exception type requires alignment beyond the minimum; // guaranteed by the target C++ runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:65,allocate,allocated,65,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// UnfilledBitsInLastUnit is the difference between the end of the; // last allocated bitfield (i.e. the first bit offset available for; // bitfields) and the end of the current data size in bits (i.e. the; // first bit offset available for non-bitfields). The current data; // size in bits is always a multiple of the char size; additionally,; // for ms_struct records it's also a multiple of the; // LastBitfieldStorageUnitSize (if set).; // The struct-layout algorithm is dictated by the platform ABI,; // which in principle could use almost any rules it likes. In; // practice, UNIXy targets tend to inherit the algorithm described; // in the System V generic ABI. The basic bitfield layout rule in; // System V is to place bitfields at the next available bit offset; // where the entire bitfield would fit in an aligned storage unit of; // the declared type; it's okay if an earlier or later non-bitfield; // is allocated in the same storage unit. However, some targets; // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't; // require this storage unit to be aligned, and therefore always put; // the bitfield at the next available bit offset.; // ms_struct basically requests a complete replacement of the; // platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:76,allocate,allocated,76,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,2,['allocate'],['allocated']
Energy Efficiency,// Uniform vXi16 funnel shifts can be efficiently handled by default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,efficient,efficiently,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// Unique factors with equal powers -- we've folded them into the first one's; // base.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:29,power,powers,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['power'],['powers']
Energy Efficiency,// Unique the set of defining blocks for efficient lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:41,efficient,efficient,41,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Unlike the other reductions, the first argument is a start value. The; // second argument is the vector to be reduced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:113,reduce,reduced,113,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Unsplit ranges that couldn't be allocated immediately are deferred until; // everything else has been allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:35,allocate,allocated,35,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// Up to 2 vector registers can be truncated efficiently with pack or; // permute. The latter requires an immediate mask to be loaded, which; // typically gets hoisted out of a loop. TODO: return a good value for; // BB-VECTORIZER that includes the immediate loads, which we do not want; // to count for the loop vectorizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:45,efficient,efficiently,45,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Update E to the canonical form when D is a power of two and RHS is; // canonicalized as,; // (icmp ne (A & D), 0) -> (icmp eq (A & D), D) or; // (icmp ne (A & D), D) -> (icmp eq (A & D), 0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:46,power,power,46,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['power'],['power']
Energy Efficiency,// Update LiveIntervals.; // Note: Moving all instructions and calling handleMove every time; // is the most cpu intensive operation of the scheduler.; // It would gain a lot if there was a way to recompute the; // LiveIntervals for the entire scheduling region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:140,schedul,scheduler,140,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,// Update TagMap to reflect instruction changes to reduce the number; // of later MOVs to be inserted. This needs to be done after; // OldCollisions is updated since it may be relocated by this; // insertion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp:51,reduce,reduce,51,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Update legal shuffle masks based on demanded elements if it won't reduce; // to Identity which can cause premature removal of the shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:69,reduce,reduce,69,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Update region boundaries in scheduling region we sinked from since we; // may sink an instruction that was at the beginning or end of its region,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:31,schedul,scheduling,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Update state with SU as the next scheduled unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp:36,schedul,scheduled,36,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Update the Begin iterator, as the first instruction in the block; // may have been scheduled later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:86,schedul,scheduled,86,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Update the allocated size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TBits.h:14,allocate,allocated,14,core/cont/inc/TBits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TBits.h,1,['allocate'],['allocated']
Energy Efficiency,"// Update the interval map, but only coalesce left, since intervals to the; // right use the old location numbers. This should merge two contiguous; // DBG_VALUE intervals with different vregs that were allocated to the same; // physical register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:203,allocate,allocated,203,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Update the latency of chain edges between v60 vector load or store; // instructions to be 1. These instruction cannot be scheduled in the; // same packet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:124,schedul,scheduled,124,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:108,power,power,108,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['power'],['power']
Energy Efficiency,// Update the scheduler bundle to point to this TreeEntry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,schedul,scheduler,14,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// Update the stack pointer.; // In many cases this can be done far more efficiently by pushing the; // relevant values directly to the stack. However, doing that correctly; // (in the right order, possibly skipping some empty space for undef; // values, etc) is tricky and thus left to be optimized in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:73,efficient,efficiently,73,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Update to the new value. Optimize for the case when we have a single; // operand that we're changing, but handle bulk updates efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h:129,efficient,efficiently,129,interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantsContext.h,1,['efficient'],['efficiently']
Energy Efficiency,// Update top scheduled pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,schedul,scheduled,14,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Updating predecessor's height. This is now the cycle when the; // predecessor can be scheduled without causing a pipeline stall.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:88,schedul,scheduled,88,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Use Adaptive Gauss-Kronrod integration by default for the convolution integral",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:7,Adapt,Adaptive,7,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,1,['Adapt'],['Adaptive']
Energy Efficiency,"// Use DUP for non-constant splats. For f32 constant splats, reduce to; // i32 and try again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:61,reduce,reduce,61,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Use Depth First Search on the basic blocks to find CFG edges that are; // considered cold.; // Cold regions considered must also have its inline cost compared to the; // overall inline cost of the original function. The region is outlined only; // if it reduced the inline cost of the function by 'MinOutlineRegionCost' or; // more.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:257,reduce,reduced,257,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,1,['reduce'],['reduced']
Energy Efficiency,// Use INSERTPS if we can complete the shuffle efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:47,efficient,efficiently,47,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Use PS_fi when:; // - the object is fixed, or; // - there are no objects with higher-than-default alignment, or; // - there are no dynamically allocated objects.; // Otherwise, use PS_fia.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:146,allocate,allocated,146,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Use TE storage-mapping class when large code model is enabled so that; // the chance of needing -bbigtoc is decreased. Also, the toc-entry for; // EH info is never referenced directly using instructions so it can be; // allocated with TE storage-mapping class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:223,allocate,allocated,223,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Use VDUP for non-constant splats. For f32 constant splats, reduce to; // i32 and try again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:62,reduce,reduce,62,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Use a SCHED_BARRIER's mask to identify instruction SchedGroups that should; // not be reordered accross the SCHED_BARRIER. This is used for the base; // SCHED_BARRIER, and not SCHED_GROUP_BARRIER. The difference is that; // SCHED_BARRIER will always block all instructions that can be classified; // into a particular SchedClass, whereas SCHED_GROUP_BARRIER has a fixed size; // and may only synchronize with some SchedGroups. Returns the inverse of; // Mask. SCHED_BARRIER's mask describes which instruction types should be; // allowed to be scheduled across it. Invert the mask to get the; // SchedGroupMask of instructions that should be barred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:546,schedul,scheduled,546,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// Use a ScoreboardHazardRecognizer for prepass ARM scheduling. TargetInstrImpl; // currently defaults to no prepass hazard recognizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:52,schedul,scheduling,52,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Use a delete listener to remove nodes which were deleted during; // legalization from LegalizeNodes. This is needed to handle the situation; // where a new node is allocated by the object pool to the same address of a; // previously deleted node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:167,allocate,allocated,167,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Use a heuristic to reduce number of builtin candidates in the set:; // add volatile version only if there are conversions to a volatile type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:22,reduce,reduce,22,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Use a new scanner instance since the tokens will be inside the allocated; // string. We should already have captured all the relevant tokens in the; // current scanner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:66,allocate,allocated,66,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Use a scope block to clean up AssignmentTrackingLowering before running; // MemLocFragmentFill to reduce peak memory consumption.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:101,reduce,reduce,101,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,2,"['consumption', 'reduce']","['consumption', 'reduce']"
Energy Efficiency,"// Use a vector to maintain the insertion order. Given the expected small; // number of nodes, vector should be sufficiently efficient. Elements must not; // be null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp:125,efficient,efficient,125,interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Use available stack adjustment in push instruction to allocate additional; // stack space.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:57,allocate,allocate,57,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Use default TD scheduling mechanism.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:18,schedul,scheduling,18,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// Use getActiveBits() to make use of the additional power of two knowledge,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:53,power,power,53,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['power'],['power']
Energy Efficiency,// Use one T2 instruction to reduce NumBytes; // FIXME: Move this to ARMAddressingModes.h?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp:29,reduce,reduce,29,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Use signed division by a power of two to truncate towards 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:28,power,power,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['power'],['power']
Energy Efficiency,// Use the OptMinSizeThreshold or OptSizeThreshold knob if they are available; // and reduce the threshold if the caller has the necessary attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:86,reduce,reduce,86,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Use the appropriate scalar instruction on the split subvectors before; // reducing the now partially reduced smaller vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:104,reduce,reduced,104,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Use the builder to create an exclusive scan and compute the final reduced; // value using an iterative approach. This provides an alternative; // implementation to DPP which uses WMM for scan computations. This API iterate; // over active lanes to read, compute and update the value using; // readlane and writelane intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:69,reduce,reduced,69,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Use the demanded bits analysis to determine the bits that are live out; // of the exit instruction, rounding up to the nearest power of two. If the; // use of demanded bits results in a smaller bit width, we know the value; // must be positive (i.e., IsSigned = false), because if this were not the; // case, the sign bit would have been demanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:130,power,power,130,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,1,['power'],['power']
Energy Efficiency,// Use the list reducer to identify blocks that can be extracted without; // obscuring the bug. The Blocks list will end up containing blocks that must; // be retained from the original program.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:16,reduce,reducer,16,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['reduce'],['reducer']
Energy Efficiency,"// Use the same layout as the tablegen'erated register name matcher. Ugly,; // but efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:83,efficient,efficient,83,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Use x 10 n format. (only powers of 3 allowed)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGaxis.cxx:28,power,powers,28,graf2d/graf/src/TGaxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGaxis.cxx,2,['power'],['powers']
Energy Efficiency,"// Used by Html_Block elements only.; // Each text element holds additional information as shown here. Notice that; // extra space is allocated so that zText[] will be large enough to hold the; // complete text of the element. X and y coordinates are relative to the; // virtual canvas. The y coordinate refers to the baseline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:134,allocate,allocated,134,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['allocate'],['allocated']
Energy Efficiency,"// Used by external code to know what we are monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:45,monitor,monitoring,45,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// Used for shifting constraints for OpenCL, do mask for powers of 2, URem for; // non powers of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:57,power,powers,57,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,2,['power'],['powers']
Energy Efficiency,"// Used to calculate register pressure, which is independent of loop; // scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:73,schedul,scheduling,73,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// Used to check if the reduced values used same number of times. In this; // case the compiler may produce better code. E.g. if reduced values are; // aabbccdd (8 x values), then the first node of the tree will have a node; // for 4 x abcd + shuffle <4 x abcd>, <0, 0, 1, 1, 2, 2, 3, 3>.; // Plus, the final reduction will be performed on <8 x aabbccdd>.; // Instead compiler may build <4 x abcd> tree immediately, + reduction (4; // x abcd) * 2.; // Currently it only handles add/fadd/xor. and/or/min/max do not require; // this analysis, other operations may require an extra estimation of; // the profitability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,reduce,reduced,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['reduce'],['reduced']
Energy Efficiency,// Used to determine if a cold region is worth outlining based on; // its inlining cost compared to the original function. Default is set at 10%.; // ie. if the cold region reduces the inlining cost of the original function by; // at least 10%.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:173,reduce,reduces,173,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Using a less-than relation (SUnitOrder<false>) for the TopQ priority; // gives nodes with a higher number higher priority causing the latest; // instructions to be scheduled first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:167,schedul,scheduled,167,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// Usually we should not get to this point, but the following is an attempt to; // model the cost of legalization. Currently we can only lower intrinsics with; // evl but no mask, on Power 9/10. Otherwise, we must scalarize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:183,Power,Power,183,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['Power'],['Power']
Energy Efficiency,// V60 forward scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:15,schedul,scheduling,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// VF is a power of 2 so we can emit the reduction using log2(VF) shuffles; // and vector ops, reducing the set of values being computed by half each; // round.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:11,power,power,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['power'],['power']
Energy Efficiency,"// VPDPBUSD(<16 x i32>C, <16 x i8>A, <16 x i8>B). For each dst element; // C[0] = C[0] + A[0]B[0] + A[1]B[1] + A[2]B[2] + A[3]B[3].; // The src A, B element type is i8, but the dst C element type is i32.; // When we calculate the reduce stage, we use src vector type vXi8 for it; // so we need logbias 2 to avoid extra 2 stages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:230,reduce,reduce,230,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// VRegs indexed within SparseUniverseMax are tracked by Sparse, those beyound; // are tracked by Dense. The only purpose of the threashold and the Dense set; // is to have a reasonably growing memory usage in pathological cases (large; // number of very sparse VRegFilter instances live at the same time). In; // practice even in the worst-by-execution time cases having all elements; // tracked by Sparse (very large SparseUniverseMax scenario) tends to be more; // space efficient than if tracked by Dense. The threashold is set to keep the; // worst-case memory usage within 2x of figures determined empirically for; // ""all Dense"" scenario in such worst-by-execution-time cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:474,efficient,efficient,474,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// V_FRACT is buggy on SI, so the F32 version is never used and (x-floor(x)); // is used instead. However, SI doesn't have V_FLOOR_F64, so the most; // efficient way to implement it is using V_FRACT_F64. The workaround for the; // V_FRACT bug is:; // fract(x) = isnan(x) ? x : min(V_FRACT(x), 0.99999999999999999); //; // Convert floor(x) to (x - fract(x))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:152,efficient,efficient,152,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['efficient'],['efficient']
Energy Efficiency,// Value is power of 2 if it is coming from PHI node itself by induction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:12,power,power,12,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,// Values are used by '--summary' option (allocated).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVScope.h:42,allocate,allocated,42,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVScope.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVScope.h,2,['allocate'],['allocated']
Energy Efficiency,"// Varargs are copied into a buffer allocated by the caller, and a pointer to; // the buffer is passed as an argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:36,allocate,allocated,36,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Variables allocated in module lds must all resolve to that struct,; // not to the per-kernel instance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:13,allocate,allocated,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Various bonus percentages. These are multiplied by Threshold to get the; // bonus values.; // SingleBBBonus: This bonus is applied if the callee has a single reachable; // basic block at the given callsite context. This is speculatively applied; // and withdrawn if more than one basic block is seen.; //; // LstCallToStaticBonus: This large bonus is applied to ensure the inlining; // of the last call to a static function as inlining such functions is; // guaranteed to reduce code size.; //; // These bonus percentages may be set to 0 based on properties of the caller; // and the callsite.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:475,reduce,reduce,475,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// VecTy is a power of 2 and 1 byte at smallest, but VecElemTy may be smaller; // than 1 byte (e.g. VecTy == <32 x i1>).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:14,power,power,14,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['power'],['power']
Energy Efficiency,"// Vector of pointers to all known types, index in this vector; // equals to logical type BTF id.; // Pointers point to memory owned by `TypesBuffer`; // (except pointer at index 0, which is statically allocated).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/BTF/BTFParser.h:202,allocate,allocated,202,interpreter/llvm-project/llvm/include/llvm/DebugInfo/BTF/BTFParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/BTF/BTFParser.h,1,['allocate'],['allocated']
Energy Efficiency,"// Vector reduce complex multiply by scalar, Rt & 1 map to :hi else :lo; // The insn is mapped from the 4 operand to the 3 operand raw form taking; // 3 register pairs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonAsmPrinter.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Vector type r+i form is supported since power9 as DQ form. We don't check; // the offset matching DQ form requirement(off % 16 == 0), because on PowerPC,; // imm form is preferred and the offset can be adjusted to use imm form later; // in pass PPCLoopInstrFormPrep. Also in LSR, for one LSRUse, it uses min and; // max offset to check legal addressing mode, we should be a little aggressive; // to contain other offsets for that LSRUse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:148,Power,PowerPC,148,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// Vectors passed on the stack do not shadow GPRs or FPRs even though they; // might be allocated in the portion of the PSA that is shadowed by the; // GPRs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:88,allocate,allocated,88,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Vectors with a number of elements that is not a power of two are always; // widened, for example <3 x i8> -> <4 x i8>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:51,power,power,51,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['power'],['power']
Energy Efficiency,"// Verified for:; // x86-64 FreeBSD, Linux, Darwin; // x86-32 FreeBSD, Linux, Darwin; // PowerPC Linux; // ARM Darwin (*not* EABI); // AArch64 Linux",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.cpp:89,Power,PowerPC,89,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// Verify the type metadata and build a few data structures to let us; // efficiently enumerate the type identifiers associated with a global:; // a list of GlobalTypeMembers (a GlobalObject stored alongside a vector; // of associated type metadata) and a mapping from type identifiers to their; // list of GlobalTypeMembers and last observed index in the list of globals.; // The indices will be used later to deterministically order the list of type; // identifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:74,efficient,efficiently,74,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Vertically reduce the set of vectors by summing its equally-indexed components",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:14,reduce,reduce,14,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,3,['reduce'],['reduce']
Energy Efficiency,"// Very large bundles usually come from big switches, indirect branches,; // landing pads, or loops with many 'continue' statements. It is difficult to; // allocate registers when so many different blocks are involved.; //; // Give a small negative bias to large bundles such that a substantial; // fraction of the connected blocks need to be interested before we consider; // expanding the region through the bundle. This helps compile time by; // limiting the number of blocks visited and the number of links in the; // Hopfield network.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:156,allocate,allocate,156,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,1,['allocate'],['allocate']
Energy Efficiency,// Virtual sections do not need storage allocated in the object file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp:40,allocate,allocated,40,interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// Visit operation ""Links"" along the reduction chain top-down starting from; // the phi until LoopExitValue. We keep track of the previous item; // (PreviousLink) to tell which of the two operands of a Link will remain; // scalar and which will be reduced. For minmax by select(cmp), Link will be; // the select instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:248,reduce,reduced,248,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:37,reduce,reduced,37,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,1,['reduce'],['reduced']
Energy Efficiency,// WRITELANE instructions used for SGPR spills can overwrite the inactive; // lanes of VGPRs and callee must spill and restore them even if they are; // marked Caller-saved.; // TODO: Handle this elsewhere at an early point. Walking through all MBBs; // here would be a bad heuristic. A better way should be by calling; // allocateWWMSpill during the regalloc pipeline whenever a physical; // register is allocated for the intended virtual registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:323,allocate,allocateWWMSpill,323,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,2,['allocate'],"['allocateWWMSpill', 'allocated']"
Energy Efficiency,"// WVE END HACK; // Below here directly pass binnedPdf instead of PROD(binnedPdf,constraints) as constraints are evaluated elsewhere anyway; // and omitting them reduces model complexity and associated handling/cloning times",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx:162,reduce,reduces,162,roofit/roofitcore/src/RooAbsTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx,1,['reduce'],['reduces']
Energy Efficiency,"// WVE needs adaptation for rangeName feature",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealSumPdf.cxx:13,adapt,adaptation,13,roofit/roofitcore/src/RooRealSumPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealSumPdf.cxx,1,['adapt'],['adaptation']
Energy Efficiency,"// WVE needs adaptation for rangename feature; // Partial integration scenarios",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:13,adapt,adaptation,13,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['adapt'],['adaptation']
Energy Efficiency,"// WVE needs adaptation to handle new rangeName feature",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:13,adapt,adaptation,13,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['adapt'],['adaptation']
Energy Efficiency,"// WVE needs adaptation to handle new rangeName feature; // Handle trivial passthrough scenario",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx:13,adapt,adaptation,13,roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,1,['adapt'],['adaptation']
Energy Efficiency,// Wait for any outstanding memory operations that the input registers may; // depend on. We can't track them and it's better to do the wait after the; // costly call sequence.; // TODO: Could insert earlier and schedule more liberally with operations; // that only use caller preserved registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:212,schedul,schedule,212,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['schedul'],['schedule']
Energy Efficiency,// Walk RewriteRope chunks efficiently using MoveToNextPiece() instead of the; // character iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:27,efficient,efficiently,27,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// Walk the block backwards for efficiency. We're matching a chain of; // use->defs, so we're more likely to succeed by starting from the bottom.; // Also, we want to avoid matching partial patterns.; // TODO: It would be more efficient if we removed dead instructions; // iteratively in this loop rather than waiting until the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:227,efficient,efficient,227,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// Walk the register/memloc assignments, inserting copies/loads.; // i - Tracks the index into the list of registers allocated for the call; // RealArgIdx - Tracks the index into the list of actual function arguments; // j - Tracks the index into the list of byval arguments",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:117,allocate,allocated,117,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Warn if the type is over-aligned and is being allocated by (unaligned); // global operator new.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:49,allocate,allocated,49,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,// Was the GEP already reduced to a constant?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:23,reduce,reduced,23,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Was this array object allocated through TClass?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:25,allocate,allocated,25,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// Was this object allocated through TClass?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:19,allocate,allocated,19,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// WatchOS is adopting the 64-bit AAPCS rule on composite types: if they're; // bigger than 128-bits, they get placed in space allocated by the caller,; // and a pointer is passed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp:127,allocate,allocated,127,interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// We allocate arrays with the BumpPtrAllocator and never free or copy them,; // for LocationOps and AdditionalDependencies, as we never expect to copy or; // destroy an SDDbgValue. If we ever start copying or destroying instances, we; // should manage the allocated memory appropriately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h:6,allocate,allocate,6,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// We allocate one more than the number of blocks in the function to; // accommodate for the possible fake block we may insert at the end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:6,allocate,allocate,6,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// We allocated CONIN$:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/StreamReaderWin.cpp:6,allocate,allocated,6,core/textinput/src/textinput/StreamReaderWin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/StreamReaderWin.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// We allocated CONOUT$:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayWin.cpp:6,allocate,allocated,6,core/textinput/src/textinput/TerminalDisplayWin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayWin.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// We allocated with operator new and with some extra memory hanging off the; // end, so don't just delete this. I'm not sure if this is actually; // required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:6,allocate,allocated,6,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// We allow moving from *const* Values, by marking all members as mutable!; // This hack is needed to support initializer-list syntax efficiently.; // (std::initializer_list<T> is a container of const T).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:134,efficient,efficiently,134,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['efficient'],['efficiently']
Energy Efficiency,"// We already allocated the preserved area, so the stack offset computed; // by CC_VE would be correct now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:14,allocate,allocated,14,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,['allocate'],['allocated']
Energy Efficiency,"// We also define global_device and global_host address spaces,; // to distinguish global pointers allocated on host from pointers; // allocated on device, which are a subset of __global.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:99,allocate,allocated,99,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,['allocate'],['allocated']
Energy Efficiency,"// We also need to add an implicit def of this register for the later; // use to read from.; // For the register allocator to have allocated a register clobbered; // by the call which is used later, it must be the case that; // the call doesn't return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:131,allocate,allocated,131,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// We also need to consider the sign bit in Lo if Hi has just sign bits,; // i.e. Hi is 0 or -1. However, that only needs to take the MSB into; // account. That is, the maximal shift is; // - 32 if Lo and Hi have opposite signs;; // - 33 if Lo and Hi have the same sign.; //; // Or, MaxShAmt = 33 + OppositeSign, where; //; // OppositeSign is defined as ((Lo ^ Hi) >> 31), which is; // - -1 if Lo and Hi have opposite signs; and; // - 0 otherwise.; //; // All in all, ShAmt is calculated as; //; // umin(sffbh(Hi), 33 + (Lo^Hi)>>31) - 1.; //; // or; //; // umin(sffbh(Hi) - 1, 32 + (Lo^Hi)>>31).; //; // to reduce the critical path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:607,reduce,reduce,607,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We also track the estimated dynamic (that is, actually executed) cost in; // the rolled form. This helps identify cases when the savings from unrolling; // aren't just exposing dead control flows, but actual reduced dynamic; // instructions due to the simplifications which we expect to occur after; // unrolling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:211,reduce,reduced,211,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// We are being conservative here. We only require this work-around if; // CurrentSubEntries > 3 &&; // (CurrentSubEntries % 4 == 3 || CurrentSubEntries % 4 == 0); //; // We have to be conservative, because we don't know for certain that; // our stack allocation algorithm for Evergreen/NI is correct. Applying this; // work-around when CurrentSubEntries > 3 allows us to over-allocate stack; // resources without any problems.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp:377,allocate,allocate,377,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:340,efficient,efficiently,340,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// We are interested in instructions that copy values to ACC/UACC.; // The copy into UACC will be simply a COPY to a subreg so we; // want to allocate the corresponding physical subreg for the source.; // The copy into ACC will be a BUILD_UACC so we want to allocate; // the same number UACC for the source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:142,allocate,allocate,142,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// We are looking for a pattern of, and finding the minimal acceptable cost:; // reduce(mul(ext(A), ext(B))) or; // reduce(mul(A, B)) or; // reduce(ext(A)) or; // reduce(A).; // The basic idea is that we walk down the tree to do that, finding the root; // reduction instruction in InLoopReductionImmediateChains. From there we find; // the pattern of mul/ext and test the cost of the entire pattern vs the cost; // of the components. If the reduction cost is lower then we return it for the; // reduction instruction and 0 for the other instructions in the pattern. If; // it is not we return an invalid cost specifying the orignal cost method; // should be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:81,reduce,reduce,81,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,4,['reduce'],['reduce']
Energy Efficiency,// We are trying to use VMOV/VMOVX/VINS to more efficiently lower insert and; // extracts of v8f16 and v8i16 vectors. Check that we have two adjacent; // inserts of the correct type:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:48,efficient,efficiently,48,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// We are using the following formula for BC(It, K):; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / K!; //; // Suppose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the res",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:827,efficient,efficiently,827,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// We assume all standard global 'operator new' functions allocate memory in; // heap. We realize this is an approximation that might not correctly model; // a custom global allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:58,allocate,allocate,58,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,// We assume only one text segment in the main binary for simplicity and; // reduce the overhead of checking multiple ranges during symbolization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:77,reduce,reduce,77,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// We assume that memet/memcpy operates in chunks of the ""largest"" native; // type size and aligned on the same value. That means optimal start and size; // of memset/memcpy should be modulo of preferred alignment of that type. That; // is it there is no any sense in trying to reduce store size any further; // since any ""extra"" stores comes for free anyway.; // On the other hand, maximum alignment we can achieve is limited by alignment; // of initial store.; // TODO: Limit maximum alignment by preferred (or abi?) alignment of the; // ""largest"" native type.; // Note: What is the proper way to get that value?; // Should TargetTransformInfo::getRegisterBitWidth be used or anything else?; // PrefAlign = std::min(DL.getPrefTypeAlign(LargestType), PrefAlign);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:278,reduce,reduce,278,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We assume the input buffers are valid for the lifetime of the interpreter.; // By default, tflite allocates memory in an arena and will periodically take; // away memory and reallocate it in a different location after evaluations in; // order to improve utilization of the buffers owned in the arena. So, we; // explicitly mark our input buffers as persistent to avoid this behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:101,allocate,allocates,101,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// We build scheduling units by walking a block's instruction list; // from bottom to top.; // Each MIs' memory operand(s) is analyzed to a list of underlying; // objects. The SU is then inserted in the SUList(s) mapped from the; // Value(s). Each Value thus gets mapped to lists of SUs depending; // on it, stores and loads kept separately. Two SUs are trivially; // non-aliasing if they both depend on only identified Values and do; // not share any common Value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:12,schedul,scheduling,12,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// We build up the blend mask while checking whether a blend is a viable way; // to reduce the shuffle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:84,reduce,reduce,84,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:451,power,power,451,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,3,['power'],['power']
Energy Efficiency,"// We can change which blocks are exit blocks of all the cloned sibling; // loops, the current loop, and any parent loops which shared exit blocks; // with the current loop. As a consequence, we need to re-form LCSSA for; // them. But we shouldn't need to re-form LCSSA for any child loops.; // FIXME: This could be made more efficient by tracking which exit blocks are; // new, and focusing on them, but that isn't likely to be necessary.; //; // In order to reasonably rebuild LCSSA we need to walk inside-out across the; // loop nest and update every loop that could have had its exits changed. We; // also need to cover any intervening loops. We add all of these loops to; // a list and sort them by loop depth to achieve this without updating; // unnecessary loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:326,efficient,efficient,326,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// We can codegen setcc op, imm very efficiently compared to a brcond.; // Check for those cases here.; // setcc op, 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:37,efficient,efficiently,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// We can compute the correct backedge taken count for loops with unknown; // strides if we can prove that the loop is not an infinite loop with side; // effects. Here's the loop structure we are trying to handle -; //; // i = start; // do {; // A[i] = i;; // i += s;; // } while (i < end);; //; // The backedge taken count for such loops is evaluated as -; // (max(end, start + stride) - start - 1) /u stride; //; // The additional preconditions that we need to check to prove correctness; // of the above formula is as follows -; //; // a) IV is either nuw or nsw depending upon signedness (indicated by the; // NoWrap flag).; // b) the loop is guaranteed to be finite (e.g. is mustprogress and has; // no side effects within the loop); // c) loop has a single static exit (with no abnormal exits); //; // Precondition a) implies that if the stride is negative, this is a single; // trip loop. The backedge taken count formula reduces to zero in this case.; //; // Precondition b) and c) combine to imply that if rhs is invariant in L,; // then a zero stride means the backedge can't be taken without executing; // undefined behavior.; //; // The positive stride case is the same as isKnownPositive(Stride) returning; // true (original behavior of the function).; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:929,reduce,reduces,929,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// We can convert this to:; // 1. Any extend iN to iM; // 2. SHL by M-N; // 3. [US][ADD|SUB|SHL]SAT; // 4. L/ASHR by M-N; //; // It may be more efficient to lower this to a min and a max operation in; // the higher precision arithmetic if the promoted operation isn't legal,; // but this decision is up to the target's lowering request.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:144,efficient,efficient,144,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// We can integrate over m if power = 0.5",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooArgusBG.cxx:30,power,power,30,roofit/roofit/src/RooArgusBG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooArgusBG.cxx,1,['power'],['power']
Energy Efficiency,"// We can narrow this more efficiently than Helper can by using ffbh/ffbl; // which return -1 when the input is zero:; // (ctlz_zero_undef hi:lo) -> (umin (ffbh hi), (add (ffbh lo), 32)); // (cttz_zero_undef hi:lo) -> (umin (add (ffbl hi), 32), (ffbl lo)); // (ffbh hi:lo) -> (umin (ffbh hi), (uaddsat (ffbh lo), 32)); // (ffbl hi:lo) -> (umin (uaddsat (ffbh hi), 32), (ffbh lo))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:27,efficient,efficiently,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// We can only process vectors that have a bit size of 128 or higher (with an; // additional 64 bits for Neon). Additionally, these vectors must have a; // power-of-2 size, as we later split them into the smallest supported size; // and merging them back together after applying complex operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:156,power,power-of-,156,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:50,power,powers,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['power'],['powers']
Energy Efficiency,// We can only use 1 << X without more sophisticated analysis. C << X where; // C is a power of 2 but not 1 can result in zero which cannot be translated; // to bittest. Likewise any C >> X (either arith or logical) can be zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:87,power,power,87,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// We can promote shl(x, cst) if we can promote x. Since shl overwrites the; // upper bits we can reduce BitsToClear by the shift amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:98,reduce,reduce,98,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['reduce'],['reduce']
Energy Efficiency,// We can reduce the size of gc live bundle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['reduce'],['reduce']
Energy Efficiency,// We can turn on ROP Protect on Power 8 and above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:33,Power,Power,33,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,1,['Power'],['Power']
Energy Efficiency,"// We can use an unpack to do the blending rather than an or in some; // cases. Even though the or may be (very minorly) more efficient, we; // preference this lowering because there are common cases where part of; // the complexity of the shuffles goes away when we do the final blend as; // an unpack.; // FIXME: It might be worth trying to detect if the unpack-feeding; // shuffles will both be pshufb, in which case we shouldn't bother with; // this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:126,efficient,efficient,126,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,// We can use the minimum and maximum VLEN values to bound VLENB. We; // know VLEN must be a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:93,power,power,93,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// We can use the splice instruction for certain index values where we are; // able to efficiently generate the correct predicate. The index will be; // inverted and used directly as the input to the ptrue instruction, i.e.; // -1 -> vl1, -2 -> vl2, etc. The predicate will then be reversed to get the; // splice predicate. However, we can only do this if we can guarantee that; // there are enough elements in the vector, hence we check the index <= min; // number of elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:87,efficient,efficiently,87,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// We can't currently handle Power style floating point operations here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:29,Power,Power,29,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Power'],['Power']
Energy Efficiency,"// We can't do PRE safely on a critical edge, so instead we schedule; // the edge to be split and perform the PRE the next time we iterate; // on the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:60,schedul,schedule,60,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['schedul'],['schedule']
Energy Efficiency,// We can't handle loads that extend past the allocated memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:46,allocate,allocated,46,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['allocate'],['allocated']
Energy Efficiency,// We can't handle stores that extend past the allocated memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:47,allocate,allocated,47,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// We can't handle this case efficiently. Allocate a sufficiently; // aligned object on the stack, store each operand into it, then load; // the result as a vector.; // Create the stack frame object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:29,efficient,efficiently,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,2,"['Allocate', 'efficient']","['Allocate', 'efficiently']"
Energy Efficiency,// We can't reduce this case; just treat it normally.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:12,reduce,reduce,12,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['reduce'],['reduce']
Energy Efficiency,// We can't schedule across a use of the register in question.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:12,schedul,schedule,12,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,2,['schedul'],['schedule']
Energy Efficiency,// We compare the costs of a vector.reduce.add to sequential add.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:36,reduce,reduce,36,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We couldn't handle the requested integer size so we fallback by breaking; // the request down into several, smaller, integers.; // Since sizes greater or equal to ""Size"" are invalid, we use the greatest; // power of 2 that is less than ""Size"" as our largest piece of granularity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:210,power,power,210,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,1,['power'],['power']
Energy Efficiency,// We create ADJCALLSTACKUP and ADJCALLSTACKDOWN around _tls_get_addr; // as scheduling fence to avoid it is scheduled before; // mflr in the prologue and the address in LR is clobbered (PR25839).; // We don't really need to save data to the stack - the clobbered; // registers are already saved when the SDNode (e.g. PPCaddiTlsgdLAddr); // gets translated to the pseudo instruction (e.g. ADDItlsgdLADDR).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:77,schedul,scheduling,77,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"// We currently don't have a way to correctly allocate LDS objects that; // aren't directly associated with a kernel. We do force inlining of; // functions that use local objects. However, if these dead functions are; // not eliminated, we don't want a compile time error. Just emit a warning; // and a trap, since there should be no callable path here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:46,allocate,allocate,46,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// We currently have two techniques for handling results with zeros: early; // masking (the default) and late masking. Late masking is sometimes more; // efficient, but because the structure of the bit groups is different, it; // is hard to tell without generating both and comparing the results. With; // late masking, we ignore zeros in the resulting value when inserting each; // set of bit groups, and then mask in the zeros at the end. With early; // masking, we only insert the non-zero parts of the result at every step.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:154,efficient,efficient,154,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// We define the Phis after creating the new pipelined code, so; // we need to rename the Phi values in scheduled instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:104,schedul,scheduled,104,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// We define vscale to be VLEN/RVVBitsPerBlock. VLEN is always a power; // of two >= 64, and RVVBitsPerBlock is 64. Thus, vscale must be; // a power of two as well.; // FIXME: This doesn't work for zve32, but that's already broken; // elsewhere for the same reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,power,power,65,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['power'],['power']
Energy Efficiency,"// We didn't track asymmetric errors so far, so now we need to allocate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:63,allocate,allocate,63,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// We divide by two as a cheap and simple heuristic to reduce the; // critcal path length, which increases the priority of using the graph; // height/depth in the scheduler's cost computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:55,reduce,reduce,55,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,2,"['reduce', 'schedul']","['reduce', 'scheduler']"
Energy Efficiency,"// We do not check for one-use of the vector load because a broadcast load; // is expected to be a win for code size, register pressure, and possibly; // uops even if the original vector load is not eliminated.; // Reduce the vector load and shuffle to a broadcasted scalar load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:215,Reduce,Reduce,215,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,// We do not currently implement these libm ops for PowerPC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:52,Power,PowerPC,52,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,// We do schedule a valid scheduling such that a Block corresponds; // to a range of instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:9,schedul,schedule,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// We don't allocate the segment if we know the implicit arguments weren't; // used, even if the ABI implies we need them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:12,allocate,allocate,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// We don't currently model the OOO reorder buffer, so consider all; // scheduled MOps to be ""retired"". We do loosely model in-order resource; // latency. If this instruction uses an in-order resource, account for any; // likely stall cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:72,schedul,scheduled,72,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// We don't have definitions for variables on the backedge, because we; // haven't gotten that far in the CFG. Thus, when encountering a back edge,; // we conservatively create Phi nodes for all variables. Unnecessary Phi; // nodes will be marked as incomplete, and stripped out at the end.; //; // An Phi node is unnecessary if it only refers to itself and one other; // variable, e.g. x = Phi(y, y, x) can be reduced to x = y.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:411,reduce,reduced,411,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// We don't know the microarchitecture here, so just reduce register pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:53,reduce,reduce,53,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// We don't rely on read-undef flag because in case of tentative schedule; // tracking it isn't set correctly yet. This works correctly however since; // use mask has been tracked before using LIS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp:65,schedul,schedule,65,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.cpp,1,['schedul'],['schedule']
Energy Efficiency,// We don't support putting RISC-V Vector objects into the pre-allocated; // local frame block at the moment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.h:63,allocate,allocated,63,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.h,1,['allocate'],['allocated']
Energy Efficiency,// We don't support putting SVE objects into the pre-allocated local; // frame block at the moment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.h:53,allocate,allocated,53,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.h,1,['allocate'],['allocated']
Energy Efficiency,"// We expect **all** the protected stack objects to be pre-allocated by; // LocalStackSlotPass. If it turns out that PEI still has to allocate some; // of them, we may end up messing up the expected order of the objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:59,allocate,allocated,59,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// We expect to be able to match a bit extraction instruction if the Zbs; // extension is supported and the mask is a power of two. However, we; // conservatively return false if the mask would fit in an ANDI instruction,; // on the basis that it's possible the sinking+duplication of the AND in; // CodeGenPrepare triggered by this hook wouldn't decrease the instruction; // count and would increase code size (e.g. ANDI+BNEZ => BEXTI+BNEZ).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,power,power,118,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['power'],['power']
Energy Efficiency,// We expect to have at least 2 more parameters than the 'parallel'; // directive does - the lower and upper bounds of the previous schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:132,schedul,schedule,132,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// We found a function starts segment, parse the addresses for later; // consumption.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:73,consumption,consumption,73,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['consumption'],['consumption']
Energy Efficiency,"// We found a function starts segment, parse the addresses for; // consumption.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp:67,consumption,consumption,67,interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-nm/llvm-nm.cpp,1,['consumption'],['consumption']
Energy Efficiency,"// We found an available, but not scheduled, predecessor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:34,schedul,scheduled,34,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// We found an available, but not scheduled, predecessor. If it's the; // only one we have found, keep track of it... otherwise give up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:34,schedul,scheduled,34,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,2,['schedul'],['scheduled']
Energy Efficiency,"// We found an available, but not scheduled, successor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:34,schedul,scheduled,34,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// We found the SRSRC first because it needs four registers and has an; // alignment requirement. If the SRSRC that we found is clobbering with; // the scratch wave offset, which may be in a fixed SGPR or a free SGPR; // chosen by SITargetLowering::allocateSystemSGPRs, COPY the scratch; // wave offset to a free SGPR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:249,allocate,allocateSystemSGPRs,249,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['allocate'],['allocateSystemSGPRs']
Energy Efficiency,"// We have a more efficient lowering for ""(X == 0) ? Y : -1"" using SBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,efficient,efficient,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// We have an implementation also for CUDA right now only for the most used; // basis type, which is expBasis. If the need to support other basis types; // arises, they can be implemented following this example. Remember to also; // adapt RooGaussModel::canComputeBatchWithCuda().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooGaussModel.cxx:233,adapt,adapt,233,roofit/roofit/src/RooGaussModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooGaussModel.cxx,1,['adapt'],['adapt']
Energy Efficiency,// We have handled special cases that reduce.; // Canonicalize any remaining sub to add as:; // (C2 - Y) > C --> (Y + ~C2) < ~C,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:38,reduce,reduce,38,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We have several DBG_PHIs, and a use position (the Here inst). All each; // DBG_PHI does is identify a value at a program position. We can treat each; // DBG_PHI like it's a Def of a value, and the use position is a Use of a; // value, just like SSA. We use the bulk-standard LLVM SSA updater class to; // determine which Def is used at the Use, and any PHIs that happen along; // the way.; // Adapted LLVM SSA Updater:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:396,Adapt,Adapted,396,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['Adapt'],['Adapted']
Energy Efficiency,"// We have to anticipate introducing CSR VGPR spills or spill of caller; // save VGPR reserved for SGPR spills as we now always create stack entry; // for it, if we don't have any stack objects already, since we require a FP; // if there is a call and stack. We will allocate a VGPR for SGPR spills if; // there are any SGPR spills. Whether they are CSR spills or otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:267,allocate,allocate,267,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,// We have to split the subrange into a matching and non-matching part.; // Reduce lanemask of existing lane to non-matching part.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:76,Reduce,Reduce,76,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// We have to walk this twice and computing it is not trivial, so creating an; // explicit std::vector is actually fairly efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:122,efficient,efficient,122,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// We have two limits to reduce the complexity:; // 1) AliasedCheckLimit: It's a small limit to reduce calls to; // SLP->isAliased (which is the expensive part in this loop).; // 2) MaxMemDepDistance: It's for very large blocks and it aborts; // the whole loop (even if the loop is fast, it's quadratic).; // It's important for the loop break condition (see below) to; // check this limit even between two read-only instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:25,reduce,reduce,25,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['reduce'],['reduce']
Energy Efficiency,"// We implement both StageCluster() and CommitCluster() because we can call CommitCluster() on the inner sink more; // efficiently in a single critical section. For parallel writing, it also guarantees that we produce a fully sequential; // file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:119,efficient,efficiently,119,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['efficient'],['efficiently']
Energy Efficiency,// We increment the counter only if the locations are aliased; // (instead of counting all alias checks). This gives a better; // balance between reduced runtime and accurate dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:146,reduce,reduced,146,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// We intentionally allocated just one big buffer for this object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx:20,allocate,allocated,20,io/io/src/TMemFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// We just store the allocator by reference. We use this to allocate; // contiguous memory for things like arrays or strings that cross a block; // boundary, and this memory is expected to outlive the stream. For example,; // someone could create a stream, read some stuff, then close the stream, and; // we would like outstanding references to fields to remain valid since the; // entire file is mapped anyway. Because of that, the user must supply the; // allocator to allocate broken records from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MappedBlockStream.h:60,allocate,allocate,60,interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MappedBlockStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MappedBlockStream.h,2,['allocate'],['allocate']
Energy Efficiency,// We keep only high 32-bits of hash value. So bucket size cannot; // exceed 2^31. Bucket size is always power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:105,power,power,105,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['power'],['power']
Energy Efficiency,"// We limit this transform to power-of-2 types because we expect that the; // backend can convert the simplified IR patterns to identical nodes as the; // original IR.; // TODO: If we can verify the same behavior for arbitrary types, the; // power-of-2 checks can be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:30,power,power-of-,30,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['power'],['power-of-']
Energy Efficiency,"// We look for instructions that write S registers that are then read as; // D/Q registers. These can only be caused by COPY, INSERT_SUBREG and; // REG_SEQUENCE pseudos that insert an SPR value into a DPR register or; // merge two SPR values to form a DPR register. In order avoid false; // positives we make sure that there is an SPR producer so we look past; // COPY and PHI nodes to find it.; //; // The best code pattern for when an SPR producer is going to be used by a; // DPR or QPR consumer depends on whether the other lanes of the; // corresponding DPR/QPR are currently defined.; //; // We can handle these efficiently, depending on the type of; // pseudo-instruction that is producing the pattern; //; // * COPY: * VDUP all lanes and merge the results together; // using VEXTs.; //; // * INSERT_SUBREG: * If the SPR value was originally in another DPR/QPR; // lane, and the other lane(s) of the DPR/QPR register; // that we are inserting in are undefined, use the; // original DPR/QPR value.; // * Otherwise, fall back on the same stategy as COPY.; //; // * REG_SEQUENCE: * If all except one of the input operands are; // IMPLICIT_DEFs, insert the VDUP pattern for just the; // defined input operand; // * Otherwise, fall back on the same stategy as COPY.; //; // First, get all the reads of D-registers done by this instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp:618,efficient,efficiently,618,interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// We mask write here to teach later passes that the ith element of this; // vector is undef. Thus we can use it to reduce 128 bits reg usage,; // break false dependencies and additionally make assembly easier to read.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:116,reduce,reduce,116,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We may have proven the input wasn't needed, although the ABI is; // requiring it. We just need to allocate the register appropriately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp:101,allocate,allocate,101,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// We may legitimately have non-power-of-2 alignment here.; // If so, this is UB land, emit it via `@llvm.assume` instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:32,power,power-of-,32,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['power'],['power-of-']
Energy Efficiency,// We may need more space for a Name to account for alignment. So allocate; // space for the storage type and not the name pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp:66,allocate,allocate,66,interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp,1,['allocate'],['allocate']
Energy Efficiency,// We may need to allocate extra storage for the mangling number and the; // extended-by ValueDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:18,allocate,allocate,18,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// We may not be able to keep the current target occupancy because of the just; // scheduled region. We might still be able to revert scheduling if the; // occupancy before was higher, or if the current schedule has register; // pressure higher than the excess limits which could lead to more spilling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:83,schedul,scheduled,83,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,3,['schedul'],"['schedule', 'scheduled', 'scheduling']"
Energy Efficiency,// We might as well mutate to FP_EXTEND when FP_EXTEND operation is legal; // since this operation is more efficient than stack operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:107,efficient,efficient,107,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['efficient'],['efficient']
Energy Efficiency,// We might as well mutate to FP_ROUND when FP_ROUND operation is legal; // since this operation is more efficient than stack operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:105,efficient,efficient,105,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['efficient'],['efficient']
Energy Efficiency,// We must allocate this array with new because EnterTokenStream is going to; // delete it later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:11,allocate,allocate,11,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,1,['allocate'],['allocate']
Energy Efficiency,// We need AT for the 64-bit expansion in the cases where the optional; // source register is the destination register and for the superscalar; // scheduled form.; //; // If it is not available we exit if the destination is the same as the; // source register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:147,schedul,scheduled,147,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['schedul'],['scheduled']
Energy Efficiency,// We need a 1-bit-wider range if:; // 1) LHS can be negative: least value can be reduced.; // 2) RHS can be negative: greatest value can be increased.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:82,reduce,reduced,82,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// We need a different set of heuristics for rotated and non-rotated loops.; // If a loop is rotated then the latch is also the backedge, so inserting; // post-inc expressions just before the latch is ideal. To reduce live ranges; // it also makes sense to rewrite terminating conditions to use post-inc; // expressions.; //; // If the loop is not rotated then the latch is not a backedge; the latch; // check is done in the loop head. Adding post-inc expressions before the; // latch will cause overlapping live-ranges of pre-inc and post-inc expressions; // in the loop body. In this case we do *not* want to use post-inc expressions; // in the latch check, and we want to insert post-inc expressions before; // the backedge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:211,reduce,reduce,211,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We need a label after this instruction. With basic block sections, just; // use the end symbol of the section if this is the last instruction of the; // section. This reduces the need for an additional label and also helps; // merging ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:170,reduce,reduces,170,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// We need a vector extract (or mfvsrld). Assume vector operation cost.; // The cost of the load constant for a vector extract is disregarded; // (invariant, easily schedulable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:165,schedul,schedulable,165,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['schedul'],['schedulable']
Energy Efficiency,// We need the custom lowering to make sure that the resulting sequence; // for the 32bit case is efficient on 64bit targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:98,efficient,efficient,98,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// We need the emergency stack slots to be allocated in range of the; // MUBUF/flat scratch immediate offset from the base register, so assign these; // first at the incoming SP position.; //; // TODO: We could try sorting the objects to find a hole in the first bytes; // rather than allocating as close to possible. This could save a lot of space; // on frames with alignment requirements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:43,allocate,allocated,43,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// We need to adapt other uses of Y though. Get a value that matches; // the original value of Y before inversion. While this increases; // immediate instruction count, we have just ensured that all the; // users are freely-invertible, so that 'not' *will* get folded away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:14,adapt,adapt,14,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['adapt'],['adapt']
Energy Efficiency,// We need to allocate the ABI-defined 160-byte base area whenever; // we allocate stack space for our own use and whenever we call another; // function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:14,allocate,allocate,14,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,2,['allocate'],['allocate']
Energy Efficiency,// We need to allocate:; // 2 x NumVars x Expr* - we have an original list expression and an associated; // user-defined mapper for each clause list entry.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,allocate,allocate,14,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,3,['allocate'],['allocate']
Energy Efficiency,// We need to allocate:; // 3 x NumVars x Expr* - we have an original list expression for each clause; // list entry and an equal number of private copies and inits.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,allocate,allocate,14,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,1,['allocate'],['allocate']
Energy Efficiency,// We need to allocate:; // NumVars x Expr* - we have an original list expression for each clause list; // entry.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,allocate,allocate,14,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,2,['allocate'],['allocate']
Energy Efficiency,// We need to allocate:; // NumVars x Expr* - we have an original list expression for each clause; // list entry.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,allocate,allocate,14,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// We need to check that U is based *only* on the alloca, and doesn't; // have other contributions from a select/phi operand.; // TODO: We could check whether getUnderlyingObjects() reduces to one; // object, which would allow looking through phi nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:182,reduce,reduces,182,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// We need to make sure we didn't pre-allocate the stack protector when; // doing this.; // If we already have a stack protector, this will re-assign it to a slot; // that is **not** covering the protected objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:38,allocate,allocate,38,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// We need to reduce the strength of any inlined tail calls. For; // musttail, we have to avoid introducing potential unbounded stack; // growth. For example, if functions 'f' and 'g' are mutually recursive; // with musttail, we can inline 'g' into 'f' so long as we preserve; // musttail on the cloned call to 'f'. If either the inlined call site; // or the cloned call site is *not* musttail, the program already has; // one frame of stack growth, so it's safe to remove musttail. Here is; // a table of example transformations:; //; // f -> musttail g -> musttail f ==> f -> musttail f; // f -> musttail g -> tail f ==> f -> tail f; // f -> g -> musttail f ==> f -> f; // f -> g -> tail f ==> f -> f; //; // Inlined notail calls should remain notail calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:14,reduce,reduce,14,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We only ever need one instance of TrueMatcherImpl, so we create a static; // instance and reuse it to reduce the overhead of the matcher and increase; // the chance of cache hits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:105,reduce,reduce,105,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We only really have 32-bit BFE instructions (and 16-bit on VI).; //; // On SI+ there are 64-bit BFEs, but they are scalar only and there isn't any; // effort to match them now. We want this to be false for i64 cases when the; // extraction isn't restricted to the upper or lower half. Ideally we would; // have some pass reduce 64-bit extracts to 32-bit if possible. Extracts that; // span the midpoint are probably relatively rare, so don't worry about them; // for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:324,reduce,reduce,324,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We only set the ""Offset"" field when it can't be naturally derived; // from the offset and size of the previous section. This reduces; // the noise in the YAML output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp:128,reduce,reduces,128,interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,1,['reduce'],['reduces']
Energy Efficiency,// We perform this optimization only for switches with; // unreachable default case.; // This assumtion will save us from checking if `Condition` is a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:151,power,power,151,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['power'],['power']
Energy Efficiency,// We permit the extend to hoist through basic blocks but this is only; // sensible if the target has extending loads. If you end up lowering back; // into a load and extend during the legalizer then the end result is; // hoisting the extend up to the load.; // Prefer defined extensions to undefined extensions as these are more; // likely to reduce the number of instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:344,reduce,reduce,344,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We prioritize call sites in the dictionary order of the following; // priorities:; //; // 1. Those call sites that are expected to reduce the caller size when; // inlined. Within them, we prioritize those call sites with bigger; // reduction.; //; // 2. Those call sites that have gone through the cost-benefit analysis.; // Currently, they are limited to hot call sites. Within them, we; // prioritize those call sites with higher benefit-to-cost ratios.; //; // 3. Remaining call sites are prioritized according to their costs.; // We add back StaticBonusApplied to determine whether we expect the caller; // to shrink (even if we don't delete the callee).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:134,reduce,reduce,134,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,1,['reduce'],['reduce']
Energy Efficiency,// We rely on the fact that the first 7 NameKind and StoredNameKind; // have the same numerical value. This makes the usual case efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h:129,efficient,efficient,129,interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclarationName.h,1,['efficient'],['efficient']
Energy Efficiency,// We remove links from outside blocks to enable scheduling inside the block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:49,schedul,scheduling,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// We reuse several ScheduleDAGMI and ScheduleDAGMILive; // functions, but to make them happy we must initialize; // the default Scheduler implementation (even if we do not; // run it)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:20,Schedul,ScheduleDAGMI,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,3,['Schedul'],"['ScheduleDAGMI', 'ScheduleDAGMILive', 'Scheduler']"
Energy Efficiency,"// We reuse the VL of the reduction to reduce vsetvli toggles if we can; // prove it is non-zero. For the AVL=0 case, we need the scalar to; // be the result of the reduction operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:39,reduce,reduce,39,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We scanned the old callgraph node, removing invalidated call sites and; // then added back newly found call sites. One thing that can happen is; // that an old indirect call site was deleted and replaced with a new direct; // call. In this case, we have devirtualized a call, and CGSCCPM would like; // to iteratively optimize the new code. Unfortunately, we don't really; // have a great way to detect when this happens. As an approximation, we; // just look at whether the number of indirect calls is reduced and the; // number of direct calls is increased. There are tons of ways to fool this; // (e.g. DCE'ing an indirect call and duplicating an unrelated block with a; // direct call) but this is close enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:506,reduce,reduced,506,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// We should have this assert, but there may be dead SDNodes that never; // materialize as SUnits, so they don't appear to generate liveness.; //assert(SU->NumRegDefsLeft == 0 && ""not all regdefs have scheduled uses"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:201,schedul,scheduled,201,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// We split the operation into a separate G_FADD/G_FMUL + the reduce,; // since the associativity doesn't matter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:62,reduce,reduce,62,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We still need to check that the instruction has no users before we erase; // it, because {SExt, ZExt}Inst Instruction might have other users that was; // not reduced, in such case, we need to keep that instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:161,reduce,reduced,161,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,1,['reduce'],['reduced']
Energy Efficiency,// We store a decomposed APSInt with the data allocated by ASTContext if; // BitWidth > 64. The memory may be shared between multiple; // TemplateArgument instances.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h:46,allocate,allocated,46,interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,1,['allocate'],['allocated']
Energy Efficiency,// We support -falign-loops=N where N is a power of 2. GCC supports more; // forms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:43,power,power,43,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['power'],['power']
Energy Efficiency,"// We tentatively reserve the last registers (skipping the last registers; // which may contain VCC, FLAT_SCR, and XNACK). After register allocation,; // we'll replace these with the ones immediately after those which were; // really allocated. In the prologue copies will be inserted from the; // argument to these reserved registers.; // Without HSA, relocations are used for the scratch pointer and the; // buffer resource setup is always inserted in the prologue. Scratch wave; // offset is still in an input SGPR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:234,allocate,allocated,234,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// We track whether the input is viable for all power-of-2 strides 2^1, 2^2,; // and 2^3 simultaneously. This is because we may have ambiguity with; // partially undef inputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:48,power,power-of-,48,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"// We use a pointer union between a single `MachineMemOperand` pointer and; // a pointer to an array of `MachineMemOperand` pointers. This is null when; // the number of these is zero, the single pointer variant used when the; // number is one, and the array is used for larger numbers.; //; // The array is allocated via the `SelectionDAG`'s allocator and so will; // always live until the DAG is cleaned up and doesn't require ownership here.; //; // We can't use something simpler like `TinyPtrVector` here because `SDNode`; // subclasses aren't managed in a conforming C++ manner. See the comments on; // `SelectionDAG::MorphNodeTo` which details what all goes on, but the; // constraint here is that these don't manage memory with their constructor or; // destructor and can be initialized to a good state even if they start off; // uninitialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:308,allocate,allocated,308,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['allocate'],['allocated']
Energy Efficiency,"// We use a pointer use visitor to track how an alloca is being used.; // The goal is to be able to answer the following three questions:; // 1. Should this alloca be allocated on the frame instead.; // 2. Could the content of the alloca be modified prior to CoroBegn, which would; // require copying the data from alloca to the frame after CoroBegin.; // 3. Is there any alias created for this alloca prior to CoroBegin, but used; // after CoroBegin. In that case, we will need to recreate the alias after; // CoroBegin based off the frame. To answer question 1, we track two things:; // a. List of all BasicBlocks that use this alloca or any of the aliases of; // the alloca. In the end, we check if there exists any two basic blocks that; // cross suspension points. If so, this alloca must be put on the frame. b.; // Whether the alloca or any alias of the alloca is escaped at some point,; // either by storing the address somewhere, or the address is used in a; // function call that might capture. If it's ever escaped, this alloca must be; // put on the frame conservatively.; // To answer quetion 2, we track through the variable MayWriteBeforeCoroBegin.; // Whenever a potential write happens, either through a store instruction, a; // function call or any of the memory intrinsics, we check whether this; // instruction is prior to CoroBegin. To answer question 3, we track the offsets; // of all aliases created for the alloca prior to CoroBegin but used after; // CoroBegin. std::optional is used to be able to represent the case when the; // offset is unknown (e.g. when you have a PHINode that takes in different; // offset values). We cannot handle unknown offsets and will assert. This is the; // potential issue left out. An ideal solution would likely require a; // significant redesign.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:167,allocate,allocated,167,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// We use a simple greedy algorithm.; // - Given a chain of length N, find all prefixes that; // (a) are not longer than the max register length, and; // (b) are a power of 2.; // - Starting from the longest prefix, try to create a vector of that length.; // - If one of them works, great. Repeat the algorithm on any remaining; // elements in the chain.; // - If none of them work, discard the first element and repeat on a chain; // of length N-1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:164,power,power,164,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['power'],['power']
Energy Efficiency,"// We use ldg (i.e. ld.global.nc) for invariant loads from the global address; // space.; //; // We have two ways of identifying invariant loads: Loads may be explicitly; // marked as invariant, or we may infer them to be invariant.; //; // We currently infer invariance for loads from; // - constant global variables, and; // - kernel function pointer params that are noalias (i.e. __restrict) and; // never written to.; //; // TODO: Perform a more powerful invariance analysis (ideally IPO, and ideally; // not during the SelectionDAG phase).; //; // TODO: Infer invariance only at -O2. We still want to use ldg at -O0 for; // explicitly invariant loads because these are how clang tells us to use ldg; // when the user uses a builtin.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:450,power,powerful,450,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['power'],['powerful']
Energy Efficiency,"// We use llvm::SmallVector as the underlying container for the following; // reasons:; //; // * Range sets are usually very simple, 1 or 2 ranges.; // That's why llvm::ImmutableSet is not perfect.; //; // * Ranges in sets are NOT overlapping, so it is natural to keep them; // sorted for efficient operations and queries. For this reason,; // llvm::SmallSet doesn't fit the requirements, it is not sorted when it; // is a vector.; //; // * Range set operations usually a bit harder than add/remove a range.; // Complex operations might do many of those for just one range set.; // Formerly it used to be llvm::ImmutableSet, which is inefficient for our; // purposes as we want to make these operations BOTH immutable AND; // efficient.; //; // * Iteration over ranges is widespread and a more cache-friendly; // structure is preferred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h:289,efficient,efficient,289,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,2,['efficient'],['efficient']
Energy Efficiency,"// We use the SSAUpdater to insert PHI nodes for the target addresses of; // indirect branches. We don't actually need the full power of the SSA updater; // in this particular case as we always have immediately available values, but; // this avoids us having to re-implement the PHI construction logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:128,power,power,128,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['power'],['power']
Energy Efficiency,"// We use the multiplicative formula:; // n(n-1)(n-2)...(n-(k-1)) / k(k-1)(k-2)...1 .; // At each iteration, we take the n-th term of the numeral and divide by the; // (k-n)th term of the denominator. This division will always produce an; // integral result, and helps reduce the chance of overflow in the; // intermediate computations. However, we can still overflow even when the; // final result would fit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:269,reduce,reduce,269,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We used ATLAS fully-split xAOD for testing, which is a rather unbalanced TTree, 10K branches,; // with 8K having baskets smaller than 512 bytes. To achieve good I/O performance ATLAS uses auto-flush 100,; // resulting in the smallest baskets being ~300-400 bytes, so this change increases their memory by about 8k*150B =~ 1MB,; // at the same time it significantly reduces the number of total baskets because it ensures that all 100 entries can be; // stored in a single basket (the old optimization tended to make baskets too small). In a toy example with fixed sized; // structures we found a factor of 2 fewer baskets needed in the new scheme.; // rounds up, increases basket size to ensure all entries fit into single basket as intended",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:368,reduce,reduces,368,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['reduce'],['reduces']
Energy Efficiency,"// We want to find a combination of instructions that; // gets generated when an i64 gets clamped to i16.; // The corresponding pattern is:; // G_MAX / G_MAX for i16 <= G_TRUNC i64.; // This can be efficiently written as following:; // v_cvt_pk_i16_i32 v0, v0, v1; // v_med3_i32 v0, Clamp_Min, v0, Clamp_Max",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPreLegalizerCombiner.cpp:198,efficient,efficiently,198,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPreLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPreLegalizerCombiner.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// We want to interleave small loops in order to reduce the loop overhead and; // potentially expose ILP opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:49,reduce,reduce,49,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['reduce'],['reduce']
Energy Efficiency,// We want to multiply across all the factors with the same power so that; // we can raise them to that power as a single entity. Build a mini tree; // for that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:60,power,power,60,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['power'],['power']
Energy Efficiency,"// We want to reliably handle any conditional branch terminators in the; // MBB, so we manually analyze the branch. We can handle all of the; // permutations here, including ones that analyze branch cannot.; //; // The approach is to walk backwards across the terminators, resetting at; // any unconditional non-indirect branch, and track all conditional edges; // to basic blocks as well as the fallthrough or unconditional successor; // edge. For each conditional edge, we track the target and the opposite; // condition code in order to inject a ""no-op"" cmov into that successor; // that will harden the predicate. For the fallthrough/unconditional; // edge, we inject a separate cmov for each conditional branch with; // matching condition codes. This effectively implements an ""and"" of the; // condition flags, even if there isn't a single condition flag that would; // directly implement that. We don't bother trying to optimize either of; // these cases because if such an optimization is possible, LLVM should; // have optimized the conditional *branches* in that way already to reduce; // instruction count. This late, we simply assume the minimal number of; // branch instructions is being emitted and use that to guide our cmov; // insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1087,reduce,reduce,1087,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['reduce'],['reduce']
Energy Efficiency,// We will handle the LR in the prologue/epilogue; // and allocate space on the stack ourselves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp:58,allocate,allocate,58,interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// We would like to assert that we actually read / wrote all the bytes that we; // expected to for this record, but unfortunately we can't do this. Some; // producers such as MASM over-allocate for certain types of records and; // commit the extraneous data, so when reading we can't be sure every byte; // will have been read. And when writing we over-allocate temporarily since; // we don't know how big the record is until we're finished writing it, so; // even though we don't commit the extraneous data, we still can't guarantee; // we're at the end of the allocated data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CodeViewRecordIO.cpp:185,allocate,allocate,185,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CodeViewRecordIO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/CodeViewRecordIO.cpp,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// We would like to restrict this hazard recognizer to only; // post-RA scheduling; we can tell that we're post-RA because we don't; // track VRegLiveness.; // Cortex-M7: TRM indicates that there is a single ITCM bank and two DTCM; // banks banked on bit 2. Assume that TCMs are in use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:72,schedul,scheduling,72,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// We would like to split the SP adjustment to reduce prologue/epilogue; // as following instructions. In this way, the offset of the callee saved; // register could fit in a single store. Supposed that the first sp adjust; // amount is 2032.; // add sp,sp,-2032; // sw ra,2028(sp); // sw s0,2024(sp); // sw s1,2020(sp); // sw s3,2012(sp); // sw s4,2008(sp); // add sp,sp,-64",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:47,reduce,reduce,47,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// We would like to split the SP adjustment to reduce prologue/epilogue; // as following instructions. In this way, the offset of the callee saved; // register could fit in a single store.; // e.g.; // addi.d $sp, $sp, -2032; // st.d $ra, $sp, 2024; // st.d $fp, $sp, 2016; // addi.d $sp, $sp, -16",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp:47,reduce,reduce,47,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchFrameLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// We'll often find the declarations are in the same order. Handle this; // case (and the special case of only one declaration) efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:128,efficient,efficiently,128,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// We're creating a complex value here, so we need to; // allocate storage for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:58,allocate,allocate,58,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// We're going to try and merge each register into a wider power-of-2 type,; // so we ought to have an even number of registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:59,power,power-of-,59,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['power'],['power-of-']
Energy Efficiency,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:9,schedul,scheduling,9,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// We're trying to minimize the number of instructions. If we have one; // group, using one of andi/andis can break even. If we have three; // groups, we can use both andi and andis and break even (to use both; // andi and andis we also need to or the results together). We need four; // groups if we also need to rotate. To use andi/andis we need to do more; // than break even because rotate-and-mask instructions tend to be easier; // to schedule.; // FIXME: We've biased here against using andi/andis, which is right for; // POWER cores, but not optimal everywhere. For example, on the A2,; // andi/andis have single-cycle latency whereas the rotate-and-mask; // instructions take two cycles, and it would be better to bias toward; // andi/andis in break-even cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:441,schedul,schedule,441,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,2,"['POWER', 'schedul']","['POWER', 'schedule']"
Energy Efficiency,"// We've been asked to allocate an object for the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchClones.cxx:23,allocate,allocate,23,tree/tree/src/TBranchClones.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchClones.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// Weights for adaptive kernels",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooNDKeysPdf.h:15,adapt,adaptive,15,roofit/roofit/inc/RooNDKeysPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooNDKeysPdf.h,1,['adapt'],['adaptive']
Energy Efficiency,// What do we do with different size?; // copy are same size.; // Will introduce other hooks for different size:; // * extract cost.; // * build_sequence cost.; // Copy from (resp. to) GPR to (resp. from) FPR involves FMOV.; // FIXME: This should be deduced from the scheduling model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp:267,schedul,scheduling,267,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// When Forward Scheduling is enabled, there is no stall if ProdMI and ConsMI; // are scheduled in consecutive packets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:16,Schedul,Scheduling,16,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,2,"['Schedul', 'schedul']","['Scheduling', 'scheduled']"
Energy Efficiency,"// When GV's init value is all 0, omit the EmuTlsTmplVar and let; // the emutls library function to reset newly allocated TLS variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:112,allocate,allocated,112,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// When TinyCore with Duplexes is enabled, this function is used to translate; // tiny-instructions to big-instructions and vice versa to get the slot; // consumption.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:155,consumption,consumption,155,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,1,['consumption'],['consumption']
Energy Efficiency,// When X is a power-of-two or zero and zero input is poison:; // ctlz(i32 X) ^ 31 --> cttz(X); // cttz(i32 X) ^ 31 --> ctlz(X),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:15,power,power-of-two,15,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['power'],['power-of-two']
Energy Efficiency,"// When a nobits section is followed by a non-nobits section or fill; // in the same segment, we allocate the file space for it. This behavior; // matches linkers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:97,allocate,allocate,97,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// When called via TMapFile (e.g. Update()) make sure that the dictionary; // gets allocated on the heap and not in the mapped file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:83,allocate,allocated,83,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,5,['allocate'],['allocated']
Energy Efficiency,// When composing 'distribute' with 'for' (e.g. as in 'distribute; // parallel for') we need to use the 'distribute'; // chunk lower and upper bounds rather than the whole loop iteration; // space. These are parameters to the outlined function for 'parallel'; // and we copy the bounds of the previous schedule into the; // the current ones.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:302,schedul,schedule,302,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// When computing imports we only added the variables and functions being; // imported to the export list. We also need to mark any references and calls; // they make as exported as well. We do this here, as it is more efficient; // since we may import the same values multiple times into different modules; // during the import computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:219,efficient,efficient,219,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// When enabling tracking load instructions, we always use; // __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:96,reduce,reduce,96,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// When removing, we will have to check both beginning and ending of the region.; // When inserting, we will only have to check if we are inserting NewMI in front; // of a scheduling region and do not need to check the ending since we will only; // ever be inserting before an already existing MI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:172,schedul,scheduling,172,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// When scheduling a Phi it is better to start at the late cycle and go; // backwards. The default order may insert the Phi too far away from; // its first dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,schedul,scheduling,8,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// When scheduling a dot cur instruction, check if there is an instruction; // that can use the dot cur in the same packet. If so, we'll attempt to; // schedule it before other instructions. We only do this if the load has a; // single zero-latency use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:8,schedul,scheduling,8,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// When scheduling bottom-up, use greater-than as the queue priority.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:8,schedul,scheduling,8,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// When streaming out only the filled chunk is saved.; // When reading back only the memory needed for that filled part gets; // allocated. We need to check whether the allowed chunk size is; // bigger than the allocated size. If fCoordinateAllocationSize is; // set to -1 this chunk has been allocated by the streamer and the; // buffer allocation size is defined by [fCoordinatesSize]. In that; // case we need to compare fCoordinatesSize to; // fSingleCoordinateSize * fContent->GetSize(); // to determine whether we need to expand the buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:129,allocate,allocated,129,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,3,['allocate'],['allocated']
Energy Efficiency,"// When the mask is a power-of-2 constant and op0 is a shifted-power-of-2; // constant, test if the shift amount equals the offset bit index:; // (ShiftC << X) & C --> X == (log2(C) - log2(ShiftC)) ? C : 0; // (ShiftC >> X) & C --> X == (log2(ShiftC) - log2(C)) ? C : 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:22,power,power-of-,22,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['power'],['power-of-']
Energy Efficiency,"// When the scheduler detects a stall, it will call AdvanceCycle() without; // emitting any instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:12,schedul,scheduler,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// When the simplified type and the from type are not the same, use the type; // simplifier to reduce the type, then reuse cast_retty_impl to get the; // resultant type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:95,reduce,reduce,95,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,1,['reduce'],['reduce']
Energy Efficiency,"// When there is an SVE area on the stack, always allocate the; // callee-saves and spills/locals separately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:50,allocate,allocate,50,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// When there is no integer popcount instruction (FEAT_CSSC isn't available),; // it can be more efficiently lowered to the following sequence that uses; // AdvSIMD registers/instructions as long as the copies to/from the AdvSIMD; // registers are cheap.; // FMOV D0, X0 // copy 64-bit int to vector, high bits zero'd; // CNT V0.8B, V0.8B // 8xbyte pop-counts; // ADDV B0, V0.8B // sum 8xbyte pop-counts; // UMOV X0, V0.B[0] // copy byte result back to integer reg; //; // For 128 bit vector popcounts, we lower to the following sequence:; // cnt.16b v0, v0 // v8s16, v4s32, v2s64; // uaddlp.8h v0, v0 // v8s16, v4s32, v2s64; // uaddlp.4s v0, v0 // v4s32, v2s64; // uaddlp.2d v0, v0 // v2s64; //; // For 64 bit vector popcounts, we lower to the following sequence:; // cnt.8b v0, v0 // v4s16, v2s32; // uaddlp.4h v0, v0 // v4s16, v2s32; // uaddlp.2s v0, v0 // v2s32",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp:97,efficient,efficiently,97,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:149,allocate,allocated,149,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// When using SP to access frame objects, we need to add RVV stack size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |-- MFI.getStackSize(); // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP; //; // The total amount of padding surrounding RVV objects is described by; // RVV->getRVVPadding() and it can be zero. It allows us to align the RVV; // objects to the required alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:133,allocate,allocated,133,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// When we are just looking for a reduced cost per use, don't break any; // hints, and only evict smaller spill weights.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:34,reduce,reduced,34,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,1,['reduce'],['reduced']
Energy Efficiency,// When we have a file provide a heap-allocated wrapper for the memory buffer; // to match the ownership semantics for File.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:38,allocate,allocated,38,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// When we have target data, we can reduce the GEP down to the value in bytes; // added to the address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:36,reduce,reduce,36,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// When we'd use andi/andis, we bias toward using the rotates (andi only; // has a record form, and is cracked on POWER cores). However, when using; // general 64-bit constant formation, bias toward the constant form,; // because that exposes more opportunities for CSE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:114,POWER,POWER,114,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['POWER'],['POWER']
Energy Efficiency,// Whether or not to use full register names on PowerPC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h:48,Power,PowerPC,48,interpreter/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h,1,['Power'],['PowerPC']
Energy Efficiency,// Whether this candidate should be scheduled at top/bottom.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:36,schedul,scheduled,36,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"// While Available queue is not empty, grab the node with the highest; // priority. If it is not ready put it back. Schedule the node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:116,Schedul,Schedule,116,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,3,['Schedul'],['Schedule']
Energy Efficiency,"// While AvailableQueue is not empty, grab the node with the highest; // priority. If it is not ready put it back. Schedule the node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:115,Schedul,Schedule,115,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,1,['Schedul'],['Schedule']
Energy Efficiency,"// While raw uses of blockaddress need to be relocated, differences; // between two of them don't when they are for labels in the same; // function. This is a common idiom when creating a table for the; // indirect goto extension, so we handle it efficiently here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:247,efficient,efficiently,247,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// While we could change the other users of OrigOp to use freeze(OrigOp), that; // potentially reduces their optimization potential, so let's only do this iff; // the OrigOp is only used by the freeze.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,reduce,reduces,95,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['reduce'],['reduces']
Energy Efficiency,// Wide divides are _very_ slow. Try to reduce the width of the divide if; // possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:40,reduce,reduce,40,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Widen SrcTy to WideTy. This does not affect the result, but since the; // user requested this size, it is probably better handled than SrcTy and; // should reduce the total number of legalization artifacts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:159,reduce,reduce,159,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['reduce'],['reduce']
Energy Efficiency,// Widen non-power-of-2 loads to the alignment if needed,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:13,power,power-of-,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['power'],['power-of-']
Energy Efficiency,"// Widen non-power-of-2 vectors. Such types cannot be split right now,; // and computeRegisterProperties will override ""split"" with ""widen"",; // which can cause other issues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:13,power,power-of-,13,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,// Widen odd vectors to next power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:29,power,power,29,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['power'],['power']
Energy Efficiency,// Widen scalar fp logic ops to vector to reduce isel patterns.; // FIXME: Can we do this during lowering/combine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:42,reduce,reduce,42,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// Widen subvectors to the full width rather than promoting integer; // elements. This is better because:; //; // (a) it means that we can handle the ABI for passing and returning; // sub-128 vectors without having to handle them as legal types.; //; // (b) we don't have instructions to extend on load and truncate on store,; // so promoting the integers is less efficient.; //; // (c) there are no multiplication instructions for the widest integer; // type (v2i64).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:364,efficient,efficient,364,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['efficient'],['efficient']
Energy Efficiency,"// Win64 C++ EH needs to allocate the UnwindHelp object at some fixed offset; // relative to RSP after the prologue. Find the offset of the last fixed; // object, so that we can allocate a slot immediately following it. If there; // were no fixed objects, use offset -SlotSize, which is immediately after the; // return address. Fixed objects have negative frame indices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:25,allocate,allocate,25,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// With 28 different fonts and 16 colors, we could in principle have; // as many as 448 different GCs. But in practice, a single page of; // HTML will typically have much less than this. So we won't try to; // keep all GCs on hand. Instead, we'll keep around the most recently; // used GCs and allocate new ones as necessary.; //; // The following structure is used to build a cache of GCs in the; // main widget object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:294,allocate,allocate,294,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['allocate'],['allocate']
Energy Efficiency,"// With C as a power of 2 and C != 0 and C != INT_MIN:; // icmp eq Abs(X) C ->; // (icmp eq A, C) | (icmp eq A, -C); // icmp ne Abs(X) C ->; // (icmp ne A, C) & (icmp ne A, -C); // Both of these patterns can be better optimized in; // DAGCombiner::foldAndOrOfSETCC. Note this only applies for scalar; // integers which is checked above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:15,power,power,15,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"// With a 256-bit vector, we can insert into the zero element efficiently; // using a blend if we have AVX or AVX2 and the right data type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,efficient,efficiently,62,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// With a fixed ABI, allocate fixed registers before user arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp:21,allocate,allocate,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,3,['allocate'],['allocate']
Energy Efficiency,"// With local visibility enabled, we track the owning module even for local; // declarations. We create the TU decl early and may not yet know what the; // LangOpts are, so conservatively allocate the storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:188,allocate,allocate,188,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// With more than simd_degree chunks, we need to recurse. Start by dividing; // the input into left and right subtrees. (Note that this is only optimal; // as long as the SIMD degree is a power of 2. If we ever get a SIMD degree; // of 3 or something, we'll need a more complicated strategy.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:188,power,power,188,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['power'],['power']
Energy Efficiency,"// Work around the fact that SIInstrInfo::fixImplicitOperands modifies; // implicit operands which come from the MCInstrDesc, which can fool; // ScheduleDAGInstrs::addPhysRegDataDeps into treating them as implicit; // pseudo operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:145,Schedul,ScheduleDAGInstrs,145,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['Schedul'],['ScheduleDAGInstrs']
Energy Efficiency,"// Work scheduling of the tail: multiple slots work on the same file.; // Every slot still has its own page source but these page sources may open the same file.; // Again, we need to skip empty files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:8,schedul,scheduling,8,tree/dataframe/src/RNTupleDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx,1,['schedul'],['scheduling']
Energy Efficiency,"// Workaround for the Global Scheduler. Sometimes, it creates; // A4_ext as a Pseudo instruction and calls this function to see if; // it can be added to an existing bundle. Since the instruction doesn't; // belong to any BB yet, we can't use getUnits API.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:29,Schedul,Scheduler,29,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['Schedul'],['Scheduler']
Energy Efficiency,"// Would this split be possible to allocate?; // Never allocate all gaps, we wouldn't be making progress.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:35,allocate,allocate,35,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// Writable mapfile is allocated in mapped memory. This object should; // not be deleted by ::operator delete(), because it is needed if we; // want to connect later to the file again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:23,allocate,allocated,23,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['allocate'],['allocated']
Energy Efficiency,// Write ReducerWorkItem to tmp file,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp:9,Reduce,ReducerWorkItem,9,interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp,1,['Reduce'],['ReducerWorkItem']
Energy Efficiency,"// Write to monitoring system",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx:12,monitor,monitoring,12,proof/proofplayer/src/TPerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// Write to monitoring system, if requested",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx:12,monitor,monitoring,12,proof/proofplayer/src/TPerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPerfStats.cxx,1,['monitor'],['monitoring']
Energy Efficiency,// X & (-X) is always a power of two or zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,power,power,24,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,// X & -C == -C -> X > u ~C; // X & -C != -C -> X <= u ~C; // iff C is a power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:73,power,power,73,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,// X & -X is a power of two or zero. So we can cap the value at max power of; // two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,power,power,15,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['power'],['power']
Energy Efficiency,"// X can't possibly equal the higher-precision constant, so reduce any; // equality comparison.; // TODO: Other predicates can be handled via getFCmpCode().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:60,reduce,reduce,60,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['reduce'],['reduce']
Energy Efficiency,// X shift (A srem C) -> X shift (A and (C - 1)) iff C is a power of 2.; // Because shifts by negative values (which could occur if A were negative); // are undefined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:60,power,power,60,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['power'],['power']
Energy Efficiency,"// X urem 1 --> 0; // If constant is a power of two, fold into a zext(trunc(LHS)).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:39,power,power,39,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['power'],['power']
Energy Efficiency,"// X urem Y -> X and Y-1, where Y is a power of 2,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:39,power,power,39,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['power'],['power']
Energy Efficiency,// X | C == C --> X <=u C; // X | C != C --> X >u C; // iff C+1 is a power of 2 (C is a bitmask of the low bits),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:69,power,power,69,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,// X+C <u C2 -> (X & -C2) == C; // iff C & (C2-1) == 0; // C2 is a power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:67,power,power,67,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,// X+C >u C2 -> (X & ~C2) != C; // iff C & C2 == 0; // C2+1 is a power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:65,power,power,65,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power']
Energy Efficiency,// XOP can efficiently perform BITREVERSE with VPPERM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,efficient,efficiently,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// XXX: We are running this after RA, so creating virtual registers will; // cause an assertion failure in the PostRA scheduling pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp:118,schedul,scheduling,118,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// XrdCl only allocates the object is the status was OK",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/RRawFileNetXNG.cxx:14,allocate,allocates,14,net/netxng/src/RRawFileNetXNG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/RRawFileNetXNG.cxx,1,['allocate'],['allocates']
Energy Efficiency,"// YAMLIn dynamically allocates for Interface file and in case of error,; // memory leak will occur unless wrapped around unique_ptr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp:22,allocate,allocates,22,interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// You would expect straight-line code between call-frame setup and; // call-frame destroy. You would be wrong. There are circumstances (e.g.; // CMOV_GR8 expansion of a select that feeds a function call!) where we can; // end up with the setup and the destroy in different basic blocks.; // This is bad, and breaks SP adjustment.; // So, check that all of the frames in the function are closed inside; // the same block, and, for good measure, that there are no nested frames.; //; // If any call allocates more argument stack memory than the stack; // probe size, don't do this optimization. Otherwise, this pass; // would need to synthesize additional stack probe calls to allocate; // memory for arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:498,allocate,allocates,498,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,2,['allocate'],"['allocate', 'allocates']"
Energy Efficiency,"// Yup, it does, keep the reduced version...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:26,reduce,reduced,26,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// Yup, it does, we delete the old module, and continue trying; // to reduce the testcase...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:70,reduce,reduce,70,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// [basic.stc.dynamic.allocation] (on the return value of an allocation; // function):; // ""The order, contiguity, and initial value of storage allocated by; // successive calls to an allocation function are unspecified.""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:144,allocate,allocated,144,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// [returned ptr value - sizeof(size_t) * 2 : same + sizeof(size_t) [ -> Requested alignment; // [returned ptr value - sizeof(size_t) : same + sizeof(size_t) [ -> Offset between the return ptr value and the allocated start; // [returned ptr value : same + size [ -> Real data start; // [returned ptr value + size : same + 1 [ -> MEM_MAGIC / Integrity marker; //; // Per C++ standard 3.11 Alignment [basic.align]:; // Every alignment value shall be a non-negative integral power of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/newdelete/src/NewDelete.cxx:207,allocate,allocated,207,core/newdelete/src/NewDelete.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/newdelete/src/NewDelete.cxx,2,"['allocate', 'power']","['allocated', 'power']"
Energy Efficiency,// \brief PowerPC MMA types with auto numeration,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:10,Power,PowerPC,10,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['Power'],['PowerPC']
Energy Efficiency,// \returns true if it's beneficial on this subtarget for the scheduler to; // cluster stores as well as loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:62,schedul,scheduler,62,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['schedul'],['scheduler']
Energy Efficiency,// __builtin_ppc_get_timebase is GCC 4.8+'s PowerPC-specific name for what we; // call __builtin_readcyclecounter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:44,Power,PowerPC-specific,44,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['Power'],['PowerPC-specific']
Energy Efficiency,"// __chkstk takes the number of words to allocate on the stack in R4, and; // returns the stack adjustment in number of bytes in R4. This will not; // clober any other registers (other than the obvious lr).; //; // Although, technically, IP should be considered a register which may be; // clobbered, the call itself will not touch it. Windows on ARM is a pure; // thumb-2 environment, so there is no interworking required. As a result, we; // do not expect a veneer to be emitted by the linker, clobbering IP.; //; // Each module receives its own copy of __chkstk, so no import thunk is; // required, again, ensuring that IP is not clobbered.; //; // Finally, although some linkers may theoretically provide a trampoline for; // out of range calls (which is quite common due to a 32M range limitation of; // branches for Thumb), we can generate the long-call version via; // -mcmodel=large, alleviating the need for the trampoline which may clobber; // IP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:41,allocate,allocate,41,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// `-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true`.; //; // - ""NotesAsWarnings"" (boolean). If set to true, the checker will emit a; // warning for each uninitialized field, as opposed to emitting one warning; // per constructor call, and listing the uninitialized fields that belongs; // to it in notes. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:NotesAsWarnings=true`.; //; // - ""CheckPointeeInitialization"" (boolean). If set to false, the checker will; // not analyze the pointee of pointer/reference fields, and will only check; // whether the object itself is initialized. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:CheckPointeeInitialization=true`.; //; // TODO: With some clever heuristics, some pointers should be dereferenced; // by default. For example, if the pointee is constructed within the; // constructor call, it's reasonable to say that no external object; // references it, and we wouldn't generate multiple report on the same; // pointee.; //; // - ""IgnoreRecordsWithField"" (string). If supplied, the checker will not; // analyze structures that have a field with a name or type name that; // matches the given pattern. Defaults to """".; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind""`.; //; // - ""IgnoreGuardedFields"" (boolean). If set to true, the checker will analyze; // _syntactically_ whether the found uninitialized object is used without a; // preceding assert call. Defaults to false.; //; // `-analyzer-config \; // optin.cplusplus.UninitializedObject:IgnoreGuardedFields=true`.; //; // Most of the following methods as well as the checker itself is defined in; // UninitializedObjectChecker.cpp.; //; // Some methods are implemented in UninitializedPointee.cpp, to reduce the; // complexity of the main checker file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:2684,reduce,reduce,2684,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,1,['reduce'],['reduce']
Energy Efficiency,// `-dynamiclib' for MacOS X/PowerPC,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:29,Power,PowerPC,29,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// `-falign-functions` indicates that the functions should be aligned to a; // 16-byte boundary.; //; // `-falign-functions=1` is the same as `-fno-align-functions`.; //; // The scalar `n` in `-falign-functions=n` must be an integral value between; // [0, 65536]. If the value is not a power-of-two, it will be rounded up to; // the nearest power-of-two.; //; // If we return `0`, the frontend will default to the backend's preferred; // alignment.; //; // NOTE: icc only allows values between [0, 4096]. icc uses `-falign-functions`; // to mean `-falign-functions=16`. GCC defaults to the backend's preferred; // alignment. For unaligned functions, we default to the backend's preferred; // alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:286,power,power-of-two,286,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,2,['power'],['power-of-two']
Energy Efficiency,"// a helper to delete objects allocated before jitting, so that the jitter can share data with lazily jitted code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:30,allocate,allocated,30,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,3,['allocate'],['allocated']
Energy Efficiency,"// a positive charge in B field makes a left-handed helix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoHelix.h:14,charge,charge,14,geom/geom/inc/TGeoHelix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoHelix.h,1,['charge'],['charge']
Energy Efficiency,"// adaboost adapted to regression",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBDT.h:12,adapt,adapted,12,tmva/tmva/inc/TMVA/MethodBDT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBDT.h,1,['adapt'],['adapted']
Energy Efficiency,"// adaptStartOfLine will break after lines starting with /** if the comment; // is broken anywhere. Avoid emitting this break twice here.; // Example: in /** longtextcomesherethatbreaks */ (with ColumnLimit 20) will; // insert a break after /**, so this code must not insert the same break.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,adapt,adaptStartOfLine,3,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['adapt'],['adaptStartOfLine']
Energy Efficiency,"// adaptive KDE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx:3,adapt,adaptive,3,tmva/tmva/src/KDEKernel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// adaptive sampling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/FrequentistCalculator.h:3,adapt,adaptive,3,roofit/roostats/inc/RooStats/FrequentistCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/FrequentistCalculator.h,6,['adapt'],['adaptive']
Energy Efficiency,"// adaptive sampling checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:3,adapt,adaptive,3,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// adaptive volume; // -----------------------------------------------------------------------; // TODO: optimize, perhaps multi stage with broadening limits,; // or a different root finding method entirely,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx:3,adapt,adaptive,3,tmva/tmva/src/MethodPDERS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// adaptive width",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:3,adapt,adaptive,3,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// allocHungoffUses - this is more complicated than the generic; // User::allocHungoffUses, because we have to allocate Uses for the incoming; // values and pointers to the incoming blocks, all in one allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:111,allocate,allocate,111,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['allocate'],['allocate']
Energy Efficiency,"// allocate Fisher coefficients",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFisher.cxx:3,allocate,allocate,3,tmva/tmva/src/MethodFisher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFisher.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate Fisher coefficients (use fNvars, and set the non-used ones to zero. Might; // be even less storage space on average than storing also the mapping used otherwise; // can always be changed relatively easy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx:3,allocate,allocate,3,tmva/tmva/src/DecisionTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx,2,['allocate'],['allocate']
Energy Efficiency,"// allocate GSL interpolation object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/Interpolator.cxx:3,allocate,allocate,3,math/mathmore/src/Interpolator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/Interpolator.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate a GSLDerivator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/Derivator.cxx:3,allocate,allocate,3,math/mathmore/src/Derivator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/Derivator.cxx,2,['allocate'],['allocate']
Energy Efficiency,// allocate a environment entry,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c:3,allocate,allocate,3,interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libear/ear.c,1,['allocate'],['allocate']
Energy Efficiency,"// allocate a new object based on the class found",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:3,allocate,allocate,3,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,1,['allocate'],['allocate']
Energy Efficiency,// allocate a page,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:3,allocate,allocate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// allocate a tuple for the base classes, special case for first base",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx:3,allocate,allocate,3,bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate all basic blocks immediately, to handle forward references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:3,allocate,allocate,3,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// allocate and initialize GSL interpolation object with data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/Interpolator.cxx:3,allocate,allocate,3,math/mathmore/src/Interpolator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/Interpolator.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate and register new chunk and put it on the freelist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:3,allocate,allocate,3,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,2,['allocate'],['allocate']
Energy Efficiency,"// allocate arrays",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:3,allocate,allocate,3,hist/hist/src/TH2Poly.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate bin in chunk",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:3,allocate,allocate,3,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate color now (can be delayed when we have a large colormap)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:3,allocate,allocate,3,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate entry, even if no dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx:3,allocate,allocate,3,html/src/TDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate here only the first time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx:3,allocate,allocate,3,math/fumili/src/TFumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate integral array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:3,allocate,allocate,3,hist/hist/src/THnBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate list of division points",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:3,allocate,allocate,3,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate list of pointers, if it was not done before",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:3,allocate,allocate,3,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate memeory for data reading from query",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLStatement.cxx:3,allocate,allocate,3,sql/mysql/src/TMySQLStatement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLStatement.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:3,allocate,allocate,3,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate memory for some book-keeping arrays",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCIntegrator.cxx:3,allocate,allocate,3,roofit/roofitcore/src/RooMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCIntegrator.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLInterpolator.cxx:3,allocate,allocate,3,math/mathmore/src/GSLInterpolator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLInterpolator.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate space for Nxy vertex points",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx:3,allocate,allocate,3,graf3d/g3d/src/TXTRU.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate space for Nz sections",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx:3,allocate,allocate,3,graf3d/g3d/src/TXTRU.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx,1,['allocate'],['allocate']
Energy Efficiency,// allocate space for exactly one operand,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,allocate,allocate,3,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,6,['allocate'],['allocate']
Energy Efficiency,// allocate space for exactly three operands,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:3,allocate,allocate,3,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['allocate'],['allocate']
Energy Efficiency,// allocate space for exactly two operands,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,allocate,allocate,3,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,9,['allocate'],['allocate']
Energy Efficiency,// allocate space for exactly zero operands,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,allocate,allocate,3,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,6,['allocate'],['allocate']
Energy Efficiency,"// allocate space to track the sequence of complementarity gaps,; // residual norms, and merit functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpSolverBase.cxx:3,allocate,allocate,3,math/quadp/src/TQpSolverBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpSolverBase.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate special thread for THttpServer, it will be automatically used by web window",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx:3,allocate,allocate,3,tutorials/webgui/ping/ping.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate the output string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/filter.cxx:3,allocate,allocate,3,documentation/doxygen/filter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/filter.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// allocate workspace memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGrid.cxx:3,allocate,allocate,3,roofit/roofitcore/src/RooGrid.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGrid.cxx,2,['allocate'],['allocate']
Energy Efficiency,"// allocate, deallocate nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:3,allocate,allocate,3,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['allocate'],['allocate']
Energy Efficiency,"// allocated in class (not in the 'nearest' method) for better performance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/KDTree.h:3,allocate,allocated,3,math/mathcore/src/CDT/KDTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/KDTree.h,1,['allocate'],['allocated']
Energy Efficiency,// allocates; may return null,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:3,allocate,allocates,3,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['allocate'],['allocates']
Energy Efficiency,// allocates; never returns null,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:3,allocate,allocates,3,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// also need to get all constPars so use leafNodeServerList .. will include self if is fundamental, which is what; // we want; // ensure all globs appear after robs, as we rely on this ordering for picking ""x"" var in ""reduced"" method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:218,reduce,reduced,218,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// amounts by which to increase allocated factorization space when",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TDecompSparse.h:32,allocate,allocated,32,math/matrix/inc/TDecompSparse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TDecompSparse.h,1,['allocate'],['allocated']
Energy Efficiency,"// anonymous namespace; /// Get the id of the warp in the block.; /// We assume that the warp size is 32, which is always the case; /// on the NVPTX device, to generate more efficient code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:174,efficient,efficient,174,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// apply binomial coefficient in-place so we don't have to allocate new memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/ComputeFunctions.cxx:59,allocate,allocate,59,roofit/batchcompute/src/ComputeFunctions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/ComputeFunctions.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// approximate number of receivers/node to allocate vector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel_GNN.cxx:43,allocate,allocate,43,tmva/sofie/src/RModel_GNN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel_GNN.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// ask for the list of datasets; // TODO: is now returning a TMap; viewer has to be adapted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:84,adapt,adapted,84,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['adapt'],['adapted']
Energy Efficiency,// assume (V & B != 0) where B is a power of 2,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:36,power,power,36,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,"// begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h:272,allocate,allocated,272,core/cont/inc/TCollectionProxyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h,1,['allocate'],['allocated']
Energy Efficiency,// best schedule for the region so far (not scheduled yet),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.h:8,schedul,schedule,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.h,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"// bitfields for Block, allocated here to improve packing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:24,allocate,allocated,24,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['allocate'],['allocated']
Energy Efficiency,"// bold light green",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx:14,green,green,14,tmva/tmva/src/Tools.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx,1,['green'],['green']
Energy Efficiency,"// book monitoring histograms (for AdaBost only)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:8,monitor,monitoring,8,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// bool arithmetic promotes to int, and the conversion back to bool; // doesn't reduce mod 2^n, so special-case it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:80,reduce,reduce,80,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// boosting algorithm (adaptive boosting with cost matrix)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBDT.h:23,adapt,adaptive,23,tmva/tmva/inc/TMVA/MethodBDT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBDT.h,1,['adapt'],['adaptive']
Energy Efficiency,"// boosting algorithm (adaptive boosting)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBDT.h:23,adapt,adaptive,23,tmva/tmva/inc/TMVA/MethodBDT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBDT.h,1,['adapt'],['adaptive']
Energy Efficiency,"// build invocation to JitVariationHelper; // arrays of strings are passed as const char** plus size.; // lifetime of pointees:; // - lm is the loop manager, and if that goes out of scope jitting does not happen at all (i.e. will always be valid); // - jittedVariation: heap-allocated weak_ptr that will be deleted by JitDefineHelper after usage; // - definesAddr: heap-allocated, will be deleted by JitDefineHelper after usage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:275,allocate,allocated,275,tree/dataframe/src/RDFInterfaceUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx,2,['allocate'],['allocated']
Energy Efficiency,"// by default do not use absolute tolerance in AdaptiveIntegration multidim.; // If an absolute tolerance is given integration of shar peaks often failed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:47,Adapt,AdaptiveIntegration,47,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,1,['Adapt'],['AdaptiveIntegration']
Energy Efficiency,// by default files monitored when nobrowser option specified,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:20,monitor,monitored,20,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['monitor'],['monitored']
Energy Efficiency,"// calculate the averages of the input variables needed for adaptive training",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodPDERS.h:60,adapt,adaptive,60,tmva/tmva/inc/TMVA/MethodPDERS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodPDERS.h,1,['adapt'],['adaptive']
Energy Efficiency,"// calculate the energy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx:17,energy,energy,17,math/mathmore/test/simanTSP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/simanTSP.cxx,1,['energy'],['energy']
Energy Efficiency,"// calculate the numerical gradient (using Numerical2PGradientCalculator); // LM: this I believe is not very efficient",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ParametricFunction.cxx:109,efficient,efficient,109,math/minuit2/src/ParametricFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ParametricFunction.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// calculating next power for x and 1-x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/ComputeFunctions.cxx:20,power,power,20,roofit/batchcompute/src/ComputeFunctions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/ComputeFunctions.cxx,1,['power'],['power']
Energy Efficiency,"// call once and cache the result to reduce lock contention",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx:37,reduce,reduce,37,core/base/src/TPluginManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// can skip over the bin we will be setting to save a reduce step below",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:54,reduce,reduce,54,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// charge in units of |e|/3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/TParticlePDG.h:3,charge,charge,3,montecarlo/eg/inc/TParticlePDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/TParticlePDG.h,1,['charge'],['charge']
Energy Efficiency,"// check energy loss, and if too much energy loss; // ( particle at rest ) set its status as dead",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:9,energy,energy,9,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,2,['energy'],['energy']
Energy Efficiency,// check if server enables monitoring,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:27,monitor,monitoring,27,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['monitor'],['monitoring']
Energy Efficiency,"// check we can apply reduce to objs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TExecutorCRTP.hxx:22,reduce,reduce,22,core/base/inc/ROOT/TExecutorCRTP.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TExecutorCRTP.hxx,4,['reduce'],['reduce']
Energy Efficiency,"// check where is reduced axes are last one. In this case we can do a faster implementation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx:18,reduce,reduced,18,tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,1,['reduce'],['reduced']
Energy Efficiency,// checkHazard should prevent scheduling multiple instructions per cycle that; // exceed the issue width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,schedul,scheduling,30,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// choose the kernel bandwidth to use. The default is 0; // 0 = use adaptive kernel estimator (uses local population to vary with of kernels); // 1 = use trivial kernel estimator (uses all data and sigma to estimate uniform kernel bandwidth)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h:68,adapt,adaptive,68,roofit/roofit/inc/Roo2DKeysPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h,1,['adapt'],['adaptive']
Energy Efficiency,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPage; \ingroup NTuple; \brief A page is a slice of a column that is mapped into memory. The page provides an opaque memory buffer for uncompressed, unpacked data. It does not interpret; the contents but it does now about the size (and thus the number) of the elements inside as well as the element; number range within the backing column/cluster.; For reading, pages are allocated and filled by the page source and then registered with the page pool.; For writing, the page sink allocates uninitialized pages of a given size.; The page has a pointer to its memory allocator so that it can release itself.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx:435,allocate,allocated,435,tree/ntuple/v7/inc/ROOT/RPage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx,2,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageAllocator; \ingroup NTuple; \brief Abstract interface to allocate and release pages. The page allocator acquires and releases memory for pages. It does not load the page data, the returned pages; are empty but guaranteed to have enough contiguous space for the given number of elements.; The page allocator must be thread-safe.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:125,allocate,allocate,125,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,1,['allocate'],['allocate']
Energy Efficiency,"// clang-format off; /**; \class ROOT::Experimental::RResultBase; \ingroup Base; \brief Common handling of the error case for RResult<T> (T != void) and RResult<void>. RResultBase captures a possible runtime error that might have occured. If the RResultBase leaves the scope unchecked,; it will throw an exception. RResultBase should only be allocated on the stack, which is helped by deleting the; new operator. RResultBase is movable but not copyable to avoid throwing multiple exceptions about the same failure.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:342,allocate,allocated,342,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['allocate'],['allocated']
Energy Efficiency,"// clang-format off; /**; \class ROOT::RDF::RDataSource; \ingroup dataframe; \brief RDataSource defines an API that RDataFrame can use to read arbitrary data formats. A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure; methods) provides an adaptor that RDataFrame can leverage to read any kind of tabular data formats.; RDataFrame calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are cal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:303,adapt,adaptor,303,tree/dataframe/inc/ROOT/RDataSource.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx,1,['adapt'],['adaptor']
Energy Efficiency,"// clang-format off; /**; \class TTreeReader; \ingroup treeplayer; \brief A simple, robust and fast interface to read values from ROOT columnar datasets such as TTree, TChain or TNtuple. TTreeReader is associated to TTreeReaderValue and TTreeReaderArray which are handles to concretely; access the information in the dataset. Example code can be found in; - tutorials/tree/hsimpleReader.C; - tutorials/tree/h1analysisTreeReader.C; - <a href=""https://github.com/root-project/roottest/tree/master/root/tree/reader"">This example</a>. You can generate a skeleton of `TTreeReaderValue<T>` and `TTreeReaderArray<T>` declarations; for all of a tree's branches using `TTree::MakeSelector()`. Roottest contains an; <a href=""https://github.com/root-project/roottest/tree/master/root/tree/reader"">example</a>; showing the full power. A simpler analysis example can be found below: it histograms a function of the px and py branches. ~~~{.cpp}; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C). #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"". void hsimpleReader() {; // Create a histogram for the values we read.; TH1F(""h1"", ""ntuple"", 100, -4, 4);. // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");. // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);. // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");. // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }. myHist->Draw();; }; ~~~. A more complete example including error handling and a few combinat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:816,power,power,816,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['power'],['power']
Energy Efficiency,"// clang-format off; /// Trigger the event loop of multiple RDataFrames concurrently; /// \param[in] handles A vector of RResultHandles; /// \return The number of distinct computation graphs that have been processed; ///; /// This function triggers the event loop of all computation graphs which relate to the; /// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; /// RResultPtr is that the event loops will run concurrently. Therefore, the overall; /// computation of all results is generally more efficient.; /// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ///; /// ~~~{.cpp}; /// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; /// auto r1 = df1.Histo1D(""var1"");; ///; /// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; /// auto r2 = df2.Sum(""var2"");; ///; /// // RResultPtr -> RResultHandle conversion is automatic; /// ROOT::RDF::RunGraphs({r1, r2});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:550,efficient,efficient,550,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['efficient'],['efficient']
Energy Efficiency,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Book execution of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:553,schedul,scheduled,553,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['schedul'],['scheduled']
Energy Efficiency,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined function on each entry (*instant action*).; /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; /// \param[in] columns Names of the columns/branches in input to the user function.; ///; /// The callable `f` is invoked once per entry. This is an *instant action*:; /// upon invocation, an event loop as well as execution of all scheduled actions; /// is triggered.; /// Users are responsible for the thread-safety of this callable when executing; /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; ///; /// ### Example usage:; /// ~~~{.cpp}; /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:536,schedul,scheduled,536,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['schedul'],['scheduled']
Energy Efficiency,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:133,reduce,reduce,133,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,7,"['Reduce', 'reduce']","['Reduce', 'reduce', 'reduced']"
Energy Efficiency,"// class ROnDiskPageMap; // clang-format off; /**; \class ROOT::Experimental::Internal::ROnDiskPageMapHeap; \ingroup NTuple; \brief An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:178,allocate,allocated,178,tree/ntuple/v7/inc/ROOT/RCluster.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx,1,['allocate'],['allocated']
Energy Efficiency,// class RegisterMappingTracker is a physical register file (PRF) descriptor.; // There is one RegisterMappingTracker for every PRF definition in the; // scheduling model.; //; // An instance of RegisterMappingTracker tracks the number of physical; // registers available for renaming. It also tracks the number of register; // moves eliminated per cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h:154,schedul,scheduling,154,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,1,['schedul'],['scheduling']
Energy Efficiency,// cleanup all monitoring loops,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:15,monitor,monitoring,15,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['monitor'],['monitoring']
Energy Efficiency,"// compute psi +/- phi; // Depending on whether cosTheta is positive or negative and whether it; // is less than 1 in absolute value, different mathematically equivalent; // expressions are numerically stable.; // algorithm from; // adapted for the case 3-2-1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/src/3DConversions.cxx:233,adapt,adapted,233,math/genvector/src/3DConversions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/src/3DConversions.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// compute the integral of the crystal ball function (ROOT::Math::crystalball_function); // If alpha > 0 the integral is the right tail integral.; // If alpha < 0 is the left tail integrals which are always finite for finite x. ; // parameters:; // alpha : is non equal to zero, define the # of sigma from which it becomes a power-law function (from mean-alpha*sigma); // n > 1 : is integrer, is the power of the low tail; // add a value xmin for cases when n <=1 the integral diverges ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ProbFuncMathCore.cxx:325,power,power-law,325,math/mathcore/src/ProbFuncMathCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ProbFuncMathCore.cxx,2,['power'],"['power', 'power-law']"
Energy Efficiency,"// compute the light's luminous power (in lumens) from its intensity (in candela); // by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:32,power,power,32,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,2,['power'],['power']
Energy Efficiency,"// compute the light's luminous power (in lumens) from its intensity (in candela); // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:32,power,power,32,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,2,['power'],['power']
Energy Efficiency,// compute the light's luminous power (in lumens) from its intensity (in nits),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:32,power,power,32,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['power'],['power']
Energy Efficiency,"// compute the particle's energy ratio...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:26,energy,energy,26,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['energy'],['energy']
Energy Efficiency,"// computeBackedgeTakenCount may allocate memory for its result. Inserting it; // into the BackedgeTakenCounts map transfers ownership. Otherwise, the result; // must be cleared in this scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:33,allocate,allocate,33,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['allocate'],['allocate']
Energy Efficiency,// computes the given schedule virtual execution time in clocks,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:22,schedul,schedule,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['schedul'],['schedule']
Energy Efficiency,"// const_cast<Node2*>(this)->sterilize(); - tried this to reduce mem leak on readback but no improve",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:58,reduce,reduce,58,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// constructor for all types of integrations; // allocate workspace (only if not adaptive algorithm)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx:49,allocate,allocate,49,math/mathmore/src/GSLIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx,2,"['adapt', 'allocate']","['adaptive', 'allocate']"
Energy Efficiency,"// constructor with default rule (gauss31) passing the type; // allocate workspace (only if not adaptive algorithm)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx:64,allocate,allocate,64,math/mathmore/src/GSLIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx,4,"['adapt', 'allocate']","['adaptive', 'allocate']"
Energy Efficiency,"// constructor with default type (ADaptiveSingular) , rule is not needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx:34,ADapt,ADaptiveSingular,34,math/mathmore/src/GSLIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx,1,['ADapt'],['ADaptiveSingular']
Energy Efficiency,// constructors; /** Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:63,Adapt,Adaptive,63,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,1,['Adapt'],['Adaptive']
Energy Efficiency,"// constructors; // GSLMCIntegrator::GSLMCIntegrator():; // fResult(0),fError(0),fStatus(-1),; // fWorkspace(0),; // fFunction(0); // {; // // constructor of GSL MCIntegrator.Vegas MC is set as default integration type; // //set random number generator; // fRng = new GSLRngWrapper();; // fRng->Allocate();; // // use the default options; // ROOT::Math::IntegratorMultiDimOptions opts; // this create the default options; // SetOptions(opts);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx:295,Allocate,Allocate,295,math/mathmore/src/GSLMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// copied and adapted from CodeGen::CodeGenModule::getMangledName",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp:14,adapt,adapted,14,interpreter/cling/lib/Utils/AST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp,1,['adapt'],['adapted']
Energy Efficiency,// copy - Allocate copy in Allocator and return ArrayRef<T> to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:10,Allocate,Allocate,10,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,1,['Allocate'],['Allocate']
Energy Efficiency,// copy - Allocate copy in Allocator and return StringRef to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:10,Allocate,Allocate,10,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,1,['Allocate'],['Allocate']
Energy Efficiency,"// copy from another architecture using the reference one; // this is not very efficient since creates temporary objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h:79,efficient,efficient,79,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,3,['efficient'],['efficient']
Energy Efficiency,"// coulomb = 6.24150 e+18 * eplus; //; // Energy [E]; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h:42,Energy,Energy,42,geom/geom/inc/TGeant4SystemOfUnits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h,2,['Energy'],['Energy']
Energy Efficiency,"// counts the number of toys in the limits set for adaptive sampling; // (taking weights into account; always on first test statistic)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:51,adapt,adaptive,51,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// cout << "" Cycle: "" << k << endl;; // if multiple adaptive iterations, need to swap weight sets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:52,adapt,adaptive,52,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// cout << ""Number of adaptive iterations: "" << _nAdpt << endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:22,adapt,adaptive,22,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// cout << ""tree index = "" << index << endl;; // allocate memory if necessary. numEntries is overkill?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ConfidenceBelt.cxx:49,allocate,allocate,49,roofit/roostats/src/ConfidenceBelt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ConfidenceBelt.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// create first child if fact, electron continues with less energy; // and in a different direction. To that end the electron is added; // to its own list of children, because otherwise it would vanish.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:60,energy,energy,60,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['energy'],['energy']
Energy Efficiency,"// create histograms for overtraining monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:38,monitor,monitoring,38,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,2,['monitor'],['monitoring']
Energy Efficiency,"// create map from original to projected and reduced point needed only for geometry",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx:45,reduce,reduced,45,graf3d/eve/src/TEvePolygonSetProjected.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx,2,['reduce'],['reduced']
Energy Efficiency,"// createLanaiISelDag - This pass converts a legalized DAG into a; // Lanai-specific DAG, ready for instruction scheduling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h:112,schedul,scheduling,112,interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/Lanai.h,2,['schedul'],['scheduling']
Energy Efficiency,"// creating the vectors of histogram for monitoring MVA response of each classifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBoost.h:41,monitor,monitoring,41,tmva/tmva/inc/TMVA/MethodBoost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBoost.h,1,['monitor'],['monitoring']
Energy Efficiency,// ctpop(X) -> 1 iff X is non-zero power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,power,power,35,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['power'],['power']
Energy Efficiency,"// dark green",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx:8,green,green,8,tmva/tmva/src/Tools.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx,1,['green'],['green']
Energy Efficiency,"// dataset is not parented by this node ... meaning it may need to be reduced,; // do this via the datasets() method by attaching and detaching the dataset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:70,reduce,reduced,70,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// deallocating last allocated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h:21,allocate,allocated,21,math/minuit2/inc/Minuit2/StackAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h,1,['allocate'],['allocated']
Energy Efficiency,"// default monitor: prints out one line of information; // on each interior-point iteration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpSolverBase.h:11,monitor,monitor,11,math/quadp/inc/TQpSolverBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpSolverBase.h,1,['monitor'],['monitor']
Energy Efficiency,"// determinant exponent for powers of 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TDecompBase.h:28,power,powers,28,math/matrix/inc/TDecompBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TDecompBase.h,1,['power'],['powers']
Energy Efficiency,"// determine static and/or adaptive bandwidth",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:27,adapt,adaptive,27,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// disable adaptive sampling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx:11,adapt,adaptive,11,roofit/roostats/src/FrequentistCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx,4,['adapt'],['adaptive']
Energy Efficiency,"// discriminating power",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFisher.cxx:18,power,power,18,tmva/tmva/src/MethodFisher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFisher.cxx,1,['power'],['power']
Energy Efficiency,"// doing this to avoid complaints about unused vars; // TODO: Could consider using a 'filter' node (see filter() method) applied to the dataset instead; // of creating and using a reduced dataset here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:180,reduce,reduced,180,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// don't allocate pointer since boolean vector don't have the .data() member",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel.cxx:9,allocate,allocate,9,tmva/sofie/src/RModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// drop polygons and projected/reduced points",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx:31,reduce,reduced,31,graf3d/eve/src/TEvePolygonSetProjected.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx,2,['reduce'],['reduced']
Energy Efficiency,"// efficient algorithm from UZIP.js; // i0 is lookbehind, i2 is lookahead - after processing two low-freq; // symbols that combined have high freq, will start processing i2 (high-freq,; // non-composite) symbols instead; // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,efficient,efficient,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['efficient'],['efficient']
Energy Efficiency,"// else decrease its energy by calculated energy loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:21,energy,energy,21,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,2,['energy'],['energy']
Energy Efficiency,"// empty string deactivates learning rate scheduler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:42,schedul,scheduler,42,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,4,['schedul'],['scheduler']
Energy Efficiency,"// enable draw optimization, reduced data set will be send to clients",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rh1_large.cxx:29,reduce,reduced,29,tutorials/rcanvas/rh1_large.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rh1_large.cxx,2,['reduce'],['reduced']
Energy Efficiency,"// enable draw optimization, reduced data set will be send to clients; // auto stat = canvas->Draw<RHist2StatBox>(pHist, ""hist"");; // stat->fill.color = RColor::kBlue;; // stat->fill.style = RAttrFill::kSolid;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rh3_large.cxx:29,reduce,reduced,29,tutorials/rcanvas/rh3_large.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rh3_large.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// end anonymous namespace; /// Chooses the correct key for scheduling data. If \p Op has the same (or; /// alternate) opcode as \p OpValue, the key is \p Op. Otherwise the key is \p; /// OpValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:60,schedul,scheduling,60,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,// end anonymous namespace; /// Get the appropriated Rewriter for \p MI.; /// \return A pointer to a dynamically allocated Rewriter or nullptr if no; /// rewriter works for \p MI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:113,allocate,allocated,113,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['allocate'],['allocated']
Energy Efficiency,// end anonymous namespace; /// Schedule - Schedule the DAG using list scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:32,Schedul,Schedule,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,6,"['Schedul', 'schedul']","['Schedule', 'scheduling']"
Energy Efficiency,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:240,allocate,allocated,240,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// end anonymous namespace; //===----------------------------------------------------------------------===//; // SPARC v9 ABI Implementation.; // Based on the SPARC Compliance Definition version 2.4.1.; //; // Function arguments a mapped to a nominal ""parameter array"" and promoted to; // registers depending on their type. Each argument occupies 8 or 16 bytes in; // the array, structs larger than 16 bytes are passed indirectly.; //; // One case requires special care:; //; // struct mixed {; // int i;; // float f;; // };; //; // When a struct mixed is passed by value, it only occupies 8 bytes in the; // parameter array, but the int is passed in an integer register, and the float; // is passed in a floating point register. This is represented as two arguments; // with the LLVM IR inreg attribute:; //; // declare void f(i32 inreg %i, float inreg %f); //; // The code generator will only allocate 4 bytes from the parameter array for; // the inreg arguments. All other arguments are allocated a multiple of 8; // bytes.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Sparc.cpp:895,allocate,allocate,895,interpreter/llvm-project/clang/lib/CodeGen/Targets/Sparc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/Sparc.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// end anonymous namespace; //===----------------------------------------------------------------------===//; // Static Node Priority for Register Pressure Reduction; //===----------------------------------------------------------------------===//; // Check for special nodes that bypass scheduling heuristics.; // Currently this pushes TokenFactor nodes down, but may be used for other; // pseudo-ops as well.; //; // Return -1 to schedule right above left, 1 for left above right.; // Return 0 if no bias exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:288,schedul,scheduling,288,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// end loop on input elements; // normalize for reduced mean",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx:48,reduce,reduced,48,tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,1,['reduce'],['reduced']
Energy Efficiency,"// end loop over active monitors; // If timed-out, deactivate the remaining sockets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:24,monitor,monitors,24,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['monitor'],['monitors']
Energy Efficiency,// end namespace Cephes; /* routines for efficient polynomial evaluation*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.h:41,efficient,efficient,41,math/mathcore/src/SpecFuncCephes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.h,1,['efficient'],['efficient']
Energy Efficiency,"// end namespace Util; /// \class KahanSum; /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; /// when adding a sequence of finite-precision floating point numbers.; /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; ///; /// ### Auto-vectorisable accumulation; /// This class can internally use multiple accumulators (template parameter `N`).; /// When filled from a collection that supports index access from a *contiguous* block of memory,; /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; /// of `N` numbers in a single instruction.; ///; /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; /// with `N = 1`.; /// This depends on the order and magnitude of the numbers being accumulated. Therefore, in rare cases, the accumulation; /// result can change *in dependence of N*, even when the data are identical.; /// The magnitude of such differences is well below the precision of the floating point type, and will therefore mostly show; /// in the compensation sum(see Carry()). Increasing the number of accumulators therefore only makes sense to; /// speed up the accumulation, but not to increase precision.; ///; /// \param T The type of the values to be accumulated.; /// \param N Number of accumulators. Defaults to 1. Ideal values are the widths of a vector register on the relevant architecture.; /// Depending on the instruction set, good values are:; /// - AVX2-float: 8; /// - AVX2-double: 4; /// - AVX512-float: 16; /// - AVX512-double: 8; ///; /// ### Examples; ///; /// ~~~{.cpp}; /// std::vector<double> numbers(1000);; /// for (std::size_t i=0; i<1000; ++i) {; /// numbers[i] = rand();; /// }; ///; /// ROOT::Math::KahanSu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h:126,reduce,reduces,126,math/mathcore/inc/Math/Util.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h,1,['reduce'],['reduces']
Energy Efficiency,"// end namespace detail; /// Allocate memory in an ever growing pool, as if by bump-pointer.; ///; /// This isn't strictly a bump-pointer allocator as it uses backing slabs of; /// memory rather than relying on a boundless contiguous heap. However, it has; /// bump-pointer semantics in that it is a monotonically growing pool of memory; /// where every allocation is found by merely allocating the next N bytes in; /// the slab, or the next N bytes in the next slab.; ///; /// Note that this also has a threshold for forcing allocations above a certain; /// size into their own slab.; ///; /// The BumpPtrAllocatorImpl template defaults to using a MallocAllocator; /// object, which wraps malloc, to allocate memory, but it can be changed to; /// use a custom allocator.; ///; /// The GrowthDelay specifies after how many allocated slabs the allocator; /// increases the size of the slabs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:29,Allocate,Allocate,29,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,3,"['Allocate', 'allocate']","['Allocate', 'allocate', 'allocated']"
Energy Efficiency,// end namespace llvm; // Defines symbolic names for PowerPC registers. This defines a mapping from; // register name to register number.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:53,Power,PowerPC,53,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,1,['Power'],['PowerPC']
Energy Efficiency,"// end namespace llvm; // operator new and delete aren't allowed inside namespaces.; // The throw specifications are mandated by the standard.; /// Placement new for using the MCContext's allocator.; ///; /// This placement form of operator new uses the MCContext's allocator for; /// obtaining memory. It is a non-throwing new, which means that it returns; /// null on error. (If that is what the allocator does. The current does, so if; /// this ever changes, this operator will have to be changed, too.); /// Usage looks like this (assuming there's an MCContext 'Context' in scope):; /// \code; /// // Default alignment (8); /// IntegerLiteral *Ex = new (Context) IntegerLiteral(arguments);; /// // Specific alignment; /// IntegerLiteral *Ex2 = new (Context, 4) IntegerLiteral(arguments);; /// \endcode; /// Please note that you cannot use delete on the pointer; it must be; /// deallocated using an explicit destructor call followed by; /// \c Context.Deallocate(Ptr).; ///; /// \param Bytes The number of bytes to allocate. Calculated by the compiler.; /// \param C The MCContext that provides the allocator.; /// \param Alignment The alignment of the allocated memory (if the underlying; /// allocator supports it).; /// \return The allocated memory. Could be NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h:1019,allocate,allocate,1019,interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"// end namespace llvm; /// This class acts as the glue the joins the CombinerHelper to the overall; /// Combine algorithm. The CombinerHelper is intended to report the; /// modifications it makes to the MIR to the GISelChangeObserver and the; /// observer subclass will act on these events. In this case, instruction; /// erasure will cancel any future visits to the erased instruction and; /// instruction creation will schedule that instruction for a future visit.; /// Other Combiner implementations may require more complex behaviour from; /// their GISelChangeObserver subclass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp:421,schedul,schedule,421,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Combiner.cpp,1,['schedul'],['schedule']
Energy Efficiency,// end namespace mdconst; //===----------------------------------------------------------------------===//; /// A single uniqued string.; ///; /// These are used to efficiently contain a byte sequence for metadata.; /// MDString is always unnamed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h:165,efficient,efficiently,165,interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,1,['efficient'],['efficiently']
Energy Efficiency,"// end of adaptive method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx:10,adapt,adaptive,10,tmva/tmva/src/MethodPDERS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// end of iteration loop; // save last result in case of no complete final states; // when the result is filled above (reduced storage) the resulting state will not be valid; // since they will not have parameter values and error; // the line above will fill as last element a valid state",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/VariableMetricBuilder.cxx:119,reduce,reduced,119,math/minuit2/src/VariableMetricBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/VariableMetricBuilder.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// energy us printed by GSL (and also end-line)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx:3,energy,energy,3,math/mathmore/src/GSLSimAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx,1,['energy'],['energy']
Energy Efficiency,"// epoch monitoring histograms for background",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h:9,monitor,monitoring,9,tmva/tmva/inc/TMVA/MethodANNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h,1,['monitor'],['monitoring']
Energy Efficiency,"// epoch monitoring histograms for signal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h:9,monitor,monitoring,9,tmva/tmva/inc/TMVA/MethodANNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h,1,['monitor'],['monitoring']
Energy Efficiency,"// epoch monitoring histograms for weights; // general",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h:9,monitor,monitoring,9,tmva/tmva/inc/TMVA/MethodANNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h,1,['monitor'],['monitoring']
Energy Efficiency,"// erase reduced dimensions, but keep last one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx:9,reduce,reduced,9,tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,1,['reduce'],['reduced']
Energy Efficiency,// errno == ENOMEM; try to allocate more memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:27,allocate,allocate,27,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,1,['allocate'],['allocate']
Energy Efficiency,"// evaluate the energy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx:16,energy,energy,16,math/mathmore/src/GSLSimAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx,1,['energy'],['energy']
Energy Efficiency,"// evaluate the energy given a state xp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx:16,energy,energy,16,math/mathmore/src/GSLSimAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx,1,['energy'],['energy']
Energy Efficiency,"// evaluate using free function pointer (same GSL signature); /**; signature for function pointers used by GSL; */; //typedef double ( * GSLFuncPointer ) ( double, void * );; /**; evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:476,efficient,efficient,476,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,2,"['adapt', 'efficient']","['adapter', 'efficient']"
Energy Efficiency,"// f32 and f64 are allocated in A0, A1, A2, A3 when either of the following; // is true: function is vararg, argument is 3rd or higher, there is previous; // argument which is not f32 or f64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:19,allocate,allocated,19,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,// fUseBP: true if EBP has been allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h:32,allocate,allocated,32,interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,1,['allocate'],['allocated']
Energy Efficiency,"// fill it with reduced versions of components",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCompositeDataStore.cxx:16,reduce,reduced,16,roofit/roofitcore/src/RooCompositeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCompositeDataStore.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// fill monitoring histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:8,monitor,monitoring,8,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// fixed rule for adaptive singular",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx:18,adapt,adaptive,18,math/mathmore/src/GSLIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLIntegrator.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit); // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit)); //; // For ppc_fp128:; // fold (bitcast (fneg x)) ->; // flipbit = signbit; // (xor (bitcast x) (build_pair flipbit, flipbit)); //; // fold (bitcast (fabs x)) ->; // flipbit = (and (extract_element (bitcast x), 0), signbit); // (xor (bitcast x) (build_pair flipbit, flipbit)); // This often reduces constant pool loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:425,reduce,reduces,425,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// fold (sdiv X, pow2) -> simple ops after legalize; // FIXME: We check for the exact bit here because the generic lowering gives; // better results in that case. The target-specific lowering should learn how; // to handle exact sdivs efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:235,efficient,efficiently,235,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// fold (shl (add x, c1), c2) -> (add (shl x, c2), c1 << c2); // fold (shl (or x, c1), c2) -> (or (shl x, c2), c1 << c2); // Variant of version done on multiply, except mul by a power of 2 is turned; // into a shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:178,power,power,178,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,"// fold (srl (ctlz x), ""5"") -> x iff x has one bit set (the low bit), and x has a power; // of two bitwidth. The ""5"" represents (log2 (bitwidth x)).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,power,power,82,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,"// fold (udiv x, (shl c, y)) -> x >>u (log2(c)+y) iff c is power of 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,power,power,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['power'],['power']
Energy Efficiency,"// for both: tag and charge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx:21,charge,charge,21,roofit/roofit/src/RooNonCPEigenDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx,1,['charge'],['charge']
Energy Efficiency,"// for each of the i Bernstein basis polynomials; // represent it in the 'power basis' (the naive polynomial basis); // where the integral is straight forward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:74,power,power,74,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,1,['power'],['power']
Energy Efficiency,"// for i32, general parity function using EORs is more efficient compared to; // using floating point",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:55,efficient,efficient,55,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// for pointer arithmetics; // Early return if the RVec has already been allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:73,allocate,allocated,73,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// for the enumerations defining the types; /** Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integration methods). In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h:121,Adapt,Adaptive,121,math/mathcore/inc/Math/IntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h,2,"['Adapt', 'adapt']","['Adaptive', 'adaptive']"
Energy Efficiency,"// for the enumerations defining the types; // constructors; /**; Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:125,adapt,adaptive,125,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,3,['adapt'],['adaptive']
Energy Efficiency,"// force the first monitoring info",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:19,monitor,monitoring,19,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,2,['monitor'],['monitoring']
Energy Efficiency,// fp; // Reserve the base register if we need to realign the stack and allocate; // variable-sized objects at runtime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp:72,allocate,allocate,72,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchRegisterInfo.cpp,2,['allocate'],['allocate']
Energy Efficiency,"// free allocated memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TClassDocOutput.cxx:8,allocate,allocated,8,html/src/TClassDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TClassDocOutput.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// freeze(icmp a, const)) -> icmp (freeze a), const; // This helps generate efficient conditional jumps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:76,efficient,efficient,76,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['efficient'],['efficient']
Energy Efficiency,"// fshl i16 X, X, 8 --> bswap i16 X (reduce to more-specific form)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:37,reduce,reduce,37,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['reduce'],['reduce']
Energy Efficiency,// fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW))); // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW)); // This is simpler than TargetLowering::expandFunnelShift because we can rely; // on PowerPC shift by BW being well defined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:187,Power,PowerPC,187,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"// function is cloned when creating the adapter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx:40,adapt,adapter,40,math/mathcore/src/Fitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx,1,['adapt'],['adapter']
Energy Efficiency,"// ga.SetMakeCopies(kTRUE); // commented out, because it reduces speed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticFitter.cxx:57,reduce,reduces,57,tmva/tmva/src/GeneticFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticFitter.cxx,1,['reduce'],['reduces']
Energy Efficiency,"// gcc prints these as sign extended. Sign extend value to 64 bits; // now; without this it would get ZExt'd later in; // ScheduleDAGSDNodes::EmitNode, which is very generic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:122,Schedul,ScheduleDAGSDNodes,122,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Schedul'],['ScheduleDAGSDNodes']
Energy Efficiency,"// generate array of energies threshold used; // to give a track color related to the particle; // energy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:99,energy,energy,99,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['energy'],['energy']
Energy Efficiency,"// get ROC integral and overlap integral for single method on; // training sample if fMethodWeightType == ""ByROC"" or the user; // wants detailed monitoring; // boosting (reweight training sample)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx:145,monitor,monitoring,145,tmva/tmva/src/MethodBoost.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// get discriminating power",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodFisher.h:22,power,power,22,tmva/tmva/inc/TMVA/MethodFisher.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodFisher.h,1,['power'],['power']
Energy Efficiency,"// get index; // allocate memory if necessary. numEntries is overkill?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ConfidenceBelt.cxx:17,allocate,allocate,17,roofit/roostats/src/ConfidenceBelt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ConfidenceBelt.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// get index; // cout << ""hist index = "" << index << endl;; // allocate memory if necessary. numEntries is overkill?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ConfidenceBelt.cxx:63,allocate,allocate,63,roofit/roostats/src/ConfidenceBelt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ConfidenceBelt.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// get range for graph2D (used sub-set histogram); // N.B. : this is different than in previous implementation of TGraph2D::Fit. There range used was always(0,0); // cannot use TGraph2D::GetHistogram which makes an interpolation; //TH1 * h1 = gr->GetHistogram();; //if (h1) HFit::GetDrawingRange(h1, range);; // not very efficient (t.b.i.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx:321,efficient,efficient,321,hist/hist/src/HFitImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// get the discriminating power of each variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFisher.cxx:26,power,power,26,tmva/tmva/src/MethodFisher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFisher.cxx,1,['power'],['power']
Energy Efficiency,"// get the primary monitor's info",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx:19,monitor,monitor,19,core/winnt/src/Win32Splash.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// getStackSize() includes all the locals in its size calculation. We don't; // include these locals when computing the stack size of a funclet, as they; // are allocated in the parent's stack frame and accessed via the frame; // pointer from the funclet. We only save the callee saved registers in the; // funclet, which are really the callee saved registers of the parent; // function, including the funclet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:161,allocate,allocated,161,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// global accessor; //; // Adapts a TRandom random number generator to the interface of the ones in the; // standard library (STL) so that TRandom derived generators can be used with; // STL algorithms such as `std::shuffle`.; //; // Example:; // ```; // std::vector<double> v {0, 1, 2, 3, 4, 5};; // TRandom3StdEngine rng(seed);; // std::shuffle(v.begin(), v.end(), rng);; // ```; //; // Or at a lower level:; // ```; // std::vector<double> v {0, 1, 2, 3, 4, 5};; // RandomGenerator<TRandom3> rng(seed);; // std::shuffle(v.begin(), v.end(), rng);; // ```; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h:27,Adapt,Adapts,27,tmva/tmva/inc/TMVA/Tools.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h,1,['Adapt'],['Adapts']
Energy Efficiency,"// gr->GetGraph()->GetHistogram()->SetXTitle(TString(""Energy (eV)""));; // gr->GetGraph()->GetHistogram()->SetYTitle(TString(""Cross Section (barn)""));",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSReactionDlg.cxx:54,Energy,Energy,54,test/periodic/XSReactionDlg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSReactionDlg.cxx,1,['Energy'],['Energy']
Energy Efficiency,"// greater than sizeof(void*) + sizeof(UInt_t); /// `*begin_arena` and `*end_arena` should contain the location of a memory arena of size `fgIteratorArenaSize`.; /// If iterator-specific information is of that size or less, the iterators will be constructed in place in the given; /// locations. Otherwise, iterators will be allocated via `new` and their address returned by modifying the value; /// of `*begin_arena` and `*end_arena`.; /// As a special case, given that iterators for array-backed containers are just pointers, the required information; /// will be directly stored in `*(begin|end)_arena`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h:325,allocate,allocated,325,core/cont/inc/TVirtualCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h,1,['allocate'],['allocated']
Energy Efficiency,"// gstore.SetMakeCopies(kTRUE); // commented out, because it reduces speed; // timing of GA",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticFitter.cxx:61,reduce,reduces,61,tmva/tmva/src/GeneticFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticFitter.cxx,1,['reduce'],['reduces']
Energy Efficiency,// hasFP ends up calling getMaxCallFrameComputed() which may not be; // available when getPressureLimit() is called as part of; // ScheduleDAGRRList.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp:131,Schedul,ScheduleDAGRRList,131,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,1,['Schedul'],['ScheduleDAGRRList']
Energy Efficiency,// heuristic to reduce number of builtin candidates in the set.; // Add volatile/restrict version only if there are conversions to a; // volatile/restrict type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:16,reduce,reduce,16,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// histogram of particle's energy loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.h:27,energy,energy,27,test/RootShower/RootShower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.h,1,['energy'],['energy']
Energy Efficiency,// hybrid_ls_rr_sort - Priority function for hybrid scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:52,schedul,scheduler,52,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// i.e. gauss kernel; //; // this is going to be done for both (nonadaptive KDE and adaptive KDE); // for nonadaptive KDE this is the only = final thing to do; // for adaptive KDE this is going to be used in the first (hidden) iteration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx:84,adapt,adaptive,84,tmva/tmva/src/KDEKernel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx,2,['adapt'],['adaptive']
Energy Efficiency,// i1 is by definition a power of 2 or zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:25,power,power,25,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['power'],['power']
Energy Efficiency,// if (AlgoVer==1 && (LaneId >= Offset)) copy Remote Reduce list to local; // Reduce list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:53,Reduce,Reduce,53,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,2,['Reduce'],['Reduce']
Energy Efficiency,"// if energy loss leave less energy to the particle than; // its mass, set its momentum equal to its mass; // (minimum allowed value for momentum)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:6,energy,energy,6,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,2,['energy'],['energy']
Energy Efficiency,"// if epochs are counted create monitoring histograms (only available for classification)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:32,monitor,monitoring,32,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// if fit range specified, and pdf is a RooSimultaneous, may need to 'reduce' the model if some of the pdfs are in; // range and others are not",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:70,reduce,reduce,70,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// if k is not a reduced axis is not last ones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx:17,reduce,reduced,17,tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,1,['reduce'],['reduced']
Energy Efficiency,"// if parallelepiped boundary is crossing limits; // then reduce it (deforming)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:58,reduce,reduce,58,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// if particle's energy is equal to its mass, it is at rest,; // so set its status as dead",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:17,energy,energy,17,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['energy'],['energy']
Energy Efficiency,"// if simultaneous and any channels deselected then reduce and return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:52,reduce,reduce,52,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reduce']
Energy Efficiency,// ilp_ls_rr_sort - Priority function for ILP (instruction level parallelism); // scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:82,schedul,scheduler,82,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// implementation is adapted from clangJIT; // (https://github.com/hfinkel/llvm-project-cxxjit/blob/cxxjit/clang/lib/CodeGen/JIT.cpp); // void *resolveFunction(const void *NTTPValues, const char **TypeStrings,; // unsigned Idx); // The outer header of the fat binary is documented in the CUDA; // fatbinary.h header. As mentioned there, the overall size must be a; // multiple of eight, and so we must make sure that the PTX is.; // We also need to make sure that the buffer is explicitly null; // terminated (cuobjdump, at least, seems to assume that it is).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalCUDADeviceCompiler.cpp:21,adapt,adapted,21,interpreter/cling/lib/Interpreter/IncrementalCUDADeviceCompiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalCUDADeviceCompiler.cpp,1,['adapt'],['adapted']
Energy Efficiency,"// implementation of FCN static function used internally by TFumili.; // Adapt IMultiGenFunction interface to TFumili FCN static function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx:73,Adapt,Adapt,73,math/fumili/src/TFumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx,1,['Adapt'],['Adapt']
Energy Efficiency,"// implementation of FCN static function used internally by TMinuit.; // Adapt IMultiGenFunction interface to TMinuit FCN static function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:73,Adapt,Adapt,73,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['Adapt'],['Adapt']
Energy Efficiency,"// implementation of FCN static function used internally by TMinuit.; // Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; // provided gradient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:73,Adapt,Adapt,73,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['Adapt'],['Adapt']
Energy Efficiency,"// in C++11 this will be efficient thanks to the move constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingTypeInfo.cxx:25,efficient,efficient,25,core/metacling/src/TClingTypeInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingTypeInfo.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// in GeV/cm...; // Critical Energy in MeV",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.cxx:29,Energy,Energy,29,test/RootShower/MyDetector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.cxx,1,['Energy'],['Energy']
Energy Efficiency,"// include also dynamic tensors since the vectors can be allocated with a size larger than their output; // we need a special handling for bool type allocated as vector<bool>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel.cxx:57,allocate,allocated,57,tmva/sofie/src/RModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel.cxx,2,['allocate'],['allocated']
Energy Efficiency,"// incomplete gamma function (complement integral); // igamc(a,x) = 1 - igam(a,x); //; // inf.; // -; // 1 | | -t a-1; // = ----- | e t dt.; // - | |; // | (a) -; // x; //; //; // In this implementation both arguments must be positive.; // The integral is evaluated by either a power series or; // continued fraction expansion, depending on the relative; // values of a and x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx:278,power,power,278,math/mathcore/src/SpecFuncCephes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SpecFuncCephes.cxx,1,['power'],['power']
Energy Efficiency,"// increase tolerance when using Cephes (test values are correctly checked with Mathematica; // GSL was more precise in this case; // Adapt also to 32 bits architectures",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testSpecFunc.cxx:134,Adapt,Adapt,134,math/mathmore/test/testSpecFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testSpecFunc.cxx,1,['Adapt'],['Adapt']
Energy Efficiency,"// init reduced matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:8,reduce,reduced,8,hist/hist/src/TSVDUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// initialize monitor ntuple",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodRuleFit.h:14,monitor,monitor,14,tmva/tmva/inc/TMVA/MethodRuleFit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodRuleFit.h,1,['monitor'],['monitor']
Energy Efficiency,"// initialized only once as a static function variable; // Include ""RuntimePrintValue.h"" only on the first printing.; // This keeps the interpreter lightweight and reduces the startup time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp:164,reduce,reduces,164,interpreter/cling/lib/Interpreter/ValuePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp,1,['reduce'],['reduces']
Energy Efficiency,"// initializing mostly monitoring tools of the boost process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBoost.h:23,monitor,monitoring,23,tmva/tmva/inc/TMVA/MethodBoost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBoost.h,1,['monitor'],['monitoring']
Energy Efficiency,"// initializing mostly monitoring tools of the category process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCategory.h:23,monitor,monitoring,23,tmva/tmva/inc/TMVA/MethodCategory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCategory.h,1,['monitor'],['monitoring']
Energy Efficiency,// instructions in circuits are allowed to be scheduled; // after both a successor and predecessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:46,schedul,scheduled,46,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// integrate again ADAPTIve, with different rule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testGSLIntegration.cxx:19,ADAPT,ADAPTIve,19,math/mathmore/test/testGSLIntegration.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testGSLIntegration.cxx,1,['ADAPT'],['ADAPTIve']
Energy Efficiency,// iterator access to the scheduling classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h:26,schedul,scheduling,26,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h,1,['schedul'],['scheduling']
Energy Efficiency,"// joule = 6.24150 e+12 * MeV; // symbols",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h:3,joule,joule,3,geom/geom/inc/TGeant4SystemOfUnits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h,2,['joule'],['joule']
Energy Efficiency,"// kPROOF_SETIDLE sets the client to idle; in asynchronous mode clients monitor; // TProof::IsIdle for to check the readiness of a query, so we need to send this; // before to be sure thatn everything about a query is received by the client",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:72,monitor,monitor,72,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['monitor'],['monitor']
Energy Efficiency,// keep light power of all sources constant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:14,power,power,14,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['power'],['power']
Energy Efficiency,"// keep xnew if energy is reduced",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SimulatedAnnealing.cxx:16,energy,energy,16,tmva/tmva/src/SimulatedAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SimulatedAnnealing.cxx,2,"['energy', 'reduce']","['energy', 'reduced']"
Energy Efficiency,"// keeping in reduced cov matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:14,reduce,reduced,14,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// largest block allocated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TStorage.h:17,allocate,allocated,17,core/base/inc/TStorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TStorage.h,1,['allocate'],['allocated']
Energy Efficiency,"// let allocate special thread which will be used to perform data sending via websocket; // should reduce consumption of webwindow thread when big data are send; // gEnv->SetValue(""WebGui.SenderThrds"", ""yes"");; // create window",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx:7,allocate,allocate,7,tutorials/webgui/ping/ping.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx,3,"['allocate', 'consumption', 'reduce']","['allocate', 'consumption', 'reduce']"
Energy Efficiency,"// let reduce reaction time of THttpServer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx:7,reduce,reduce,7,tutorials/webgui/ping/ping.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// lifetime of pointees:; // - lm is the loop manager, and if that goes out of scope jitting does not happen at all (i.e. will always be valid); // - jittedDefine: heap-allocated weak_ptr that will be deleted by JitDefineHelper after usage; // - definesAddr: heap-allocated, will be deleted by JitDefineHelper after usage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:169,allocate,allocated,169,tree/dataframe/src/RDFInterfaceUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx,2,['allocate'],['allocated']
Energy Efficiency,"// list of reduced vertices",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx:11,reduce,reduced,11,graf3d/eve/src/TEvePolygonSetProjected.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx,2,['reduce'],['reduced']
Energy Efficiency,// list-ilp is currently an experimental scheduler that allows various; // heuristics to be enabled prior to the normal register reduction logic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:41,schedul,scheduler,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// llvm models select's as two-address instructions. That means a copy; // is inserted before a t2MOVccr, etc. If the copy is scheduled in; // between selects we would end up creating multiple IT blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:126,schedul,scheduled,126,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"// loop on reduced axis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx:11,reduce,reduced,11,tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,1,['reduce'],['reduced']
Energy Efficiency,"// loop over all epoch-wise monitoring histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/MovieMaker.cxx:28,monitor,monitoring,28,tmva/tmvagui/src/MovieMaker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/MovieMaker.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// make ProcessLine() call to check if expr is valid; // there may be more efficient check ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTableInfo.cxx:75,efficient,efficient,75,graf3d/eve7/src/REveTableInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveTableInfo.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// make a best guess of the sparse structure; it will guarantee; // enough allocated space !",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSparse.cxx:75,allocate,allocated,75,math/matrix/src/TMatrixTSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSparse.cxx,2,['allocate'],['allocated']
Energy Efficiency,// mapped_iterator - This is a simple iterator adapter that causes a function to; // be applied whenever operator* is invoked on the iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:47,adapt,adapter,47,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['adapt'],['adapter']
Energy Efficiency,"// marks the progress of the consumption of the csv lines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RCsvDS.hxx:29,consumption,consumption,29,tree/dataframe/inc/ROOT/RCsvDS.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RCsvDS.hxx,1,['consumption'],['consumption']
Energy Efficiency,"// memcmp(x, y, Len) == 0 -> bcmp(x, y, Len) == 0; // bcmp can be more efficient than memcmp because it only has to know that; // there is a difference, not how different one is to the other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:71,efficient,efficient,71,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['efficient'],['efficient']
Energy Efficiency,// method_reference() is called passing it the ReferenceName that might be; // a reference it to an Objective-C method call. If so then it allocates and; // assembles a method call string with the values last seen and saved in; // the DisassembleInfo's class_name and selector_name fields. This is saved; // into the method field of the info and any previous string is free'ed.; // Then the class_name field in the info is set to nullptr. The method call; // string is set into ReferenceName and ReferenceType is set to; // LLVMDisassembler_ReferenceType_Out_Objc_Message. If this not a method call; // then both ReferenceType and ReferenceName are left unchanged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:139,allocate,allocates,139,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['allocate'],['allocates']
Energy Efficiency,"// minimal required region scheduler, works for ranges of SUnits*,; // SUnits or MachineIntrs*",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:27,schedul,scheduler,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"// minimal timeout to reduce load, generate dummy only if client not submit new request immediately",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:22,reduce,reduce,22,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['reduce'],['reduce']
Energy Efficiency,// module.lds will be allocated at zero in any kernel that allocates it,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:22,allocate,allocated,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,2,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,"// monitor a few more variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/DetailedOutputAggregator.cxx:3,monitor,monitor,3,roofit/roostats/src/DetailedOutputAggregator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/DetailedOutputAggregator.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// monitor convergence of training and control sample",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:3,monitor,monitor,3,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// monitor progrss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticFitter.cxx:3,monitor,monitor,3,tmva/tmva/src/GeneticFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticFitter.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// monitor read from parallel sockets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TPSocket.h:3,monitor,monitor,3,net/net/inc/TPSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TPSocket.h,1,['monitor'],['monitor']
Energy Efficiency,"// monitor write on parallel sockets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TPSocket.h:3,monitor,monitor,3,net/net/inc/TPSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TPSocket.h,1,['monitor'],['monitor']
Energy Efficiency,"// monitoring M.C. efficiency; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:3,monitor,monitoring,3,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// monitoring histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h:3,monitor,monitoring,3,tmva/tmva/inc/TMVA/MethodANNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h,1,['monitor'],['monitoring']
Energy Efficiency,"// monitors convergence of independent test sample; // monitoring histograms (not available for regression)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h:3,monitor,monitors,3,tmva/tmva/inc/TMVA/MethodANNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h,2,['monitor'],"['monitoring', 'monitors']"
Energy Efficiency,"// monitors convergence of training sample",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h:3,monitor,monitors,3,tmva/tmva/inc/TMVA/MethodANNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h,1,['monitor'],['monitors']
Energy Efficiency,"// mul i1 nsw is a special-case because -1 * -1 is poison (+1 is not; // representable). All other cases reduce to 0, so just return 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:105,reduce,reduce,105,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// must reallocate; // Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:124,allocate,allocates,124,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['allocate'],['allocates']
Energy Efficiency,"// must reduce because category var has one of the ranges",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:8,reduce,reduce,8,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// namespace ROOT; /// @brief TRangeDynCast is an adapter class that allows the typed iteration; /// through a TCollection.; ///; /// The typical use is:; /// ```{.cpp}; /// for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; /// if (!bcl) continue;; /// ... use bcl as a TBaseClass*; /// }; /// for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; /// if (!bcl) continue;; /// ... use bcl as a TBaseClass*; /// }; /// ```; /// \tparam T The new type to convert to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h:50,adapt,adapter,50,core/cont/inc/TCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h,1,['adapt'],['adapter']
Energy Efficiency,"// namespace ThreadSafetyTIL; // Nodes which declare variables; /// A named variable, e.g. ""x"".; ///; /// There are two distinct places in which a Variable can appear in the AST.; /// A variable declaration introduces a new variable, and can occur in 3 places:; /// Let-expressions: (Let (x = t) u); /// Functions: (Function (x : t) u); /// Self-applicable functions (SFunction (x) t); ///; /// If a variable occurs in any other location, it is a reference to an existing; /// variable declaration -- e.g. 'x' in (x * y + z). To save space, we don't; /// allocate a separate AST node for variable references; a reference is just a; /// pointer to the original declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h:555,allocate,allocate,555,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,1,['allocate'],['allocate']
Energy Efficiency,"// namespace clang; // operator new and delete aren't allowed inside namespaces.; /// Placement new for using the ASTContext's allocator.; ///; /// This placement form of operator new uses the ASTContext's allocator for; /// obtaining memory.; ///; /// IMPORTANT: These are also declared in clang/AST/ASTContextAllocate.h!; /// Any changes here need to also be made there.; ///; /// We intentionally avoid using a nothrow specification here so that the calls; /// to this operator will not perform a null check on the result -- the; /// underlying allocator never returns null pointers.; ///; /// Usage looks like this (assuming there's an ASTContext 'Context' in scope):; /// @code; /// // Default alignment (8); /// IntegerLiteral *Ex = new (Context) IntegerLiteral(arguments);; /// // Specific alignment; /// IntegerLiteral *Ex2 = new (Context, 4) IntegerLiteral(arguments);; /// @endcode; /// Memory allocated through this placement new operator does not need to be; /// explicitly freed, as ASTContext will free all of this memory when it gets; /// destroyed. Please note that you cannot use delete on the pointer.; ///; /// @param Bytes The number of bytes to allocate. Calculated by the compiler.; /// @param C The ASTContext that provides the allocator.; /// @param Alignment The alignment of the allocated memory (if the underlying; /// allocator supports it).; /// @return The allocated memory. Could be nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:904,allocate,allocated,904,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,4,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,// namespace clang; /// Allocates memory within a Clang preprocessing record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:24,Allocate,Allocates,24,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['Allocate'],['Allocates']
Energy Efficiency,"// namespace sys; /// This interface provides simple read-only access to a block of memory, and; /// provides simple methods for reading files and standard input into a memory; /// buffer. In addition to basic access to the characters in the file, this; /// interface guarantees you can read one character past the end of the file,; /// and that this character will read as '\0'.; ///; /// The '\0' guarantee is needed to support an optimization -- it's intended to; /// be more efficient for clients which are reading all the data to stop; /// reading when they encounter a '\0' than to continually check the file; /// position to see if it has reached the end of the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h:479,efficient,efficient,479,interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,1,['efficient'],['efficient']
Energy Efficiency,"// need an adapter from a multi-dim function to a one-dimensional",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:11,adapt,adapter,11,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['adapt'],['adapter']
Energy Efficiency,"// need to re-allocate:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:14,allocate,allocate,14,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// need to reduce the RooSimultaneous until fix: https://github.com/root-project/root/issues/8231",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:11,reduce,reduce,11,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// no ++s_instances, as no memory is allocated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/advancedcpp.cxx:37,allocate,allocated,37,bindings/pyroot/cppyy/cppyy/test/advancedcpp.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/advancedcpp.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// no Py_INCREF as no ownership; // perform the call, nullptr 'this' makes the other side allocate the memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx:90,allocate,allocate,90,bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// no need for PM in the adaptive case using Genz method (class is in MathCore)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx:25,adapt,adaptive,25,math/mathcore/src/Integrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// no need to call InitArg for interpreted functions (done in ctor); // use EvalPar since it is much more efficient than Eval",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedTF1.h:106,efficient,efficient,106,hist/hist/inc/Math/WrappedTF1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedTF1.h,1,['efficient'],['efficient']
Energy Efficiency,"// no op in case of bad values; // case the coordinate is larger than the current allocated vector size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/DataRange.cxx:82,allocate,allocated,82,math/mathcore/src/DataRange.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/DataRange.cxx,2,['allocate'],['allocated']
Energy Efficiency,"// non adaptive KDE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx:7,adapt,adaptive,7,tmva/tmva/src/KDEKernel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// non-adaptive bandwidth; // (default, and needed to calculate adaptive bandwidth)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:7,adapt,adaptive,7,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,2,['adapt'],['adaptive']
Energy Efficiency,"// not enough energy for this decay; //; //------> the max weight depends on opt:; // opt == ""Fermi"" --> fermi energy dependence for cross section; // else --> constant cross section as function of TECM (default); //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TGenPhaseSpace.cxx:14,energy,energy,14,math/physics/src/TGenPhaseSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TGenPhaseSpace.cxx,2,['energy'],['energy']
Energy Efficiency,"// not very efficient but need to re-do Dsinv for new storage of; // symmetric matrices",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dfact.h:12,efficient,efficient,12,math/smatrix/inc/Math/Dfact.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Dfact.h,3,['efficient'],['efficient']
Energy Efficiency,"// novel green",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/BDT.h:9,green,green,9,tmva/tmvagui/inc/TMVA/BDT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/BDT.h,1,['green'],['green']
Energy Efficiency,"// now save all the epoch-wise monitoring information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodANNBase.cxx:31,monitor,monitoring,31,tmva/tmva/src/MethodANNBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodANNBase.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// now we have passed the parameters we can allocate the dynamic tensors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel.cxx:44,allocate,allocate,44,tmva/sofie/src/RModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/src/RModel.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// number of adaptive width iterations. Default is 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:13,adapt,adaptive,13,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// number of output dimensions for regression; // input for adaptive volume adjustment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodPDERS.h:60,adapt,adaptive,60,tmva/tmva/inc/TMVA/MethodPDERS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodPDERS.h,1,['adapt'],['adaptive']
Energy Efficiency,"// number of reduced and projected points",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEvePolygonSetProjected.h:13,reduce,reduced,13,graf3d/eve/inc/TEvePolygonSetProjected.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEvePolygonSetProjected.h,1,['reduce'],['reduced']
Energy Efficiency,"// number of x-y points allocated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/inc/TXTRU.h:24,allocate,allocated,24,graf3d/g3d/inc/TXTRU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/inc/TXTRU.h,1,['allocate'],['allocated']
Energy Efficiency,"// number of z planes allocated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/inc/TXTRU.h:22,allocate,allocated,22,graf3d/g3d/inc/TXTRU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/inc/TXTRU.h,1,['allocate'],['allocated']
Energy Efficiency,"// opposite charge?; // Int_t rhoQc = _rhoQ*int(_correctQ);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx:12,charge,charge,12,roofit/roofit/src/RooNonCPEigenDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx,1,['charge'],['charge']
Energy Efficiency,"// optimization, try to pre-allocate tris",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:28,allocate,allocate,28,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['allocate'],['allocate']
Energy Efficiency,"// or in CSS ""x_line_color: green;""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rframe.cxx:28,green,green,28,tutorials/rcanvas/rframe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rframe.cxx,1,['green'],['green']
Energy Efficiency,// other coordinate representation; /**; Energy; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PxPyPzM4D.h:41,Energy,Energy,41,math/genvector/inc/Math/GenVector/PxPyPzM4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PxPyPzM4D.h,1,['Energy'],['Energy']
Energy Efficiency,"// particle is not a photon or neutrino; // if current particle is charged, apply magnetic field influence",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:67,charge,charged,67,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['charge'],['charged']
Energy Efficiency,"// perform monitor operation at each interior-point iteration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpSolverBase.h:11,monitor,monitor,11,math/quadp/inc/TQpSolverBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpSolverBase.h,1,['monitor'],['monitor']
Energy Efficiency,"// plot projection of 2D binned data on y; // Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; //; // All reduce() methods are interfaced in RooAbsData. All reduction techniques; // demonstrated on unbinned datasets can be applied to binned datasets as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:46,Reduce,Reduce,46,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,2,"['Reduce', 'reduce']","['Reduce', 'reduce']"
Energy Efficiency,"// positron charge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h:12,charge,charge,12,geom/geom/inc/TGeant4SystemOfUnits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h,2,['charge'],['charge']
Energy Efficiency,"// positron charge in coulomb",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h:12,charge,charge,12,geom/geom/inc/TGeant4SystemOfUnits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h,2,['charge'],['charge']
Energy Efficiency,"// power basis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:3,power,power,3,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,1,['power'],['power']
Energy Efficiency,"// power nth #sqrt[n]{arg}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLatex.cxx:3,power,power,3,graf2d/graf/src/TLatex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLatex.cxx,1,['power'],['power']
Energy Efficiency,// powerpc-apple-*,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/SubtargetFeature.cpp:3,power,powerpc-apple,3,interpreter/llvm-project/llvm/lib/TargetParser/SubtargetFeature.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/SubtargetFeature.cpp,1,['power'],['powerpc-apple']
Energy Efficiency,// powers of two; I1 == I01 << 1,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,power,powers,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['power'],['powers']
Energy Efficiency,"// prevent timers from blocking file descriptor monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:48,monitor,monitoring,48,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// print the position x in standard std::ostream; // GSL prints also niter- ntrials - temperature and then the energy and energy min value (from 1.10)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx:111,energy,energy,111,math/mathmore/src/GSLSimAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx,2,['energy'],['energy']
Energy Efficiency,"// print the position xp; // GSL prints also first niter- ntrials - temperature and then the energy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx:93,energy,energy,93,math/mathmore/src/GSLSimAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx,1,['energy'],['energy']
Energy Efficiency,"// printf(""Redraw %dx%d at %d,%d\n"", w, h, x, y);; // Allocate and clear a pixmap upon which to draw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:54,Allocate,Allocate,54,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"// printf(""reduced %d points of %d\n"", fNPnts, N);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx:11,reduce,reduced,11,graf3d/eve/src/TEvePolygonSetProjected.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePolygonSetProjected.cxx,2,['reduce'],['reduced']
Energy Efficiency,"// problems; // some PLs now have negative values, try to reduce fZ-matrix again",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:58,reduce,reduce,58,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// props was allocated by I/O system, we cannot delete here in case it gets reused",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCategory.cxx:13,allocate,allocated,13,roofit/roofitcore/src/RooCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCategory.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// provide epoch-wise monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:22,monitor,monitoring,22,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// queue all pages waiting for consumption in the pipe before we give an; // answer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:31,consumption,consumption,31,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,2,['consumption'],['consumption']
Energy Efficiency,"// queue depth rounds up to next power of 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/test/RIoUring.cxx:33,power,power,33,io/io/test/RIoUring.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/test/RIoUring.cxx,1,['power'],['power']
Energy Efficiency,"// raising 1-x to the power of degree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/ComputeFunctions.cxx:22,power,power,22,roofit/batchcompute/src/ComputeFunctions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/ComputeFunctions.cxx,1,['power'],['power']
Energy Efficiency,"// re-allocate the object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TPolyLine.cxx:6,allocate,allocate,6,graf2d/graf/src/TPolyLine.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TPolyLine.cxx,20,['allocate'],['allocate']
Energy Efficiency,"// re-allocate the outline points",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx:6,allocate,allocate,6,graf3d/g3d/src/TXTRU.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// re-allocate the z positions/scales",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx:6,allocate,allocate,6,graf3d/g3d/src/TXTRU.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// re-map into reduced hierarchy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:15,reduce,reduced,15,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// reaction Q for the lowest; // energy state",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTReactionXS.h:33,energy,energy,33,test/periodic/NdbMTReactionXS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/NdbMTReactionXS.h,1,['energy'],['energy']
Energy Efficiency,"// reduce THttpServer timer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx:3,reduce,reduce,3,tutorials/webgui/ping/ping.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// reduce [N] to []",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:3,reduce,reduce,3,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// reduce arguments if possible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/TMPWorkerExecutor.h:3,reduce,reduce,3,core/multiproc/inc/TMPWorkerExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/TMPWorkerExecutor.h,2,['reduce'],['reduce']
Energy Efficiency,"// reduce fEpsilon by a factor .001 for large kappa",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/VavilovAccurate.cxx:3,reduce,reduce,3,math/mathmore/src/VavilovAccurate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/VavilovAccurate.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// reduce final gradient result from T to double",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:3,reduce,reduce,3,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,2,['reduce'],['reduce']
Energy Efficiency,"// reduce n here since unbinned adaptive is slow",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:3,reduce,reduce,3,hist/hist/test/test_tkde.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx,2,"['adapt', 'reduce']","['adaptive', 'reduce']"
Energy Efficiency,"// reduce number of variable parameters by one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:3,reduce,reduce,3,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// reduce one dimension of the array; // return size of reduced dimension",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:3,reduce,reduce,3,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"// reduce statistics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:3,reduce,reduce,3,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,1,['reduce'],['reduce']
Energy Efficiency,// reduce step for smaller angles to keep normal distance approx same,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,reduce,reduce,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['reduce'],['reduce']
Energy Efficiency,"// reduce the data here for convenience, not really necessary because will happen inside RooNLLVar but still; // fData.reset( fData->reduce(RooFit::SelectVars(*fData->get()),RooFit::CutRange(rangeName)) );",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:3,reduce,reduce,3,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,2,['reduce'],['reduce']
Energy Efficiency,"// reduce the fit result by moving unselected float pars into the constPars list and dropping their covariances",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:3,reduce,reduce,3,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reduce']
Energy Efficiency,// reduce the number of lists!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp:3,reduce,reduce,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp,1,['reduce'],['reduce']
Energy Efficiency,// reduce to a single unit,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:3,reduce,reduce,3,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// reduced and projected points",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEvePolygonSetProjected.h:3,reduce,reduced,3,graf3d/eve/inc/TEvePolygonSetProjected.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEvePolygonSetProjected.h,1,['reduce'],['reduced']
Energy Efficiency,// reduced line segments,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,reduce,reduced,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['reduce'],['reduced']
Energy Efficiency,"// reduced scatter matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/fit/fitEllipseTGraphDLSF.cxx:3,reduce,reduced,3,tutorials/fit/fitEllipseTGraphDLSF.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/fit/fitEllipseTGraphDLSF.cxx,1,['reduce'],['reduced']
Energy Efficiency,// reduced vertices,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,reduce,reduced,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['reduce'],['reduced']
Energy Efficiency,"// rehash the hash table to reduce the collission rate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx:28,reduce,reduce,28,test/tcollex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// release allocated space in fKeep and set to 0 so; // Expand() will shrink correctly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:11,allocate,allocated,11,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// remember the number of nodes beforehand (for monitoring purposes)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDT.cxx:48,monitor,monitoring,48,tmva/tmva/src/MethodDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDT.cxx,1,['monitor'],['monitoring']
Energy Efficiency,// remove adjacent keyframes scheduled at the same time,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:29,schedul,scheduled,29,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['schedul'],['scheduled']
Energy Efficiency,"// remove template constructor since is ambiguous; /** Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementing operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integration methods); */; // this is ambiguous; // template<class Function>; // IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; // fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; // SetFunction(f, dim);; // }; /// destructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h:156,adapt,adaptive,156,math/mathcore/inc/Math/IntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h,2,['adapt'],['adaptive']
Energy Efficiency,"// remove the last "",; // lifetime of pointees:; // - jittedFilter: heap-allocated weak_ptr to the actual jittedFilter that will be deleted by JitFilterHelper; // - prevNodeOnHeap: heap-allocated shared_ptr to the actual previous node that will be deleted by JitFilterHelper; // - definesOnHeap: heap-allocated, will be deleted by JitFilterHelper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:73,allocate,allocated,73,tree/dataframe/src/RDFInterfaceUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx,3,['allocate'],['allocated']
Energy Efficiency,"// remove the last "",; // lifetime of pointees:; // - lm is the loop manager, and if that goes out of scope jitting does not happen at all (i.e. will always be valid); // - jittedDefine: heap-allocated weak_ptr that will be deleted by JitDefineHelper after usage; // - definesAddr: heap-allocated, will be deleted by JitDefineHelper after usage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:192,allocate,allocated,192,tree/dataframe/src/RDFInterfaceUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx,2,['allocate'],['allocated']
Energy Efficiency,"// reserve n for more efficient usage; //dv.Data().reserve(n);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx:22,efficient,efficient,22,hist/hist/src/HFitInterface.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// reset monitoring histogram vectors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodANNBase.cxx:9,monitor,monitoring,9,tmva/tmva/src/MethodANNBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodANNBase.cxx,1,['monitor'],['monitoring']
Energy Efficiency,// resulting shift; // Reduce shift amount for IsAdd.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DivisionByConstantInfo.cpp:23,Reduce,Reduce,23,interpreter/llvm-project/llvm/lib/Support/DivisionByConstantInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DivisionByConstantInfo.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"// retrieve the first TTree; // (re-adapted from TEventIter.cxx)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TMPWorkerTree.cxx:36,adapt,adapted,36,tree/treeplayer/src/TMPWorkerTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TMPWorkerTree.cxx,1,['adapt'],['adapted']
Energy Efficiency,"// return bin content in binz1, binz2, reduced flags; // return true if bin should be displayed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:39,reduce,reduced,39,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['reduce'],['reduced']
Energy Efficiency,// return the allocated FileNumber.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:14,allocate,allocated,14,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// return the number of bits allocated by the number ""n""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:29,allocate,allocated,29,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,1,['allocate'],['allocated']
Energy Efficiency,// returns max pressure for a tentative schedule,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:40,schedul,schedule,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// right/left-handed (+/- 1) - ""charge""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoHelix.h:32,charge,charge,32,geom/geom/inc/TGeoHelix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoHelix.h,1,['charge'],['charge']
Energy Efficiency,// root with arbitrary power,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:23,power,power,23,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['power'],['power']
Energy Efficiency,// running first pass with TargetOccupancy = 0 mimics previous scheduling; // approach and is a performance magic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:63,schedul,scheduling,63,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"// save previous allocated colors, delete at end when not used anymore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:17,allocate,allocated,17,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,2,['allocate'],['allocated']
Energy Efficiency,// schedule() have seen register pressure over the critical limits and had to; // track register pressure for actual scheduling heuristics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:3,schedul,schedule,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"// scheduleRegions walks bottom to top, so its likely we just get next; // instruction to track",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:3,schedul,scheduleRegions,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,1,['schedul'],['scheduleRegions']
Energy Efficiency,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:3,schedul,scheduledNode,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,6,['schedul'],"['scheduled', 'scheduledNode', 'scheduling']"
Energy Efficiency,"// select (extelt V, Index), T, F --> select (splat V, Index), T, F; // Splatting the extracted condition reduces code (we could directly create a; // splat shuffle of the source vector to eliminate the intermediate step).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:106,reduce,reduces,106,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['reduce'],['reduces']
Energy Efficiency,// send data with post request - most efficient way,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:38,efficient,efficient,38,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['efficient'],['efficient']
Energy Efficiency,"// set adaptive weights in fWeights matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:7,adapt,adaptive,7,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// set default max of function calls according to the number of parameters; // formula from Minuit2 (adapted)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitConfig.cxx:101,adapt,adapted,101,math/mathcore/src/FitConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitConfig.cxx,1,['adapt'],['adapted']
Energy Efficiency,// set table size in stack; // allocate and link in new table,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,allocate,allocate,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['allocate'],['allocate']
Energy Efficiency,// set the light's intensity (in candela) from the desired luminous power (in lumens),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:68,power,power,68,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,2,['power'],['power']
Energy Efficiency,// set the light's intensity (in nits) from the desired luminous power (in lumens),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:65,power,power,65,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['power'],['power']
Energy Efficiency,"// set to 1 the reduced dims",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx:16,reduce,reduced,16,tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Reduce.hxx,1,['reduce'],['reduced']
Energy Efficiency,"// shut down the write direction (no more writes from our side); // drain anything the other end might still want to send",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:68,drain,drain,68,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['drain'],['drain']
Energy Efficiency,"// so the worst parameter is found - fix it and exclude,; // reduce fZ-matrix again",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:61,reduce,reduce,61,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// special options for Adaptive mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx:23,Adapt,Adaptive,23,tmva/tmva/src/MethodPDERS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx,1,['Adapt'],['Adaptive']
Energy Efficiency,"// specific method for one-dim; /// Set number of points for active integration rule.; /// - For the GSL adaptive integrator, `n = 1,2,3,4,5,6` correspond to the 15,21,31,41,51,61-point integration rules.; /// - For the GaussLegendre integrator, use values > 6, which correspond to the actual number of points being evaluated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h:105,adapt,adaptive,105,math/mathcore/inc/Math/IntegratorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h,1,['adapt'],['adaptive']
Energy Efficiency,// src_ls_rr_sort - Priority function for source order scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:55,schedul,scheduler,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduler']
Energy Efficiency,// static schedules algorithims for distribute,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:10,schedul,schedules,10,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['schedul'],['schedules']
Energy Efficiency,"// static_assert that sizeof(T) is not ""too big"".; //; // Because our policy guarantees at least one inlined element, it is possible; // for an arbitrarily large inlined element to allocate an arbitrarily large; // amount of inline storage. We generally consider it an antipattern for a; // SmallVector to allocate an excessive amount of inline storage, so we want; // to call attention to these cases and make sure that users are making an; // intentional decision if they request a lot of inline storage.; //; // We want this assertion to trigger in pathological cases, but otherwise; // not be too easy to hit. To accomplish that, the cutoff is actually somewhat; // larger than kPreferredSmallVectorSizeof (otherwise,; // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that; // pattern seems useful in practice).; //; // One wrinkle is that this assertion is in theory non-portable, since; // sizeof(T) is in general platform-dependent. However, we don't expect this; // to be much of an issue, because most LLVM development happens on 64-bit; // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for; // 32-bit hosts, dodging the issue. The reverse situation, where development; // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a; // 64-bit host, is expected to be very rare.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:181,allocate,allocate,181,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,2,['allocate'],['allocate']
Energy Efficiency,"// std::call_once from libc++ is used on all Unix platforms. Other; // implementations like libstdc++ are known to have problems on NetBSD,; // OpenBSD and PowerPC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:156,Power,PowerPC,156,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['Power'],['PowerPC']
Energy Efficiency,"// std::cout<<""LASymMatrix(const ABObj<sym, LASymMatrix, T>& v)""<<std::endl;; // std::cout<<""allocate ""<<fSize<<std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/LASymMatrix.h:93,allocate,allocate,93,math/minuit2/inc/Minuit2/LASymMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/LASymMatrix.h,1,['allocate'],['allocate']
Energy Efficiency,"// std::cout<<""LAVector(const ABObj<LAVector, T>& v)""<<std::endl;; // std::cout<<""allocate ""<<fSize<<std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/LAVector.h:82,allocate,allocate,82,math/minuit2/inc/Minuit2/LAVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/LAVector.h,1,['allocate'],['allocate']
Energy Efficiency,"// std::cout<<""StackAllocator Allocate ""<<default_size<<std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h:30,Allocate,Allocate,30,math/minuit2/inc/Minuit2/StackAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h,1,['Allocate'],['Allocate']
Energy Efficiency,"// sterilize first so that cache elements don't appear in the client list; // safety net in case sterilizing one client deletes another one of our clients; // monitor for change in clients list size; // found this was only case in 6.26 (valgrind shows invalid read), in 6.28 these went away; // might be in 6.28 the client list iterator became able to handle in-loop edits but didn't see; // in test case that client count changed so just resterilizing if that's the case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:159,monitor,monitor,159,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['monitor'],['monitor']
Energy Efficiency,"// still very slight dark shift ??; //QueryColors((Colormap)cmap, &xc, 1);; //printf(""1 xc.red = %u, xc.green = %u, xc.blue = %u\n"", xc.red, xc.green, xc.blue);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx:104,green,green,104,graf2d/x11/src/GX11Gui.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx,2,['green'],['green']
Energy Efficiency,"// struct RDaosNTupleAnchor; // clang-format off; /**; \class ROOT::Experimental::Internal::RPageSinkDaos; \ingroup NTuple; \brief Storage provider that writes ntuple pages to into a DAOS container. Currently, an object is allocated for ntuple metadata (anchor/header/footer).; Objects can correspond to pages or clusters of pages depending on the RNTuple-DAOS mapping strategy.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx:223,allocate,allocated,223,tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,1,['allocate'],['allocated']
Energy Efficiency,"// t2STMIA is reduced to tSTMIA_UPD which has writeback. We can only do this; // if the base register is killed, as then it doesn't matter what its value; // is after the instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:14,reduce,reduced,14,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['reduce'],['reduced']
Energy Efficiency,"// take address of first adapter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx:25,adapt,adapter,25,core/base/src/TUUID.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx,1,['adapt'],['adapter']
Energy Efficiency,"// test of multidimentional Integration; // Calculates an integral of a function; // in 2,3,..., 8 dimensions; // by using adaptive Genz Malik cubature; // and MonteCarlo methods:; // --PLAIN; // --VEGAS; // --MISER; //; // from; // IntegratorMultiDim class; // and GSLMCIntegrator class; //; // Compares time performance; // for different dimensions; // draws a graph; //; // Author: Magdalena Slawinska; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testMCIntegration.cxx:123,adapt,adaptive,123,math/mathmore/test/testMCIntegration.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testMCIntegration.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:234,adapt,adaptation,234,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['adapt'],['adaptation']
Energy Efficiency,"// the adaptive sampling algorithm wants at least one toy event to be outside; // of the requested pvalue including the sampling variation. That leads to an equation; // N-1 = (1-alpha)N + Z sqrt(N - (1-alpha)N) // for upper limit and; // 1 = alpha N - Z sqrt(alpha N) // for lower limit; //; // solving for N gives:; // N = 1/alpha * [3/2 + sqrt(5)] for Z = 1 (which is used currently); // thus, a good guess for the first iteration of events is N=3.73/alpha~4/alpha; // should replace alpha here by smaller tail probability: eg. alpha*Min(leftsideFrac, 1.-leftsideFrac); // totalMC will be incremented by 2 before first call, so initiated it at half the value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NeymanConstruction.cxx:7,adapt,adaptive,7,roofit/roostats/src/NeymanConstruction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NeymanConstruction.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// the rest of this function is an adaptation of RooAbsTestStatistic::initSimMode:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx:35,adapt,adaptation,35,roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,1,['adapt'],['adaptation']
Energy Efficiency,"// this creates the gsl_rng structure; // no real need to call CreateEngine since the underlined MIXMAX engine is created; // by calling GSLMixMaxWrapper::Seed(gsl_default_seed) that is called; // when gsl_rng is allocated (in Initialize)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx:213,allocate,allocated,213,math/mathmore/src/GSLRndmEngines.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// this is done only for adaptive KDE; // fill a temporary histo using nonadaptive KDE; // this histo is identical with the final output when using only nonadaptive KDE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx:25,adapt,adaptive,25,tmva/tmva/src/KDEKernel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/KDEKernel.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// this is not very efficient, as the same normalization; // is calculated once per neuron instead of just once",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TNeuron.cxx:20,efficient,efficient,20,math/mlp/src/TNeuron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TNeuron.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// this should do a cleanup of the remaining; // X allocated objects...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGClient.cxx:51,allocate,allocated,51,gui/gui/src/TGClient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGClient.cxx,1,['allocate'],['allocated']
Energy Efficiency,// this vector holds free registers that we allocate in groups for some of the; // LEON passes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.h:44,allocate,allocate,44,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.h,1,['allocate'],['allocate']
Energy Efficiency,"// tiledpbf16ps.scalarize.inner.body:; // calculate idxa, idxb, idxc; // %eltc = extractelement <256 x i32> %vec.c.inner.phi, i16 %idxc; // %eltcf32 = bitcast i32 %eltc to float; // %elta = extractelement <256 x i32> %veca, i16 %idxa; // %eltav2i16 = bitcast i32 %elta to <2 x i16>; // %eltb = extractelement <256 x i32> %vecb, i16 %idxb; // %eltbv2i16 = bitcast i32 %eltb to <2 x i16>; // %shufflea = shufflevector <2 x i16> %elta, <2 x i16> zeroinitializer, <4; // x i32> <i32 2, i32 0, i32 3, i32 1>; // %eltav2f32 = bitcast <4 x i16> %shufflea to <2 x float>; // %shuffleb = shufflevector <2 x i16> %eltb, <2 xi16> zeroinitializer, <4 x; // i32> <i32 2, i32 0, i32 3, i32 1>; // %eltbv2f32 = bitcast <4 x i16> %shuffleb to <2 x float>; // %mulab = fmul <2 x float> %eltav2f32, %eltbv2f32; // %acc = call float; // @llvm.vector.reduce.fadd.v2f32(float %eltcf32, <2 x float> %mulab); // %neweltc = bitcast float %acc to i32; // %NewVecC = insertelement <256 x i32> %vec.c.inner.phi, i32 %neweltc,; // i16 %idxc; // %NewVecD = insertelement <256 x i32> %vec.d.inner.phi, i32 %neweltc,; // i16 %idxc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXIntrinsics.cpp:831,reduce,reduce,831,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXIntrinsics.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// tiledpbssd.scalarize.inner.body:; // calculate idxa, idxb; // %eltc = extractelement <256 x i32> %vec.c.inner.phi, i16 %idxc; // %elta = extractelement <256 x i32> %veca, i16 %idxa; // %eltav4i8 = bitcast i32 %elta to <4 x i8>; // %eltb = extractelement <256 x i32> %vecb, i16 %idxb; // %eltbv4i8 = bitcast i32 %eltb to <4 x i8>; // %eltav4i32 = sext <4 x i8> %eltav4i8 to <4 x i32>; // %eltbv4i32 = sext <4 x i8> %eltbv4i8 to <4 x i32>; // %mulab = mul <4 x i32> %eltbv4i32, %eltav4i32; // %acc = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %131); // %neweltc = add i32 %elt, %acc; // %NewVecC = insertelement <256 x i32> %vec.c.inner.phi, i32 %neweltc,; // i16 %idxc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXIntrinsics.cpp:523,reduce,reduce,523,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXIntrinsics.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// time or energy of (x,y,z,t) or (px,py,pz,e)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h:11,energy,energy,11,math/physics/inc/TLorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h,1,['energy'],['energy']
Energy Efficiency,"// to reset the underlying allocate space; // if (fPRealData) fPRealData->Delete();; // delete fPRealData;; // fPRealData = 0;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx:27,allocate,allocate,27,core/meta/src/TProtoClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// todo: this would be a lot more powerful if we used scev, but all the; // plumbing is currently missing to pass a pointer in from the pass; // Check for cmp (phi [x, preheader] ...), y where (pred x, y is known",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:34,power,powerful,34,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['power'],['powerful']
Energy Efficiency,"// total energy in C.M. minus the sum of the masses",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TGenPhaseSpace.cxx:9,energy,energy,9,math/physics/src/TGenPhaseSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TGenPhaseSpace.cxx,1,['energy'],['energy']
Energy Efficiency,"// total energy in the C.M. minus the total mass",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TGenPhaseSpace.h:9,energy,energy,9,math/physics/inc/TGenPhaseSpace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TGenPhaseSpace.h,1,['energy'],['energy']
Energy Efficiency,"// try to reduce some error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:10,reduce,reduce,10,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// try to reduce some error messages; //bool silentMode = (RooMsgService::instance().globalKillBelow() >= RooFit::ERROR || RooMsgService::instance().silentMode()) ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:10,reduce,reduce,10,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// try to reduce the size of the interval",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:10,reduce,reduce,10,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// turn adaptive sampling off if given",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:8,adapt,adaptive,8,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; // begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:369,allocate,allocated,369,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['allocate'],['allocated']
Energy Efficiency,"// typedef void* (*CopyIterator_t)(void **dest, const void *source);; // Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; // If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); // Otherwise the iterator will be allocated via a regular new.; // The actual address of the iterator is returned in both case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:356,allocate,allocated,356,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['allocate'],['allocated']
Energy Efficiency,"// udiv exact (mul nsw X, C), C --> X; // sdiv exact (mul nuw X, C), C --> X; // where C is not a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:98,power,power,98,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['power'],['power']
Energy Efficiency,"// update internal rho parameters; // redetermine static and/or adaptive bandwidth",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx:64,adapt,adaptive,64,roofit/roofit/src/RooNDKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNDKeysPdf.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// use a reduced state for not-final iterations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/VariableMetricBuilder.cxx:9,reduce,reduced,9,math/minuit2/src/VariableMetricBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/VariableMetricBuilder.cxx,1,['reduce'],['reduced']
Energy Efficiency,"// use array pre-allocated in tree->Draw . This is faster; // assert(x != 0);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testFitPerf.cxx:17,allocate,allocated,17,roofit/roofit/test/testFitPerf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testFitPerf.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// use name to reduce the fit result, if one given",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:15,reduce,reduce,15,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reduce']
Energy Efficiency,"// use unique_ptr<RDefineBase> instead of make_unique<NewCol_t> to reduce jit/compile-times",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:67,reduce,reduce,67,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,2,['reduce'],['reduce']
Energy Efficiency,"// used ONLY for the monitoring tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx:21,monitor,monitoring,21,tmva/tmva/src/MethodBoost.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx,2,['monitor'],['monitoring']
Energy Efficiency,"// v16i8 is a special case, as we have 16 entries but only 8 positional bits; // per entry. We split it into two halves, apply the mask, zip the halves to; // create 8x 16-bit values, and the perform the vector reduce.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:211,reduce,reduce,211,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,// vXi1 can be efficiently extracted with MOVMSK.; // TODO: AVX512 predicate mask handling.; // NOTE: This doesn't work well for roundtrip scalarization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:15,efficient,efficiently,15,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['efficient'],['efficiently']
Energy Efficiency,// vXi8 multiplications are always promoted to vXi16.; // Sub-128-bit types can be extended/packed more efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:104,efficient,efficiently,104,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"// valid schedule type values, without monotonicity flags",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:9,schedul,schedule,9,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['schedul'],['schedule']
Energy Efficiency,"// variance = reducedVar;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:14,reduce,reducedVar,14,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['reduce'],['reducedVar']
Energy Efficiency,"// void TFumiliMinimizer::FcnGrad( int &, double * g, double & f, double * x , int iflag ) {; // // implementation of FCN static function used internally by TFumili.; // // Adapt IMultiGradFunction interface to TFumili FCN static function in the case of user; // // provided gradient.; // ROOT::Math::IMultiGradFunction * gFunc = dynamic_cast<ROOT::Math::IMultiGradFunction *> ( fgFunc);; // assert(gFunc != 0);; // f = gFunc->operator()(x);; // // calculates also derivatives; // if (iflag == 2) gFunc->Gradient(x,g);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx:173,Adapt,Adapt,173,math/fumili/src/TFumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx,1,['Adapt'],['Adapt']
Energy Efficiency,"// vscale is not necessarily a power-of-2, which means we cannot guarantee; // an overflow to zero when updating induction variables and so an; // additional overflow check is required before entering the vector loop.; // Get the maximum unsigned value for the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:31,power,power-of-,31,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['power'],['power-of-']
Energy Efficiency,// vscale(power-of-two) is a power-of-two for some targets,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:10,power,power-of-two,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['power'],['power-of-two']
Energy Efficiency,"// wait for queue to drain",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TThreadPool.h:21,drain,drain,21,core/thread/inc/TThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TThreadPool.h,1,['drain'],['drain']
Energy Efficiency,// wait_cnt scores for every vgpr.; // Keep track of the VgprUB and SgprUB to make merge at join efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:97,efficient,efficient,97,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['efficient'],['efficient']
Energy Efficiency,// warn +dataWithBytesNoCopy:length:freeWhenDone: cannot take; // ownership of memory allocated by 'new',MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers/mismatched_deallocator_example.cpp:86,allocate,allocated,86,interpreter/llvm-project/clang/docs/analyzer/checkers/mismatched_deallocator_example.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers/mismatched_deallocator_example.cpp,1,['allocate'],['allocated']
Energy Efficiency,// warn: argument is not allocated by malloc,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers/unix_malloc_example.c:25,allocate,allocated,25,interpreter/llvm-project/clang/docs/analyzer/checkers/unix_malloc_example.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers/unix_malloc_example.c,1,['allocate'],['allocated']
Energy Efficiency,// warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]',MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers/newdelete_example.cpp:82,allocate,allocated,82,interpreter/llvm-project/clang/docs/analyzer/checkers/newdelete_example.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers/newdelete_example.cpp,1,['allocate'],['allocated']
Energy Efficiency,// warn: deleting memory allocated by alloca,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers/newdelete_example.cpp:25,allocate,allocated,25,interpreter/llvm-project/clang/docs/analyzer/checkers/newdelete_example.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers/newdelete_example.cpp,1,['allocate'],['allocated']
Energy Efficiency,"// was allocated as TObjArray in TGenerator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/src/TPythia8.cxx:7,allocate,allocated,7,montecarlo/pythia8/src/TPythia8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/src/TPythia8.cxx,2,['allocate'],['allocated']
Energy Efficiency,"// watt = 6.24150 e+3 * MeV/ns; //; // Force [E][L^-1]; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h:3,watt,watt,3,geom/geom/inc/TGeant4SystemOfUnits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h,2,['watt'],['watt']
Energy Efficiency,"// we don't use a std::vector or std::array here, because we want a mix of the two;; // a stack-allocated container with fixed capacity but dynamic size, i.e. the equivalent; // of static_vector from the Boost Container library",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx:96,allocate,allocated,96,math/minuit2/src/MnPrint.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx,1,['allocate'],['allocated']
Energy Efficiency,"// we will store computed adaptive weights in weights",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:26,adapt,adaptive,26,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// when Mathmore is not built only possible type is ADAPTIVE. There is no other choice",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx:52,ADAPT,ADAPTIVE,52,math/mathcore/src/Integrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Integrator.cxx,1,['ADAPT'],['ADAPTIVE']
Energy Efficiency,"// when implementing a dynamic schedule for a 'for' combined with a; // 'distribute' (e.g. 'distribute parallel for'), the 'for' loop; // is not normalized as each team only executes its own assigned; // distribute chunk",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:31,schedul,schedule,31,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['schedul'],['schedule']
Energy Efficiency,"// when of reading from a file fKernelFunction is a nullptr; // we need to recreate Kernel class (with adaptive weights if needed) and; // recreate kernel function pointer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:103,adapt,adaptive,103,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// when using adaptive mirror a much; // smaller bandwidth is used. Not sure this is correct; // seee line TKDE.cxx:770",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:14,adapt,adaptive,14,hist/hist/test/test_tkde.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// white on green background",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx:12,green,green,12,tmva/tmva/src/Tools.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx,1,['green'],['green']
Energy Efficiency,"// will allocate it later",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootCanvas.cxx:8,allocate,allocate,8,gui/gui/src/TRootCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootCanvas.cxx,1,['allocate'],['allocate']
Energy Efficiency,"// with binned not adaptive it is good for high statistics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:19,adapt,adaptive,19,hist/hist/test/test_tkde.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"// write additional monitoring histograms to main target file (not the weight file); // again, make sure the histograms go into the method's subdirectory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:20,monitor,monitoring,20,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['monitor'],['monitoring']
Energy Efficiency,"// write classifier-specific monitoring information to target file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h:29,monitor,monitoring,29,tmva/tmva/inc/TMVA/MethodBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h,1,['monitor'],['monitoring']
Energy Efficiency,"// write method specific monitoring histograms to target file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/IMethod.h:25,monitor,monitoring,25,tmva/tmva/inc/TMVA/IMethod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/IMethod.h,1,['monitor'],['monitoring']
Energy Efficiency,"// write title; // commented out for now because it reduces overview; /*; len = strlen(classNames[i]);; for (Int_t w = 0; w < (maxLen - len + 2); w++); out << ""."";; out << "" "";. out << ""<a name=\""Title:"";; out << classPtr->GetName();; out << ""\"">"";; ReplaceSpecialChars(out, classPtr->GetTitle());; out << ""</a></tt>"" << std::endl;; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TClassDocOutput.cxx:52,reduce,reduces,52,html/src/TClassDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TClassDocOutput.cxx,1,['reduce'],['reduces']
Energy Efficiency,"// writing the monitoring histograms and tree to a file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBoost.h:15,monitor,monitoring,15,tmva/tmva/inc/TMVA/MethodBoost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBoost.h,1,['monitor'],['monitoring']
Energy Efficiency,"// xRooNode xRooNode::fitTo(const xRooNode& _data) const {; //; //; // auto _pdf = get<RooAbsPdf>();; // if (!_pdf) throw std::runtime_error(""Not a pdf"");; //; // auto _globs = _data.globs(); // keep alive because may own the globs; // RooArgSet globsSet(_globs.argList());; //; // std::shared_ptr<RooSimultaneous> newPdf;; // if(auto s = get<RooSimultaneous>(); s) {; // auto rangeName = GetRange();; // if (rangeName) {; // // need to reduce the RooSimultaneous until fix: https://github.com/root-project/root/issues/8231; // std::vector<TString> chanPatterns;; // TStringToken pattern(rangeName, "","");; // while (pattern.NextToken()) {; // chanPatterns.emplace_back(pattern);; // }; // auto& _cat = const_cast<RooAbsCategoryLValue&>(s->indexCat());; // newPdf = std::make_shared<RooSimultaneous>(TString::Format(""%s_reduced"",GetName()),""Reduced model"",_cat);; // for(auto& c : variations()) {; // TString cName(c->GetName());; // cName = cName(cName.Index('=')+1,cName.Length());; // _cat.setLabel(cName);; // bool matchAny=false;; // for(auto& p : chanPatterns) {; // if (cName.Contains(TRegexp(p,true))) { matchAny=true; break; }; // if (_cat.hasRange(p) && _cat.inRange(p)) { matchAny=true; break; }; // }; // if(matchAny) {; // newPdf->addPdf( *c->get<RooAbsPdf>(), cName );; // }; // }; // RooFitResultTree t(newPdf->GetName(),"""",*newPdf);; // auto _fr = std::const_pointer_cast<RooFitResult>(t.fitTo(_data.get<RooAbsData>(), &globsSet));; // xRooNode parent(_data.GetName(),nullptr,*this);; // xRooNode out(_fr->GetName(),/*acquire(_fr)*/ _fr,parent);; // // do full propagation by 'checking' the fr ...; // out.Checked(&out,true);; // return out;; // }; // }; //; //; //; // std::string treeName = TString::Format(""fits_%s"",GetName()).Data();; //; // auto _frt = getObject<TTree>(treeName); // get existing frt; //; // std::shared_ptr<RooFitResultTree> t;; // if (_frt) {; // t = std::make_shared<RooFitResultTree>(_frt.get());; // } else {; // t = std::make_shared<RooFitResultTree>(treeNam",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:437,reduce,reduce,437,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,2,"['Reduce', 'reduce']","['Reduced', 'reduce']"
Energy Efficiency,"// xRooNode xRooNode::generate(bool expected) const {; //; // auto fr = fitResult();; // auto _fr = fr.get<RooFitResult>();; //; // auto _pdf = (get<RooAbsPdf>()) ? std::shared_ptr<const xRooNode>(this, [](const xRooNode*){}) : parentPdf();; // if (!_pdf) {; // throw std::runtime_error(""Could not find pdf"");; // }; //; // std::shared_ptr<RooDataTree> t;; //; // std::shared_ptr<RooSimultaneous> newPdf;; // if(auto s = _pdf->get<RooSimultaneous>(); s) {; // auto rangeName = GetRange();; // if (rangeName) {; // // need to reduce the RooSimultaneous until fix: https://github.com/root-project/root/issues/8231; // std::vector<TString> chanPatterns;; // TStringToken pattern(rangeName, "","");; // while (pattern.NextToken()) {; // chanPatterns.emplace_back(pattern);; // }; // auto& _cat = const_cast<RooAbsCategoryLValue&>(s->indexCat());; // newPdf = std::make_shared<RooSimultaneous>(TString::Format(""%s_reduced"",GetName()),""Reduced model"",_cat);; // for(auto& c : _pdf->variations()) {; // TString cName(c->GetName());; // cName = cName(cName.Index('=')+1,cName.Length());; // _cat.setLabel(cName);; // bool matchAny=false;; // for(auto& p : chanPatterns) {; // if (cName.Contains(TRegexp(p,true))) { matchAny=true; break; }; // if (_cat.hasRange(p) && _cat.inRange(p)) { matchAny=true; break; }; // }; // if(matchAny) {; // newPdf->addPdf( *c->get<RooAbsPdf>(), cName );; // }; // }; // t = std::make_shared<RooDataTree>(newPdf->GetName(),"""",*newPdf);; // RooArgSet s1(_pdf->obs().argList());; // RooArgSet s2(_pdf->globs().argList());s1.remove(s2);; // t->SetObservables(&s1,&s2);; // auto _data = t->generate(_fr,expected);; //; // xRooNode parent(_fr ? _fr->GetName() : ""unknown"",nullptr,xRooNode(t,*this));; // xRooNode out(_data.first->GetName(),/*acquire(_fr)*/ _data.first,parent);; // out.emplace_back(std::make_shared<xRooNode>("".globs"",std::const_pointer_cast<RooArgSet>(_data.second),out));; // return out;; // }; // }; //; //; // std::string treeName = TString::Format(""gen_%s"",_pdf->",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:525,reduce,reduce,525,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,2,"['Reduce', 'reduce']","['Reduced', 'reduce']"
Energy Efficiency,"// xcol[i].red = xcol[i].green = xcol[i].blue = 0;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:25,green,green,25,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,1,['green'],['green']
Energy Efficiency,// yaml2obj sets the alignment of a segment to 1 by default.; // We do not print the default alignment to reduce noise in the output.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp:106,reduce,reduce,106,interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,1,['reduce'],['reduce']
Energy Efficiency,"// you look for some 100% efficient pre-selection cut to remove background.. i.e. nSelS=0 && nSelB>5%nTotB or ( nSelB=0 nSelS>5%nTotS)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:26,efficient,efficient,26,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['efficient'],['efficient']
Energy Efficiency,"// }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:1523,efficient,efficiently,1523,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,2,['efficient'],['efficiently']
Energy Efficiency,"//! allocated data buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/inc/TMySQLStatement.h:4,allocate,allocated,4,sql/mysql/inc/TMySQLStatement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/inc/TMySQLStatement.h,1,['allocate'],['allocated']
Energy Efficiency,"//! power of specular lamp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLLightSet.h:4,power,power,4,graf3d/gl/inc/TGLLightSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLLightSet.h,1,['power'],['power']
Energy Efficiency,"//! power of the front lamp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLLightSet.h:4,power,power,4,graf3d/gl/inc/TGLLightSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLLightSet.h,1,['power'],['power']
Energy Efficiency,"//! power of the side lamps",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLLightSet.h:4,power,power,4,graf3d/gl/inc/TGLLightSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLLightSet.h,1,['power'],['power']
Energy Efficiency,"//! size of allocated data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/inc/TMySQLStatement.h:12,allocate,allocated,12,sql/mysql/inc/TMySQLStatement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/inc/TMySQLStatement.h,1,['allocate'],['allocated']
Energy Efficiency,"//!< Must be a power of 2 minus 1.; /**; * @brief Ring buffer for length component of pair (data, length).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:15,power,power,15,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['power'],['power']
Energy Efficiency,"//![fNumPIDs] allocated size of array fParentIDs for each ProcessID",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TRefTable.h:14,allocate,allocated,14,core/cont/inc/TRefTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TRefTable.h,1,['allocate'],['allocated']
Energy Efficiency,"//""energy""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SimulatedAnnealing.cxx:3,energy,energy,3,tmva/tmva/src/SimulatedAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SimulatedAnnealing.cxx,1,['energy'],['energy']
Energy Efficiency,"//#define w 0xFFFFFFL // White; //#define A 0xCCCCCCL // Gray; //#define B 0xCCCCFFL // Blue; //#define Y 0xFFFFCCL // Yellow; //#define O 0xFFCCCCL // Orange; //#define G 0xCCFFCCL // Green",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSPeriodicTable.cxx:185,Green,Green,185,test/periodic/XSPeriodicTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSPeriodicTable.cxx,1,['Green'],['Green']
Energy Efficiency,"//#ifdef TODO_LATER; /**; Multiply (combine) this Lorentz rotation by a pure Lorentz boost; */; //TODO: implement directly in a more efficient way. Now are implemented; // going through another LorentzRotation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzRotation.h:133,efficient,efficient,133,math/genvector/inc/Math/GenVector/LorentzRotation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzRotation.h,1,['efficient'],['efficient']
Energy Efficiency,"//(useBins) ? fKDE->fSumOfCounts : fKDE->fNEvents;; //if (!useCount) nSum = fKDE->fNEvents;; // in case of non-adaptive fWeights is a vector of size 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:111,adapt,adaptive,111,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['adapt'],['adaptive']
Energy Efficiency,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:43,Schedul,Scheduler,43,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,4,"['Schedul', 'schedul']","['Scheduler', 'scheduling']"
Energy Efficiency,"//---------------------------------------------------------------------------; // Adapter class used to handle streaming collection of pointers; //---------------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h:82,Adapt,Adapter,82,io/io/inc/TStreamerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h,1,['Adapt'],['Adapter']
Energy Efficiency,"//---------------------------------------------------------------------------; // Allocate and initialize the basket control arrays; //---------------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:82,Allocate,Allocate,82,tree/tree/src/TBranchSTL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx,2,['Allocate'],['Allocate']
Energy Efficiency,"//--------------------------------------------------------------------------; // Allocate global variables; /////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/RConversionRuleParser.cxx:81,Allocate,Allocate,81,core/foundation/src/RConversionRuleParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/RConversionRuleParser.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,"//-------------------------------------------------------------; //; // toGreen(Window_t id); //; // The same as above except changing the color to green.; //; //-------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx:148,green,green,148,test/histviewer/histaction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx,1,['green'],['green']
Energy Efficiency,/// 'omp parallel for' loop condition used when composed with; /// 'omp distribute' in the same construct and when schedule is; /// chunked and the chunk size is 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:115,schedul,schedule,115,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['schedul'],['schedule']
Energy Efficiency,"/// ******************************************************************; /// * *; /// * Runge-Kutta method for tracking a particle through a magnetic *; /// * field. Uses Nystroem algorithm (See Handbook Nat. Bur. of *; /// * Standards, procedure 25.5.20) *; /// * *; /// * Input parameters *; /// * CHARGE Particle charge *; /// * STEP Step size *; /// * VECT Initial co-ords,direction cosines,momentum *; /// * Output parameters *; /// * VOUT Output co-ords,direction cosines,momentum *; /// * User routine called *; /// * CALL GUFLD(X,F) *; /// * *; /// * ==>Called by : <USER>, GUSWIM *; /// * Authors R.Brun, M.Hansroul ********* *; /// * V.Perevoztchikov (CUT STEP implementation) *; /// * *; /// * *; /// ******************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx:299,CHARGE,CHARGE,299,graf3d/eve/src/TEveTrackPropagator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx,4,"['CHARGE', 'charge']","['CHARGE', 'charge']"
Energy Efficiency,/// 0x800 is reserved for compatibility with XLC.; /// Produce a runtime error if the data is not already allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:106,allocate,allocated,106,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['allocate'],['allocated']
Energy Efficiency,"/// <summary>; /// Retrieves the next set of product instances in the enumeration sequence.; /// </summary>; /// <param name=""celt"">The number of product instances to retrieve.</param>; /// <param name=""rgelt"">A pointer to an array of <see; /// cref=""ISetupInstance""/>.</param>; /// <param name=""pceltFetched"">A pointer to the number of product instances; /// retrieved. If celt is 1 this parameter may be NULL.</param>; /// <returns>S_OK if the number of elements were fetched, S_FALSE if nothing; /// was fetched (at end of enumeration), E_INVALIDARG if celt is greater than; /// 1 and pceltFetched is NULL, or E_OUTOFMEMORY if an <see; /// cref=""ISetupInstance""/> could not be allocated.</returns>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:680,allocate,allocated,680,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,1,['allocate'],['allocated']
Energy Efficiency,"/// @brief Figure out the output size of a node. It is the size of the; /// vector observable that it depends on, or 1 if it doesn't depend on any; /// or is a reducer node.; /// @param key The node to look up the size for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h:160,reduce,reducer,160,roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,1,['reduce'],['reducer']
Energy Efficiency,"/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; /// through a TCollection. This requires the collection to contain elements; /// of the type requested (or a derived class). Any deviation from this expectation; /// will only be caught/reported by an assert in debug builds.; ///; /// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; ///; /// The typical use is:; /// ```{.cpp}; /// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; /// ... use bcl as a TBaseClass*; /// }; /// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; /// ... use bcl as a TBaseClass*; /// }; /// ```; /// \tparam T The new type to convert to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h:34,adapt,adapter,34,core/cont/inc/TCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h,1,['adapt'],['adapter']
Energy Efficiency,"/// @name Materialization; /// Materialization is used to construct functions only as they're needed.; /// This; /// is useful to reduce memory usage in LLVM or parsing work done by the; /// BitcodeReader to load the Module.; /// @{; /// If this function's Module is being lazily streamed in functions from disk; /// or some other source, this method can be used to check to see if the; /// function has been read in yet or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:130,reduce,reduce,130,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['reduce'],['reduce']
Energy Efficiency,"/// @}; // Emits code that executes when the comparison result in the ll/sc; // expansion of a cmpxchg instruction is such that the store-conditional will; // not execute. This makes it possible to balance out the load-linked with; // a dedicated instruction, if desired.; // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would; // be unnecessarily held, except if clrex, inserted by this hook, is executed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:338,monitor,monitor,338,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['monitor'],['monitor']
Energy Efficiency,/// @}; /// @name String Comparison; /// @{; /// Check for string equality. This is more efficient than compare() when; /// the relative ordering of inequal strings isn't needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h:89,efficient,efficient,89,interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h,1,['efficient'],['efficient']
Energy Efficiency,"/// @}; /// Inserts in the IR a target-specific intrinsic specifying a fence.; /// It is called by AtomicExpandPass before expanding an; /// AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad; /// if shouldInsertFencesForAtomic returns true.; ///; /// Inst is the original atomic instruction, prior to other expansions that; /// may be performed.; ///; /// This function should either return a nullptr, or a pointer to an IR-level; /// Instruction*. Even complex fence sequences can be represented by a; /// single Instruction* through an intrinsic to be lowered later.; ///; /// The default implementation emits an IR fence before any release (or; /// stronger) operation that stores, and after any acquire (or stronger); /// operation. This is generally a correct implementation, but backends may; /// override if they wish to use alternative schemes (e.g. the PowerPC; /// standard ABI uses a fence before a seq_cst load instead of after a; /// seq_cst store).; /// @{",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:859,Power,PowerPC,859,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Power'],['PowerPC']
Energy Efficiency,/// @}; /// Returns whether this instance allocated memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:42,allocate,allocated,42,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,1,['allocate'],['allocated']
Energy Efficiency,"/// @}; //===--------------------------------------------------------------------===//; // Accessors used to build up machine instructions.; /// Add the specified operand to the instruction. If it is an implicit; /// operand, it is added to the end of the operand list. If it is an; /// explicit operand it is added at the end of the explicit operand list; /// (before the first implicit operand).; ///; /// MF must be the machine function that was used to allocate this; /// instruction.; ///; /// MachineInstrBuilder provides a more convenient interface for creating; /// instructions and adding operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:457,allocate,allocate,457,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['allocate'],['allocate']
Energy Efficiency,"/// A (possibly-)qualified type.; ///; /// For efficiency, we don't store CV-qualified types as nodes on their; /// own: instead each reference to a type stores the qualifiers. This; /// greatly reduces the number of nodes we need to allocate for types (for; /// example we only need one for 'int', 'const int', 'volatile int',; /// 'const volatile int', etc).; ///; /// As an added efficiency bonus, instead of making this a pair, we; /// just store the two bits we care about in the low bits of the; /// pointer. To handle the packing/unpacking, we make QualType be a; /// simple wrapper class that acts like a smart pointer. A third bit; /// indicates whether there are extended qualifiers present, in which; /// case the pointer points to a special structure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:195,reduce,reduces,195,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,"['allocate', 'reduce']","['allocate', 'reduces']"
Energy Efficiency,/// A BumpPtrAllocator object used to quickly allocate and release; /// objects internal to the Preprocessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:46,allocate,allocate,46,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['allocate'],['allocate']
Energy Efficiency,/// A BumpPtrAllocator that allows only elements of a specific type to be; /// allocated.; ///; /// This allows calling the destructor in DestroyAll() and when the allocator is; /// destroyed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:79,allocate,allocated,79,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['allocate'],['allocated']
Energy Efficiency,/// A BumpPtrAllocator to allocate states.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h:26,allocate,allocate,26,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,1,['allocate'],['allocate']
Energy Efficiency,"/// A GC strategy for uncooperative targets. This implements lowering for the; /// llvm.gc* intrinsics for targets that do not natively support them (which; /// includes the C backend). Note that the code generated is not quite as; /// efficient as algorithms which generate stack maps to identify roots.; ///; /// In order to support this particular transformation, all stack roots are; /// coallocated in the stack. This allows a fully target-independent stack map; /// while introducing only minor runtime overhead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp:236,efficient,efficient,236,interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// A Helper struct that stores information about a class in a class; /// hierarchy. The information stored in these structs struct is used during; /// the generation of ClassHierarchyDescriptors and BaseClassDescriptors.; // During RTTI creation, MSRTTIClasses are stored in a contiguous array with; // implicit depth first pre-order tree connectivity. getFirstChild and; // getNextSibling allow us to walk the tree efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:417,efficient,efficiently,417,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['efficient'],['efficiently']
Energy Efficiency,/// A JITLinkMemoryManager that allocates in-process memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h:32,allocate,allocates,32,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,1,['allocate'],['allocates']
Energy Efficiency,"/// A Literal pointer to an object allocated in memory.; /// At compile time, pointer literals are represented by symbolic names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h:35,allocate,allocated,35,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,1,['allocate'],['allocated']
Energy Efficiency,/// A MachineSchedStrategy implementation for AArch64 post RA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineScheduler.h:62,schedul,scheduling,62,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,/// A MachineSchedStrategy implementation for PowerPC post RA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:46,Power,PowerPC,46,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,2,"['Power', 'schedul']","['PowerPC', 'scheduling']"
Energy Efficiency,/// A MachineSchedStrategy implementation for PowerPC pre RA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h:46,Power,PowerPC,46,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.h,2,"['Power', 'schedul']","['PowerPC', 'scheduling']"
Energy Efficiency,/// A MachineSchedStrategy implementation for SystemZ post RA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:62,schedul,scheduling,62,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// A POD-like structure that we use to store a global reference together with; /// its metadata types. In this pass we frequently need to query the set of; /// metadata types referenced by a global, which at the IR level is an expensive; /// operation involving a map lookup; this data structure helps to reduce the; /// number of times we need to do this lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:306,reduce,reduce,306,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// A ScheduleDAG for scheduling lists of MachineInstr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:6,Schedul,ScheduleDAG,6,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,2,"['Schedul', 'schedul']","['ScheduleDAG', 'scheduling']"
Energy Efficiency,"/// A TokenBuffer-powered token manager.; /// It tracks the underlying token buffers, source manager, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h:18,power,powered,18,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h,1,['power'],['powered']
Energy Efficiency,/// A ^ B can be specified using other logic ops in a variety of patterns. We; /// can fold these early and efficiently by morphing an existing instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:108,efficient,efficiently,108,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"/// A boolean expression such as ""true"" or ""V1 & !V2"".; /// Expressions may refer to boolean atomic variables. These should take a; /// consistent true/false value across the set of formulas being considered.; ///; /// (Formulas are always expressions in terms of boolean variables rather than; /// e.g. integers because our underlying model is SAT rather than e.g. SMT).; ///; /// Simple formulas such as ""true"" and ""V1"" are self-contained.; /// Compound formulas connect other formulas, e.g. ""(V1 & V2) || V3"" is an 'or'; /// formula, with pointers to its operands ""(V1 & V2)"" and ""V3"" stored as; /// trailing objects.; /// For this reason, Formulas are Arena-allocated and over-aligned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Formula.h:662,allocate,allocated,662,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Formula.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Formula.h,1,['allocate'],['allocated']
Energy Efficiency,"/// A boolean indicator for each slot listed in the FunctionInfo as to; /// whether it has been used in the current statepoint. Since we try to; /// preserve stack slots across safepoints, there can be gaps in which; /// slots have been allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h:237,allocate,allocated,237,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,1,['allocate'],['allocated']
Energy Efficiency,"/// A builder class that knows how to construct Instruction objects.; ///; /// Every llvm-mca Instruction is described by an object of class InstrDesc.; /// An InstrDesc describes which registers are read/written by the instruction,; /// as well as the instruction latency and hardware resources consumed.; ///; /// This class is used by the tool to construct Instructions and instruction; /// descriptors (i.e. InstrDesc objects).; /// Information from the machine scheduling model is used to identify processor; /// resources that are consumed by an instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/InstrBuilder.h:466,schedul,scheduling,466,interpreter/llvm-project/llvm/include/llvm/MCA/InstrBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/InstrBuilder.h,1,['schedul'],['scheduling']
Energy Efficiency,/// A bump pointer allocated array of offsets for each source line.; ///; /// This is lazily computed. The lines are owned by the SourceManager; /// BumpPointerAllocator object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:19,allocate,allocated,19,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['allocate'],['allocated']
Energy Efficiency,"/// A callback for emitting header usage information to a file in JSON. Each; /// line in the file is a JSON object that includes the source file name and; /// the list of headers directly or indirectly included from it. For example:; ///; /// {""source"":""/tmp/foo.c"",; /// ""includes"":[""/usr/include/stdio.h"", ""/usr/include/stdlib.h""]}; ///; /// To reduce the amount of data written to the file, we only record system; /// headers that are directly included from a file that isn't in the system; /// directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:348,reduce,reduce,348,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// A collection of instructions to delete.; /// We try to batch deletions to simplify code and make things a bit more; /// efficient. We also make sure there is no dangling pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:124,efficient,efficient,124,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['efficient'],['efficient']
Energy Efficiency,/// A concrete instance of a particular driver option.; ///; /// The Arg class encodes just enough information to be able to; /// derive the argument values efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/Arg.h:157,efficient,efficiently,157,interpreter/llvm-project/llvm/include/llvm/Option/Arg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/Arg.h,1,['efficient'],['efficiently']
Energy Efficiency,/// A counter of decoder groups scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:32,schedul,scheduled,32,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// A counterpart of LiveRange::createDeadDef: Make sure the range has a; /// value defined at @p Def.; /// If @p ForVNI is null, and there is no value defined at @p Def, a new; /// value will be allocated using @p VNInfoAllocator.; /// If @p ForVNI is null, the return value is the value defined at @p Def,; /// either a pre-existing one, or the one newly created.; /// If @p ForVNI is not null, then @p Def should be the location where; /// @p ForVNI is defined. If the range does not have a value defined at; /// @p Def, the value @p ForVNI will be used instead of allocating a new; /// one. If the range already has a value defined at @p Def, it must be; /// same as @p ForVNI. In either case, @p ForVNI will be the return value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:196,allocate,allocated,196,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:158,efficient,efficient,158,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,1,['efficient'],['efficient']
Energy Efficiency,/// A dummy default scheduler factory indicates whether the scheduler; /// is overridden on the command line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,schedul,scheduler,20,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduler']
Energy Efficiency,/// A dynamically-allocated heap object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:18,allocate,allocated,18,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// A factory, from which one makes pools, from which one creates; /// individual attributes which are deallocated with the pool.; ///; /// Note that it's tolerably cheap to create and destroy one of; /// these as long as you don't actually allocate anything in it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:241,allocate,allocate,241,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['allocate'],['allocate']
Energy Efficiency,/// A free register is not currently in use and can be allocated; /// immediately without checking aliases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:55,allocate,allocated,55,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// A function to deduce a function pass type and wrap it in the; /// templated adaptor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:80,adapt,adaptor,80,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,4,['adapt'],['adaptor']
Energy Efficiency,"/// A function to deduce a loop pass type and wrap it in the templated; /// adaptor.; ///; /// If \p Pass is a loop pass, the returned adaptor will be in loop mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:76,adapt,adaptor,76,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,2,['adapt'],['adaptor']
Energy Efficiency,"/// A helper class keeping track of loaded libraries. It implements a fast; /// search O(1) while keeping deterministic iterability in a memory efficient; /// way. The underlying set uses a custom hasher for better efficiency given the; /// specific problem where the library names (m_LibName) are relatively short; /// strings and the base paths (m_Path) are repetitive long strings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:144,efficient,efficient,144,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// A helper class to manage the placement of various structures into the final; /// minidump binary. Space for objects can be allocated via various allocate***; /// methods, while the final minidump file is written by calling the writeTo; /// method. The plain versions of allocation functions take a reference to the; /// data which is to be written (and hence the data must be available until; /// writeTo is called), while the ""New"" versions allocate the data in an; /// allocator-managed buffer, which is available until the allocator object is; /// destroyed. For both kinds of functions, it is possible to modify the; /// data for which the space has been ""allocated"" until the final writeTo call.; /// This is useful for ""linking"" the allocated structures via their offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpEmitter.cpp:127,allocate,allocated,127,interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpEmitter.cpp,5,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/// A helper function that returns all RDF code that is currently scheduled for just-in-time compilation.; /// This allows different RLoopManager instances to share these data.; /// We want RLoopManagers to be able to add their code to a global ""code to execute via cling"",; /// so that, lazily, we can jit everything that's needed by all RDFs in one go, which is potentially; /// much faster than jitting each RLoopManager's code separately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:66,schedul,scheduled,66,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['schedul'],['scheduled']
Energy Efficiency,/// A helper function that returns true if the given type is irregular. The; /// type is irregular if its allocated size doesn't equal the store size of an; /// element of the corresponding vector type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:106,allocate,allocated,106,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// A kind of the 'schedule' clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:19,schedul,schedule,19,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,['schedul'],['schedule']
Energy Efficiency,"/// A list of DIE values.; ///; /// This is a singly-linked list, but instead of reversing the order of; /// insertion, we keep a pointer to the back of the list so we can push in; /// order.; ///; /// There are two main reasons to choose a linked list over a customized; /// vector-like data structure.; ///; /// 1. For teardown efficiency, we want DIEs to be BumpPtrAllocated. Using a; /// linked list here makes this way easier to accomplish.; /// 2. Carrying an extra pointer per \a DIEValue isn't expensive. 45% of DIEs; /// have 2 or fewer values, and 90% have 5 or fewer. A vector would be; /// over-allocated by 50% on average anyway, the same cost as the; /// linked-list node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:607,allocate,allocated,607,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,1,['allocate'],['allocated']
Energy Efficiency,/// A list of recently allocated nodes that can potentially be recycled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h:23,allocate,allocated,23,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,1,['allocate'],['allocated']
Energy Efficiency,"/// A memcmp expansion that only has one block of load and compare can bypass; /// the compare, branch, and phi IR that is required in the general case.; /// This function also analyses users of memcmp, and if there is only one user; /// from which we can conclude that only 2 out of 3 memcmp outcomes really; /// matter, then it generates more efficient code with only one comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:345,efficient,efficient,345,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// A memory efficient llvm::VectorSet. The class provides O(1) search; /// complexity. It is tuned to compare BasePaths first by checking the; /// address and then the representation which models the base path reuse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:13,efficient,efficient,13,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// A new-allocated array of size NumTemplParamLists,; /// containing pointers to the ""outer"" template parameter lists.; /// It includes all of the template parameter lists that were matched; /// against the template-ids occurring into the NNS and possibly (in the; /// case of an explicit specialization) a final ""template <>"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:10,allocate,allocated,10,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['allocate'],['allocated']
Energy Efficiency,/// A pass that does profile-guided sinking of instructions into loops.; ///; /// This is a function pass as it shouldn't be composed into any kind of; /// unified loop pass pipeline. The goal of it is to sink code into loops that; /// is loop invariant but only required within the loop body when doing so; /// reduces the global expected dynamic frequency with which it executes.; /// A classic example is an extremely cold branch within a loop body.; ///; /// We do this as a separate pass so that during normal optimization all; /// invariant operations can be held outside the loop body to simplify; /// fundamental analyses and transforms of the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h:312,reduce,reduces,312,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,1,['reduce'],['reduces']
Energy Efficiency,"/// A pipeline for a specific subtarget.; ///; /// It emulates an out-of-order execution of instructions. Instructions are; /// fetched from a MCInst sequence managed by an initial 'Fetch' stage.; /// Instructions are firstly fetched, then dispatched to the schedulers, and; /// then executed.; ///; /// This class tracks the lifetime of an instruction from the moment where; /// it gets dispatched to the schedulers, to the moment where it finishes; /// executing and register writes are architecturally committed.; /// In particular, it monitors changes in the state of every instruction; /// in flight.; ///; /// Instructions are executed in a loop of iterations. The number of iterations; /// is defined by the SourceMgr object, which is managed by the initial stage; /// of the instruction pipeline.; ///; /// The Pipeline entry point is method 'run()' which executes cycles in a loop; /// until there are new instructions to dispatch, and not every instruction; /// has been retired.; ///; /// Internally, the Pipeline collects statistical information in the form of; /// histograms. For example, it tracks how the dispatch group size changes; /// over time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Pipeline.h:258,schedul,schedulers,258,interpreter/llvm-project/llvm/include/llvm/MCA/Pipeline.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Pipeline.h,3,"['monitor', 'schedul']","['monitors', 'schedulers']"
Energy Efficiency,"/// A pointer to a memory block, live or dead.; ///; /// This object can be allocated into interpreter stack frames. If pointing to; /// a live block, it is a link in the chain of pointers pointing to the block.; ///; /// In the simplest form, a Pointer has a Block* (the pointee) and both Base; /// and Offset are 0, which means it will point to raw data.; ///; /// The Base field is used to access metadata about the data. For primitive; /// arrays, the Base is followed by an InitMap. In a variety of cases, the; /// Base is preceded by an InlineDescriptor, which is used to track the; /// initialization state, among other things.; ///; /// The Offset field is used to access the actual data. In other words, the; /// data the pointer decribes can be found at; /// Pointee->rawData() + Pointer.Offset.; ///; ///; /// Pointee Offset; ///  ; ///  ; ///  ; /// ; ///  Block  InlineDesc  InitMap  Actual Data ; /// ; /// ; /// ; /// ; /// Base",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:76,allocate,allocated,76,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,1,['allocate'],['allocated']
Energy Efficiency,/// A processor resource descriptor.; ///; /// There is an instance of this class for every processor resource defined by; /// the machine scheduling model.; /// Objects of class ResourceState dynamically track the usage of processor; /// resource units.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:139,schedul,scheduling,139,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:49,schedul,scheduling,49,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,3,['schedul'],"['schedule', 'scheduled', 'scheduling']"
Energy Efficiency,"/// A pseudo-iterator adaptor that is designed to implement ""early increment""; /// style loops.; ///; /// This is *not a normal iterator* and should almost never be used directly. It; /// is intended primarily to be used with range based for loops and some range; /// algorithms.; ///; /// The iterator isn't quite an `OutputIterator` or an `InputIterator` but; /// somewhere between them. The constraints of these iterators are:; ///; /// - On construction or after being incremented, it is comparable and; /// dereferencable. It is *not* incrementable.; /// - After being dereferenced, it is neither comparable nor dereferencable, it; /// is only incrementable.; ///; /// This means you can only dereference the iterator once, and you can only; /// increment it once between dereferences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:22,adapt,adaptor,22,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['adapt'],['adaptor']
Energy Efficiency,"/// A query AA is always scheduled as long as we do updates because it does; /// lazy computation that cannot be determined to be done from the outside.; /// However, while query AAs will not be fixed if they do not have outstanding; /// dependences, we will only schedule them like other AAs. If a query AA that; /// received a new query it needs to request an update via; /// `Attributor::requestUpdateForAA`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:25,schedul,scheduled,25,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"/// A range of powers-of-2 vectorization factors with fixed start and; /// adjustable end. The range includes start and excludes end, e.g.,:; /// [1, 16) = {1, 2, 4, 8}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:15,power,powers-of-,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['power'],['powers-of-']
Energy Efficiency,"/// A raw_ostream that writes to an SmallVector or SmallString. This is a; /// simple adaptor class. This class does not encounter output errors.; /// raw_svector_ostream operates without a buffer, delegating all memory; /// management to the SmallString. Thus the SmallString is always up-to-date,; /// may be used directly and there is no need to call flush().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:86,adapt,adaptor,86,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['adapt'],['adaptor']
Energy Efficiency,/// A reference to the ScheduleDAG's SUnits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:23,Schedul,ScheduleDAG,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['Schedul'],['ScheduleDAG']
Energy Efficiency,/// A region of an MBB for scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,schedul,scheduling,27,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// A register state may also be a virtual register number, indication; /// that the physical register is currently allocated to a virtual; /// register. In that case, LiveVirtRegs contains the inverse mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:116,allocate,allocated,116,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// A resource manager for processor resource units and groups.; ///; /// This class owns all the ResourceState objects, and it is responsible for; /// acting on requests from a Scheduler by updating the internal state of; /// ResourceState objects.; /// This class doesn't know about instruction itineraries and functional units.; /// In future, it can be extended to support itineraries too through the same; /// public interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:178,Schedul,Scheduler,178,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['Schedul'],['Scheduler']
Energy Efficiency,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:127,efficient,efficient,127,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// A select shuffle of a select shuffle with a shared operand can be reduced; /// to a single select shuffle. This is an obvious improvement in IR, and the; /// backend is expected to lower select shuffles efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:70,reduce,reduced,70,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,"['efficient', 'reduce']","['efficiently', 'reduced']"
Energy Efficiency,/// A shadow allocated register is a register that was allocated; /// but wasn't added to the location list (Locs).; /// \returns true if the register was allocated as shadow or false otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:13,allocate,allocated,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,3,['allocate'],['allocated']
Energy Efficiency,"/// A stack-allocated class that identifies which local; /// variable declaration instantiations are present in this scope.; ///; /// A new instance of this class type will be created whenever we; /// instantiate a new function declaration, which will have its own; /// set of parameter declarations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h:12,allocate,allocated,12,interpreter/llvm-project/clang/include/clang/Sema/Template.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h,1,['allocate'],['allocated']
Energy Efficiency,"/// A switch()-like statement whose cases are string literals.; ///; /// The StringSwitch class is a simple form of a switch() statement that; /// determines whether the given string matches one of the given string; /// literals. The template type parameter \p T is the type of the value that; /// will be returned from the string-switch expression. For example,; /// the following code switches on the name of a color in \c argv[i]:; ///; /// \code; /// Color color = StringSwitch<Color>(argv[i]); /// .Case(""red"", Red); /// .Case(""orange"", Orange); /// .Case(""yellow"", Yellow); /// .Case(""green"", Green); /// .Case(""blue"", Blue); /// .Case(""indigo"", Indigo); /// .Cases(""violet"", ""purple"", Violet); /// .Default(UnknownColor);; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h:591,green,green,591,interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringSwitch.h,2,"['Green', 'green']","['Green', 'green']"
Energy Efficiency,"/// A trie to efficiently match against the entries of the compilation; /// database in order of matching suffix length.; ///; /// When a clang tool is supposed to operate on a specific file, we have to; /// find the corresponding file in the compilation database. Although entries; /// in the compilation database are keyed by filename, a simple string match; /// is insufficient because of symlinks. Commonly, a project hierarchy looks; /// like this:; /// /<project-root>/src/<path>/<somefile>.cc (used as input for the tool); /// /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB); ///; /// Furthermore, there might be symlinks inside the source folder or inside the; /// database, so that the same source file is translated with different build; /// options.; ///; /// For a given input file, the \c FileMatchTrie finds its entries in order; /// of matching suffix length. For each suffix length, there might be one or; /// more entries in the database. For each of those entries, it calls; /// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might; /// be zero or more entries with the same matching suffix length that are; /// equivalent to the input file. Three cases are distinguished:; /// 0 equivalent files: Continue with the next suffix length.; /// 1 equivalent file: Best match found, return it.; /// >1 equivalent files: Match is ambiguous, return error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:14,efficient,efficiently,14,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// A type-checked pair of {Register Location (or 0), Index}, used to index; /// into a \ref VarLocMap. This can be efficiently converted to a 64-bit int; /// for insertion into a \ref VarLocSet, and efficiently converted back. The; /// type-checker helps ensure that the conversions aren't lossy.; ///; /// Why encode a location /into/ the VarLocMap index? This makes it possible; /// to find the open VarLocs killed by a register def very quickly. This is a; /// performance-critical operation for LiveDebugValues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:116,efficient,efficiently,116,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,2,['efficient'],['efficiently']
Energy Efficiency,"/// A type-erased variant of the above invalidate method with the same core; /// API other than passing an analysis ID rather than an analysis type; /// parameter.; ///; /// This is sadly less efficient than the above routine, which leverages; /// the type parameter to avoid the type erasure overhead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:193,efficient,efficient,193,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['efficient'],['efficient']
Energy Efficiency,/// A vector of BugReports for tracking the allocated pointers and cleanup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:44,allocate,allocated,44,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['allocate'],['allocated']
Energy Efficiency,"/// A vector that allocates memory in pages.; ///; /// Order is kept, but memory is allocated only when one element of the page is; /// accessed. This introduces a level of indirection, but it is useful when you; /// have a sparsely initialised vector where the full size is allocated upfront.; ///; /// As a side effect the elements are initialised later than in a normal vector.; /// On the first access to one of the elements of a given page, all the elements; /// of the page are initialised. This also means that the elements of the page; /// are initialised beyond the size of the vector.; ///; /// Similarly on destruction the elements are destroyed only when the page is; /// not needed anymore, delaying invoking the destructor of the elements.; ///; /// Notice that this has iterators only on materialized elements. This; /// is deliberately done under the assumption you would dereference the elements; /// while iterating, therefore materialising them and losing the gains in terms; /// of memory usage this container provides. If you have such a use case, you; /// probably want to use a normal std::vector or a llvm::SmallVector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:18,allocate,allocates,18,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,3,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,"/// A vector that has set insertion semantics.; ///; /// This adapter class provides a way to keep a set of things that also has the; /// property of a deterministic iteration order. The order of iteration is the; /// order of insertion.; ///; /// The key and value types are derived from the Set and Vector types; /// respectively. This allows the vector-type operations and set-type operations; /// to have different types. In particular, this is useful when storing pointers; /// as ""Foo *"" values but looking them up as ""const Foo *"" keys.; ///; /// No constraint is placed on the key and value types, although it is assumed; /// that value_type can be converted into key_type for insertion. Users must be; /// aware of any loss of information in this conversion. For example, setting; /// value_type to float and key_type to int can produce very surprising results,; /// but it is not explicitly disallowed.; ///; /// The parameter N specifies the ""small"" size of the container, which is the; /// number of elements upto which a linear scan over the Vector will be used; /// when searching for elements instead of checking Set, due to it being better; /// for performance. A value of 0 means that this mode of operation is not used,; /// and is the default value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:62,adapt,adapter,62,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,1,['adapt'],['adapter']
Energy Efficiency,"/// A very specialized mode that will optimize for code size at any and all; /// costs.; ///; /// This is useful primarily when there are absolute size limitations and; /// any effort taken to reduce the size is worth it regardless of the; /// execution time impact. You should expect this level to produce rather; /// slow, but very small, code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:193,reduce,reduce,193,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,1,['reduce'],['reduce']
Energy Efficiency,"/// AbstractLatticeFunction - This class is implemented by the dataflow instance; /// to specify what the lattice values are and how they handle merges etc. This; /// gives the client the power to compute lattice values from instructions,; /// constants, etc. The current requirement is that lattice values must be; /// copyable. At the moment, nothing tries to avoid copying. Additionally,; /// lattice keys must be able to be used as keys of a mapping data structure.; /// Internally, the generic solver currently uses a DenseMap to map lattice keys; /// to lattice values. If the lattice key is a non-standard type, a; /// specialization of DenseMapInfo must be provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:188,power,power,188,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,1,['power'],['power']
Energy Efficiency,"/// Accumulate a mapping between each DILocalVariable fragment and other; /// fragments of that DILocalVariable which overlap. This reduces work during; /// the data-flow stage from ""Find any overlapping fragments"" to ""Check if the; /// known-to-overlap fragments are present"".; /// \param MI A previously unprocessed DEBUG_VALUE instruction to analyze for; /// fragment usage.; /// \param SeenFragments Map from DILocalVariable to all fragments of that; /// Variable which are known to exist.; /// \param OverlappingFragments The overlap map being constructed, from one; /// Var/Fragment pair to a vector of fragments known to overlap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:132,reduce,reduces,132,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['reduce'],['reduces']
Energy Efficiency,"/// Accumulate a mapping between each DILocalVariable fragment and other; /// fragments of that DILocalVariable which overlap. This reduces work during; /// the data-flow stage from ""Find any overlapping fragments"" to ""Check if the; /// known-to-overlap fragments are present"".; /// \param MI A previously unprocessed debug instruction to analyze for; /// fragment usage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:132,reduce,reduces,132,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['reduce'],['reduces']
Energy Efficiency,/// Actual page data. All the page elements are allocated on the; /// first access of any of the elements of the page. Elements are default; /// constructed and elements of the page are stored contiguously.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:48,allocate,allocated,48,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,1,['allocate'],['allocated']
Energy Efficiency,/// Adapt a InMemoryFile for VFS' File interface. The goal is to make; /// \p InMemoryFileAdaptor mimic as much as possible the behavior of; /// \p RealFile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:4,Adapt,Adapt,4,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['Adapt'],['Adapt']
Energy Efficiency,/// Adapt std::less<T> for array_pod_sort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:4,Adapt,Adapt,4,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['Adapt'],['Adapt']
Energy Efficiency,"/// Adapt the metadata for the specified instruction according to the; /// provided mapping. This is normally used after cloning an instruction, when; /// some noalias scopes needed to be cloned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:4,Adapt,Adapt,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,1,['Adapt'],['Adapt']
Energy Efficiency,/// Adapter to write values to a stream in a particular byte order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/EndianStream.h:4,Adapt,Adapter,4,interpreter/llvm-project/llvm/include/llvm/Support/EndianStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/EndianStream.h,1,['Adapt'],['Adapter']
Energy Efficiency,/// Adaptor between \c ast_matchers::MatchFinder and \c; /// tooling::RefactoringTool.; ///; /// Runs AST matchers and stores the \c tooling::Replacements in a map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h:4,Adapt,Adaptor,4,interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h,1,['Adapt'],['Adaptor']
Energy Efficiency,/// Adaptor from InMemoryDir::iterator to directory_iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:4,Adapt,Adaptor,4,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['Adapt'],['Adaptor']
Energy Efficiency,/// Adaptor that maps from a SCC to its functions.; ///; /// Designed to allow composition of a FunctionPass(Manager) and; /// a CGSCCPassManager. Note that if this pass is constructed with a pointer; /// to a \c CGSCCAnalysisManager it will run the; /// \c FunctionAnalysisManagerCGSCCProxy analysis prior to running the function; /// pass over the SCC to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Adapt,Adaptor,4,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['Adapt'],['Adaptor']
Energy Efficiency,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:4,Adapt,Adaptor,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,3,"['Adapt', 'adapt']","['Adaptor', 'adaptor']"
Energy Efficiency,/// Adapts design from MacroFusion; /// Puts valid candidate instructions back-to-back so they can easily; /// be turned into VOPD instructions; /// Greedily pairs instruction candidates. O(n^2) algorithm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNVOPDUtils.cpp:4,Adapt,Adapts,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNVOPDUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNVOPDUtils.cpp,1,['Adapt'],['Adapts']
Energy Efficiency,/// Adapts the indent levels of comment lines to the indent of the; /// subsequent line.; // FIXME: Can/should this be done in the UnwrappedLineParser?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h:4,Adapt,Adapts,4,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.h,1,['Adapt'],['Adapts']
Energy Efficiency,"/// Add a ""macro"" context to the top of the include stack,; /// which will cause the lexer to start returning the specified tokens.; ///; /// If \p DisableMacroExpansion is true, tokens lexed from the token stream; /// will not be subject to further macro expansion. Otherwise, these tokens; /// will be re-macro-expanded when/if expansion is enabled.; ///; /// If \p OwnsTokens is false, this method assumes that the specified stream; /// of tokens has a permanent owner somewhere, so they do not need to be; /// copied. If it is true, it assumes the array of tokens is allocated with; /// \c new[] and the Preprocessor will delete[] it.; ///; /// If \p IsReinject the resulting tokens will have Token::IsReinjected flag; /// set, see the flag documentation for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:571,allocate,allocated,571,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:198,Schedul,ScheduleDAGInstrs,198,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['Schedul'],['ScheduleDAGInstrs']
Energy Efficiency,"/// Add a pass to the queue of passes to run. This passes ownership of; /// the Pass to the PassManager. When the PassManager is destroyed, the pass; /// will be destroyed as well, so there is no need to delete the pass. This; /// may even destroy the pass right away if it is found to be redundant. This; /// implies that all passes MUST be allocated with 'new'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h:342,allocate,allocated,342,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h,1,['allocate'],['allocated']
Energy Efficiency,/// Add a postprocessing step to the DAG builder.; /// Mutations are applied in the order that they are added after normal DAG; /// building and before MachineSchedStrategy initialization.; ///; /// ScheduleDAGMI takes ownership of the Mutation object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:199,Schedul,ScheduleDAGMI,199,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['Schedul'],['ScheduleDAGMI']
Energy Efficiency,"/// Add a sectalign directive for \p Segment and \p Section to the maximum; /// expected page size for Darwin.; ///; /// On iPhone 6+ the max supported page size is 16K. On macOS, the max is 4K.; /// Use a common alignment constant (16K) for now, and reduce the alignment on; /// macOS if it proves important.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:251,reduce,reduce,251,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Add a stream to the MSF file with the given size, occupying the given; /// list of blocks. This is useful when reading a MSF file and you want a; /// particular stream to occupy the original set of blocks. If the given; /// blocks are already allocated, or if the number of blocks specified is; /// incorrect for the given stream size, this function will return an Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h:247,allocate,allocated,247,interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,/// Add more elements to the type for the given type index to the next power of; /// 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:71,power,power,71,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['power'],['power']
Energy Efficiency,/// Add more elements to the vector to reach the next power of two.; /// No effect if the type is not a vector or the element count is a power of; /// two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:54,power,power,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,2,['power'],['power']
Energy Efficiency,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:156,schedul,scheduling,156,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['schedul'],['scheduling']
Energy Efficiency,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:45,schedul,scheduled,45,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,/// Add the minimum set of target-independent passes that are required for; /// register allocation. No coalescing or scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:118,schedul,scheduling,118,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['schedul'],['scheduling']
Energy Efficiency,"/// AddInstanceMethodToGlobalPool - All instance methods in a translation; /// unit are added to a global pool. This allows us to efficiently associate; /// a selector with a method declaraation for purposes of typechecking; /// messages sent to ""id"" (where the class of the object is unknown).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:130,efficient,efficiently,130,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// AddPseudoTwoAddrDeps - If two nodes share an operand and one of them uses; /// it as a def&use operand. Add a pseudo control edge from it to the other; /// node (if it won't create a cycle) so the two-address one will be scheduled; /// first (lower in the schedule). If both nodes are two-address, favor the; /// one that has a CopyToReg use (more likely to be a loop induction update).; /// If both are two-address, but one is commutable while the other is not; /// commutable, favor the one that's not commutable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:225,schedul,scheduled,225,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,/// Address of the output variable in which the stride value is returned; /// necessary to generated the static_chunked scheduled loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:120,schedul,scheduled,120,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// AddressRange objects are encoded and decoded to be relative to a base; /// address. This will be the FunctionInfo's start address if the AddressRange; /// is directly contained in a FunctionInfo, or a base address of the; /// containing parent AddressRange or AddressRanges. This allows address; /// ranges to be efficiently encoded using ULEB128 encodings as we encode the; /// offset and size of each range instead of full addresses. This also makes; /// encoded addresses easy to relocate as we just need to relocate one base; /// address.; /// @{",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/ExtractRanges.h:317,efficient,efficiently,317,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/ExtractRanges.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/ExtractRanges.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// AddressRangesMap class maps values to the address ranges.; /// It keeps normalized address ranges and corresponding values.; /// This class keeps a sorted vector of AddressRangeValuePair objects; /// and can perform insertions and searches efficiently.; /// Intersecting([100,200), [150,300)) ranges splitted into non-conflicting; /// parts([100,200), [200,300)). Adjacent([100,200), [200,300)) address; /// ranges are not combined during insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:244,efficient,efficiently,244,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// Adds SU to the SUList of V. If Map grows huge, reduce its size by calling; /// reduce().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:51,reduce,reduce,51,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,2,['reduce'],['reduce']
Energy Efficiency,"/// Adds a register data dependency if the instruction that defines the; /// virtual register used at OperIdx is mapped to an SUnit. Add a register; /// antidependency from this SUnit to instructions that occur later in the same; /// scheduling region if they write the virtual register.; ///; /// TODO: Handle ExitSU ""uses"" properly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:234,schedul,scheduling,234,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// Adds custom features for a visualization of the ScheduleDAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:52,Schedul,ScheduleDAG,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['Schedul'],['ScheduleDAG']
Energy Efficiency,/// Adds dependencies from instructions in the current list of; /// instructions being scheduled to scheduling barrier. We want to make sure; /// instructions which define registers that are either used by the; /// terminator or are live-out are properly scheduled. This is especially; /// important when the definition latency of the return value(s) are too; /// high to be hidden by the branch or when the liveout registers used by; /// instructions in the fallthrough block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:87,schedul,scheduled,87,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,3,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,/// Adds monotonicity modifier flags to schedule type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:40,schedul,schedule,40,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// Adds ordering modifier flags to schedule type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:36,schedul,schedule,36,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['schedul'],['schedule']
Energy Efficiency,"/// Adds register dependencies (data, anti, and output) from this SUnit; /// to following instructions in the same scheduling region that depend the; /// physical register referenced at OperIdx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:115,schedul,scheduling,115,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Adds register output and data dependencies from this SUnit to instructions; /// that occur later in the same scheduling region if they read from or write to; /// the virtual register defined at OperIdx.; ///; /// TODO: Hoist loop induction variable increments. This has to be; /// reevaluated. Generally, IV scheduling should be done before coalescing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:113,schedul,scheduling,113,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,2,['schedul'],['scheduling']
Energy Efficiency,/// Adds the list of reduced values to list of already checked values for the; /// vectorization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,reduce,reduced,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:83,schedul,scheduled,83,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,3,['schedul'],['scheduled']
Energy Efficiency,"/// AdvanceCycle - This callback is invoked whenever the next top-down; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts. This should increment the; /// internal state of the hazard recognizer so that previously ""Hazard""; /// instructions will now not be hazards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:94,schedul,scheduled,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// After calling BuildSchedGraph, each machine instruction in the current; /// scheduling region is mapped to an SUnit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:80,schedul,scheduling,80,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// After the schedule has been formed, call this function to combine; /// the instructions from the different stages/cycles. That is, this; /// function creates a schedule that represents a single iteration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,schedul,schedule,14,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],['schedule']
Energy Efficiency,"/// Align for dynamic shared memory if any. Dynamic shared memory is; /// allocated directly after the static one, i.e., LDSSize. Need to pad; /// LDSSize to ensure that dynamic one is aligned accordingly.; /// The maximal alignment is updated during IR translation or lowering; /// stages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h:74,allocate,allocated,74,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h,1,['allocate'],['allocated']
Energy Efficiency,/// All DIEValues are allocated through this allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:22,allocate,allocated,22,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,1,['allocate'],['allocated']
Energy Efficiency,/// All allocated UserLabel instances.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:8,allocate,allocated,8,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// All allocated UserValue instances.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:8,allocate,allocated,8,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// All field IDs of late model extensions for efficient lookup. When a column gets added to the extension; /// header, this enables us to determine if the column belongs to a field of the header extension of if it; /// belongs to a field of the regular header that gets extended by additional column representations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:47,efficient,efficient,47,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,1,['efficient'],['efficient']
Energy Efficiency,/// All type identifier related information. Because these fields are; /// relatively uncommon we only allocate space for them if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:103,allocate,allocate,103,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['allocate'],['allocate']
Energy Efficiency,/// Allocate (scavenge) vregs inside a single basic block.; /// Returns true if the target spill callback created new vregs and a 2nd pass; /// is necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate - Return a pointer to storage for an object of type; /// SubClass. The storage may be either newly allocated or recycled.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/RecyclingAllocator.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/RecyclingAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/RecyclingAllocator.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,/// Allocate BitSize bits in the byte array where Bits contains the bits to; /// set. AllocByteOffset is set to the offset within the byte array and; /// AllocMask is set to the bitmask for those bits. This uses the LPT (Longest; /// Processing Time) multiprocessor scheduling algorithm to lay out the bits; /// efficiently; the pass allocates bit sets in decreasing size order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,4,"['Allocate', 'allocate', 'efficient', 'schedul']","['Allocate', 'allocates', 'efficiently', 'scheduling']"
Energy Efficiency,/// Allocate \a Size bytes of \a Alignment aligned memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PerThreadBumpPtrAllocator.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/PerThreadBumpPtrAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PerThreadBumpPtrAllocator.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate \a Size bytes of \a Alignment aligned memory. This method; /// must be implemented by \c DerivedT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate a TemplateArgumentLoc where all locations have; /// been initialized to the given location.; ///; /// \param Arg The template argument we are producing template argument; /// location information for.; ///; /// \param NTTPType For a declaration template argument, the type of; /// the non-type template parameter that corresponds to this template; /// argument. Can be null if no type sugar is available to add to the; /// type from the template argument.; ///; /// \param Loc The source location to use for the resulting template; /// argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate a TypeSourceInfo where all locations have been; /// initialized to a given location, which defaults to the empty; /// location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate a User with an operand pointer co-allocated.; ///; /// This is used for subclasses which need to allocate a variable number; /// of operands, ie, 'hung off uses'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/IR/User.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h,3,"['Allocate', 'allocate']","['Allocate', 'allocate', 'allocated']"
Energy Efficiency,"/// Allocate a User with the operands co-allocated. If DescBytes is non-zero; /// then allocate an additional DescBytes bytes before the operands. These; /// bytes can be accessed by calling getDescriptor.; ///; /// DescBytes needs to be divisible by sizeof(void *). The allocated; /// descriptor, if any, is aligned to sizeof(void *) bytes.; ///; /// This is used for subclasses which have a fixed number of operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/IR/User.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h,4,"['Allocate', 'allocate']","['Allocate', 'allocate', 'allocated']"
Energy Efficiency,/// Allocate a User with the operands co-allocated.; ///; /// This is used for subclasses which have a fixed number of operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/IR/User.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate a buffer of memory with the given size and alignment.; ///; /// When the compiler supports aligned operator new, this will use it to; /// handle even over-aligned allocations.; ///; /// However, this doesn't make any attempt to leverage the fancier techniques; /// like posix_memalign due to portability. It is mostly intended to allow; /// compatibility with platforms that, after aligned allocation was added, use; /// reduced default alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemAlloc.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/MemAlloc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemAlloc.h,2,"['Allocate', 'reduce']","['Allocate', 'reduced']"
Energy Efficiency,/// Allocate a copy of \p A using the DebugInfoNames allocator; /// and return a reference to it. If multiple arguments are given the strings; /// are concatenated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a copy of \p Borrowed into memory that we own.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangle.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangle.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a copy of the given string using the LinkGraph's allocator.; /// This can be useful when renaming symbols or adding new content to the; /// graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a copy of the given string using the LinkGraph's allocator.; /// This can be useful when renaming symbols or adding new content to the; /// graph.; ///; /// Note: This Twine-based overload requires an extra string copy and an; /// extra heap allocation for large strings. The ArrayRef<char> overload; /// should be preferred where possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate a copy of the given string using the LinkGraph's allocator.; ///; /// The allocated string will be terminated with a null character, and the; /// returned MutableArrayRef will include this null character in the last; /// position.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate a copy of the given string using the LinkGraph's allocator.; ///; /// The allocated string will be terminated with a null character, and the; /// returned MutableArrayRef will include this null character in the last; /// position.; ///; /// Note: This Twine-based overload requires an extra string copy and an; /// extra heap allocation for large strings. The ArrayRef<char> overload; /// should be preferred where possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,/// Allocate a leaf node and add it to the tree.; ///; /// \param Parent The parent of this node.; /// \param StartIdx The start index of this node's associated string.; /// \param Edge The label on the edge leaving \p Parent to this node.; ///; /// \returns A pointer to the allocated leaf node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SuffixTree.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/SuffixTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SuffixTree.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate a memory block of (at least) the given size suitable for data.; /// The SectionID is a unique identifier assigned by the JIT engine, and; /// optionally recorded by the memory manager to access a loaded section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate a memory block of (at least) the given size suitable for; /// executable code. The SectionID is a unique identifier assigned by the; /// RuntimeDyld instance, and optionally recorded by the memory manager to; /// access a loaded section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a memory block of (at least) the given size to be used for; /// thread-local storage (TLS).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a mutable buffer of the given size using the LinkGraph's; /// allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a new MachineBasicBlock. Use this instead of; /// `new MachineBasicBlock'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a new MachineInstr. Use this instead of `new MachineInstr'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate a new MachineMemOperand by copying an existing one,; /// replacing only AliasAnalysis information. MachineMemOperands are owned; /// by the MachineFunction and need not be explicitly deallocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate a new MachineMemOperand by copying an existing one,; /// replacing the flags. MachineMemOperands are owned; /// by the MachineFunction and need not be explicitly deallocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a new MacroInfo object with the provided SourceLocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a new MemoryBuffer of the specified size that is not initialized.; /// Note that the caller should initialize the memory allocated by this; /// method. The memory is owned by the MemoryBuffer object.; ///; /// \param Alignment Set to indicate that the buffer should be aligned to at; /// least the specified alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate a new slab and move the bump pointers over into the new; /// slab, modifying CurPtr and End.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a new zero-initialized MemoryBuffer of the specified size. Note; /// that the caller need not initialize the memory allocated by this method.; /// The memory is owned by the MemoryBuffer object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate a number of loaded SLocEntries, which will be actually; /// loaded on demand from the external source.; ///; /// NumSLocEntries will be allocated, which occupy a total of TotalSize space; /// in the global source view. The lowest ID and the base offset of the; /// entries will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate a register for the virtual register \p VReg. The last use of; /// \p VReg is around the current position of the register scavenger \p RS.; /// \p ReserveAfter controls whether the scavenged register needs to be reserved; /// after the current instruction, otherwise it will only be reserved before the; /// current instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a string and populate it with the given external symbol name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate a temp value on the stack that MCDC can use to track condition; /// results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate an Instrument, and return a unique pointer to it. This function; /// may be useful to create instruments coming from comments in the assembly.; /// See createInstruments to create Instruments from MCInst",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate an array of MachineOperands. This is only intended for use by; /// internal MachineInstr functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate an array of at least the requested capacity.; ///; /// Return an existing recycled array, or allocate one from Allocator if; /// none are available for recycling.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,2,"['Allocate', 'allocate']","['Allocate', 'allocate']"
Energy Efficiency,/// Allocate an attribute of the given size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate an internal node and add it to the tree.; ///; /// \param Parent The parent of this node. Only null when allocating the root.; /// \param StartIdx The start index of this node's associated string.; /// \param EndIdx The end index of this node's associated string.; /// \param Edge The label on the edge leaving \p Parent to this node.; ///; /// \returns A pointer to the allocated internal node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SuffixTree.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/SuffixTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SuffixTree.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate an uninitialized TypeSourceInfo.; ///; /// The caller should initialize the memory held by TypeSourceInfo using; /// the TypeLoc wrappers.; ///; /// \param T the type that will be the basis for type source info. This type; /// should refer to how the declarator was written in source code, not to; /// what type semantic analysis resolved the declarator to.; ///; /// \param Size the size of the type info to create, or 0 if the size; /// should be calculated based on the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate and construct a new UniqueMachineInstr for MI and return.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate and construct an extra info structure for a `MachineInstr`.; ///; /// This is allocated on the function's allocator and so lives the life of; /// the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate and initialise an array with desired size and values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:4,Allocate,Allocate,4,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate and initialize a register mask with @p NumRegister bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate and initialize an instance of the YAML representation of the; /// MachineFunctionInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate and initialize the different members.; /// In particular, the XXXInfo data structure.; /// \pre Fn, Target, MMI, and FunctionNumber are properly set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate and return a default initialized instance of the YAML; /// representation for the MachineFunctionInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate and return a hazard recognizer to use for by non-scheduling; /// passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,"['Allocate', 'schedul']","['Allocate', 'scheduling']"
Energy Efficiency,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions after register allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,4,"['Allocate', 'schedul']","['Allocate', 'scheduling']"
Energy Efficiency,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions before register allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,4,"['Allocate', 'schedul']","['Allocate', 'scheduling']"
Energy Efficiency,/// Allocate implicit function VGPR arguments at the end of allocated user; /// arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,/// Allocate implicit function VGPR arguments in fixed registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate memory according to the rules of the active lowering.; ///; /// \param CG - if non-null, will be updated for the new call",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate memory for BackedgeTakenInfo and copy the not-taken count of each; /// computable exit into a persistent ExitNotTakenInfo array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate memory for a deserialized declaration.; ///; /// This routine must be used to allocate memory for any declaration that is; /// deserialized from a module file.; ///; /// \param Size The size of the allocated object.; /// \param Ctx The context in which we will allocate memory.; /// \param ID The global ID of the deserialized declaration.; /// \param Extra The amount of extra space to allocate after the object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,5,"['Allocate', 'allocate']","['Allocate', 'allocate', 'allocated']"
Energy Efficiency,/// Allocate memory for a new value on the heap or stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate memory for a non-deserialized declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate memory in the preprocessing record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate memory on the device and move data from device to host.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate memory on the device and move data from host to device.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate new storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate some vregs and offsets in the VMap. Then populate just the; /// offsets while leaving the vregs empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate space at the specified alignment.; // This method is *not* marked noalias, because; // SpecificBumpPtrAllocator::DestroyAll() loops over all allocations, and; // that loop is not based on the Allocate() return value.; //; // Allocate(0, N) is valid, it returns a non-null pointer (which should not; // be dereferenced).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,3,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate space for a new set of loaded preprocessed entities.; ///; /// \returns The index into the set of loaded preprocessed entities, which; /// corresponds to the first newly-allocated entity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate space for a new set of loaded preprocessed skipped; /// ranges.; ///; /// \returns The index into the set of loaded preprocessed ranges, which; /// corresponds to the first newly-allocated range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,/// Allocate space for an array of objects without constructing them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate space on the stack large enough to pass an argument by value.; /// The size and alignment information of the argument is encoded in; /// its parameter attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate stack space in 1Mb chunks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpStack.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/lib/AST/Interp/InterpStack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpStack.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate storage for a parameter of a function call made in this frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,2,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate storage for an object of type T in this stack frame.; /// Populates LV with a handle to the created object. Key identifies; /// the temporary within the stack frame, and must not be reused without; /// bumping the temporary version number.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate storage for conversion sequences for NumConversions; /// conversions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Allocate the array of Uses, followed by a pointer; /// (with bottom bit set) to the User.; /// \param IsPhi identifies callers which are phi nodes and which need; /// N BasicBlock* allocated along with N",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/IR/User.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h,2,"['Allocate', 'allocate']","['Allocate', 'allocated']"
Energy Efficiency,/// Allocate the definition data for this class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:4,Allocate,Allocate,4,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate the given objc object.; /// call i8* \@objc_alloc(i8* %value),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate the given objc object.; /// call i8* \@objc_allocWithZone(i8* %value),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:4,Allocate,Allocate,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate the root node and add it to the tree.; ///; /// \returns A pointer to the root.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SuffixTree.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/Support/SuffixTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SuffixTree.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Allocate the table with the specified number of buckets and otherwise; /// setup the map as empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:4,Allocate,Allocate,4,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// AllocateBuckets - Allocated initialized bucket memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FoldingSet.cpp:4,Allocate,AllocateBuckets,4,interpreter/llvm-project/llvm/lib/Support/FoldingSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FoldingSet.cpp,2,['Allocate'],"['AllocateBuckets', 'Allocated']"
Energy Efficiency,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Allocate,AllocateReg,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,3,"['Allocate', 'allocate']","['AllocateReg', 'allocate', 'allocated']"
Energy Efficiency,"/// AllocateReg - Attempt to allocate one register. If it is not available,; /// return zero. Otherwise, return the register, marking it and any aliases; /// as allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Allocate,AllocateReg,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,3,"['Allocate', 'allocate']","['AllocateReg', 'allocate', 'allocated']"
Energy Efficiency,"/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive; /// registers. If this is not possible, return zero. Otherwise, return the first; /// register of the block that were allocated, marking the entire block as allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Allocate,AllocateRegBlock,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,4,"['Allocate', 'allocate']","['AllocateRegBlock', 'allocate', 'allocated']"
Energy Efficiency,/// AllocateStack - Allocate a chunk of stack space with the specified size; /// and alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Allocate,AllocateStack,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,2,['Allocate'],"['Allocate', 'AllocateStack']"
Energy Efficiency,/// Allocated API-exposed wrappters for Diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:4,Allocate,Allocated,4,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,1,['Allocate'],['Allocated']
Energy Efficiency,"/// Allocates LS resources for instruction IR.; ///; /// This method assumes that a previous call to `isAvailable(IR)` succeeded; /// returning LSU_AVAILABLE.; ///; /// Rules are:; /// By default, rules are:; /// 1. A store may not pass a previous store.; /// 2. A load may not pass a previous store unless flag 'NoAlias' is set.; /// 3. A load may pass a previous load.; /// 4. A store may not pass a previous load (regardless of flag 'NoAlias').; /// 5. A load has to wait until an older load barrier is fully executed.; /// 6. A store has to wait until an older store barrier is fully executed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates LS resources for instruction IR.; ///; /// This method assumes that a previous call to `isAvailable(IR)` succeeded; /// with a LSUnitBase::Status value of LSU_AVAILABLE.; /// Returns the GroupID associated with this instruction. That value will be; /// used to set the LSUTokenID field in class Instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a RefSCC and constructs it using the graph allocator.; ///; /// The arguments are forwarded to the constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a \c DeclListNode or returns one from the \c ListNodeFreeList; /// pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:4,Allocate,Allocates,4,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a descriptor for a primitive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Allocate,Allocates,4,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a descriptor for a record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Allocate,Allocates,4,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a descriptor for an array of composites of unknown size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Allocate,Allocates,4,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a descriptor for an array of composites.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Allocate,Allocates,4,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a descriptor for an array of primitives of unknown size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Allocate,Allocates,4,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a descriptor for an array of primitives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Allocate,Allocates,4,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a memory block of (at least) the given size suitable for; /// executable code.; ///; /// The value of \p Alignment must be a power of two. If \p Alignment is zero; /// a default alignment of 16 will be used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,4,"['Allocate', 'power']","['Allocates', 'power']"
Energy Efficiency,/// Allocates a physical register for VirtReg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['Allocate'],['Allocates']
Energy Efficiency,"/// Allocates a register for VirtReg definition. Typically the register is; /// already assigned from a use of the virtreg, however we still need to; /// perform an allocation if:; /// - It is a dead definition without any uses.; /// - The value is live out and all uses are in different basic blocks.; ///; /// \return true if MI's MachineOperands were re-arranged/invalidated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a register for a VirtReg use.; /// \return true if MI's MachineOperands were re-arranged/invalidated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates a space storing a local given its type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:4,Allocate,Allocates,4,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates an SCC and constructs it using the graph allocator.; ///; /// The arguments are forwarded to the constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['Allocate'],['Allocates']
Energy Efficiency,"/// Allocates and fills a page that contains the index-th element. The default implementation searches; /// the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed columns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:4,Allocate,Allocates,4,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates output DIE for the specified \p TypeDescriptor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,1,['Allocate'],['Allocates']
Energy Efficiency,/// Allocates schedule data chunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Allocate,Allocates,4,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Allocate', 'schedul']","['Allocates', 'schedule']"
Energy Efficiency,"/// Allocates space for storing at least `n` elements. This function returns a pointer to the actual object on; /// which insertions should take place. For associative collections, this function returns a pointer to a temporary; /// buffer known as the staging area. If the insertion happened in a staging area (i.e. the returned pointer !=; /// proxied object), `Commit()` should be called on the value returned by this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h:4,Allocate,Allocates,4,core/cont/inc/TVirtualCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h,1,['Allocate'],['Allocates']
Energy Efficiency,"/// Allocates the global in the pool, reserving storate for data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:4,Allocate,Allocates,4,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// AllocationState is a part of the checker specific state together with the; /// MemRegion corresponding to the allocated data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:114,allocate,allocated,114,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Allocator and owner of BlockChain structures.; ///; /// We build BlockChains lazily while processing the loop structure of; /// a function. To reduce malloc traffic, we allocate them using this; /// slab-like allocator, and destroy them after the pass completes. An; /// important guarantee is that this allocator produces stable pointers to; /// the chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:147,reduce,reduce,147,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,2,"['allocate', 'reduce']","['allocate', 'reduce']"
Energy Efficiency,/// Allocator object used for creating machine code objects.; ///; /// We use a bump pointer allocator to avoid the need to track all allocated; /// objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h:134,allocate,allocated,134,interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,1,['allocate'],['allocated']
Energy Efficiency,/// Allocator used to allocate storage for this diagnostic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:22,allocate,allocate,22,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['allocate'],['allocate']
Energy Efficiency,"/// AllocsForIndirectGlobals - If an instruction allocates memory for an; /// indirect global, this map indicates which one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:49,allocate,allocates,49,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,1,['allocate'],['allocates']
Energy Efficiency,/// Allow targets to perform final scheduling actions at the level of the; /// whole MachineFunction. By default does nothing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:35,schedul,scheduling,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Allow the target to reverse allocation order of local live ranges. This; /// will generally allocate shorter local live ranges first. For targets with; /// many registers, this could reduce regalloc compile time by a large; /// factor. It is disabled by default for three reasons:; /// (1) Top-down allocation is simpler and easier to debug for targets that; /// don't benefit from reversing the order.; /// (2) Bottom-up allocation could result in poor evicition decisions on some; /// targets affecting the performance of compiled code.; /// (3) Bottom-up allocation is no longer guaranteed to optimally color.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:96,allocate,allocate,96,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,2,"['allocate', 'reduce']","['allocate', 'reduce']"
Energy Efficiency,"/// Allows the target to handle physreg-carried dependency; /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether; /// to add the edge to the dependency graph.; /// Def - input: Selection DAG node defininfg physical register; /// User - input: Selection DAG node using physical register; /// Op - input: Number of User operand; /// PhysReg - inout: set to the physical register if the edge is; /// necessary, unchanged otherwise; /// Cost - inout: physical register copy cost.; /// Returns 'true' is the edge is necessary, 'false' otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:102,Schedul,ScheduleDAGSDNodes,102,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Schedul'],['ScheduleDAGSDNodes']
Energy Efficiency,/// An ElaboratedTypeKeyword. 8 bits for efficient access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:41,efficient,efficient,41,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['efficient'],['efficient']
Energy Efficiency,"/// An ID used in the DbgOpIDMap (below) to lookup a stored DbgOp. This is used; /// in place of actual DbgOps inside of a DbgValue to reduce its size, as; /// DbgValue is very frequently used and passed around, and the actual DbgOp is; /// over 8x larger than this class, due to storing a MachineOperand. This ID; /// should be equal for all equal DbgOps, and also encodes whether the mapped; /// DbgOp is a constant, meaning that for simple equality or const-ness checks; /// it is not necessary to lookup this ID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:135,reduce,reduce,135,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['reduce'],['reduce']
Energy Efficiency,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:16,adapt,adapter,16,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,1,['adapt'],['adapter']
Energy Efficiency,"/// An abstract interface for privatizability.; ///; /// A pointer is privatizable if it can be replaced by a new, private one.; /// Privatizing pointer reduces the use count, interaction between unrelated; /// code parts.; ///; /// In order for a pointer to be privatizable its value cannot be observed; /// (=nocapture), it is (for now) not written (=readonly & noalias), we know; /// what values are necessary to make the private copy look like the original; /// one, and the values we need can be loaded (=dereferenceable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:153,reduce,reduces,153,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['reduce'],['reduces']
Energy Efficiency,"/// An adapter for std::invoke_result that falls back to std::result_of if the former is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/TypeTraits.hxx:7,adapt,adapter,7,core/foundation/inc/ROOT/TypeTraits.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/TypeTraits.hxx,1,['adapt'],['adapter']
Energy Efficiency,"/// An adapter that can be used to translate diagnostics from one or more; /// llvm::SourceMgr instances to a ,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h:7,adapt,adapter,7,interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h,1,['adapt'],['adapter']
Energy Efficiency,/// An allocated TLS section,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:7,allocate,allocated,7,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['allocate'],['allocated']
Energy Efficiency,"/// An allocator for DiagnosticStorage objects, which uses a small cache to; /// objects, used to reduce malloc()/free() traffic for partial diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:98,reduce,reduce,98,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['reduce'],['reduce']
Energy Efficiency,"/// An efficient representation of a full path to a library which does not; /// duplicate common path patterns reducing the overall memory footprint.; ///; /// For example, `/home/.../lib/libA.so`, m_Path will contain a pointer; /// to `/home/.../lib/`; /// will be stored and .second `libA.so`.; /// This approach reduces the duplicate paths as at one location there may be; /// plenty of libraries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:7,efficient,efficient,7,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,2,"['efficient', 'reduce']","['efficient', 'reduces']"
Energy Efficiency,/// An immutable set of CallDescriptions.; /// Checkers can efficiently decide if a given CallEvent matches any; /// CallDescription in the set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h:60,efficient,efficiently,60,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,1,['efficient'],['efficiently']
Energy Efficiency,/// An instruction propagated through the simulated instruction pipeline.; ///; /// This class is used to monitor changes to the internal state of instructions; /// that are sent to the various components of the simulated hardware pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:106,monitor,monitor,106,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['monitor'],['monitor']
Energy Efficiency,"/// An iterator adaptor that filters the elements of given inner iterators.; ///; /// The predicate parameter should be a callable object that accepts the wrapped; /// iterator's reference type and returns a bool. When incrementing or; /// decrementing the iterator, it will call the predicate on each element and; /// skip any where it returns false.; ///; /// \code; /// int A[] = { 1, 2, 3, 4 };; /// auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });; /// // R contains { 1, 3 }.; /// \endcode; ///; /// Note: filter_iterator_base implements support for forward iteration.; /// filter_iterator_impl exists to provide support for bidirectional iteration,; /// conditional on whether the wrapped iterator supports it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:16,adapt,adaptor,16,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['adapt'],['adaptor']
Energy Efficiency,"/// An operand value in an instruction which is to be replaced with some; /// equivalent, possibly strength-reduced, replacement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:108,reduce,reduced,108,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['reduce'],['reduced']
Energy Efficiency,"/// An optional transcription object. This uses much more state than simply; /// traversing the DFA for acceptance, so is heap allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h:127,allocate,allocated,127,interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,1,['allocate'],['allocated']
Energy Efficiency,"/// An x-value expression is a reference to an object with; /// independent storage but which can be ""moved"", i.e.; /// efficiently cannibalized for its resources.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h:120,efficient,efficiently,120,interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h,1,['efficient'],['efficiently']
Energy Efficiency,/// Answers whether the usual array deallocation function for the; /// allocated type expects the size of the allocation as a; /// parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:71,allocate,allocated,71,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['allocate'],['allocated']
Energy Efficiency,/// Answers whether the usual array deallocation function for the; /// allocated type expects the size of the allocation as a; /// parameter. This can be true even if the actual deallocation; /// function that we're using doesn't want a size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:71,allocate,allocated,71,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Append the argument following \p A to \p DAL assuming \p A is an Xarch; /// argument. If \p AllocatedArgs is null pointer, synthesized arguments are; /// added to \p DAL, otherwise they are appended to \p AllocatedArgs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:96,Allocate,AllocatedArgs,96,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,2,['Allocate'],['AllocatedArgs']
Energy Efficiency,"/// Apply a less-than relation on the node order, which corresponds to the; /// instruction order prior to scheduling. IsReverse implements greater-than.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:107,schedul,scheduling,107,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Apply a set of heuristics to a new candidate for PostRA scheduling.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:60,schedul,scheduling,60,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:111,efficient,efficient,111,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,"['efficient', 'schedul']","['efficient', 'scheduled']"
Energy Efficiency,/// Apply changes to the instruction if needed. The changes are need; /// to improve the scheduling and depend up on the final schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,schedul,scheduling,89,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,/// Apply each ScheduleDAGMutation step in order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:15,Schedul,ScheduleDAGMutation,15,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,4,['Schedul'],['ScheduleDAGMutation']
Energy Efficiency,/// ArgDbgValues - A list of DBG_VALUE instructions created during isel for; /// function arguments that are inserted after scheduling is completed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:124,schedul,scheduling,124,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Argument adaptative overload.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:13,adapt,adaptative,13,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,1,['adapt'],['adaptative']
Energy Efficiency,"/// As each node is scheduled, this method is invoked. This allows the; /// priority function to adjust the priority of related unscheduled nodes,; /// for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:20,schedul,scheduled,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Assign a complexity or rank value to LLVM Values. This is used to reduce; /// the amount of pattern matching needed for compares and commutative; /// instructions. For example, if we have:; /// icmp ugt X, Constant; /// or; /// xor (add X, Constant), cast Z; ///; /// We do not have to consider the commuted variants of these patterns because; /// canonicalization based on complexity guarantees the above ordering.; ///; /// This routine maps IR values to various complexity ranks:; /// 0 -> undef; /// 1 -> Constants; /// 2 -> Other non-instructions; /// 3 -> Arguments; /// 4 -> Cast and (f)neg/not instructions; /// 5 -> Other instructions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:70,reduce,reduce,70,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['reduce'],['reduce']
Energy Efficiency,"/// Assign this MachineInstr's memory reference descriptor list.; ///; /// Unlike other methods, this *will* allocate them into a new array; /// associated with the provided `MachineFunction`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:109,allocate,allocate,109,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['allocate'],['allocate']
Energy Efficiency,/// Assigns the instruction for the SUnit. This may be used during; /// post-regalloc scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:86,schedul,scheduling,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Assigns the representative SDNode for this SUnit. This may be used; /// during pre-regalloc scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:96,schedul,scheduling,96,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Assumes both ""true"" and ""false"" for \p cond, and returns both; /// corresponding states (respectively).; ///; /// This is more efficient than calling assume() twice. Note that one (but not; /// both) of the returned states may be NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h:131,efficient,efficient,131,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Assumes given range both ""true"" and ""false"" for \p Val, and returns both; /// corresponding states (respectively).; ///; /// This is more efficient than calling assume() twice. Note that one (but not; /// both) of the returned states may be NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h:142,efficient,efficient,142,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,1,['efficient'],['efficient']
Energy Efficiency,/// Attaches ScheduleData to Instruction with the leading key.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Schedul,ScheduleData,13,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Schedul'],['ScheduleData']
Energy Efficiency,"/// Attaches ScheduleData to Instruction.; /// Note that the mapping survives during all vectorization iterations, i.e.; /// ScheduleData structures are recycled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,Schedul,ScheduleData,13,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['Schedul'],['ScheduleData']
Energy Efficiency,/// Attempt the reassociation transformation to reduce critical path length.; /// See the above comments before getMachineCombinerPatterns().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:48,reduce,reduce,48,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Attempt to build or re-use a precompiled preamble when (re-)parsing; /// the source file.; ///; /// This routine will compute the preamble of the main source file. If a; /// non-trivial preamble is found, it will precompile that preamble into a; /// precompiled header so that the precompiled preamble can be used to reduce; /// reparsing time. If a precompiled preamble has already been constructed,; /// this routine will determine if it is still valid and, if so, avoid; /// rebuilding the precompiled preamble.; ///; /// \param AllowRebuild When true (the default), this routine is; /// allowed to rebuild the precompiled preamble if it is found to be; /// out-of-date.; ///; /// \param MaxLines When non-zero, the maximum number of lines that; /// can occur within the preamble.; ///; /// \returns If the precompiled preamble can be used, returns a newly-allocated; /// buffer that should be used in place of the main file when doing so.; /// Otherwise, returns a NULL pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:321,reduce,reduce,321,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,2,"['allocate', 'reduce']","['allocated', 'reduce']"
Energy Efficiency,"/// Attempt to perform the SMS algorithm on the specified loop. This function is; /// the main entry point for the algorithm. The function identifies candidate; /// loops, calculates the minimum initiation interval, and attempts to schedule; /// the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:232,schedul,schedule,232,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// Attempt to reassociate \P Root and \P Prev according to \P Pattern to; /// reduce critical path length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:79,reduce,reduce,79,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['reduce'],['reduce']
Energy Efficiency,"/// Attempt to rotate a loop based on profile data to reduce branch cost.; ///; /// With profile data, we can determine the cost in terms of missed fall through; /// opportunities when rotating a loop chain and select the best rotation.; /// Basically, there are three kinds of cost to consider for each rotation:; /// 1. The possibly missed fall through edge (if it exists) from BB out of; /// the loop to the loop header.; /// 2. The possibly missed fall through edges (if they exist) from the loop; /// exits to BB out of the loop.; /// 3. The missed fall through edge (if it exists) from the last BB to the; /// first BB in the loop chain.; /// Therefore, the cost for a given rotation is the sum of costs listed above.; /// We select the best rotation with the smallest cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:54,reduce,reduce,54,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Attempt to write the given bytes into the stream at the desired; /// offset. This will always necessitate a copy. Cannot shrink or grow the; /// stream, only writes into existing allocated space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h:183,allocate,allocated,183,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Attempts to make code in the caller as efficient as possible under the; /// assumption that the call is not commonly executed. As such, these calls; /// often preserve all registers so that the call does not break any live; /// ranges in the caller side.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h:43,efficient,efficient,43,interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Attempts to reduce MI, returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:16,reduce,reduce,16,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Attempts to reduce a cleanup's entry block to a fallthrough. This; /// is basically llvm::MergeBlockIntoPredecessor, except; /// simplified/optimized for the tighter constraints on cleanup blocks.; ///; /// Returns the new block, whatever it is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:16,reduce,reduce,16,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// BacktrackBottomUp - Backtrack scheduling to a previous cycle specified in; /// BTCycle in order to schedule a specific node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:34,schedul,scheduling,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,/// Base class for GenericScheduler. This class maintains information about; /// scheduling candidates based on TargetSchedModel making it easy to implement; /// heuristics for either preRA or postRA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:81,schedul,scheduling,81,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduling']
Energy Efficiency,/// Base class for a machine scheduler class that can run at any point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,schedul,scheduler,29,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,/// Base class for all values computed by abstract interpretation.; ///; /// Don't use `Value` instances by value. All `Value` instances are allocated; /// and owned by `DataflowAnalysisContext`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Value.h:141,allocate,allocated,141,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Value.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:836,adapt,adapt,836,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h,1,['adapt'],['adapt']
Energy Efficiency,"/// Base struct for all ""concrete attribute"" deductions.; ///; /// The abstract attribute is a minimal interface that allows the Attributor to; /// orchestrate the abstract/fixpoint analysis. The design allows to hide away; /// implementation choices made for the subclasses but also to structure their; /// implementation and simplify the use of other abstract attributes in-flight.; ///; /// To allow easy creation of new attributes, most methods have default; /// implementations. The ones that do not are generally straight forward, except; /// `AbstractAttribute::updateImpl` which is the location of most reasoning; /// associated with the abstract attribute. The update is invoked by the; /// Attributor in case the situation used to justify the current optimistic; /// state might have changed. The Attributor determines this automatically; /// by monitoring the `Attributor::getAAFor` calls made by abstract attributes.; ///; /// The `updateImpl` method should inspect the IR and other abstract attributes; /// in-flight to justify the best possible (=optimistic) state. The actual; /// implementation is, similar to the underlying abstract state encoding, not; /// exposed. In the most common case, the `updateImpl` will go through a list of; /// reasons why its optimistic state is valid given the current information. If; /// any combination of them holds and is sufficient to justify the current; /// optimistic state, the method shall return UNCHAGED. If not, the optimistic; /// state is adjusted to the situation and the method shall return CHANGED.; ///; /// If the manifestation of the ""concrete attribute"" deduced by the subclass; /// differs from the ""default"" behavior, which is a (set of) LLVM-IR; /// attribute(s) for an argument, call site argument, function return value, or; /// function, the `AbstractAttribute::manifest` method should be overloaded.; ///; /// NOTE: If the state obtained via getState() is INVALID, thus if; /// AbstractAttribute::getState().isValidState() ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:856,monitor,monitoring,856,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['monitor'],['monitoring']
Energy Efficiency,"/// BaseSubobjectInfo - Represents a single base subobject in a complete class.; /// For a class hierarchy like; ///; /// class A { };; /// class B : A { };; /// class C : A, B { };; ///; /// The BaseSubobjectInfo graph for C will have three BaseSubobjectInfo; /// instances, one for B and two for A.; ///; /// If a base is virtual, it will only have one BaseSubobjectInfo allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:373,allocate,allocated,373,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Based only on latency of instructions, determine if it is cost efficient; /// to replace the instruction InstDesc by the instructions stored in the; /// array InstDescRepl.; /// Return true if replacement is expected to be faster.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:67,efficient,efficient,67,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,2,['efficient'],['efficient']
Energy Efficiency,/// Basic block currently being allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:32,allocate,allocated,32,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:510,reduce,reduce,510,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// Binary functor that adapts to any other binary functor after dereferencing; /// operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:24,adapt,adapts,24,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['adapt'],['adapts']
Energy Efficiency,"/// BlockExpr - Adaptor class for mixing a BlockDecl with expressions.; /// ^{ statement-body } or ^(int arg1, float arg2){ statement-body }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:16,Adapt,Adaptor,16,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['Adapt'],['Adaptor']
Energy Efficiency,"/// Blocks until all scheduled tasks finished",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:21,schedul,scheduled,21,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['schedul'],['scheduled']
Energy Efficiency,"/// Boundary nodes are placeholders for the boundary of the; /// scheduling region.; ///; /// BoundaryNodes can have DAG edges, including Data edges, but they do not; /// correspond to schedulable entities (e.g. instructions) and do not have a; /// valid ID. Consequently, always check for boundary nodes before accessing; /// an associative data structure keyed on node ID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:65,schedul,scheduling,65,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,2,['schedul'],"['schedulable', 'scheduling']"
Energy Efficiency,/// BreakAntiDependencies - Identifiy anti-dependencies within the; /// ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:72,Schedul,ScheduleDAG,72,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,1,['Schedul'],['ScheduleDAG']
Energy Efficiency,"/// Buffer size to use for writing to files, must be a multiple of 4096 bytes. Testing suggests that 4MiB gives best; /// performance (with Direct I/O) at a reasonable memory consumption.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:175,consumption,consumption,175,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,1,['consumption'],['consumption']
Energy Efficiency,"/// Buffered resources will have this field set to a positive number different; /// than zero. A buffered resource behaves like a reservation station; /// implementing its own buffer for out-of-order execution.; ///; /// A BufferSize of 1 is used by scheduler resources that force in-order; /// execution.; ///; /// A BufferSize of 0 is used to model in-order issue/dispatch resources.; /// Since in-order issue/dispatch resources don't implement buffers, dispatch; /// events coincide with issue events.; /// Also, no other instruction ca be dispatched/issue while this resource is; /// in use. Only when all the ""resource cycles"" are consumed (after the issue; /// event), a new instruction ca be dispatched.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:250,schedul,scheduler,250,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['schedul'],['scheduler']
Energy Efficiency,"/// Build 'dist_schedule' clause with schedule kind \a Kind and chunk; /// size expression \a ChunkSize.; ///; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param KLoc Starting location of the argument.; /// \param CommaLoc Location of ','.; /// \param EndLoc Ending location of the clause.; /// \param Kind DistSchedule kind.; /// \param ChunkSize Chunk size.; /// \param HelperChunkSize Helper chunk size for combined directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:38,schedul,schedule,38,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Build 'schedule' clause with schedule kind \a Kind and chunk size; /// expression \a ChunkSize.; ///; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param KLoc Starting location of the argument.; /// \param CommaLoc Location of ','.; /// \param EndLoc Ending location of the clause.; /// \param Kind Schedule kind.; /// \param ChunkSize Chunk size.; /// \param HelperChunkSize Helper chunk size for combined directives.; /// \param M1 The first modifier applied to 'schedule' clause.; /// \param M1Loc Location of the first modifier; /// \param M2 The second modifier applied to 'schedule' clause.; /// \param M2Loc Location of the second modifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:11,schedul,schedule,11,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,5,"['Schedul', 'schedul']","['Schedule', 'schedule']"
Energy Efficiency,"/// Build VPlans for power-of-2 VF's between \p MinVF and \p MaxVF inclusive,; /// according to the information gathered by Legal when it checked if it is; /// legal to vectorize the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:21,power,power-of-,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,1,['power'],['power-of-']
Energy Efficiency,"/// Build VPlans for power-of-2 VF's between \p MinVF and \p MaxVF inclusive,; /// according to the information gathered by Legal when it checked if it is; /// legal to vectorize the loop. This method creates VPlans using VPRecipes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:21,power,power-of-,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,1,['power'],['power-of-']
Energy Efficiency,"/// Build a binary operator, assuming that appropriate storage has been; /// allocated for the trailing objects when needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:77,allocate,allocated,77,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['allocate'],['allocated']
Energy Efficiency,/// Build a bundle from the ScheduleData nodes corresponding to the; /// scalar instruction for each lane.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,Schedul,ScheduleData,28,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Schedul'],['ScheduleData']
Energy Efficiency,"/// Build a call expression, assuming that appropriate storage has been; /// allocated for the trailing objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:77,allocate,allocated,77,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['allocate'],['allocated']
Energy Efficiency,/// Build a case statement assuming that the storage for the; /// trailing objects has been properly allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h:101,allocate,allocated,101,interpreter/llvm-project/clang/include/clang/AST/Stmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:878,reduce,reduce,878,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...; ///; /// Given a vector of values raised to various powers, where no two values are; /// equal and the powers are sorted in decreasing order, compute the minimal; /// DAG of multiplies to compute the final product, and return that product; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:118,power,powers,118,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['power'],['powers']
Energy Efficiency,"/// Build a new OpenMP 'allocate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,allocate,allocate,24,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Build a new OpenMP 'schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,schedul,schedule,24,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Build a strategy from a number of threads as a string provided in \p Num.; /// When Num is above the max number of threads specified by the \p Default; /// strategy, we attempt to equally allocate the threads on all CPU sockets.; /// ""0"" or an empty string will return the \p Default strategy.; /// ""all"" for using all hardware threads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:192,allocate,allocate,192,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['allocate'],['allocate']
Energy Efficiency,/// Build an empty '#pragma omp tile' AST node for deserialization.; ///; /// \param C Context of the AST.; /// \param NumClauses Number of clauses to allocate.; /// \param NumLoops Number of associated loops to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:151,allocate,allocate,151,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,2,['allocate'],['allocate']
Energy Efficiency,/// Build an empty '#pragma omp unroll' AST node for deserialization.; ///; /// \param C Context of the AST.; /// \param NumClauses Number of clauses to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:153,allocate,allocate,153,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Build an expression graph dominated by the current processed TruncInst and; /// Check if it is eligible to be reduced to a smaller type.; ///; /// \return the scalar version of the new type to be used for the reduced; /// expression graph, or nullptr if the expression graph is not; /// eligible to be reduced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:114,reduce,reduced,114,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,3,['reduce'],['reduced']
Energy Efficiency,"/// Build and insert \p Res = G_DYN_STACKALLOC \p Size, \p Align; ///; /// G_DYN_STACKALLOC does a dynamic stack allocation and writes the address of; /// the allocated memory into \p Res.; /// \pre setBasicBlock or setMI must have been called.; /// \pre \p Res must be a generic virtual register with pointer type.; ///; /// \return a MachineInstrBuilder for the newly created instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:159,allocate,allocated,159,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Build sdiv by power-of-2 with conditional move instructions; /// Ref: ""Hacker's Delight"" by Henry Warren 10-1; /// If conditional move/branch is preferred, we lower sdiv x, +/-2**k into:; /// bgez x, label; /// add x, x, 2**k-1; /// label:; /// sra res, x, k; /// neg res, res (when the divisor is negative)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:18,power,power-of-,18,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['power'],['power-of-']
Energy Efficiency,"/// Build up a vector of value/power pairs factoring a product.; ///; /// Given a series of multiplication operands, build a vector of factors and; /// the powers each is raised to when forming the final product. Sort them in; /// the order of descending power.; ///; /// (x*x) -> [(x, 2)]; /// ((x*x)*x) -> [(x, 3)]; /// ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]; ///; /// \returns Whether any factors have a power greater than one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:31,power,power,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,4,['power'],"['power', 'powers']"
Energy Efficiency,"/// BuildSchedGraph - Build the SUnit graph from the selection dag that we; /// are input. This SUnit graph is similar to the SelectionDAG, but; /// excludes nodes that aren't interesting to scheduling, and represents; /// flagged together nodes with a single SUnit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h:191,schedul,scheduling,191,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// BuildSchedGraph - Build the SUnit graph from the selection dag that we; /// are input. This SUnit graph is similar to the SelectionDAG, but; /// excludes nodes that aren't interesting to scheduling, and represents; /// glued together nodes with a single SUnit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:191,schedul,scheduling,191,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Builds SUnits for the current region.; /// If \p RPTracker is non-null, compute register pressure as a side effect.; /// The DAG builder is an efficient place to do it because it already visits; /// operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:147,efficient,efficient,147,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Byte offset (possibly negative) from start of amd_kernel_code_t; /// object to kernel's entry point instruction. The actual code for; /// the kernel is required to be 256 byte aligned to match hardware; /// requirements (SQ cache line is 16). The code must be position; /// independent code (PIC) for AMD devices to give runtime the; /// option of copying code to discrete GPU memory or APU L2; /// cache. The Finalizer should endeavour to allocate all kernel; /// machine code in contiguous memory pages so that a device; /// pre-fetcher will tend to only pre-fetch Kernel Code objects,; /// improving cache performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:444,allocate,allocate,444,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['allocate'],['allocate']
Energy Efficiency,/// CCState - This class holds information needed while lowering arguments and; /// return values. It captures which registers are already assigned and which; /// stack slots are used. It provides accessors to allocate these values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:210,allocate,allocate,210,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['allocate'],['allocate']
Energy Efficiency,/// CMOV of constants requires materializing constant operands in registers.; /// Try to fold those constants into an 'add' instruction to reduce instruction; /// count. We do this with CMOV rather the generic 'select' because there are; /// earlier folds that may be used to turn select-of-constants into logic hacks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:139,reduce,reduce,139,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// COPYs don't have register class constraints, so if the user instruction; /// is a COPY, we just try to avoid introducing additional cross-class; /// COPYs. For example:; ///; /// RegClassA = COPY RegClassB // Copy parameter; /// ...; /// RegClassB = COPY RegClassA // UseI parameter; ///; /// which after forwarding becomes; ///; /// RegClassA = COPY RegClassB; /// ...; /// RegClassB = COPY RegClassB; ///; /// so we have reduced the number of cross-class COPYs and potentially; /// introduced a nop COPY that can be removed.; // Allow forwarding if src and dst belong to any common class, so long as they; // don't belong to any (possibly smaller) common class that requires copies to; // go via a different class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:427,reduce,reduced,427,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['reduce'],['reduced']
Energy Efficiency,/// CRTP base class for adapting an iterator to a different type.; ///; /// This class can be used through CRTP to adapt one iterator into another.; /// Typically this is done through providing in the derived class a custom \c; /// operator* implementation. Other methods can be overridden as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:24,adapt,adapting,24,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,2,['adapt'],"['adapt', 'adapting']"
Energy Efficiency,"/// CRTP base class providing obvious overloads for the core \c; /// Allocate() methods of LLVM-style allocators.; ///; /// This base class both documents the full public interface exposed by all; /// LLVM-style allocators, and redirects all of the overloads to a single core; /// set of methods which the derived class must define.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h:69,Allocate,Allocate,69,interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// CXString contains a 'const char *' that it allocated with malloc().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.cpp:47,allocate,allocated,47,interpreter/llvm-project/clang/tools/libclang/CXString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXString.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Cache of all stable symbols, indexed by SymIndexId. Just because a; /// symbol has been parsed does not imply that it will be stable and have; /// an Id. Id allocation is an implementation, with the only guarantee; /// being that once an Id is allocated, the symbol can be assumed to be; /// cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h:248,allocate,allocated,248,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,1,['allocate'],['allocated']
Energy Efficiency,/// Cache of failed test results. Successful test results are never cached; /// since we always reduce following a success.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:96,reduce,reduce,96,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,1,['reduce'],['reduce']
Energy Efficiency,/// Cache of failed test results. Successful test results are never cached; /// since we always reduce following a success. We maintain an independent; /// cache from that used by the individual delta passes because we may get; /// hits across multiple individual delta invocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DAGDeltaAlgorithm.cpp:96,reduce,reduce,96,interpreter/llvm-project/llvm/lib/Support/DAGDeltaAlgorithm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DAGDeltaAlgorithm.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// Cache policy: the maximum size for the cache directory in bytes. A value; /// over the amount of available space on the disk will be reduced to the; /// amount of available space. A value of 0 will be ignored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:137,reduce,reduced,137,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['reduce'],['reduced']
Energy Efficiency,/// Cache the current connection level of each subtree.; /// This mutable array is updated during scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:98,schedul,scheduling,98,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Calculate the maximum register pressure of the scheduled instructions stream,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:51,schedul,scheduled,51,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,/// CalculateSethiUllmanNumbers - Calculate Sethi-Ullman numbers of all; /// scheduling units.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:77,schedul,scheduling,77,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Call ReleasePred for each predecessor, then update register live def/gen.; /// Always update LiveRegDefs for a register dependence even if the current SU; /// also defines the register. This effectively create one large live range; /// across a sequence of two-address node. This is important because the; /// entire chain must be scheduled together. Example:; ///; /// flags = (3) add; /// flags = (2) addc flags; /// flags = (1) addc flags; ///; /// results in; ///; /// LiveRegDefs[flags] = 3; /// LiveRegGens[flags] = 1; ///; /// If (2) addc is unscheduled, then (1) addc must also be unscheduled to avoid; /// interference on flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:335,schedul,scheduled,335,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"/// Call the appropriate runtime routine to initialize it before start; /// of loop.; /// This is used for non static scheduled types and when the ordered; /// clause is present on the loop construct.; /// Depending on the loop schedule, it is necessary to call some runtime; /// routine before start of the OpenMP loop to get the loop upper / lower; /// bounds \a LB and \a UB and stride \a ST.; ///; /// \param CGF Reference to current CodeGenFunction.; /// \param Loc Clang source location.; /// \param ScheduleKind Schedule kind, specified by the 'schedule' clause.; /// \param IVSize Size of the iteration variable in bits.; /// \param IVSigned Sign of the iteration variable.; /// \param Ordered true if loop is ordered, false otherwise.; /// \param DispatchValues struct containing llvm values for lower bound, upper; /// bound, and chunk expression.; /// For the default (nullptr) value, the chunk 1 will be used.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:118,schedul,scheduled,118,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,5,"['Schedul', 'schedul']","['Schedule', 'ScheduleKind', 'schedule', 'scheduled']"
Energy Efficiency,"/// Call the appropriate runtime routine to initialize it before start; /// of loop.; ///; /// This is used only in case of static schedule, when the user did not; /// specify a ordered clause on the loop construct.; /// Depending on the loop schedule, it is necessary to call some runtime; /// routine before start of the OpenMP loop to get the loop upper / lower; /// bounds LB and UB and stride ST.; ///; /// \param CGF Reference to current CodeGenFunction.; /// \param Loc Clang source location.; /// \param DKind Kind of the directive.; /// \param ScheduleKind Schedule kind, specified by the 'schedule' clause.; /// \param Values Input arguments for the construct.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:131,schedul,schedule,131,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,10,"['Schedul', 'schedul']","['Schedule', 'ScheduleKind', 'schedule']"
Energy Efficiency,/// Call the appropriate runtime routine to notify that we finished; /// iteration of the ordered loop with the dynamic scheduling.; ///; /// \param CGF Reference to current CodeGenFunction.; /// \param Loc Clang source location.; /// \param IVSize Size of the iteration variable in bits.; /// \param IVSigned Sign of the iteration variable.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:120,schedul,scheduling,120,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,2,['schedul'],['scheduling']
Energy Efficiency,"/// Call the destructor of each allocated object and deallocate all but the; /// current slab and reset the current pointer to the beginning of it, freeing; /// all memory allocated so far.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:32,allocate,allocated,32,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,2,['allocate'],['allocated']
Energy Efficiency,"/// Callback after a node is scheduled. Mark a newly scheduled tree, notify; /// DFSResults, and resort the priority Q.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,schedul,scheduled,29,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduled']
Energy Efficiency,/// Called after ScheduleDAGMI has scheduled an instruction and updated; /// scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:17,Schedul,ScheduleDAGMI,17,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,"['Schedul', 'schedul']","['ScheduleDAGMI', 'scheduled']"
Energy Efficiency,/// Called for a region before scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:31,schedul,scheduling,31,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Called on well-formed '#pragma omp allocate'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:39,allocate,allocate,39,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['allocate'],['allocate']
Energy Efficiency,/// Called on well-formed 'allocate' clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:27,allocate,allocate,27,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['allocate'],['allocate']
Energy Efficiency,/// Called on well-formed 'schedule' clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:27,schedul,schedule,27,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['schedul'],['schedule']
Energy Efficiency,/// Called when the scheduler has finished scheduling the current region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:20,schedul,scheduler,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,"/// Called whenever a symbol becomes dead.; ///; /// This callback should be used by the checkers to aggressively clean; /// up/reduce the checker state, which is important for reducing the overall; /// memory usage. Specifically, if a checker keeps symbol specific information; /// in the state, it can and should be dropped after the symbol becomes dead.; /// In addition, reporting a bug as soon as the checker becomes dead leads to; /// more precise diagnostics. (For example, one should report that a malloced; /// variable is not freed right after it goes out of scope.); ///; /// \param SR The SymbolReaper object can be queried to determine which; /// symbols are dead.; ///; /// check::DeadSymbols",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:128,reduce,reduce,128,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Can the stack be realigned. This can be false if the target does not; /// support stack realignment, or if the user asks us not to realign the; /// stack. In this situation, overaligned allocas are all treated as dynamic; /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC; /// lowering. All non-alloca stack objects have their alignment clamped to the; /// base ABI stack alignment.; /// FIXME: There is room for improvement in this case, in terms of; /// grouping overaligned allocas into a ""secondary stack frame"" and; /// then only use a single alloca to allocate this frame and only a; /// single virtual register to access it. Currently, without such an; /// optimization, each such alloca gets its own dynamic realignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:590,allocate,allocate,590,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['allocate'],['allocate']
Energy Efficiency,/// Certain SIMD instructions with vector element operand are not efficient.; /// Rewrite them into SIMD instructions with vector operands. This rewrite; /// is driven by the latency of the instructions.; /// Return true if the SIMD instruction is modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:66,efficient,efficient,66,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// Certain SIMD instructions with vector element operand are not efficient.; /// Rewrite them into SIMD instructions with vector operands. This rewrite; /// is driven by the latency of the instructions.; /// The instruction of concerns are for the time being FMLA, FMLS, FMUL,; /// and FMULX and hence they are hardcoded.; ///; /// For example:; /// fmla v0.4s, v1.4s, v2.s[1]; ///; /// Is rewritten into; /// dup v3.4s, v2.s[1] // DUP not necessary if redundant; /// fmla v0.4s, v1.4s, v3.4s; ///; /// Return true if the SIMD instruction is modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:66,efficient,efficient,66,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['efficient'],['efficient']
Energy Efficiency,/// Check if operand \p OpIdx is known to be a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:47,power,power,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['power'],['power']
Energy Efficiency,/// Check if scheduling of this SU is possible; /// in the current packet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:13,schedul,scheduling,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Check if scheduling of this SU is possible; /// in the current packet.; /// It is _not_ precise (statefull), it is more like; /// another heuristic. Many corner cases are figured; /// empirically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:13,schedul,scheduling,13,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Check if the existing node-sets are profitable. If not, then ignore the; /// recurrent node-sets, and attempt to schedule all nodes together. This is; /// a heuristic. If the MII is large and all the recurrent node-sets are small,; /// then it's best to try to schedule all instructions together instead of; /// starting with the recurrent node-sets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:117,schedul,schedule,117,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],['schedule']
Energy Efficiency,"/// Check if the instr pair, FirstMI and SecondMI, should be scheduled; /// together. Given SecondMI, when FirstMI is unspecified, then check if; /// SecondMI may be part of a fused pair at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNVOPDUtils.cpp:61,schedul,scheduled,61,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNVOPDUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNVOPDUtils.cpp,1,['schedul'],['scheduled']
Energy Efficiency,/// Check if the instruction in 'IR' can be dispatched during this cycle.; /// Return SC_AVAILABLE if both scheduler and LS resources are available.; ///; /// This method is also responsible for setting field HadTokenStall if; /// IR cannot be dispatched to the Scheduler due to unavailable resources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:107,schedul,scheduler,107,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,2,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency,/// Check if the multiply is by a power-of-2 constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:34,power,power-of-,34,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['power'],['power-of-']
Energy Efficiency,/// Check if the specified \a ScheduleKind is dynamic.; /// This kind of worksharing directive is emitted without outer loop.; /// \param ScheduleKind Schedule Kind specified in the 'schedule' clause.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:30,Schedul,ScheduleKind,30,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,4,"['Schedul', 'schedul']","['Schedule', 'ScheduleKind', 'schedule']"
Energy Efficiency,/// Check if the specified \a ScheduleKind is static chunked.; /// \param ScheduleKind Schedule kind specified in the 'schedule' clause.; /// \param Chunked True if chunk is specified in the clause.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:30,Schedul,ScheduleKind,30,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,4,"['Schedul', 'schedul']","['Schedule', 'ScheduleKind', 'schedule']"
Energy Efficiency,/// Check if the specified \a ScheduleKind is static non-chunked.; /// This kind of distribute directive is emitted without outer loop.; /// \param ScheduleKind Schedule kind specified in the 'dist_schedule' clause.; /// \param Chunked True if chunk is specified in the clause.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:30,Schedul,ScheduleKind,30,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,3,['Schedul'],"['Schedule', 'ScheduleKind']"
Energy Efficiency,/// Check if the specified \a ScheduleKind is static non-chunked.; /// This kind of worksharing directive is emitted without outer loop.; /// \param ScheduleKind Schedule kind specified in the 'schedule' clause.; /// \param Chunked True if chunk is specified in the clause.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:30,Schedul,ScheduleKind,30,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,4,"['Schedul', 'schedul']","['Schedule', 'ScheduleKind', 'schedule']"
Energy Efficiency,/// Check if the specified \a ScheduleKind is static non-chunked.; /// \param ScheduleKind Schedule kind specified in the 'dist_schedule' clause.; /// \param Chunked True if chunk is specified in the clause.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:30,Schedul,ScheduleKind,30,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,3,['Schedul'],"['Schedule', 'ScheduleKind']"
Energy Efficiency,/// Check if this APInt's negated value is a power of two greater than zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:45,power,power,45,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['power'],['power']
Energy Efficiency,/// Check if this APInt's value is a power of two greater than zero.; ///; /// \returns true if the argument APInt value is a power of two > 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:37,power,power,37,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,2,['power'],['power']
Energy Efficiency,/// Check if this global has a custom object file section.; ///; /// This is more efficient than calling getSection() and checking for an empty; /// string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalObject.h:82,efficient,efficient,82,interpreter/llvm-project/llvm/include/llvm/IR/GlobalObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalObject.h,1,['efficient'],['efficient']
Energy Efficiency,/// Check if we are casting to a struct with a flexible array at the end.; /// \code; /// struct foo {; /// size_t len;; /// struct bar data[];; /// };; /// \endcode; /// or; /// \code; /// struct foo {; /// size_t len;; /// struct bar data[0];; /// }; /// \endcode; /// In these cases it is also valid to allocate size of struct foo + a multiple; /// of struct bar.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp:306,allocate,allocate,306,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CastSizeChecker.cpp,1,['allocate'],['allocate']
Energy Efficiency,"/// Check that TMemFile do not (re-)allocate the external contents.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/test/TROMemFileTests.cxx:36,allocate,allocate,36,io/io/test/TROMemFileTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/test/TROMemFileTests.cxx,1,['allocate'],['allocate']
Energy Efficiency,"/// Check that the value argument for __builtin_is_aligned(value, alignment) and; /// __builtin_aligned_{up,down}(value, alignment) is an integer or a pointer; /// type (but not a function pointer) and that the alignment is a power-of-two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:226,power,power-of-two,226,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['power'],['power-of-two']
Energy Efficiency,"/// Check whether a compaction lowering can be done by dropping even/odd; /// elements and compute how many times even/odd elements must be dropped.; ///; /// This handles shuffles which take every Nth element where N is a power of; /// two. Example shuffle masks:; ///; /// (even); /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30; /// N = 2: 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12, 0, 4, 8, 12; /// N = 2: 0, 4, 8, 12, 16, 20, 24, 28, 0, 4, 8, 12, 16, 20, 24, 28; /// N = 3: 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8; /// N = 3: 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24; ///; /// (odd); /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 0, 2, 4, 6, 8, 10, 12, 14; /// N = 1: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31; ///; /// Any of these lanes can of course be undef.; ///; /// This routine only supports N <= 3.; /// FIXME: Evaluate whether either AVX or AVX-512 have any opportunities here; /// for larger N.; ///; /// \returns N above, or the number of times even/odd elements must be dropped; /// if there is such a number. Otherwise returns zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:223,power,power,223,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,/// Check whether a particular block is allocated or free.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h:40,allocate,allocated,40,interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Checks if N is a multiplication by a constant where we can extract out a; /// power of two from the constant so that it can be used in a shift, but only; /// if it simplifies the materialization of the constant. Returns true if it; /// is, and assigns to PowerOfTwo the power of two that should be extracted; /// out and to NewMulConst the new constant to be multiplied by.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:82,power,power,82,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,3,"['Power', 'power']","['PowerOfTwo', 'power']"
Energy Efficiency,"/// Checks if a bundle of instructions can be scheduled, i.e. has no; /// cyclic dependencies. This is only a dry-run, no instructions are; /// actually moved at this stage.; /// \returns the scheduling bundle. The returned Optional value is not; /// std::nullopt if \p VL is allowed to be scheduled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:46,schedul,scheduled,46,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,/// Checks if the provided list of reduced values was checked already for; /// vectorization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,reduce,reduced,35,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all operands are either not instructions; /// or phi nodes or instructions from different blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,schedul,scheduling,50,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['schedul'],['scheduling']
Energy Efficiency,/// Checks if the provided value does not require scheduling. It does not; /// require scheduling if this is not an instruction or it is an instruction; /// that does not read/write memory and all users are phi nodes or instructions; /// from the different blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:50,schedul,scheduling,50,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['schedul'],['scheduling']
Energy Efficiency,/// Checks if the specified array of instructions does not require scheduling.; /// It is so if all either instructions have operands that do not require; /// scheduling or their users do not require scheduling since they are phis or; /// in other basic blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:67,schedul,scheduling,67,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,['schedul'],['scheduling']
Energy Efficiency,/// Checks if the specified list of the instructions/values can be vectorized; /// and fills required data before actual scheduling of the instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:121,schedul,scheduling,121,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// Checks if the specified value does not require scheduling. It does not; /// require scheduling if all operands and all users do not need to be scheduled; /// in the current basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:51,schedul,scheduling,51,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,/// Checks that a type is suitable as the allocated type; /// in a new-expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:42,allocate,allocated,42,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Choose a default value for the schedule clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h:35,schedul,schedule,35,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h,1,['schedul'],['schedule']
Energy Efficiency,/// Choose default schedule type and chunk value for the; /// dist_schedule clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:19,schedul,schedule,19,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['schedul'],['schedule']
Energy Efficiency,/// Choose default schedule type and chunk value for the; /// schedule clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:19,schedul,schedule,19,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,2,['schedul'],['schedule']
Energy Efficiency,"/// Chooses the correct key for scheduling data. If \p Op has the same (or; /// alternate) opcode as \p OpValue, the key is \p Op. Otherwise the key is; /// \p OpValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,schedul,scheduling,32,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// Chunk size specified using 'schedule' clause (nullptr if chunk; /// was not specified),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:32,schedul,schedule,32,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Class Scheduler is responsible for issuing instructions to pipeline; /// resources.; ///; /// Internally, it delegates to a ResourceManager the management of processor; /// resources. This class is also responsible for tracking the progress of; /// instructions from the dispatch stage, until the write-back stage.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:10,Schedul,Scheduler,10,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['Schedul'],['Scheduler']
Energy Efficiency,"/// Class representing coefficient of floating-point addend.; /// This class needs to be highly efficient, which is especially true for; /// the constructor. As of I write this comment, the cost of the default; /// constructor is merely 4-byte-store-zero (Assuming compiler is able to; /// perform write-merging).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:96,efficient,efficient,96,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// Class to represented the control flow structure of an OpenMP canonical loop.; ///; /// The control-flow structure is standardized for easy consumption by; /// directives associated with loops. For instance, the worksharing-loop; /// construct may change this control flow such that each loop iteration is; /// executed on only one thread. The constraints of a canonical loop in brief; /// are:; ///; /// * The number of loop iterations must have been computed before entering the; /// loop.; ///; /// * Has an (unsigned) logical induction variable that starts at zero and; /// increments by one.; ///; /// * The loop's CFG itself has no side-effects. The OpenMP specification; /// itself allows side-effects, but the order in which they happen, including; /// how often or whether at all, is unspecified. We expect that the frontend; /// will emit those side-effect instructions somewhere (e.g. before the loop); /// such that the CanonicalLoopInfo itself can be side-effect free.; ///; /// Keep in mind that CanonicalLoopInfo is meant to only describe a repeated; /// execution of a loop body that satifies these constraints. It does NOT; /// represent arbitrary SESE regions that happen to contain a loop. Do not use; /// CanonicalLoopInfo for such purposes.; ///; /// The control flow can be described as follows:; ///; /// Preheader; /// |; /// /-> Header; /// | |; /// | Cond---\; /// | | |; /// | Body |; /// | | | |; /// | <...> |; /// | | | |; /// \--Latch |; /// |; /// Exit; /// |; /// After; ///; /// The loop is thought to start at PreheaderIP (at the Preheader's terminator,; /// including) and end at AfterIP (at the After's first instruction, excluding).; /// That is, instructions in the Preheader and After blocks (except the; /// Preheader's terminator) are out of CanonicalLoopInfo's control and may have; /// side-effects. Typically, the Preheader is used to compute the loop's trip; /// count. The instructions from BodyIP (at the Body block's first instruction,; /// excludin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:143,consumption,consumption,143,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['consumption'],['consumption']
Energy Efficiency,"/// Class which can be overriden by targets to enforce instruction; /// dependencies and behaviours that aren't expressed well enough; /// within the scheduling model for mca to automatically simulate; /// them properly.; /// If you implement this class for your target, make sure to also implement; /// a target specific InstrPostProcess class as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h:150,schedul,scheduling,150,interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Class which can be overriden by targets to modify the; /// mca::Instruction objects before the pipeline starts.; /// A common usage of this class is to add immediate operands to certain; /// instructions or to remove Defs/Uses from an instruction where the; /// schedulinng model is incorrect.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h:266,schedul,schedulinng,266,interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,1,['schedul'],['schedulinng']
Energy Efficiency,/// Cleans up after scheduling in the given block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:20,schedul,scheduling,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Cleanup action for allocate support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:23,allocate,allocate,23,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Clear the vector, i.e. clear the allocated pages, the whole page; /// lookup index and reset the size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:37,allocate,allocated,37,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,1,['allocate'],['allocated']
Energy Efficiency,/// Clone - Creates a clone of the specified SUnit. It does not copy the; /// predecessors / successors info nor the temporary scheduling states.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h:127,schedul,scheduling,127,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Clone the specified noalias decl scopes. Then adapt all instructions in the; /// NewBlocks basicblocks to the cloned versions.; /// 'Ext' will be added to the duplicate scope names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:50,adapt,adapt,50,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,1,['adapt'],['adapt']
Energy Efficiency,"/// Clone the specified noalias decl scopes. Then adapt all instructions in the; /// [IStart, IEnd] (IEnd included !) range to the cloned versions. 'Ext' will be; /// added to the duplicate scope names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:50,adapt,adapt,50,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,1,['adapt'],['adapt']
Energy Efficiency,/// Clone this CorrectionCandidateCallback. CorrectionCandidateCallbacks are; /// initially stack-allocated. However in case where delayed typo-correction; /// is done we need to move the callback to storage with a longer lifetime.; /// Every class deriving from CorrectionCandidateCallback must implement; /// this method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TypoCorrection.h:98,allocate,allocated,98,interpreter/llvm-project/clang/include/clang/Sema/TypoCorrection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TypoCorrection.h,1,['allocate'],['allocated']
Energy Efficiency,/// Close is a hint to the runtime to allocate memory close to; /// the target device.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:38,allocate,allocate,38,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['allocate'],['allocate']
Energy Efficiency,"/// ClusterNeighboringLoads - Force nearby loads together by ""gluing"" them.; /// This function finds loads of the same base and different offsets. If the; /// offsets are not far apart (target specific), it add MVT::Glue inputs and; /// outputs to ensure they are scheduled together and in order. This; /// optimization may benefit some targets by improving cache locality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:264,schedul,scheduled,264,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['schedul'],['scheduled']
Energy Efficiency,/// ClusterNodes - Cluster certain nodes which should be scheduled together.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:57,schedul,scheduled,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,2,['schedul'],['scheduled']
Energy Efficiency,/// Coalesce adjacent dbg locs describing memory locations that have contiguous; /// fragments. This reduces the cost of LiveDebugValues which does SSA; /// construction for each explicitly stated variable fragment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:101,reduce,reduces,101,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['reduce'],['reduces']
Energy Efficiency,"/// Collapse a loop nest into a single loop.; ///; /// Merges loops of a loop nest into a single CanonicalLoopNest representation; /// that has the same number of innermost loop iterations as the origin loop; /// nest. The induction variables of the input loops are derived from the; /// collapsed loop's induction variable. This is intended to be used to; /// implement OpenMP's collapse clause. Before applying a directive,; /// collapseLoops normalizes a loop nest to contain only a single loop and the; /// directive's implementation does not need to handle multiple loops itself.; /// This does not remove the need to handle all loop nest handling by; /// directives, such as the ordered(<n>) clause or the simd schedule-clause; /// modifier of the worksharing-loop directive.; ///; /// Example:; /// \code; /// for (int i = 0; i < 7; ++i) // Canonical loop ""i""; /// for (int j = 0; j < 9; ++j) // Canonical loop ""j""; /// body(i, j);; /// \endcode; ///; /// After collapsing with Loops={i,j}, the loop is changed to; /// \code; /// for (int ij = 0; ij < 63; ++ij) {; /// int i = ij / 9;; /// int j = ij % 9;; /// body(i, j);; /// }; /// \endcode; ///; /// In the current implementation, the following limitations apply:; ///; /// * All input loops have an induction variable of the same type.; ///; /// * The collapsed loop will have the same trip count integer type as the; /// input loops. Therefore it is possible that the collapsed loop cannot; /// represent all iterations of the input loops. For instance, assuming a; /// 32 bit integer type, and two input loops both iterating 2^16 times, the; /// theoretical trip count of the collapsed loop would be 2^32 iteration,; /// which cannot be represented in an 32-bit integer. Behavior is undefined; /// in this case.; ///; /// * The trip counts of every input loop must be available at \p ComputeIP.; /// Non-rectangular loops are not yet supported.; ///; /// * At each nest level, code between a surrounding loop and its nested loop; /// is ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:717,schedul,schedule-clause,717,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['schedul'],['schedule-clause']
Energy Efficiency,"/// Collect all values that are directly or indirectly referenced by @p Root,; /// including Root itself. This is a BF search such that the more steps needed; /// to get to the reference, the more behind it is found in @p Collection. Each; /// step could be its own reduction, therefore we consider later values ""more; /// reduced"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp:323,reduce,reduced,323,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,1,['reduce'],['reduced']
Energy Efficiency,/// Collect store and getelementptr instructions and organize them; /// according to the underlying object of their pointer operands. We sort the; /// instructions by their underlying objects to reduce the cost of; /// consecutive access queries.; ///; /// TODO: We can further reduce this cost if we flush the chain creation; /// every time we run into a memory barrier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:195,reduce,reduce,195,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,2,['reduce'],['reduce']
Energy Efficiency,"/// Combine G_UREM x, (known power of 2) to an add and bitmasking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:29,power,power,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['power'],['power']
Energy Efficiency,/// Commit the accumulated symbols to the module symbol stream. Safe to call; /// in parallel on different DbiModuleDescriptorBuilder objects. Only modifies; /// the pre-allocated stream in question.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptorBuilder.h:170,allocate,allocated,170,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptorBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptorBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Commit to a primary definition of the class RD, which is known to be; /// a definition of the class. We might not have read the definition data; /// for it yet. If we haven't then allocate placeholder definition data; /// now too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:184,allocate,allocate,184,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['allocate'],['allocate']
Energy Efficiency,"/// Commits pending elements in a staging area (see Allocate() for more information).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h:52,Allocate,Allocate,52,core/cont/inc/TVirtualCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Common chains to reuse offsets for a loop to reduce register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:49,reduce,reduce,49,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// Common code between 32-bit and 64-bit PowerPC targets.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h:42,Power,PowerPC,42,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.h,1,['Power'],['PowerPC']
Energy Efficiency,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, using a lock manager; /// to avoid building the same module in multiple compiler instances.; ///; /// Uses a lock file manager and exponential backoff to reduce the chances that; /// multiple instances will compete to create the same module. On timeout,; /// deletes the lock file in order to avoid deadlock from crashing processes or; /// bugs in the lock file manager.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:284,reduce,reduce,284,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// Compile time Log2.; /// Valid only for positive powers of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:52,power,powers,52,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,1,['power'],['powers']
Energy Efficiency,/// CompoundLiteralRegion - A memory region representing a compound literal.; /// Compound literals are essentially temporaries that are stack allocated; /// or in the global constant pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h:143,allocate,allocated,143,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Compute \ref DefOperandIndexes so it contains the indices of ""def"" operands; /// that are to be allocated. Those are ordered in a way that small classes,; /// early clobbers and livethroughs are allocated first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:100,allocate,allocated,100,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,2,['allocate'],['allocated']
Energy Efficiency,"/// Compute a layout for a struct containing the given fields, making a; /// best-effort attempt to minimize the amount of space required.; ///; /// Two features are supported which require a more careful solution; /// than the well-known ""sort by decreasing alignment"" solution:; ///; /// - Fields may be assigned a fixed offset in the layout. If there are; /// gaps among the fixed-offset fields, the algorithm may attempt; /// to allocate flexible-offset fields into those gaps. If that's; /// undesirable, the caller should ""block out"" those gaps by e.g.; /// just creating a single fixed-offset field that represents the; /// entire ""header"".; ///; /// - The size of a field is not required to be a multiple of, or even; /// greater than, the field's required alignment. The only constraint; /// on fields is that they must not be zero-sized.; ///; /// To simplify the implementation, any fixed-offset fields in the; /// layout must appear at the start of the field array, and they must; /// be ordered by increasing offset.; ///; /// The algorithm will produce a guaranteed-minimal layout with no; /// interior padding in the following ""C-style"" case:; ///; /// - every field's size is a multiple of its required alignment and; /// - either no fields have initially fixed offsets, or the fixed-offset; /// fields have no interior padding and end at an offset that is at; /// least as aligned as all the flexible-offset fields.; ///; /// Otherwise, while the algorithm will make a best-effort attempt to; /// avoid padding, it cannot guarantee a minimal layout, as there is; /// no known efficient algorithm for doing so.; ///; /// The layout produced by this algorithm may not be stable across LLVM; /// releases. Do not use this anywhere where ABI stability is required.; ///; /// Flexible-offset fields with the same size and alignment will be ordered; /// the same way they were in the initial array. Otherwise the current; /// algorithm makes no effort to preserve the initial order of; /// ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OptimizedStructLayout.h:433,allocate,allocate,433,interpreter/llvm-project/llvm/include/llvm/Support/OptimizedStructLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OptimizedStructLayout.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Compute an ordered list of the dependence graph nodes, which; /// indicates the order that the nodes will be scheduled. This is a; /// two-level algorithm. First, a partial order is created, which; /// consists of a list of sets ordered from highest to lowest priority.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:113,schedul,scheduled,113,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"/// Compute and return the use operand latency of a given pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overridden; /// by a target. Use computeOperandLatency to get the best estimate of; /// latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:110,schedul,scheduling,110,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Compute known bits from a shift operator, including those with a; /// non-constant shift amount. Known is the output of this function. Known2 is a; /// pre-allocated temporary with the same bit width as Known and on return; /// contains the known bit of the shift value source. KF is an; /// operator-specific function that, given the known-bits and a shift amount,; /// compute the implied known-bits of the shift operator's result respectively; /// for that shift amount. The results from calling KF are conservatively; /// combined for all permitted shift amounts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:160,allocate,allocated,160,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Compute live registers just before instruction \p Before (in normal schedule; /// direction). Computes backwards so multiple queries in the same block must; /// come in reverse order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:72,schedul,schedule,72,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:87,schedul,schedule,87,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,4,['schedul'],"['schedule', 'scheduled', 'scheduling']"
Energy Efficiency,"/// Compute several functions need to order the nodes for scheduling.; /// ASAP - Earliest time to schedule a node.; /// ALAP - Latest time to schedule a node.; /// MOV - Mobility function, difference between ALAP and ASAP.; /// D - Depth of each node.; /// H - Height of each node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:58,schedul,scheduling,58,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,3,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"/// Compute the alignment for a column/row \p Idx with \p Stride between them.; /// The address at \p Idx == 0 has alignment \p A. If \p Stride is a; /// ConstantInt, reduce the initial alignment based on the byte offset. For; /// non-ConstantInt strides, return the common alignment of the initial; /// alignment and the element size in bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:167,reduce,reduce,167,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:62,schedul,scheduling,62,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,/// Compute the next cycle at which the given processor resource can be; /// scheduled. Returns the next cycle and the index of the processor resource; /// instance in the reserved cycles vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:77,schedul,scheduled,77,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,/// Compute the next cycle at which the given processor resource unit; /// can be scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:82,schedul,scheduled,82,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduled']
Energy Efficiency,/// Compute the number of operands to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:38,allocate,allocate,38,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,3,['allocate'],['allocate']
Energy Efficiency,/// Compute the scheduling start slot for the instruction. The start slot; /// depends on any predecessor or successor nodes scheduled already.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:16,schedul,scheduling,16,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"/// Compute the stall cycles based on this SUnit's ready time. Heuristics treat; /// these ""soft stalls"" differently than the hard stall cycles based on CPU; /// resources and computed by checkHazard(). A fully in-order model; /// (MicroOpBufferSize==0) will not make use of this since instructions are not; /// available for scheduling until they are ready. However, a weaker in-order; /// model may use this for heuristics. For example, if a processor has in-order; /// behavior when reading certain resources, this may come into play.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:326,schedul,scheduling,326,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// Computed node ordering for scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:31,schedul,scheduling,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Computes function attributes in post-order over the call graph.; ///; /// By operating in post-order, this pass computes precise attributes for; /// called functions prior to processsing their callers. This ""bottom-up""; /// approach allows powerful interprocedural inference of function attributes; /// like memory access patterns, etc. It can discover functions that do not; /// access memory, or only read memory, and give them the readnone/readonly; /// attribute. It also discovers function arguments that are not captured by; /// the function and marks them with the nocapture attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionAttrs.h:244,power,powerful,244,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionAttrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionAttrs.h,1,['power'],['powerful']
Energy Efficiency,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:152,efficient,efficient,152,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,2,"['allocate', 'efficient']","['allocate', 'efficient']"
Energy Efficiency,"/// Conjure a symbol representing heap allocated memory region.; ///; /// Note, now, the expression *doesn't* need to represent a location.; /// But the type need to!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h:39,allocate,allocated,39,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Conjure a symbol representing heap allocated memory region.; ///; /// Note, the expression should represent a location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h:39,allocate,allocated,39,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,"/// ConnectedVNInfoEqClasses - Helper class that can divide VNInfos in a; /// LiveInterval into equivalence clases of connected components. A; /// LiveInterval that has multiple connected components can be broken into; /// multiple LiveIntervals.; ///; /// Given a LiveInterval that may have multiple connected components, run:; ///; /// unsigned numComps = ConEQ.Classify(LI);; /// if (numComps > 1) {; /// // allocate numComps-1 new LiveIntervals into LIS[1..]; /// ConEQ.Distribute(LIS);; /// }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:411,allocate,allocate,411,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,1,['allocate'],['allocate']
Energy Efficiency,/// Constant iteration adapter for range-for loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:23,adapt,adapter,23,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['adapt'],['adapter']
Energy Efficiency,"/// Construct a vectorizable tree that starts at \p Roots, ignoring users for; /// the purpose of scheduling and extraction in the \p UserIgnoreLst.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:98,schedul,scheduling,98,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Construct adapter from a batch of values.; /// - If `batch.size() == 1`, always return the value at `batch[0]`.; /// - Else, return `batch[i]`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/BracketAdapters.h:14,adapt,adapter,14,roofit/roofitmore/src/BracketAdapters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/BracketAdapters.h,1,['adapt'],['adapter']
Energy Efficiency,"/// Construct adapter from a fallback value and a batch of values.; /// - If `batch.empty()`, always return `payload`.; /// - Else, return `batch[i]`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/BracketAdapters.h:14,adapt,adapter,14,roofit/roofitmore/src/BracketAdapters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/BracketAdapters.h,1,['adapt'],['adapter']
Energy Efficiency,/// Construct an integral constant template argument. The memory to; /// store the value is allocated with Ctx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h:92,allocate,allocated,92,interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,1,['allocate'],['allocated']
Energy Efficiency,/// Constructor - Allocates space for the class decisions and clears them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h:18,Allocate,Allocates,18,interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h,1,['Allocate'],['Allocates']
Energy Efficiency,/// Constructor for the mapping of an instruction.; /// \p NumOperands must be equal to number of all the operands of; /// the related instruction.; /// The rationale is that it is more efficient for the optimizers; /// to be able to assume that the mapping of the ith operand is; /// at the index i.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:186,efficient,efficient,186,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Constructor for unweighted data; /// Varius option for TKDE can be passed in the option string as below.; /// Note that min and max will define the plotting range but will not restrict the data in the unbinned case; /// Instead when use binning, only the data in the range will be considered.; /// Note also, that when some data exists outside the range, one should not use the mirror option with unbinned.; /// Adaptive will be soon very slow especially for Nevents > 10000.; /// For this reason, by default for Nevents >=10000, the data are automatically binned in; /// nbins=Min(10000,Nevents/10); /// In case of ForceBinning option the default number of bins is 1000",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TKDE.h:416,Adapt,Adaptive,416,hist/hist/inc/TKDE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TKDE.h,1,['Adapt'],['Adaptive']
Energy Efficiency,/// Constructs an SUnit for post-regalloc scheduling to represent a; /// MachineInstr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:42,schedul,scheduling,42,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Constructs an SUnit for pre-regalloc scheduling to represent an; /// SDNode and any nodes flagged to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:41,schedul,scheduling,41,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Contains all scheduling data for a basic block.; /// It does not schedules instructions, which are not memory read/write; /// instructions and their operands are either constants, or arguments, or; /// phis, or instructions from others blocks, or their users are phis or from; /// the other blocks. The resulting vector instructions can be placed at the; /// beginning of the basic block without scheduling (if operands does not need; /// to be scheduled) or at the end of the block (if users are outside of the; /// block). It allows to save some compile time and memory used by the; /// compiler.; /// ScheduleData is assigned for each instruction in between the boundaries of; /// the tree entry, even for those, which are not part of the graph. It is; /// required to correctly follow the dependencies between the instructions and; /// their correct scheduling. The ScheduleData is not allocated for the; /// instructions, which do not require scheduling, like phis, nodes with; /// extractelements/insertelements only or nodes with instructions, with; /// uses/operands outside of the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,schedul,scheduling,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,9,"['Schedul', 'allocate', 'schedul']","['ScheduleData', 'allocated', 'scheduled', 'schedules', 'scheduling']"
Energy Efficiency,/// Contains all scheduling relevant data for an instruction.; /// A ScheduleData either represents a single instruction or a member of an; /// instruction bundle (= a group of instructions which is combined into a; /// vector instruction).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:17,schedul,scheduling,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Schedul', 'schedul']","['ScheduleData', 'scheduling']"
Energy Efficiency,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:683,schedul,schedule,683,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,7,['schedul'],"['schedule', 'scheduleMapAppendingVariable', 'scheduleMapGlobalAlias', 'scheduleMapGlobalIFunc', 'scheduleMapGlobalInitializer', 'scheduleRemapFunction']"
Energy Efficiency,"/// Control the placement of special register scavenging spill slots when; /// allocating a stack frame.; ///; /// If this returns true, the frame indexes used by the RegScavenger will be; /// allocated closest to the incoming stack pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:193,allocate,allocated,193,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Convert the given type to a string suitable for printing as part of; /// a diagnostic.; ///; /// There are four main criteria when determining whether we should have an; /// a.k.a. clause when pretty-printing a type:; ///; /// 1) Some types provide very minimal sugar that doesn't impede the; /// user's understanding --- for example, elaborated type; /// specifiers. If this is all the sugar we see, we don't want an; /// a.k.a. clause.; /// 2) Some types are technically sugared but are much more familiar; /// when seen in their sugared form --- for example, va_list,; /// vector types, and the magic Objective C types. We don't; /// want to desugar these, even if we do produce an a.k.a. clause.; /// 3) Some types may have already been desugared previously in this diagnostic.; /// if this is the case, doing another ""aka"" would just be clutter.; /// 4) Two different types within the same diagnostic have the same output; /// string. In this case, force an a.k.a with the desugared type when; /// doing so will provide additional information.; ///; /// \param Context the context in which the type was allocated; /// \param Ty the type to print; /// \param QualTypeVals pointer values to QualTypes which are used in the; /// diagnostic message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:1112,allocate,allocated,1112,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Converts a \c Matcher<InnerT> to a \c Matcher<OuterT>, where; /// \c OuterT is any type that is supported by \c Getter.; ///; /// \code Getter<OuterT>::value() \endcode returns a; /// \code InnerTBase (OuterT::*)() \endcode, which is used to adapt a \c OuterT; /// object into a \c InnerT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:246,adapt,adapt,246,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['adapt'],['adapt']
Energy Efficiency,"/// Converts a \c Matcher<T> to a matcher of desired type \c To by; /// ""adapting"" a \c To into a \c T.; ///; /// The \c ArgumentAdapterT argument specifies how the adaptation is done.; ///; /// For example:; /// \c ArgumentAdaptingMatcher<HasMatcher, T>(InnerMatcher);; /// Given that \c InnerMatcher is of type \c Matcher<T>, this returns a matcher; /// that is convertible into any matcher of type \c To by constructing; /// \c HasMatcher<To, T>(InnerMatcher).; ///; /// If a matcher does not need knowledge about the inner type, prefer to use; /// PolymorphicMatcher.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:73,adapt,adapting,73,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,2,['adapt'],"['adaptation', 'adapting']"
Energy Efficiency,"/// Converts alignment exponent (i.e. power of two (or zero)) to the; /// corresponding alignment to use. If alignment is too large, returns; /// a corresponding error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:38,power,power,38,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['power'],['power']
Energy Efficiency,"/// Copy the iterator `source` into `dest`. `dest` should contain the location of a memory arena of size; /// `fgIteratorArenaSize`.; /// If iterator-specific information is of that size or less, the iterators will be constructed in place in the given; /// locations. Otherwise, iterators will be allocated via `new` and their address returned by modifying the value; /// of `*begin_arena` and `*end_arena`. The actual address of the iterator is returned in any case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h:297,allocate,allocated,297,core/cont/inc/TVirtualCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h,1,['allocate'],['allocated']
Energy Efficiency,/// CopyAndMoveSuccessors - Clone the specified node and move its scheduled; /// successors to the newly created node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:66,schedul,scheduled,66,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['schedul'],['scheduled']
Energy Efficiency,/// Count the scheduled (issued) micro-ops that can be retired by; /// time=CurrCycle assuming the first scheduled instr is retired at time=0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:14,schedul,scheduled,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduled']
Energy Efficiency,/// Create GEP with single dynamic index. The address alignment is reduced; /// according to the element size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h:67,reduce,reduced,67,interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,1,['reduce'],['reduced']
Energy Efficiency,"/// Create a DAG scheduling mutation to pair instructions back to back; /// for instructions that benefit according to the target-specific; /// predicate functions. shouldScheduleAdjacent will be true if any of the; /// provided predicates are true.; /// If BranchOnly is true, only branch instructions with one of their; /// predecessors will be fused.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h:17,schedul,scheduling,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Create a MachineInstrBuilder for manipulating an existing instruction.; /// F must be the machine function that was used to allocate I.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:128,allocate,allocate,128,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Create a call expression.; /// \param Fn The callee expression,; /// \param Args The argument array,; /// \param Ty The type of the call expression (which is *not* the return; /// type in general),; /// \param VK The value kind of the call expression (lvalue, rvalue, ...),; /// \param RParenLoc The location of the right parenthesis in the call; /// expression.; /// \param FPFeatures Floating-point features associated with the call,; /// \param MinNumArgs Specifies the minimum number of arguments. The actual; /// number of arguments will be the greater of Args.size(); /// and MinNumArgs. This is used in a few places to allocate; /// enough storage for the default arguments.; /// \param UsesADL Specifies whether the callee was found through; /// argument-dependent lookup.; ///; /// Note that you can use CreateTemporary if you need a temporary call; /// expression on the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:630,allocate,allocate,630,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['allocate'],['allocate']
Energy Efficiency,/// Create a content block with initially mutable data of the given size.; /// Content will be allocated via the LinkGraph's allocateBuffer method.; /// By default the memory will be zero-initialized. Passing false for; /// ZeroInitialize will prevent this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:95,allocate,allocated,95,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,2,['allocate'],"['allocateBuffer', 'allocated']"
Energy Efficiency,"/// Create a defined addressable for the given content.; /// The content is assumed to be writable, and the caller is responsible; /// for ensuring that it lives for the duration of the Block's lifetime.; /// The standard way to achieve this is to allocate it on the Graph's; /// allocator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:248,allocate,allocate,248,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['allocate'],['allocate']
Energy Efficiency,/// Create a generic scheduler with no vreg liveness or DAG mutation passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:21,schedul,scheduler,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,/// Create a new AllocationOrder for VirtReg.; /// @param VirtReg Virtual register to allocate for.; /// @param VRM Virtual register map for function.; /// @param RegClassInfo Information about reserved and allocatable registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h:86,allocate,allocate,86,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Create a new ModuloSchedule.; /// \arg ScheduledInstrs The new loop instructions, in total resequenced; /// order.; /// \arg Cycle Cycle index for all instructions in ScheduledInstrs. Cycle does; /// not need to start at zero. ScheduledInstrs must be partially ordered by; /// Cycle.; /// \arg Stage Stage index for all instructions in ScheduleInstrs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:43,Schedul,ScheduledInstrs,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,4,['Schedul'],"['ScheduleInstrs', 'ScheduledInstrs']"
Energy Efficiency,/// Create a new \c SourceMgr adaptor that maps to the given source; /// manager and diagnostics engine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h:30,adapt,adaptor,30,interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceMgrAdapter.h,1,['adapt'],['adaptor']
Energy Efficiency,"/// Create a new `MSFBuilder`.; ///; /// \param BlockSize The internal block size used by the PDB file. See; /// isValidBlockSize() for a list of valid block sizes.; ///; /// \param MinBlockCount Causes the builder to reserve up front space for; /// at least `MinBlockCount` blocks. This is useful when using `MSFBuilder`; /// to read an existing MSF that you want to write back out later. The; /// original MSF file's SuperBlock contains the exact number of blocks used; /// by the file, so is a good hint as to how many blocks the new MSF file; /// will contain. Furthermore, it is actually necessary in this case. To; /// preserve stability of the file's layout, it is helpful to try to keep; /// all streams mapped to their original block numbers. To ensure that this; /// is possible, space for all blocks must be allocated beforehand so that; /// streams can be assigned to them.; ///; /// \param CanGrow If true, any operation which results in an attempt to; /// locate a free block when all available blocks have been exhausted will; /// allocate a new block, thereby growing the size of the final MSF file.; /// When false, any such attempt will result in an error. This is especially; /// useful in testing scenarios when you know your test isn't going to do; /// anything to increase the size of the file, so having an Error returned if; /// it were to happen would catch a programming error; ///; /// \returns an llvm::Error representing whether the operation succeeded or; /// failed. Currently the only way this can fail is if an invalid block size; /// is specified, or `MinBlockCount` does not leave enough room for the; /// mandatory reserved blocks required by an MSF file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h:819,allocate,allocated,819,interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,/// Create a new code-completion string that describes how to insert; /// this result into a program.; ///; /// \param S The semantic analysis that created the result.; ///; /// \param Allocator The allocator that will be used to allocate the; /// string itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:230,allocate,allocate,230,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Create a new expression graph using the reduced /p SclTy type and replace; /// the old expression graph with it. Also erase all instructions in the old; /// graph, except those that are still needed outside the graph.; ///; /// \param SclTy scalar version of new type to reduce expression graph into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:44,reduce,reduced,44,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"/// Create a new indirectbr instruction, specifying an; /// Address to jump to. The number of expected destinations can be specified; /// here to make memory allocation more efficient. This constructor also; /// autoinserts at the end of the specified BasicBlock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:174,efficient,efficient,174,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Create a new indirectbr instruction, specifying an; /// Address to jump to. The number of expected destinations can be specified; /// here to make memory allocation more efficient. This constructor can also; /// autoinsert before another instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:174,efficient,efficient,174,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Create a new switch instruction, specifying a value to switch on and a; /// default destination. The number of additional cases can be specified here; /// to make memory allocation more efficient. This constructor also; /// auto-inserts at the end of the specified BasicBlock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:190,efficient,efficient,190,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Create a new switch instruction, specifying a value to switch on and a; /// default destination. The number of additional cases can be specified here; /// to make memory allocation more efficient. This constructor can also; /// auto-insert before another instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:190,efficient,efficient,190,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Create a new switch instruction, specifying a; /// default destination. The number of additional handlers can be specified; /// here to make memory allocation more efficient.; /// This constructor also autoinserts at the end of the specified BasicBlock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:168,efficient,efficient,168,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Create a new switch instruction, specifying a; /// default destination. The number of additional handlers can be specified; /// here to make memory allocation more efficient.; /// This constructor can also autoinsert before another instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:168,efficient,efficient,168,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['efficient'],['efficient']
Energy Efficiency,/// Create a runtime call for __tgt_interop_destroy; ///; /// \param Loc The insert and source location description.; /// \param InteropVar variable to be allocated; /// \param Device devide to which offloading will occur; /// \param NumDependences number of dependence variables; /// \param DependenceAddress pointer to dependence variables; /// \param HaveNowaitClause does nowait clause exist; ///; /// \returns CallInst to the __tgt_interop_destroy call,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:155,allocate,allocated,155,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,/// Create a runtime call for __tgt_interop_init; ///; /// \param Loc The insert and source location description.; /// \param InteropVar variable to be allocated; /// \param InteropType type of interop operation; /// \param Device devide to which offloading will occur; /// \param NumDependences number of dependence variables; /// \param DependenceAddress pointer to dependence variables; /// \param HaveNowaitClause does nowait clause exist; ///; /// \returns CallInst to the __tgt_interop_init call,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:152,allocate,allocated,152,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,/// Create a runtime call for __tgt_interop_use; ///; /// \param Loc The insert and source location description.; /// \param InteropVar variable to be allocated; /// \param Device devide to which offloading will occur; /// \param NumDependences number of dependence variables; /// \param DependenceAddress pointer to dependence variables; /// \param HaveNowaitClause does nowait clause exist; ///; /// \returns CallInst to the __tgt_interop_use call,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:151,allocate,allocated,151,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,/// Create a runtime call for kmpc_Alloc; ///; /// \param Loc The insert and source location description.; /// \param Size Size of allocated memory space; /// \param Allocator Allocator information instruction; /// \param Name Name of call Instruction for OMP_alloc; ///; /// \returns CallInst to the OMP_Alloc call,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:131,allocate,allocated,131,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Create a switch instruction with the specified value, default dest,; /// and with a hint for the number of cases that will be added (for efficient; /// allocation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:141,efficient,efficient,141,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Create an OpenCL kernel for an enqueued block.; ///; /// The type of the first argument (the block literal) is the struct type; /// of the block literal instead of a pointer type. The first argument; /// (block literal) is passed directly by value to the kernel. The kernel; /// allocates the same type of struct on stack and stores the block literal; /// to it and passes its pointer to the block invoke function. The kernel; /// has ""enqueued-block"" function attribute and kernel argument metadata.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/AMDGPU.cpp:283,allocate,allocates,283,interpreter/llvm-project/clang/lib/CodeGen/Targets/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/AMDGPU.cpp,1,['allocate'],['allocates']
Energy Efficiency,/// Create an artificial edge between FirstSU and SecondSU.; /// Make data dependencies from the FirstSU also dependent on the SecondSU to; /// prevent them from being scheduled between the FirstSU and the SecondSU; /// and vice-versa.; /// Fusing more than 2 instructions is not currently supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h:168,schedul,scheduled,168,interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Create an indirect branch instruction with the specified address; /// operand, with an optional hint for the number of destinations that will be; /// added (for efficient allocation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:165,efficient,efficient,165,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Create an instance of ScheduleDAGInstrs to be run within the standard; /// MachineScheduler pass for this function and target at the current; /// optimization level.; ///; /// This can also be used to plug a new MachineSchedStrategy into an instance; /// of the standard ScheduleDAGMI:; /// return new ScheduleDAGMI(C, std::make_unique<MyStrategy>(C), /*RemoveKillFlags=*/false); ///; /// Return NULL to select the default (generic) machine scheduler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:26,Schedul,ScheduleDAGInstrs,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,4,"['Schedul', 'schedul']","['ScheduleDAGInstrs', 'ScheduleDAGMI', 'scheduler']"
Energy Efficiency,"/// Create debugging information entry for an array.; /// \param Size Array size.; /// \param AlignInBits Alignment.; /// \param Ty Element type.; /// \param Subscripts Subscripts.; /// \param DataLocation The location of the raw data of a descriptor-based; /// Fortran array, either a DIExpression* or; /// a DIVariable*.; /// \param Associated The associated attribute of a descriptor-based; /// Fortran array, either a DIExpression* or; /// a DIVariable*.; /// \param Allocated The allocated attribute of a descriptor-based; /// Fortran array, either a DIExpression* or; /// a DIVariable*.; /// \param Rank The rank attribute of a descriptor-based; /// Fortran array, either a DIExpression* or; /// a DIVariable*.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h:471,Allocate,Allocated,471,interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,2,"['Allocate', 'allocate']","['Allocated', 'allocated']"
Energy Efficiency,/// Create machine specific model for scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:38,schedul,scheduling,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['schedul'],['scheduling']
Energy Efficiency,/// Create the initialization entity for an object allocated via new.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:51,allocate,allocated,51,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Create the scheduler. If a specific scheduler was specified; /// via the SchedulerRegistry, use it, otherwise select the; /// one preferred by the target.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:15,schedul,scheduler,15,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,3,"['Schedul', 'schedul']","['SchedulerRegistry', 'scheduler']"
Energy Efficiency,/// Create the standard converging machine scheduler. This will be used as the; /// default scheduler if the target does not set a default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:43,schedul,scheduler,43,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduler']
Energy Efficiency,/// Create the standard converging machine scheduler. This will be used as the; /// default scheduler if the target does not set a default.; /// Adds default DAG mutations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:43,schedul,scheduler,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduler']
Energy Efficiency,/// CreateLLVMCodeGen - Create a CodeGenerator instance.; /// It is the responsibility of the caller to call delete on; /// the allocated CodeGenerator instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ModuleBuilder.h:128,allocate,allocated,128,interpreter/llvm-project/clang/include/clang/CodeGen/ModuleBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ModuleBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,/// CreateMachineBasicBlock - Allocate a new MachineBasicBlock. Use this; /// instead of `new MachineBasicBlock'. Sets `MachineBasicBlock::BBID` if; /// basic-block-sections is enabled for the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:30,Allocate,Allocate,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// CreateMachineInstr - Allocate a new MachineInstr. Use this instead; /// of `new MachineInstr'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:25,Allocate,Allocate,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// CreateReg - Allocate a single virtual register for the given type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp:16,Allocate,Allocate,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"/// CreateRegs - Allocate the appropriate number of virtual registers of; /// the correctly promoted or expanded types. Assign these registers; /// consecutive vreg numbers and return the first assigned number.; ///; /// In the case that the given value has struct or array type, this function; /// will assign registers for each member or element.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp:17,Allocate,Allocate,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,/// CreateTargetHazardRecognizer - Return the hazard recognizer to use for; /// this target when scheduling the DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:97,schedul,scheduling,97,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// CreateTargetPostRAHazardRecognizer - Return the postRA hazard recognizer; /// to use for this target when scheduling the DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:110,schedul,scheduling,110,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// CreateTempAlloca - This creates an alloca and inserts it into the entry; /// block if \p ArraySize is nullptr, otherwise inserts it at the current; /// insertion point of the builder. The caller is responsible for setting an; /// appropriate alignment on; /// the alloca.; ///; /// \p ArraySize is the number of array elements to be allocated if it; /// is not nullptr.; ///; /// LangAS::Default is the address space of pointers to local variables and; /// temporaries, as exposed in the source language. In certain; /// configurations, this is not the same as the alloca address space, and a; /// cast is needed to lift the pointer from the alloca AS into; /// LangAS::Default. This can happen when the target uses a restricted; /// address space for the stack but the source language requires; /// LangAS::Default to be a generic address space. The latter condition is; /// common for most programming languages; OpenCL is an exception in that; /// LangAS::Default is the private address space, which naturally maps; /// to the stack.; ///; /// Because the address of a temporary is often exposed to the program in; /// various ways, this function will perform the cast. The original alloca; /// instruction is returned through \p Alloca if it is not nullptr.; ///; /// The cast is not performaed in CreateTempAllocaWithoutCast. This is; /// more efficient if the caller knows that the address will not be exposed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:337,allocate,allocated,337,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,2,"['allocate', 'efficient']","['allocated', 'efficient']"
Energy Efficiency,"/// Creates (allocates on the heap), an exception (OurException instance),; /// of the supplied type info type.; /// @param type type info type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:13,allocate,allocates,13,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['allocate'],['allocates']
Energy Efficiency,"/// Creates PowerPC subtarget-specific name corresponding to the specified; /// generic MASSV function, and the PowerPC subtarget.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:12,Power,PowerPC,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,2,['Power'],['PowerPC']
Energy Efficiency,"/// Creates a LocalTrampolinePool with the given RunCallback function.; /// Returns an error if this function is unable to correctly allocate, write; /// and protect the resolver code block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h:133,allocate,allocate,133,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/IndirectionUtils.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Creates an SUnit for each real instruction, numbered in top-down; /// topological order. The instruction order A < B, implies that no edge exists; /// from B to A.; ///; /// Map each real instruction to its SUnit.; ///; /// After initSUnits, the SUnits vector cannot be resized and the scheduler may; /// hang onto SUnit pointers. We may relax this in the future by using SUnit IDs; /// instead of pointers.; ///; /// MachineScheduler relies on initSUnits numbering the nodes by their order in; /// the original instruction list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:290,schedul,scheduler,290,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduler']
Energy Efficiency,/// Creates the initial topological ordering from the DAG to be scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:64,schedul,scheduled,64,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// CurArraySize - The allocated size of CurArray, always a power of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:23,allocate,allocated,23,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,2,"['allocate', 'power']","['allocated', 'power']"
Energy Efficiency,/// CurCycle - The current scheduler state corresponds to this cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:27,schedul,scheduler,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],['scheduler']
Energy Efficiency,"/// Current heap allocations, along with the location where each was; /// allocated. We use std::map here because we need stable addresses; /// for the stored APValues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:74,allocate,allocated,74,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Current high-level properties of the IR of the function (e.g. is in SSA; /// form or whether registers have been allocated),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:117,allocate,allocated,117,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Currently only scheduling top-down, so this method is empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:19,schedul,scheduling,19,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Custom-sized slabs allocated for too-large allocation requests.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:23,allocate,allocated,23,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['allocate'],['allocated']
Energy Efficiency,"/// DWARF expression.; ///; /// This is (almost) a DWARF expression that modifies the location of a; /// variable, or the location of a single piece of a variable, or (when using; /// DW_OP_stack_value) is the constant variable value.; ///; /// TODO: Co-allocate the expression elements.; /// TODO: Separate from MDNode, or otherwise drop Distinct and Temporary; /// storage types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:254,allocate,allocate,254,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,1,['allocate'],['allocate']
Energy Efficiency,"/// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned; /// to a specified boundary. This node always has two return values: a new; /// stack pointer value and a chain. The first operand is the token chain,; /// the second is the number of bytes to allocate, and the third is the; /// alignment boundary. The size is guaranteed to be a multiple of the; /// stack alignment, and the alignment is guaranteed to be bigger than the; /// stack alignment (if required) or 0 to get standard stack alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:25,Allocate,Allocate,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,"['Allocate', 'allocate']","['Allocate', 'allocate']"
Energy Efficiency,/// Deallocate \a Ptr to \a Size bytes of memory allocated by this; /// allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h:49,allocate,allocated,49,interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,2,['allocate'],['allocated']
Energy Efficiency,"/// Deallocate a buffer of memory with the given size and alignment.; ///; /// If supported, this will used the sized delete operator. Also if supported,; /// this will pass the alignment to the delete operator.; ///; /// The pointer must have been allocated with the corresponding new operator,; /// most likely using the above helper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemAlloc.h:249,allocate,allocated,249,interpreter/llvm-project/llvm/include/llvm/Support/MemAlloc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemAlloc.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Deallocate all but the current slab and reset the current pointer; /// to the beginning of it, freeing all memory allocated so far.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:118,allocate,allocated,118,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['allocate'],['allocated']
Energy Efficiency,/// Deallocate an array with the specified Capacity.; ///; /// Cap must be the same capacity that was given to allocate().; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h:111,allocate,allocate,111,interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,1,['allocate'],['allocate']
Energy Efficiency,"/// DebugACrash - Given a predicate that determines whether a component crashes; /// on a program, try to destructively reduce the program while still keeping; /// the predicate true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:120,reduce,reduce,120,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// DeclStmt - Adaptor class for mixing declarations with statements and; /// expressions. For example, CompoundStmt mixes statements, expressions; /// and declarations (variables, types). Another example is ForStmt, where; /// the first statement can be an expression or a declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h:15,Adapt,Adaptor,15,interpreter/llvm-project/clang/include/clang/AST/Stmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h,1,['Adapt'],['Adaptor']
Energy Efficiency,/// Default instruction selection strategy used by class Scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:57,Schedul,Scheduler,57,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['Schedul'],['Scheduler']
Energy Efficiency,/// Default register class filter function for register allocation. All virtual; /// registers should be allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocCommon.h:105,allocate,allocated,105,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocCommon.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocCommon.h,1,['allocate'],['allocated']
Energy Efficiency,/// Define a generic scheduling policy for targets that don't provide their own; /// MachineSchedStrategy. This can be overriden for each scheduling region; /// before building the DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:21,schedul,scheduling,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduling']
Energy Efficiency,/// Define a kind of processor resource that will be modeled by the scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:68,schedul,scheduler,68,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['schedul'],['scheduler']
Energy Efficiency,"/// DelayForLiveRegsBottomUp - Returns true if it is necessary to delay; /// scheduling of the given node to satisfy live physical register dependencies.; /// If the specific node is the last one that's available to schedule, do; /// whatever is necessary (i.e. backtracking or cloning) to make it possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:77,schedul,scheduling,77,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,4,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"/// Deletes the true previously allocated exception whose address; /// is calculated from the supplied OurBaseException_t::unwindException; /// member address. Handles (ignores), NULL pointers.; /// @param expToDelete exception to delete",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:32,allocate,allocated,32,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Dellocate an array of MachineOperands and recycle the memory. This is; /// only intended for use by internal MachineInstr functions.; /// Cap must be the same capacity that was used to allocate the array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:189,allocate,allocate,189,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['allocate'],['allocate']
Energy Efficiency,"/// DeltaTree - a multiway search tree (BTree) structure with some fancy; /// features. B-Trees are generally more memory and cache efficient than; /// binary trees, because they store multiple keys/values in each node. This; /// implements a key/value mapping from index to delta, and allows fast lookup; /// on index. However, an added (important) bonus is that it can also; /// efficiently tell us the full accumulated delta for a specific file offset; /// as well, without traversing the whole tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Core/DeltaTree.h:132,efficient,efficient,132,interpreter/llvm-project/clang/include/clang/Rewrite/Core/DeltaTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Core/DeltaTree.h,2,['efficient'],"['efficient', 'efficiently']"
Energy Efficiency,/// DemotePHIToStack - This function takes a virtual register computed by a PHI; /// node and replaces it with a slot in the stack frame allocated via alloca.; /// The PHI node is deleted. It returns the pointer to the alloca inserted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:137,allocate,allocated,137,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// DemoteRegToStack - This function takes a virtual register computed by an; /// Instruction and replaces it with a slot in the stack frame, allocated via; /// alloca. This allows the CFG to be changed around without fear of; /// invalidating the SSA information for the value. It returns the pointer to; /// the alloca inserted to create a stack slot for I.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:142,allocate,allocated,142,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// DemoteRegister - if CanLowerReturn is false, DemoteRegister is a vreg; /// allocated to hold a pointer to the hidden sret parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:79,allocate,allocated,79,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Describes a memory lifetime policy for memory to be allocated by a; /// JITLinkMemoryManager.; ///; /// All memory allocated by a call to JITLinkMemoryManager::allocate should be; /// deallocated if a call is made to; /// JITLinkMemoryManager::InFlightAllocation::abandon. The policies below apply; /// to finalized allocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h:56,allocate,allocated,56,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,/// Describes a segment to be allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h:30,allocate,allocated,30,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,1,['allocate'],['allocated']
Energy Efficiency,/// Describes the kind of result that can be tail-allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:50,allocate,allocated,50,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['allocate'],['allocated']
Energy Efficiency,/// Determine an efficient buffer size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:17,efficient,efficient,17,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['efficient'],['efficient']
Energy Efficiency,/// Determine the schedule type using schedule and ordering clause arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:18,schedul,schedule,18,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,2,['schedul'],['schedule']
Energy Efficiency,"/// Determine whether instruction 'To' is reachable from 'From', without passing; /// through any blocks in ExclusionSet, returning true if uncertain.; ///; /// Determine whether there is a path from From to To within a single function.; /// Returns false only if we can prove that once 'From' has been executed then; /// 'To' can not be executed. Conservatively returns true.; ///; /// This function is linear with respect to the number of blocks in the CFG,; /// walking down successors from From to reach To, with a fixed threshold.; /// Using DT or LI allows us to answer more quickly. LI reduces the cost of; /// an entire loop of any number of blocks to be the same as the cost of a; /// single block. DT reduces the cost by allowing the search to terminate when; /// we find a block that dominates the block containing 'To'. DT is most useful; /// on branchy code but not loops, and LI is most useful on code with loops but; /// does not help on branchy code outside loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:593,reduce,reduces,593,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,2,['reduce'],['reduces']
Energy Efficiency,"/// Determine whether this local variable can be used with the named; /// return value optimization (NRVO).; ///; /// The named return value optimization (NRVO) works by marking certain; /// non-volatile local variables of class type as NRVO objects. These; /// locals can be allocated within the return slot of their containing; /// function, in which case there is no need to copy the object to the; /// return slot when returning from the function. Within the function body,; /// each return that returns the NRVO object will have this variable as its; /// NRVO candidate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:276,allocate,allocated,276,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Determine which scheduling algorithm to use, determined from schedule clause; /// arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:20,schedul,scheduling,20,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"/// Determines the preferred type of the current function argument, by; /// examining the signatures of all possible overloads.; /// Returns null if unknown or ambiguous, or if code completion is off.; ///; /// If the code completion point has been reached, also reports the function; /// signatures that were considered.; ///; /// FIXME: rename to GuessCallArgumentType to reduce confusion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:374,reduce,reduce,374,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['reduce'],['reduce']
Energy Efficiency,/// Did not track -> allocated. Other state (released) -> allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:21,allocate,allocated,21,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,2,['allocate'],['allocated']
Energy Efficiency,/// Did not track -> released. Other state (allocated) -> released.; /// The statement associated with the release might be missing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:44,allocate,allocated,44,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Did not track -> relinquished. Other state (allocated) -> relinquished.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:48,allocate,allocated,48,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Direct loop termination test which is more efficient than; /// comparison with \c end().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:47,efficient,efficient,47,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Disable sized deallocation for MemoryBufferMMapFile, because it has; /// tail-allocated data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp:82,allocate,allocated,82,interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Disable sized deallocation for MemoryBufferMem, because it has; /// tail-allocated data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp:77,allocate,allocated,77,interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// DisableGVCompilation - If called, the JIT will abort if it's asked to; /// allocate space and populate a GlobalVariable that is not internal to; /// the module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:79,allocate,allocate,79,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['allocate'],['allocate']
Energy Efficiency,/// DisassemblerTables - Encapsulates all the decode tables being generated by; /// the table emitter. Contains functions to populate the tables as well as; /// to emit them as hierarchical C structures suitable for consumption by the; /// runtime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h:216,consumption,consumption,216,interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.h,1,['consumption'],['consumption']
Energy Efficiency,"/// Disconnect an edge from the given node.; ///; /// Removes the given edge from the adjacency list of the given node.; /// This operation leaves the edge in an 'asymmetric' state: It will no; /// longer appear in an iteration over the given node's (NId's) edges, but; /// will appear in an iteration over the 'other', unnamed node's edges.; ///; /// This does not correspond to any normal graph operation, but exists to; /// support efficient PBQP graph-reduction based solvers. It is used to; /// 'effectively' remove the unnamed node from the graph while the solver; /// is performing the reduction. The solver will later call reconnectNode; /// to restore the edge in the named node's adjacency list.; ///; /// Since the degree of a node is the number of connected edges,; /// disconnecting an edge from a node 'u' will cause the degree of 'u' to; /// drop by 1.; ///; /// A disconnected edge WILL still appear in an iteration over the graph; /// edges.; ///; /// A disconnected edge should not be removed from the graph, it should be; /// reconnected first.; ///; /// A disconnected edge can be reconnected by calling the reconnectEdge; /// method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h:435,efficient,efficient,435,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:133,efficient,efficient,133,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['efficient'],['efficient']
Energy Efficiency,/// Distribute Loop condition used when composing 'omp distribute'; /// with 'omp for' in a same construct when schedule is chunked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:112,schedul,schedule,112,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Do initial placement of the jump tables. Because Thumb2's TBB and TBH; /// instructions can be made more efficient if the jump table immediately; /// follows the instruction, it's best to place them immediately next to their; /// jumps to begin with. In almost all cases they'll never be moved from that; /// position.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:109,efficient,efficient,109,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['efficient'],['efficient']
Energy Efficiency,/// Do not inline functions which allocate this many bytes on the stack; /// when the caller is recursive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:34,allocate,allocate,34,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Do we allocate an array? If so, the first trailing ""Stmt *"" is the; /// size expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h:10,allocate,allocate,10,interpreter/llvm-project/clang/include/clang/AST/Stmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Do we have an efficient pattern in a .td file for this node?; ///; /// \param V - pointer to the BuildVectorSDNode being matched; /// \param HasDirectMove - does this subtarget have VSR <-> GPR direct moves?; ///; /// There are some patterns where it is beneficial to keep a BUILD_VECTOR; /// node as a BUILD_VECTOR node rather than expanding it. The patterns where; /// the opposite is true (expansion is beneficial) are:; /// - The node builds a vector out of integers that are not 32 or 64-bits; /// - The node builds a vector out of constants; /// - The node is a ""load-and-splat""; /// In all other cases, we will choose to keep the BUILD_VECTOR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:18,efficient,efficient,18,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// Does an efficient ""scan"" of the sources to detect the presence of; /// preprocessor (or module import) directives and collects the raw lexed tokens; /// for those directives so that the \p Lexer can ""replay"" them when the file is; /// included.; ///; /// Note that the behavior of the raw lexer is affected by the language mode,; /// while at this point we want to do a scan and collect tokens once,; /// irrespective of the language mode that the file will get included in. To; /// compensate for that the \p Lexer, while ""replaying"", will adjust a token; /// where appropriate, when it could affect the preprocessor's state.; /// For example in a directive like; ///; /// \code; /// #if __has_cpp_attribute(clang::fallthrough); /// \endcode; ///; /// The preprocessor needs to see '::' as 'tok::coloncolon' instead of 2; /// 'tok::colon'. The \p Lexer will adjust if it sees consecutive 'tok::colon'; /// while in C++ mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:12,efficient,efficient,12,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:83,schedul,scheduler,83,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,6,"['Schedul', 'schedul']","['ScheduleHazardRecognizer', 'scheduler']"
Energy Efficiency,/// Does this machine model include instruction-level scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:54,schedul,scheduling,54,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Don't change without adapting ReadAt()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx:25,adapt,adapting,25,io/io/inc/ROOT/RRawFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx,1,['adapt'],['adapting']
Energy Efficiency,"/// Double the size of the allocated memory, guaranteeing space for at; /// least one more element or MinSize if specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:27,allocate,allocated,27,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Double the size of the allocated memory, guaranteeing space for at; /// least one more element or MinSize if specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:27,allocate,allocated,27,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['allocate'],['allocated']
Energy Efficiency,"/// Drop all references to operands.; ///; /// This function is in charge of ""letting go"" of all objects that this User; /// refers to. This allows one to 'delete' a whole class at a time, even; /// though there may be circular references... First all references are; /// dropped, and all use counts go to zero. Then everything is deleted for; /// real. Note that no operations are valid on an object that has ""dropped; /// all references"", except operator delete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h:67,charge,charge,67,interpreter/llvm-project/llvm/include/llvm/IR/User.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h,1,['charge'],['charge']
Energy Efficiency,"/// Dual division/remainder interface.; ///; /// Sometimes it is convenient to divide two APInt values and obtain both the; /// quotient and remainder. This function does both operations in the same; /// computation making it a little more efficient. The pair of input arguments; /// may overlap with the pair of output arguments. It is safe to call; /// udivrem(X, Y, X, Y), for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:240,efficient,efficient,240,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in the direction of movement, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:9,Schedul,Scheduling,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['Schedul'],['Scheduling']
Energy Efficiency,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in whichever direction at has moved, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:9,Schedul,Scheduling,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,1,['Schedul'],['Scheduling']
Energy Efficiency,/// Each processor resource is associated with a so-called processor resource; /// mask. This vector allows to correlate processor resource IDs with; /// processor resource masks. There is exactly one element per each processor; /// resource declared by the scheduling model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:258,schedul,scheduling,258,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Efficiently reads \p Size bytes from \p Ref, and writes it to this stream.; /// This operation will not invoke any copies of the source data, regardless; /// of the source stream's implementation.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:4,Efficient,Efficiently,4,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,1,['Efficient'],['Efficiently']
Energy Efficiency,"/// Efficiently reads all data from \p Ref, and writes it to this stream.; /// This operation will not invoke any copies of the source data, regardless; /// of the source stream's implementation.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:4,Efficient,Efficiently,4,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,1,['Efficient'],['Efficiently']
Energy Efficiency,"/// Efficiently reset a range of bits in [I, E)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:4,Efficient,Efficiently,4,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,1,['Efficient'],['Efficiently']
Energy Efficiency,/// Efficiently return the length of this identifier info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:4,Efficient,Efficiently,4,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['Efficient'],['Efficiently']
Energy Efficiency,"/// Efficiently set a range of bits in [I, E)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:4,Efficient,Efficiently,4,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,1,['Efficient'],['Efficiently']
Energy Efficiency,"/// Efficiently stores a list of ExplodedNodes, or an optional flag.; ///; /// NodeGroup provides opaque storage for a list of ExplodedNodes, optimizing; /// for the case when there is only one node in the group. This is a fairly; /// common case in an ExplodedGraph, where most nodes have only one; /// predecessor and many have only one successor. It can also be used to; /// store a flag rather than a node list, which ExplodedNode uses to mark; /// whether a node is a sink. If the flag is set, the group is implicitly; /// empty and no nodes may be added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h:4,Efficient,Efficiently,4,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,1,['Efficient'],['Efficiently']
Energy Efficiency,/// Emit a code for the allocate directive.; /// \param D The allocate declaration,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:24,allocate,allocate,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,2,['allocate'],['allocate']
Energy Efficiency,/// Emit a diagnostic via the adapted diagnostic client.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:30,adapt,adapted,30,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,2,['adapt'],['adapted']
Energy Efficiency,"/// Emit a helper that reduces data across two OpenMP threads (lanes); /// in the same warp. It uses shuffle instructions to copy over data from; /// a remote lane's stack. The reduction algorithm performed is specified; /// by the fourth parameter.; ///; /// Algorithm Versions.; /// Full Warp Reduce (argument value 0):; /// This algorithm assumes that all 32 lanes are active and gathers; /// data from these 32 lanes, producing a single resultant value.; /// Contiguous Partial Warp Reduce (argument value 1):; /// This algorithm assumes that only a *contiguous* subset of lanes; /// are active. This happens for the last warp in a parallel region; /// when the user specified num_threads is not an integer multiple of; /// 32. This contiguous subset always starts with the zeroth lane.; /// Partial Warp Reduce (argument value 2):; /// This algorithm gathers data from any number of lanes at any position.; /// All reduced values are stored in the lowest possible lane. The set; /// of problems every algorithm addresses is a super set of those; /// addressable by algorithms with a lower version number. Overhead; /// increases as algorithm version increases.; ///; /// Terminology; /// Reduce element:; /// Reduce element refers to the individual data field with primitive; /// data types to be combined and reduced across threads.; /// Reduce list:; /// Reduce list refers to a collection of local, thread-private; /// reduce elements.; /// Remote Reduce list:; /// Remote Reduce list refers to a collection of remote (relative to; /// the current thread) reduce elements.; ///; /// We distinguish between three states of threads that are important to; /// the implementation of this function.; /// Alive threads:; /// Threads in a warp executing the SIMT instruction, as distinguished from; /// threads that are inactive due to divergent control flow.; /// Active threads:; /// The minimal set of threads that has to be alive upon entry to this; /// function. The computation is correct iff a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:23,reduce,reduces,23,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,5,"['Reduce', 'reduce']","['Reduce', 'reduced', 'reduces']"
Energy Efficiency,"/// Emit a machine register location. As an optimization this may also consume; /// the prefix of a DwarfExpression if a more efficient representation for; /// combining the register location and the first operation exists.; ///; /// \param FragmentOffsetInBits If this is one fragment out of a; /// fragmented; /// location, this is the offset of the; /// fragment inside the entire variable.; /// \return false if no DWARF register exists; /// for MachineReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:126,efficient,efficient,126,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Emit an alignment directive to the specified power of two boundary. If a; /// global value is specified, and if that global has an explicit alignment; /// requested, it will override the alignment request if required for; /// correctness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:49,power,power,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,1,['power'],['power']
Energy Efficiency,"/// Emit instructions to copy a Reduce list, which contains partially; /// aggregated values, in the specified direction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:32,Reduce,Reduce,32,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"/// Emit target-specific code that performs a memcpy.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.; ///; /// If AlwaysInline is true, the size is constant and the target should not; /// emit any calls and is strongly encouraged to attempt to emit inline code; /// even if it is beyond the usual threshold because this intrinsic is being; /// expanded in a place where calls are not feasible (e.g. within the prologue; /// for another call). If the target chooses to decline an AlwaysInline; /// request here, legalize will resort to using simple loads and stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:212,efficient,efficient,212,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,1,['efficient'],['efficient']
Energy Efficiency,/// Emit target-specific code that performs a memmove.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:213,efficient,efficient,213,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,1,['efficient'],['efficient']
Energy Efficiency,/// Emit target-specific code that performs a memset.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple stores and can be more; /// efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used. Note that if AlwaysInline is true the; /// function has to return a valid SDValue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:206,efficient,efficient,206,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Emit the table to Out, which must not be at offset 0.; ///; /// Uses the provided Info instead of a stack allocated one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:110,allocate,allocated,110,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Emit the user-defined mapper function. The code generation follows the; /// pattern in the example below.; /// \code; /// void .omp_mapper.<type_name>.<mapper_id>.(void *rt_mapper_handle,; /// void *base, void *begin,; /// int64_t size, int64_t type,; /// void *name = nullptr) {; /// // Allocate space for an array section first or add a base/begin for; /// // pointer dereference.; /// if ((size > 1 || (base != begin && maptype.IsPtrAndObj)) &&; /// !maptype.IsDelete); /// __tgt_push_mapper_component(rt_mapper_handle, base, begin,; /// size*sizeof(Ty), clearToFromMember(type));; /// // Map members.; /// for (unsigned i = 0; i < size; i++) {; /// // For each component specified by this mapper:; /// for (auto c : begin[i]->all_components) {; /// if (c.hasMapper()); /// (*c.Mapper())(rt_mapper_handle, c.arg_base, c.arg_begin, c.arg_size,; /// c.arg_type, c.arg_name);; /// else; /// __tgt_push_mapper_component(rt_mapper_handle, c.arg_base,; /// c.arg_begin, c.arg_size, c.arg_type,; /// c.arg_name);; /// }; /// }; /// // Delete the array section.; /// if (size > 1 && maptype.IsDelete); /// __tgt_push_mapper_component(rt_mapper_handle, base, begin,; /// size*sizeof(Ty), clearToFromMember(type));; /// }; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:292,Allocate,Allocate,292,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Emit va_arg for a platform using the common void* representation,; /// where arguments are simply emitted in an array of slots on the stack.; ///; /// This version implements the core direct-value passing rules.; ///; /// \param SlotSize - The size and alignment of a stack slot.; /// Each argument will be allocated to a multiple of this number of; /// slots, and all the slots will be aligned to this value.; /// \param AllowHigherAlign - The slot alignment is not a cap;; /// an argument type with an alignment greater than the slot size; /// will be emitted on a higher-alignment address, potentially; /// leaving one or more empty slots behind as padding. If this; /// is false, the returned address might be less-aligned than; /// DirectAlign.; /// \param ForceRightAdjust - Default is false. On big-endian platform and; /// if the argument is smaller than a slot, set this flag will force; /// right-adjust the argument in its slot irrespective of the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h:311,allocate,allocated,311,interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Emit va_arg for a platform using the common void* representation,; /// where arguments are simply emitted in an array of slots on the stack.; ///; /// \param IsIndirect - Values of this type are passed indirectly.; /// \param ValueInfo - The size and alignment of this type, generally; /// computed with getContext().getTypeInfoInChars(ValueTy).; /// \param SlotSizeAndAlign - The size and alignment of a stack slot.; /// Each argument will be allocated to a multiple of this number of; /// slots, and all the slots will be aligned to this value.; /// \param AllowHigherAlign - The slot alignment is not a cap;; /// an argument type with an alignment greater than the slot size; /// will be emitted on a higher-alignment address, potentially; /// leaving one or more empty slots behind as padding.; /// \param ForceRightAdjust - Default is false. On big-endian platform and; /// if the argument is smaller than a slot, set this flag will force; /// right-adjust the argument in its slot irrespective of the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h:448,allocate,allocated,448,interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,1,['allocate'],['allocated']
Energy Efficiency,/// EmitAggregateCopy - Emit an aggregate copy.; ///; /// \param isVolatile \c true iff either the source or the destination is; /// volatile.; /// \param MayOverlap Whether the tail padding of the destination might be; /// occupied by some other object. More efficient code can often be; /// generated if not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:260,efficient,efficient,260,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['efficient'],['efficient']
Energy Efficiency,/// EmitInstruction -- Print out a single PowerPC MI in Darwin syntax to; /// the current output stream.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:42,Power,PowerPC,42,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"/// EmitSchedule - Emit the machine code in scheduled order. Return the new; /// InsertPos and MachineBasicBlock that contains this insertion; /// point. ScheduleDAGSDNodes holds a BB pointer for convenience, but this does; /// not necessarily refer to returned BB. The emitter may split blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:44,schedul,scheduled,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,2,"['Schedul', 'schedul']","['ScheduleDAGSDNodes', 'scheduled']"
Energy Efficiency,"/// Emits list of dependecies based on the provided data (array of; /// dependence/expression pairs) for depobj construct. In this case, the; /// variable is allocated in dynamically. \returns Pointer to the first; /// element of the array casted to VoidPtr type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:158,allocate,allocated,158,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Emits reduction function.; /// \param ReducerName Name of the function calling the reduction.; /// \param ArgsElemType Array type containing pointers to reduction variables.; /// \param Privates List of private copies for original reduction arguments.; /// \param LHSExprs List of LHS in \a ReductionOps reduction operations.; /// \param RHSExprs List of RHS in \a ReductionOps reduction operations.; /// \param ReductionOps List of reduction operations in form 'LHS binop RHS'; /// or 'operator binop(LHS, RHS)'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:42,Reduce,ReducerName,42,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['Reduce'],['ReducerName']
Energy Efficiency,"/// Emits section data from the object file to the MemoryManager.; /// \param IsCode if it's true then allocateCodeSection() will be; /// used for emits, else allocateDataSection() will be used.; /// \return SectionID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:103,allocate,allocateCodeSection,103,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,2,['allocate'],"['allocateCodeSection', 'allocateDataSection']"
Energy Efficiency,/// Enable tracking of recently allocated nodes for potential reclamation; /// when calling reclaimRecentlyAllocatedNodes().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h:32,allocate,allocated,32,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Enable use of alias analysis during code generation (during MI; /// scheduling, DAGCombine, etc.).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:72,schedul,scheduling,72,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,5,['schedul'],['scheduling']
Energy Efficiency,"/// Encapsulates the layout of an assembly file at a particular point in time.; ///; /// Assembly may require computing multiple layouts for a particular assembly; /// file as part of the relaxation process. This class encapsulates the layout; /// at a single point in time in such a way that it is always possible to; /// efficiently compute the exact address of any symbol in the assembly file,; /// even during the relaxation process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmLayout.h:323,efficient,efficiently,323,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmLayout.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// Enforce C++2a [expr.const]/4.17, which disallows new-expressions unless; /// ""the allocated storage is deallocated within the evaluation"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:86,allocate,allocated,86,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Engages in a tight little dance with the lexer to efficiently; /// preprocess tokens.; ///; /// Lexers know only about tokens within a single source file, and don't; /// know anything about preprocessor-level issues like the \#include stack,; /// token expansion, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:54,efficient,efficiently,54,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// EnterTokenStream - Add a ""macro"" context to the top of the include stack,; /// which will cause the lexer to start returning the specified tokens.; ///; /// If DisableMacroExpansion is true, tokens lexed from the token stream will; /// not be subject to further macro expansion. Otherwise, these tokens will; /// be re-macro-expanded when/if expansion is enabled.; ///; /// If OwnsTokens is false, this method assumes that the specified stream of; /// tokens has a permanent owner somewhere, so they do not need to be copied.; /// If it is true, it assumes the array of tokens is allocated with new[] and; /// must be freed.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:584,allocate,allocated,584,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// EquivalenceClasses - This represents a collection of equivalence classes and; /// supports three efficient operations: insert an element into a class of its; /// own, union two classes, and find the class for a given element. In; /// addition to these modification methods, it is possible to iterate over all; /// of the equivalence classes and all of the elements in a class.; ///; /// This implementation is an efficient implementation that only stores one copy; /// of the element being indexed per entry in the set, and allows any arbitrary; /// type to be indexed (as long as it can be ordered with operator< or a; /// comparator is provided).; ///; /// Here is a simple example using integers:; ///; /// \code; /// EquivalenceClasses<int> EC;; /// EC.unionSets(1, 2); // insert 1, 2 into the same set; /// EC.insert(4); EC.insert(5); // insert 4, 5 into own sets; /// EC.unionSets(5, 1); // merge the set for 1 with 5's set.; ///; /// for (EquivalenceClasses<int>::iterator I = EC.begin(), E = EC.end();; /// I != E; ++I) { // Iterate over all of the equivalence sets.; /// if (!I->isLeader()) continue; // Ignore non-leader sets.; /// for (EquivalenceClasses<int>::member_iterator MI = EC.member_begin(I);; /// MI != EC.member_end(); ++MI) // Loop over members in this set.; /// cerr << *MI << "" ""; // Print member.; /// cerr << ""\n""; // Finish set.; /// }; /// \endcode; ///; /// This example prints:; /// 4; /// 5 1 2; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h:101,efficient,efficient,101,interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/EquivalenceClasses.h,2,['efficient'],['efficient']
Energy Efficiency,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:52,monitor,monitored,52,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,8,"['MONITOR', 'monitor']","['MONITOR', 'monitor', 'monitored', 'monitoring']"
Energy Efficiency,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:52,monitor,monitored,52,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,7,"['MONITOR', 'monitor']","['MONITORX', 'monitor', 'monitored', 'monitoring']"
Energy Efficiency,"/// Evaluate all the vector of function derivatives (gradient) at a point x.; /// Derived classes must re-implement it if more efficient than evaluating one at a time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:127,efficient,efficient,127,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,1,['efficient'],['efficient']
Energy Efficiency,/// Evaluates the buffer size that needs to be allocated.; ///; /// \param [in] Blocks The amount of blocks that needs to be allocated.; /// \param [in] BlockBytes The size of a block.; /// \returns The symbolic value of \p Blocks * \p BlockBytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:47,allocate,allocated,47,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,2,['allocate'],['allocated']
Energy Efficiency,/// ExactFilter - The occasional extended opcode (such as VMCALL or MONITOR); /// requires the ModR/M byte to have a specific value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86ModRMFilters.h:68,MONITOR,MONITOR,68,interpreter/llvm-project/llvm/utils/TableGen/X86ModRMFilters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86ModRMFilters.h,1,['MONITOR'],['MONITOR']
Energy Efficiency,"/// Execute all of the passes scheduled for execution by invoking; /// runOnFunction method. Keep track of whether any of the passes modifies; /// the function, and if so, return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:30,schedul,scheduled,30,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"/// Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:30,schedul,scheduled,30,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,2,['schedul'],['scheduled']
Energy Efficiency,/// Execute all of the passes scheduled for execution.; ///; /// @return True if any of the passes modifies the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:30,schedul,scheduled,30,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Expander that simply annotates each scheduled instruction with a post-instr; /// symbol that can be consumed by the ModuloScheduleTest pass.; ///; /// The post-instr symbol is a way of annotating an instruction that can be; /// roundtripped in MIR. The syntax is:; /// MYINST %0, post-instr-symbol <mcsymbol Stage-1_Cycle-5>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:40,schedul,scheduled,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Expected number of uses for reduction operations/reduced values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:53,reduce,reduced,53,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,/// Expressions to check later. We defer checking these to reduce; /// stack usage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:59,reduce,reduce,59,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// Extend the standard ScheduleDAGMILive to provide more context and override; /// the top-level schedule() driver.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:24,Schedul,ScheduleDAGMILive,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,2,"['Schedul', 'schedul']","['ScheduleDAGMILive', 'schedule']"
Energy Efficiency,/// Extends the scheduling region so that V is inside the region.; /// \returns true if the region size is within the limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:16,schedul,scheduling,16,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// Extra information required for cleanups that have resolved; /// branches through them. This has to be allocated on the side; /// because everything on the cleanup stack has be trivially; /// movable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:106,allocate,allocated,106,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,1,['allocate'],['allocated']
Energy Efficiency,"/// FIXME: The following static functions are SizeChangeStrategy functions; /// that are meant to temporarily mimic the behaviour of the old legalization; /// based on doubling/halving non-legal types as closely as possible. This is; /// not entirly possible as only legalizing the types that are exactly a power; /// of 2 times the size of the legal types would require specifying all those; /// sizes explicitly.; /// In practice, not specifying those isn't a problem, and the below functions; /// should disappear quickly as we add support for legalizing non-power-of-2; /// sized types further.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp:307,power,power,307,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLegalizerInfo.cpp,2,['power'],"['power', 'power-of-']"
Energy Efficiency,/// FPR - The set of FP registers that should be allocated for arguments; /// on Darwin and AIX.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:49,allocate,allocated,49,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Fast multiset implementation for objects that can be identified by small; /// unsigned keys.; ///; /// SparseMultiSet allocates memory proportional to the size of the key; /// universe, so it is not recommended for building composite data structures.; /// It is useful for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time; /// fast clear() as fast as a vector. The find(), insert(), and erase(); /// operations are all constant time, and typically faster than a hash table.; /// The iteration order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:122,allocate,allocates,122,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,1,['allocate'],['allocates']
Energy Efficiency,/// FastRegisterAllocation Pass - This pass register allocates as fast as; /// possible. It is best suited for debug code where live ranges are short.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:53,allocate,allocates,53,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['allocate'],['allocates']
Energy Efficiency,"/// FileRemover - This class is a simple object meant to be stack allocated.; /// If an exception is thrown from a region, the object removes the filename; /// specified (if deleteIt is true).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileUtilities.h:66,allocate,allocated,66,interpreter/llvm-project/llvm/include/llvm/Support/FileUtilities.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileUtilities.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Finalize memory should be allocated by the allocator, and then be; /// overwritten and deallocated after all finalization functions have been; /// run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h:30,allocate,allocated,30,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h,1,['allocate'],['allocated']
Energy Efficiency,"/// FinalizeMachineBundles - This pass finalize machine instruction; /// bundles (created earlier, e.g. during pre-RA scheduling).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:118,schedul,scheduling,118,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Find Section in LocalSections. If the secton is not found - emit; /// it and store in LocalSections.; /// \param IsCode if it's true then allocateCodeSection() will be; /// used for emmits, else allocateDataSection() will be used.; /// \return SectionID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:142,allocate,allocateCodeSection,142,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,2,['allocate'],"['allocateCodeSection', 'allocateDataSection']"
Energy Efficiency,"/// Find a DeclRefExpr in the given expression.; ///; /// In its most basic form (ShouldRetrieveFromComparisons == false),; /// this function can be simply reduced to the following question:; ///; /// - If expression E is used as a function argument, could we say; /// that DeclRefExpr nested in E is used as an argument?; ///; /// According to this rule, we can say that parens, casts and dereferencing; /// (dereferencing only applied to function pointers, but this is our case); /// can be skipped.; ///; /// When we should look into comparisons the question changes to:; ///; /// - If expression E is used as a condition, could we say that; /// DeclRefExpr is being checked?; ///; /// And even though, these are two different questions, they have quite a lot; /// in common. Actually, we can say that whatever expression answers; /// positively the first question also fits the second question as well.; ///; /// In addition, we skip binary operators == and !=, and unary opeartor !.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:156,reduce,reduced,156,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['reduce'],['reduced']
Energy Efficiency,"/// Find the shortest repeating sequence of values in the build vector.; ///; /// e.g. { u, X, u, X, u, u, X, u } -> { X }; /// { X, Y, u, Y, u, u, X, u } -> { X, Y }; ///; /// Currently this must be a power-of-2 build vector.; /// If passed a non-null UndefElements bitvector, it will resize it to match; /// the original vector width and set the bits where elements are undef.; /// If result is false, Sequence will be empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:202,power,power-of-,202,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['power'],['power-of-']
Energy Efficiency,"/// Find the shortest repeating sequence of values in the build vector.; ///; /// e.g. { u, X, u, X, u, u, X, u } -> { X }; /// { X, Y, u, Y, u, u, X, u } -> { X, Y }; ///; /// Currently this must be a power-of-2 build vector.; /// The DemandedElts mask indicates the elements that must be present,; /// undemanded elements in Sequence may be null (SDValue()). If passed a; /// non-null UndefElements bitvector, it will resize it to match the original; /// vector width and set the bits where elements are undef. If result is; /// false, Sequence will be empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:202,power,power-of-,202,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['power'],['power-of-']
Energy Efficiency,"/// FindPredecessorBlocks - Put the predecessors of Info->BB into the Preds; /// vector, set Info->NumPreds, and allocate space in Info->Preds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:113,allocate,allocate,113,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,1,['allocate'],['allocate']
Energy Efficiency,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:53,allocate,allocated,53,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,6,"['allocate', 'schedul']","['allocated', 'scheduling']"
Energy Efficiency,/// Finds the initial set of vreg intervals to allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:47,allocate,allocate,47,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['allocate'],['allocate']
Energy Efficiency,/// Fixes register kill flags that scheduling has made invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:35,schedul,scheduling,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Flush column data, preparing for CommitCluster or to reduce memory usage. This will trigger compression of pages,; /// but not actually write to storage (unless buffered writing is turned off).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:57,reduce,reduce,57,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,1,['reduce'],['reduce']
Energy Efficiency,"/// Flush column data, preparing for CommitCluster or to reduce memory usage. This will trigger compression of pages,; /// but not actually write to storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:57,reduce,reduce,57,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,1,['reduce'],['reduce']
Energy Efficiency,"/// Flush columns in order of allocated write page size until the sum of all write page allocations; /// leaves space for at least targetAvailableSize bytes. Only use columns with a write page size larger; /// than pageSizeLimit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:30,allocate,allocated,30,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['allocate'],['allocated']
Energy Efficiency,/// Fold a floating-point divide by power of two into fixed-point to; /// floating-point conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:36,power,power,36,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,/// Fold a floating-point multiply by power of two into floating-point to; /// fixed-point conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:38,power,power,38,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['power'],['power']
Energy Efficiency,/// For available scheduling models FDIV + two independent FMULs are much; /// faster than two FDIVs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:18,schedul,scheduling,18,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// For consumptions, just emit the subexpression and perform the; /// consumption like normal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:8,consumption,consumptions,8,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,2,['consumption'],"['consumption', 'consumptions']"
Energy Efficiency,"/// For consumptions, just emit the subexpression and thus elide; /// the retain/release pair.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:8,consumption,consumptions,8,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['consumption'],['consumptions']
Energy Efficiency,"/// For each coordinate in `xN`, add `weightN[i]` to the bin at coordinate; /// `xN[i]`. The sizes of `xN` and `weightN` must be the same. This is more; /// efficient than many separate calls to `Fill()`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:157,efficient,efficient,157,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['efficient'],['efficient']
Energy Efficiency,"/// For each coordinate in `xN`, add `weightN[i]` to the bin at coordinate; /// `xN[i]`. The sizes of `xN` and `weightN` must be the same. This is more; /// efficient than many separate calls to `Fill()`.; /// Overload for passing initializer lists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:157,efficient,efficient,157,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['efficient'],['efficient']
Energy Efficiency,"/// For pattern like:; ///; /// DomCond = icmp sgt/slt CmpOp0, CmpOp1 (might not be in DomBB); /// ...; /// DomBB:; /// ...; /// br DomCond, TrueBB, CmpBB; /// CmpBB: (with DomBB being the single predecessor); /// ...; /// Cmp = icmp eq CmpOp0, CmpOp1; /// ...; ///; /// It would use two comparison on targets that lowering of icmp sgt/slt is; /// different from lowering of icmp eq (PowerPC). This function try to convert; /// 'Cmp = icmp eq CmpOp0, CmpOp1' to ' Cmp = icmp slt/sgt CmpOp0, CmpOp1'.; /// After that, DomCond and Cmp can use the same comparison so reduce one; /// comparison.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:384,Power,PowerPC,384,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,"['Power', 'reduce']","['PowerPC', 'reduce']"
Energy Efficiency,/// For power-of-2 C:; /// ((X s>> ShiftC) ^ X) u< C --> (X + C) u< (C << 1); /// ((X s>> ShiftC) ^ X) u> (C - 1) --> (X + C) u> ((C << 1) - 1),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:8,power,power-of-,8,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power-of-']
Energy Efficiency,"/// For reclaims, emit the subexpression as a retained call and; /// skip the consumption.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:78,consumption,consumption,78,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['consumption'],['consumption']
Energy Efficiency,"/// For the instruction sequence of store below, F and I values; /// are bundled together as an i64 value before being stored into memory.; /// Sometimes it is more efficient to generate separate stores for F and I,; /// which can remove the bitwise instructions or sink them to colder places.; ///; /// (store (or (zext (bitcast F to i32) to i64),; /// (shl (zext I to i64), 32)), addr) -->; /// (store F, addr) and (store I, addr+4); ///; /// Similarly, splitting for other merged store can also be beneficial, like:; /// For pair of {i32, i32}, i64 store --> two i32 stores.; /// For pair of {i32, i16}, i64 store --> two i32 stores.; /// For pair of {i16, i16}, i32 store --> two i16 stores.; /// For pair of {i16, i8}, i32 store --> two i16 stores.; /// For pair of {i8, i8}, i16 store --> two i8 stores.; ///; /// We allow each target to determine specifically which kind of splitting is; /// supported.; ///; /// The store patterns are commonly seen from the simple code snippet below; /// if only std::make_pair(...) is sroa transformed before inlined into hoo.; /// void goo(const std::pair<int, float> &);; /// hoo() {; /// ...; /// goo(std::make_pair(tmp, ftmp));; /// ...; /// }; ///; /// Although we already have similar splitting in DAG Combine, we duplicate; /// it in CodeGenPrepare to catch the case in which pattern is across; /// multiple BBs. The logic in DAG Combine is kept to catch case generated; /// during code expansion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:165,efficient,efficient,165,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['efficient'],['efficient']
Energy Efficiency,/// ForceUnitLatencies - Return true if all scheduling edges should be given; /// a latency value of one. The default is to return false; schedulers may; /// override this as needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h:44,schedul,scheduling,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,2,['schedul'],"['schedulers', 'scheduling']"
Energy Efficiency,/// Free memory allocated for User and Use objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h:16,allocate,allocated,16,interpreter/llvm-project/llvm/include/llvm/IR/User.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h,1,['allocate'],['allocated']
Energy Efficiency,/// Freely adapt every user of V as-if V was changed to !V.; /// WARNING: only if canFreelyInvertAllUsersOf() said this can be done.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:11,adapt,adapt,11,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['adapt'],['adapt']
Energy Efficiency,/// Frees memory allocated in a Clang preprocessing record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:17,allocate,allocated,17,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Function called from send and receive template functions in debug builds; /// used to monitor the messages that are going to be sent or are received.; /// By defining this in the implementation file, compilation is a lot faster; /// during debugging of Messenger or communication protocols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx:90,monitor,monitor,90,roofit/multiprocess/src/Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx,1,['monitor'],['monitor']
Energy Efficiency,"/// Function wide BasicBlock to BlockChain mapping.; ///; /// This mapping allows efficiently moving from any given basic block to the; /// BlockChain it participates in, if any. We use it to, among other things,; /// allow implicitly defining edges between chains as the existing edges; /// between basic blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:82,efficient,efficiently,82,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['efficient'],['efficiently']
Energy Efficiency,"/// Functions used to generate atomic reductions. Such functions take two; /// Values representing pointers to LHS and RHS of the reduction, as well as; /// the element type of these pointers. They are expected to atomically; /// update the LHS to the reduced value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:252,reduce,reduced,252,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['reduce'],['reduced']
Energy Efficiency,"/// GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of; /// the most recent dynamic alloca. For most targets that would be 0, but; /// for some others (e.g. PowerPC, PowerPC64) that would be compile-time; /// known nonzero constant. The only operand here is the chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:176,Power,PowerPC,176,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Power'],['PowerPC']
Energy Efficiency,/// Generate Phis for the specified block in the generated pipelined code.; /// These are new Phis needed because the definition is scheduled after the; /// use in the pipelined sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:132,schedul,scheduled,132,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"/// Generate cc1-compatible command line arguments from this instance,; /// wrapping the result as a std::vector<std::string>.; ///; /// This is a (less-efficient) wrapper over generateCC1CommandLine().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h:153,efficient,efficient,153,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Generate cc1-compatible command line arguments from this instance.; ///; /// \param [out] Args - The generated arguments. Note that the caller is; /// responsible for inserting the path to the clang executable and ""-cc1"" if; /// desired.; /// \param SA - A function that given a Twine can allocate storage for a given; /// command line argument and return a pointer to the newly allocated string.; /// The returned pointer is what gets appended to Args.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h:293,allocate,allocate,293,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,/// Generate code to reduce the loop iteration by one and check if the loop; /// is finished. Return the value/register of the new loop count. We need; /// this function when peeling off one or more iterations of a loop. This; /// function assumes the nth iteration is peeled first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:21,reduce,reduce,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['reduce'],['reduce']
Energy Efficiency,/// Generate the checks and store it. This also performs the grouping; /// of pointers to reduce the number of memchecks necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:90,reduce,reduce,90,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['reduce'],['reduce']
Energy Efficiency,"/// Generate the destroy-helper function for a block closure object:; /// static void block_destroy_helper(block_t *theBlock);; ///; /// Note that this destroys a heap-allocated block closure object;; /// it should not be confused with a 'byref destroy helper', which; /// destroys the heap-allocated contents of an individual __block; /// variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:168,allocate,allocated,168,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,2,['allocate'],['allocated']
Energy Efficiency,/// Generates a vector reduction using shufflevectors to reduce the value.; /// Fast-math-flags are propagated using the IRBuilder's setting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:57,reduce,reduce,57,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,1,['reduce'],['reduce']
Energy Efficiency,"/// Generates an object of the field type and allocates new initialized memory according to the type.; /// Implemented at the end of this header because the implementation is using RField<T>::TypeName(); /// The returned object can be released with `delete`, i.e. it is valid to call; /// auto ptr = field->CreateObject();; /// delete ptr.release();; ///; /// Note that CreateObject<void> is supported. The returned unique_ptr has a custom deleter that reports an error; /// if it is called. The intended use of the returned unique_ptr<void> is to call `release()`. In this way, the; /// transfer of pointer ownership is explicit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:46,allocate,allocates,46,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['allocate'],['allocates']
Energy Efficiency,/// Generates an ordered vector reduction using extracts to reduce the value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:60,reduce,reduce,60,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,1,['reduce'],['reduce']
Energy Efficiency,"/// Generic reduction nodes. These nodes represent horizontal vector; /// reduction operations, producing a scalar result.; /// The SEQ variants perform reductions in sequential order. The first; /// operand is an initial scalar accumulator value, and the second operand; /// is the vector to reduce.; /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC; /// ... is equivalent to; /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:293,reduce,reduce,293,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['reduce'],['reduce']
Energy Efficiency,/// GenericScheduler shrinks the unscheduled zone using heuristics to balance; /// the schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:87,schedul,schedule,87,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['schedule']
Energy Efficiency,/// Get a scaled count for the minimum execution time of the scheduled; /// micro-ops that are ready to execute by getExecutedCount. Notice the; /// feedback loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:61,schedul,scheduled,61,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Get an allocated IRInstructionData struct using the InstDataAllocator.; ///; /// \param I - The Instruction to wrap with IRInstructionData.; /// \param Legality - A boolean value that is true if the instruction is to; /// be considered for similarity, and false if not.; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:11,allocate,allocated,11,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,2,['allocate'],['allocated']
Energy Efficiency,/// Get an allocated IRInstructionDataList object using the IDLAllocator.; ///; /// \returns An allocated IRInstructionDataList object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:11,allocate,allocated,11,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,2,['allocate'],['allocated']
Energy Efficiency,/// Get an empty allocated IRInstructionData struct using the; /// InstDataAllocator.; ///; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:17,allocate,allocated,17,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,2,['allocate'],['allocated']
Energy Efficiency,/// Get an instruction mapping where all the operands map to; /// the same register bank and have similar size.; ///; /// \pre MI.getNumOperands() <= 3; ///; /// \return An InstructionMappings with a statically allocated; /// OperandsMapping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.h:211,allocate,allocated,211,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Get an instruction mapping.; /// \return An InstructionMappings with a statically allocated; /// OperandsMapping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86RegisterBankInfo.h:86,allocate,allocated,86,interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86RegisterBankInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Get current register pressure for the bottom scheduled instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:49,schedul,scheduled,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Get current register pressure for the top scheduled instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:46,schedul,scheduled,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Get disk space usage information.; ///; /// Note: Users must be careful about ""Time Of Check, Time Of Use"" kind of bug.; /// Note: Windows reports results according to the quota allocated to the user.; ///; /// @param Path Input path.; /// @returns a space_info structure filled with the capacity, free, and; /// available space on the device \a Path is on. A platform specific error_code; /// is returned on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:182,allocate,allocated,182,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Get mutable content for this block.; ///; /// If this Block's content is not already mutable this will trigger a copy; /// of the existing immutable content to a new, mutable buffer allocated using; /// LinkGraph::allocateContent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:186,allocate,allocated,186,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,2,['allocate'],"['allocateContent', 'allocated']"
Energy Efficiency,/// Get register pressure for the entire scheduling region before scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:41,schedul,scheduling,41,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduling']
Energy Efficiency,/// Get scheduling itinerary of a CPU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:8,schedul,scheduling,8,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Get the (LLVM) name of the PowerPC cpu we are targeting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp:31,Power,PowerPC,31,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp,1,['Power'],['PowerPC']
Energy Efficiency,/// Get the (LLVM) name of the PowerPC cpu we are tuning for.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp:31,Power,PowerPC,31,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/PPC.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"/// Get the JumpTableInfo for this function.; /// If it does not already exist, allocate one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:80,allocate,allocate,80,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['allocate'],['allocate']
Energy Efficiency,/// Get the allocated storage for the given parameter of the given call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:12,allocate,allocated,12,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Get the column limit for this line. This is the style's column; /// limit, potentially reduced for preprocessor definitions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:91,reduce,reduced,91,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,1,['reduce'],['reduced']
Energy Efficiency,"/// Get the id of the current lane in the Warp.; /// We assume that the warp size is 32, which is always the case; /// on the NVPTX device, to generate more efficient code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:157,efficient,efficient,157,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// Get the instruction mapping for G_FPEXT.; ///; /// \pre (DstSize, SrcSize) pair is one of the following:; /// (32, 16), (64, 16), (64, 32), (128, 64); ///; /// \return An InstructionMapping with statically allocated OperandsMapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.h:210,allocate,allocated,210,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Get the list of blocks allocated to a particular stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h:27,allocate,allocated,27,interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Get the location on which the report should be uniqued. Two warnings are; /// considered to be equivalent whenever they have the same bug types,; /// descriptions, and uniqueing locations. Out of a class of equivalent; /// warnings only one gets displayed to the user. For most warnings the; /// uniqueing location coincides with their location, but sometimes; /// it makes sense to use different locations. For example, a leak; /// checker can place the warning at the location where the last reference; /// to the leaking resource is dropped but at the same time unique the warning; /// by where that resource is acquired (allocated).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:629,allocate,allocated,629,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Get the number of elements allocated. For a simple allocation of a single; /// element, this will return a constant 1 value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:31,allocate,allocated,31,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Get the number of latency cycles ""covered"" by the scheduled; /// instructions. This is the larger of the critical path within the zone; /// and the number of cycles required to issue the instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:54,schedul,scheduled,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Get the padding size that must be inserted before this fragment.; /// Used for bundling. By default, no padding is inserted.; /// Note that padding size is restricted to 8 bits. This is an optimization; /// to reduce the amount of space used for each fragment. In practice, larger; /// padding should never be required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h:214,reduce,reduce,214,interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h,1,['reduce'],['reduce']
Energy Efficiency,"/// Get the process's estimated page size.; /// This function always succeeds, but if the underlying syscall to determine; /// the page size fails then this will silently return an estimated page size.; /// The estimated page size is guaranteed to be a power of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:253,power,power,253,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,1,['power'],['power']
Energy Efficiency,"/// Get the scaled count of scheduled micro-ops and resources, including; /// executed resources.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:28,schedul,scheduled,28,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Get the spelling of a token into a preallocated buffer, instead; /// of as an std::string.; ///; /// The caller is required to allocate enough space for the token, which is; /// guaranteed to be at least Tok.getLength() bytes long. The length of the; /// actual result is returned.; ///; /// Note that this method may do two possible things: it may either fill in; /// the buffer specified with characters, or it may *change the input pointer*; /// to point to a constant buffer with the data already in it (avoiding a; /// copy). The caller is not allowed to modify the returned buffer pointer; /// if an internal buffer is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:131,allocate,allocate,131,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['allocate'],['allocate']
Energy Efficiency,/// Get the total number of blocks that exist in the MSF file but are not; /// allocated to any valid data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h:79,allocate,allocated,79,interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,/// Get the total number of blocks that will be allocated to actual data in; /// this MSF file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h:48,allocate,allocated,48,interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,/// Get whether the local allocation blob should be allocated together or; /// let PEI allocate the locals in it directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:52,allocate,allocated,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/// GetBestDestForBranchOnUndef - If we determine that the specified block ends; /// in an undefined jump, decide which block is best to revector to.; ///; /// Since we can pick an arbitrary destination, we pick the successor with the; /// fewest predecessors. This should reduce the in-degree of the others.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:273,reduce,reduce,273,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// GetInstrType - Classify the specified powerpc opcode according to its; /// pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:42,power,powerpc,42,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,1,['power'],['powerpc']
Energy Efficiency,"/// Gets all the parameters of the RooAbsReal. This is in principle not; /// necessary, because we can always ask the RooAbsReal itself, but the; /// Evaluator has the cached information to get the answer quicker.; /// Therefore, this is not meant to be used in general, just where it matters.; /// \warning If we find another solution to get the parameters efficiently,; /// this function might be removed without notice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx:358,efficient,efficiently,358,roofit/roofitcore/src/RooFit/Evaluator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx,1,['efficient'],['efficiently']
Energy Efficiency,"/// Gets called after scheduling, manifests attributes to the LLVM IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:22,schedul,scheduling,22,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Gets latency information for \p Inst from the itinerary; /// scheduling model, based on \p DC information.; /// \return The maximum expected latency over all the operands or -1; /// if no information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:65,schedul,scheduling,65,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Gets the list of initial values for linear variables.; ///; /// There are NumVars expressions with initial values allocated after the; /// varlist, they are followed by NumVars update expressions (used to update; /// the linear variable's value on current iteration) and they are followed by; /// NumVars final expressions (used to calculate the linear variable's; /// value after the loop body). After these lists, there are 2 helper; /// expressions - linear step and a helper to calculate it before the; /// loop body (used when the linear step is not constant):; ///; /// { Vars[] /* in OMPVarListClause */; Privates[]; Inits[]; Updates[];; /// Finals[]; Step; CalcStep; }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:118,allocate,allocated,118,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['allocate'],['allocated']
Energy Efficiency,/// Gets the machine model for instruction scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:43,schedul,scheduling,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Given a Count of resource usage and a Latency value, return true if a; /// SchedBoundary becomes resource limited.; /// If we are checking after scheduling a node, we should return true when; /// we just reach the resource limit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:149,schedul,scheduling,149,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// Given a \p V value and a \p SclTy scalar type return the generated reduced; /// value of \p V based on the type \p SclTy.; ///; /// \param V value to be reduced.; /// \param SclTy scalar version of new type to reduce to.; /// \return the new reduced value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:71,reduce,reduced,71,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,4,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"/// Given a list of possible callee implementation for a call site, select one; /// that fits the \p Threshold. If none are found, the Reason will give the last; /// reason for the failure (last, in the order of CalleeSummaryList entries).; ///; /// FIXME: select ""best"" instead of first that fits. But what is ""best""?; /// - The smallest: more likely to be inlined.; /// - The one with the least outgoing edges (already well optimized).; /// - One from a module already being imported from in order to reduce the; /// number of source modules parsed/linked.; /// - One that has PGO data attached.; /// - [insert you fancy metric here]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:503,reduce,reduce,503,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Given a power-of-two unit size, return the offset of the aligned unit; /// of that size which contains the given offset.; ///; /// In other words, round down to the nearest multiple of the unit size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:12,power,power-of-two,12,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['power'],['power-of-two']
Energy Efficiency,"/// Given a reduced list of functions that still expose the bug, extract as many; /// basic blocks from the region as possible without obscuring the bug.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:12,reduce,reduced,12,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['reduce'],['reduced']
Energy Efficiency,"/// Given a reduced list of functions that still exposed the bug, check to see; /// if we can extract the loops in the region without obscuring the bug. If so,; /// it reduces the amount of code identified.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:12,reduce,reduced,12,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,2,['reduce'],"['reduced', 'reduces']"
Energy Efficiency,"/// Given a reduced scalar type \p Ty and a \p V value, return a reduced type; /// for \p V, according to its type, if it vector type, return the vector; /// version of \p Ty, otherwise return \p Ty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:12,reduce,reduced,12,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,2,['reduce'],['reduced']
Energy Efficiency,"/// Given an G_SDIV \p MI expressing a signed divide by constant, return an; /// expression that implements it by multiplying by a magic number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:182,Power,PowerPC,182,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['Power'],['PowerPC']
Energy Efficiency,"/// Given an G_UDIV \p MI expressing a divide by constant, return an; /// expression that implements it by multiplying by a magic number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:175,Power,PowerPC,175,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['Power'],['PowerPC']
Energy Efficiency,"/// Given an ISD::SDIV node expressing a divide by constant power of 2, return a; /// DAG expression that will generate the same value by right shifting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,power,power,60,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,"/// Given an ISD::SDIV node expressing a divide by constant, return; /// a DAG expression to select that will generate the same value by multiplying; /// by a magic number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:210,Power,PowerPC,210,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"/// Given an ISD::SDIV node expressing a divide by constant,; /// return a DAG expression to select that will generate the same value by; /// multiplying by a magic number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:210,Power,PowerPC,210,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"/// Given an ISD::SREM node expressing a remainder by constant power of 2,; /// return a DAG expression that will generate the same value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,power,power,63,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['power'],['power']
Energy Efficiency,"/// Given an ISD::UDIV node expressing a divide by constant, return a DAG; /// expression that will generate the same value by multiplying by a magic; /// number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:200,Power,PowerPC,200,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"/// Given an ISD::UDIV node expressing a divide by constant,; /// return a DAG expression to select that will generate the same value by; /// multiplying by a magic number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:210,Power,PowerPC,210,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Power'],['PowerPC']
Energy Efficiency,"/// Given an MCInst and a vector of Instrument, a target can; /// return a SchedClassID. This can be used by a subtarget to return a; /// PseudoInstruction SchedClassID instead of the one that belongs to the; /// BaseInstruction This can be useful when a BaseInstruction does not convey; /// the correct scheduling information without additional data. By default,; /// it returns the SchedClassID that belongs to MCI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h:304,schedul,scheduling,304,interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:359,schedul,scheduling,359,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Given i1 V, can every user of V be freely adapted if V is changed to !V ?; /// InstCombine's freelyInvertAllUsersOf() must be kept in sync with this fn.; /// NOTE: for Instructions only!; ///; /// See also: isFreeToInvert()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:46,adapt,adapted,46,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['adapt'],['adapted']
Energy Efficiency,/// Grow - Allocate a larger backing store for the buckets and move it over.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:11,Allocate,Allocate,11,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,1,['Allocate'],['Allocate']
Energy Efficiency,/// Grow - Allocate a larger backing store for the buckets and move it over.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp:11,Allocate,Allocate,11,interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,1,['Allocate'],['Allocate']
Energy Efficiency,"/// Grow the allocated memory (without initializing new elements), doubling; /// the size of the allocated memory. Guarantees space for at least one more; /// element, or MinSize more elements if specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:13,allocate,allocated,13,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,2,['allocate'],['allocated']
Energy Efficiency,"/// Grow the allocated memory (without initializing new elements), doubling; /// the size of the allocated memory. Guarantees space for at least one more; /// element, or MinSize more elements if specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:13,allocate,allocated,13,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,2,['allocate'],['allocated']
Energy Efficiency,"/// GrowBucketCount - resize the hash table and rehash everything.; /// NewBucketCount must be a power of two, and must be greater than the old; /// bucket count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:97,power,power,97,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['power'],['power']
Energy Efficiency,"/// Handle __builtin_alloca_with_align. This is declared; /// as (size_t, size_t) where the second size_t must be a power of 2 greater; /// than 8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:116,power,power,116,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['power'],['power']
Energy Efficiency,"/// Handle the cases when we prefer one instruction over another. Case 1 - we; /// prefer not to generate multiple loads in the packet to avoid a potential; /// bank conflict. Case 2 - if a packet contains a dot cur instruction, then we; /// prefer the instruction that can use the dot cur result. However, if the use; /// is not scheduled in the same packet, then prefer other instructions in the; /// subsequent packet. Case 3 - we prefer a vector store that can be converted; /// to a .new store. The packetizer will not generate the .new store if the; /// store doesn't have resources to fit in the packet (but the .new store may; /// have resources). We attempt to schedule the store as soon as possible to; /// help packetize the two instructions together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:330,schedul,scheduled,330,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,2,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,"/// HandleByVal - Every parameter *after* a byval parameter is passed; /// on the stack. Remember the next parameter register to allocate,; /// and then confiscate the rest of the parameter registers to insure; /// this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:129,allocate,allocate,129,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['allocate'],['allocate']
Energy Efficiency,/// Helper class used to collect all the possible overloads of an; /// argument adaptative matcher function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:80,adapt,adaptative,80,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,1,['adapt'],['adaptative']
Energy Efficiency,"/// Helper function of findBestLoopTop. Find the best loop top block; /// from predecessors of old top.; ///; /// Look for a block which is strictly better than the old top for laying; /// out before the old top of the loop. This looks for only two patterns:; ///; /// 1. a block has only one successor, the old loop top; ///; /// Because such a block will always result in an unconditional jump,; /// rotating it in front of the old top is always profitable.; ///; /// 2. a block has two successors, one is old top, another is exit; /// and it has more than one predecessors; ///; /// If it is below one of its predecessors P, only P can fall through to; /// it, all other predecessors need a jump to it, and another conditional; /// jump to loop header. If it is moved before loop header, all its; /// predecessors jump to it, then fall through to loop header. So all its; /// predecessors except P can reduce one taken branch.; /// At the same time, move it before old top increases the taken branch; /// to loop exit block, so the reduced taken branch will be compared with; /// the increased taken branch to the loop exit block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:905,reduce,reduce,905,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,/// Helper function to calculate whether the given Load/Store can have its; /// width reduced to ExtVT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:86,reduce,reduced,86,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['reduce'],['reduced']
Energy Efficiency,/// Helper to get the stage of an instruction in the schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:53,schedul,schedule,53,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Helper to tail-allocate \p Key. It'd be nice to generalize this so it; /// could be reused elsewhere, maybe even taking an llvm::function_ref to; /// type-erase the allocator and put it in a source file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h:19,allocate,allocate,19,interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMapEntry.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Helpers for generating columns. We use the fact that most fields have the same C++/memory types; /// for all their column representations.; /// Where possible, we call the helpers not from the header to reduce compilation time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:207,reduce,reduce,207,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['reduce'],['reduce']
Energy Efficiency,"/// Holds functions indicating the possible targets of call sites. This set; /// is empty for lattice values in the undefined, overdefined, and untracked; /// states. The maximum size of the set is controlled by; /// MaxFunctionsPerValue. Since most LLVM values are expected to be in; /// uninteresting states (i.e., overdefined), CVPLatticeVal objects should be; /// small and efficiently copyable.; // FIXME: This could be a TinyPtrVector and/or merge with LatticeState.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:378,efficient,efficiently,378,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,1,['efficient'],['efficiently']
Energy Efficiency,/// How many bytes we've allocated.; ///; /// Used so that we can compute how much space was wasted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:25,allocate,allocated,25,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['allocate'],['allocated']
Energy Efficiency,/// ID for the next output instruction allocated with allocateOutputInsnID(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:39,allocate,allocated,39,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,2,['allocate'],"['allocateOutputInsnID', 'allocated']"
Energy Efficiency,/// ID for the next temporary register ID allocated with allocateTempRegID(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:42,allocate,allocated,42,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,2,['allocate'],"['allocateTempRegID', 'allocated']"
Energy Efficiency,/// IdentifierResolver - Keeps track of shadowed decls on enclosing; /// scopes. It manages the shadowing chains of declaration names and; /// implements efficient decl lookup based on a declaration name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/IdentifierResolver.h:154,efficient,efficient,154,interpreter/llvm-project/clang/include/clang/Sema/IdentifierResolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/IdentifierResolver.h,1,['efficient'],['efficient']
Energy Efficiency,/// Identifies basic blocks that are part of loops and should to be; /// visited twice and returns efficient traversal order for all the blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:99,efficient,efficient,99,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,1,['efficient'],['efficient']
Energy Efficiency,/// Identifiy anti-dependencies along the critical path; /// of the ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:68,Schedul,ScheduleDAG,68,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,2,['Schedul'],['ScheduleDAG']
Energy Efficiency,/// Identify DAG roots and setup scheduler queues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:33,schedul,scheduler,33,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,/// Identify one of the processor resource kinds consumed by a; /// particular scheduling class for the specified number of cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:79,schedul,scheduling,79,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Idiomatically, nodes are allocated on an Arena and never moved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:29,allocate,allocated,29,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,1,['allocate'],['allocated']
Energy Efficiency,"/// If C is a scalar/fixed width vector of known powers of 2, then this; /// function returns a new scalar/fixed width vector obtained from logBase2; /// of C. Undef vector elements are set to zero.; /// Return a null pointer otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:49,power,powers,49,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,1,['power'],['powers']
Energy Efficiency,"/// If ReorderWhileClustering is set to true, no attempt will be made to; /// reduce reordering due to store clustering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:78,reduce,reduce,78,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['reduce'],['reduce']
Energy Efficiency,"/// If \p Pass is a loop-nest pass, \p Pass will first be wrapped into a; /// \c LoopPassManager and the returned adaptor will be in loop-nest mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:114,adapt,adaptor,114,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,1,['adapt'],['adaptor']
Energy Efficiency,"/// If \p Pass is an instance of \c LoopPassManager, the returned adaptor will; /// be in loop-nest mode if the pass manager contains only loop-nest passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:66,adapt,adaptor,66,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,1,['adapt'],['adaptor']
Energy Efficiency,"/// If any user of a VPWidenIntOrFpInductionRecipe needs scalar values,; /// provide them by building scalar steps off of the canonical scalar IV and; /// update the original IV's users. This is an optional optimization to reduce; /// the needs of vector extracts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:223,reduce,reduce,223,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['reduce'],['reduce']
Energy Efficiency,"/// If complete unrolling will reduce the cost of the loop, we will boost; /// the Threshold by a certain percent to allow more aggressive complete; /// unrolling. This value provides the maximum boost percentage that we; /// can apply to Threshold (The value should be no less than 100).; /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,; /// MaxPercentThresholdBoost / 100); /// E.g. if complete unrolling reduces the loop execution time by 50%; /// then we boost the threshold by the factor of 2x. If unrolling is not; /// expected to reduce the running time, then we do not increase the; /// threshold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:31,reduce,reduce,31,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,3,['reduce'],"['reduce', 'reduces']"
Energy Efficiency,"/// If in \p S \p Sym is used, check whether \p Sym was allocated as a zero; /// sized memory region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:56,allocate,allocated,56,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// If maxDynamicGroupSize is not enabled then must be 0, and any amount of; /// dynamic group segment can be allocated for a dispatch, otherwise the value; /// specifies the maximum number of bytes of dynamic group segment that can be; /// allocated for a dispatch. If the kernel being finalized has any; /// maxdynamicsize control directives, then the values must be the same, and; /// must be the same as this argument if it is enabled. This value can be used; /// by the finalizer to determine the maximum number of bytes of group memory; /// used by each work-group by adding this value to the group memory required; /// for all group segment variables used by the kernel and all functions it; /// calls, and group memory used to implement other HSAIL features such as; /// fbarriers and the detect exception operations. This can allow the finalizer; /// to determine the expected number of work-groups that can be executed by a; /// compute unit and allow more resources to be allocated to the work-items if; /// it is known that fewer work-groups can be executed due to group memory; /// limitations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:110,allocate,allocated,110,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,3,['allocate'],['allocated']
Energy Efficiency,"/// If one operand of an icmp is effectively a bool (value range of {0,1}),; /// then try to reduce patterns based on that limit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:93,reduce,reduce,93,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// If possible, create a new code completion string for the given; /// result.; ///; /// \returns Either a new, heap-allocated code completion string describing; /// how to use this result, or NULL to indicate that the string or name of the; /// result is all that is needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:118,allocate,allocated,118,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// If requestedWorkgroupsPerCu is not enabled then must be 0, and the; /// finalizer is free to generate ISA that may result in any number of; /// work-groups executing on a single compute unit. Otherwise, the finalizer; /// should attempt to generate ISA that will allow the specified number of; /// work-groups to execute on a single compute unit. This is only a hint and; /// can be ignored by the finalizer. If the kernel being finalized, or any of; /// the functions it calls, has a requested control directive, then the values; /// must be the same. This can be used to determine the number of resources; /// that should be allocated to a single work-group and work-item. For example,; /// a low value may allow more resources to be allocated, resulting in higher; /// per work-item performance, as it is known there will never be more than the; /// specified number of work-groups actually executing on the compute; /// unit. Conversely, a high value may allocate fewer resources, resulting in; /// lower per work-item performance, which is offset by the fact it allows more; /// work-groups to actually execute on the compute unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:631,allocate,allocated,631,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,3,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"/// If target has efficient vector element load/store instructions, it can; /// return true here so that insertion/extraction costs are not added to; /// the scalarization cost of a load/store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:18,efficient,efficient,18,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['efficient'],['efficient']
Energy Efficiency,"/// If the ScheduleRegionSizeBudget is exhausted, we allow small scheduling; /// regions to be handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,Schedul,ScheduleRegionSizeBudget,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Schedul', 'schedul']","['ScheduleRegionSizeBudget', 'scheduling']"
Energy Efficiency,"/// If the \p File has an MD5 checksum, return it as an MD5Result; /// allocated in the MCContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:71,allocate,allocated,71,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,1,['allocate'],['allocated']
Energy Efficiency,"/// If the \p State's next token is an r_brace closing a nested block,; /// format the nested block before it.; ///; /// Returns \c true if all children could be placed successfully and adapts; /// \p Penalty as well as \p State. If \p DryRun is false, also directly; /// creates changes using \c Whitespaces.; ///; /// The crucial idea here is that children always get formatted upon; /// encountering the closing brace right after the nested block. Now, if we; /// are currently trying to keep the ""}"" on the same line (i.e. \p NewLine is; /// \c false), the entire block has to be kept on the same line (which is only; /// possible if it fits on the line, only contains a single statement, etc.; ///; /// If \p NewLine is true, we format the nested block on separate lines, i.e.; /// break after the ""{"", format all lines with correct indentation and the put; /// the closing ""}"" on yet another new line.; ///; /// This enables us to keep the simple structure of the; /// \c UnwrappedLineFormatter, where we only have two options for each token:; /// break or don't break.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:186,adapt,adapts,186,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['adapt'],['adapts']
Energy Efficiency,"/// If the expression is not a call, and the state change is; /// released -> allocated, it must be the realloc return value; /// check. If we have to handle more cases here, it might be cleaner just; /// to track this extra bit in the state itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:78,allocate,allocated,78,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// If the return symbol is assumed to be error, remove the allocated info; /// from consideration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:60,allocate,allocated,60,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// If the specified cast instruction is a noop copy (e.g. it's casting from; /// one pointer type to another, i32->i8 on PPC), sink it into user blocks to; /// reduce the number of virtual registers that must be created and coalesced.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:161,reduce,reduce,161,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// If there is a current run, end it.; ///; /// This method collects various book-keeping required to clear and close; /// resources associated with the current run, but may also allocate some; /// for the next run.; ///; /// Calling \ref endRun before associating a run through \ref createRun leads; /// to undefined behaviour.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h:180,allocate,allocate,180,interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,1,['allocate'],['allocate']
Energy Efficiency,/// If there was virtual register allocated for the value V emit CopyFromReg; /// of the specified type Ty. Return empty SDValue() otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:34,allocate,allocated,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['allocate'],['allocated']
Energy Efficiency,/// If this constructor does't have a trail-allocated explicit specifier.; /// Whether this constructor is explicit specified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:44,allocate,allocated,44,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['allocate'],['allocated']
Energy Efficiency,"/// If this is a constant FP splat and the splatted constant FP is an; /// exact power or 2, return the log base 2 integer value. Otherwise,; /// return -1.; ///; /// The BitWidth specifies the necessary bit precision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:81,power,power,81,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['power'],['power']
Energy Efficiency,"/// If this is an array allocation, does the usual deallocation; /// function for the allocated type want to know the allocated size?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h:86,allocate,allocated,86,interpreter/llvm-project/clang/include/clang/AST/Stmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h,2,['allocate'],['allocated']
Energy Efficiency,"/// If this method returns true, handling of the scheduling regions; /// themselves (in case of a scheduling boundary in MBB) will be done; /// beginning with the topmost region of MBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:49,schedul,scheduling,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,4,['schedul'],['scheduling']
Energy Efficiency,"/// If this state contains both undef and not undef, we can reduce; /// undef to the not undef value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:60,reduce,reduce,60,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['reduce'],['reduce']
Energy Efficiency,"/// If true, then instruction selection should seek to shrink the FP constant; /// of the specified type to a smaller type in order to save space and / or; /// reduce runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:160,reduce,reduce,160,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['reduce'],['reduce']
Energy Efficiency,"/// If true, then instruction selection should; /// seek to shrink the FP constant of the specified type to a smaller type; /// in order to save space and / or reduce runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:160,reduce,reduce,160,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['reduce'],['reduce']
Energy Efficiency,"/// If vector was first created with capacity 0, getFirstEl() points to the; /// memory right after, an area unallocated. If a subsequent allocation,; /// that grows the vector, happens to return the same pointer as getFirstEl(),; /// get a new allocation, otherwise isSmall() will falsely return that no; /// allocation was done (true) and the memory will not be freed in the; /// destructor. If a VSize is given (vector size), also copy that many; /// elements to the new allocation - used if realloca fails to increase; /// space, and happens to allocate precisely at BeginX.; /// This is unlikely to be called often, but resolves a memory leak when the; /// situation does occur.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:549,allocate,allocate,549,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['allocate'],['allocate']
Energy Efficiency,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:154,allocate,allocated,154,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// If we have a shift-by-constant of a bin op (bitwise logic op or add/sub w/; /// shl) that itself has a shift-by-constant operand with identical opcode, we; /// may be able to convert that into 2 independent shifts followed by the logic; /// op. This eliminates a use of an intermediate value (reduces dependency; /// chain).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:297,reduce,reduces,297,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['reduce'],['reduces']
Energy Efficiency,"/// If we have space, allocates from inline storage. Otherwise, allocates; /// from the slab allocator.; /// FIXME: It would probably be nice to have a SmallBumpPtrAllocator; /// instead.; /// FIXME: Now that this only allocates ImplicitConversionSequences, do we; /// want to un-generalize this?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:22,allocate,allocates,22,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,3,['allocate'],['allocates']
Energy Efficiency,"/// If we have:; /// icmp eq/ne (urem/srem %x, %y), 0; /// iff %y is a power-of-two, we can replace this with a bit test:; /// icmp eq/ne (and %x, (add %y, -1)), 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:71,power,power-of-two,71,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['power'],['power-of-two']
Energy Efficiency,"/// If we reduce or update the program somehow, call this method to update; /// bugdriver with it. This deletes the old module and sets the specified one; /// as the current program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:10,reduce,reduce,10,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,2,['reduce'],['reduce']
Energy Efficiency,"/// If we're narrowing or widening the result of a vector select and the final; /// size is the same size as a setcc (compare) feeding the select, then try to; /// apply the cast operation to the select's operands because matching vector; /// sizes for a select condition and other operands should be more efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:306,efficient,efficient,306,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['efficient'],['efficient']
Energy Efficiency,/// Implement ScheduleDAGInstrs interface for scheduling a sequence of; /// reorderable instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:14,Schedul,ScheduleDAGInstrs,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,4,"['Schedul', 'schedul']","['ScheduleDAGInstrs', 'scheduling']"
Energy Efficiency,"/// Implement the ScheduleDAGInstrs interface for handling the next scheduling; /// region. This covers all instructions in a block, while schedule() may only; /// cover a subset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:18,Schedul,ScheduleDAGInstrs,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,6,"['Schedul', 'schedul']","['ScheduleDAGInstrs', 'schedule', 'scheduling']"
Energy Efficiency,"/// Implement the fusion of instr pairs in the scheduling DAG,; /// anchored at the instr in AnchorSU..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:47,schedul,scheduling,47,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Implementation of format_provider<T> for ranges.; ///; /// This will print an arbitrary range as a delimited sequence of items.; ///; /// The options string of a range type has the grammar:; ///; /// range_style ::= [separator] [element_style]; /// separator ::= ""$"" delimeted_expr; /// element_style ::= ""@"" delimeted_expr; /// delimeted_expr ::= ""["" expr ""]"" | ""("" expr "")"" | ""<"" expr "">""; /// expr ::= <any string not containing delimeter>; ///; /// where the separator expression is the string to insert between consecutive; /// items in the range and the argument expression is the Style specification to; /// be used when formatting the underlying type. The default separator if; /// unspecified is ' ' (space). The syntax of the argument expression follows; /// whatever grammar is dictated by the format provider or format adapter used; /// to format the value type.; ///; /// Note that attempting to format an `iterator_range<T>` where no format; /// provider can be found for T will result in a compile error.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatProviders.h:835,adapt,adapter,835,interpreter/llvm-project/llvm/include/llvm/Support/FormatProviders.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatProviders.h,1,['adapt'],['adapter']
Energy Efficiency,"/// Implements an efficient mapping from strings to IdentifierInfo nodes.; ///; /// This has no other purpose, but this is an extremely performance-critical; /// piece of the code, as each occurrence of every identifier goes through; /// here when lexed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:18,efficient,efficient,18,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Implements vector reduce operation promotion.; ///; /// All vector operands are promoted to a vector type with larger element; /// type, and the start value is promoted to a larger scalar type. Then the; /// result is truncated back to the original scalar type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:22,reduce,reduce,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// In case we optimize for size we use repmovsb even if it's less efficient; /// so we can save the loads/stores of the leftover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp:67,efficient,efficient,67,interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp,1,['efficient'],['efficient']
Energy Efficiency,/// Index in Instrs of the instruction being earliest in the schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:61,schedul,schedule,61,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// Index in Instrs of the instruction being latest in the schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:59,schedul,schedule,59,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// Index within this itinerary of the schedule class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DFAPacketizerEmitter.cpp:39,schedul,schedule,39,interpreter/llvm-project/llvm/utils/TableGen/DFAPacketizerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DFAPacketizerEmitter.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// Inform the memory manager about the total amount of memory required to; /// allocate all sections to be loaded:; /// \p CodeSize - the total size of all code sections; /// \p DataSizeRO - the total size of all read-only data sections; /// \p DataSizeRW - the total size of all read-write data sections; ///; /// Note that by default the callback is disabled. To enable it; /// redefine the method needsToReserveAllocationSpace to return true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:80,allocate,allocate,80,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Information about DAG subtrees. If DFSResult is NULL, then SchedulerTrees; /// will be empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:63,Schedul,SchedulerTrees,63,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['Schedul'],['SchedulerTrees']
Energy Efficiency,/// Information about a stack frame for std::allocator<T>::[de]allocate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:63,allocate,allocate,63,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['allocate'],['allocate']
Energy Efficiency,"/// Information about a template-id annotation; /// token.; ///; /// A template-id annotation token contains the template name,; /// template arguments, and the source locations for important; /// tokens. All of the information about template arguments is allocated; /// directly after this structure.; /// A template-id annotation token can also be generated by a type-constraint; /// construct with no explicit template arguments, e.g. ""template<C T>"" would; /// annotate C as a TemplateIdAnnotation with no template arguments (the angle; /// locations would be invalid in this case).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedTemplate.h:256,allocate,allocated,256,interpreter/llvm-project/clang/include/clang/Sema/ParsedTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedTemplate.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Information for lazily generating a cleanup. Subclasses must be; /// POD-like: cleanups will not be destructed, and they will be; /// allocated on the cleanup stack and freely copied and moved; /// around.; ///; /// Cleanup implementations should generally be declared in an; /// anonymous namespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/EHScopeStack.h:138,allocate,allocated,138,interpreter/llvm-project/clang/lib/CodeGen/EHScopeStack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/EHScopeStack.h,1,['allocate'],['allocated']
Energy Efficiency,/// Initialize state associated with the next scheduling region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:46,schedul,scheduling,46,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Initialize the DAG and common scheduler state for a new; /// scheduling region. This does not actually create the DAG, only clears; /// it. The scheduling driver may call BuildSchedGraph multiple times per; /// scheduling region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:34,schedul,scheduler,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,4,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,/// Initialize the ScheduleData structures for new instructions in the; /// scheduling region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,Schedul,ScheduleData,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Schedul', 'schedul']","['ScheduleData', 'scheduling']"
Energy Efficiency,"/// Initialize the array cookie for the given allocation.; ///; /// \param NewPtr - a char* which is the presumed-non-null; /// return value of the allocation function; /// \param NumElements - the computed number of elements,; /// potentially collapsed from the multidimensional array case;; /// always a size_t; /// \param ElementType - the base element allocated type,; /// i.e. the allocated type after stripping all array types",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:356,allocate,allocated,356,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,2,['allocate'],['allocated']
Energy Efficiency,/// Initialize the machine model for instruction scheduling.; ///; /// The machine model API keeps a copy of the top-level MCSchedModel table; /// indices and may query TargetSubtargetInfo and TargetInstrInfo to resolve; /// dynamic properties.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:49,schedul,scheduling,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Initialize the per-region scheduling policy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,schedul,scheduling,30,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// Initialize the scheduler state for the next scheduling region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:19,schedul,scheduler,19,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,"/// Initialize the scheduling model and feature bits.; ///; /// FIXME: Find a way to stick this in the constructor, since it should only; /// be called during initialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:19,schedul,scheduling,19,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Inline descriptor embedded in structures and arrays.; ///; /// Such descriptors precede all composite array elements and structure fields.; /// If the base of a pointer is not zero, the base points to the end of this; /// structure. The offset field is used to traverse the pointer chain up; /// to the root structure which allocated the object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:328,allocate,allocated,328,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Insert a dependency-breaking instruction; /// before MI to eliminate an unwanted dependency on OpNum.; ///; /// If it wasn't possible to avoid a def in the last N instructions before MI; /// (see getPartialRegUpdateClearance), this hook will be called to break the; /// unwanted dependency.; ///; /// On x86, an xorps instruction can be used as a dependency breaker:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// xorps %xmm0, %xmm0; /// cvtsi2ss %rbx, %xmm0; ///; /// An <imp-kill> operand should be added to MI if an instruction was; /// inserted. This ties the instructions together in the post-ra scheduler.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:618,schedul,scheduler,618,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['schedul'],['scheduler']
Energy Efficiency,"/// Insert a file into this GSYM creator.; ///; /// Inserts a file by adding a FileEntry into the ""Files"" member variable if; /// the file has not already been added. The file path is split into; /// directory and filename which are both added to the string table. This; /// allows paths to be stored efficiently by reusing the directories that are; /// common between multiple files.; ///; /// \param Path The path to the file to insert.; /// \param Style The path style for the ""Path"" parameter.; /// \returns The unique file index for the inserted file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:301,efficient,efficiently,301,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// Insert a point into kd-tree; /// @note external point-buffer is used to reduce kd-tree's memory footprint; /// @param iPoint index of point in external point-buffer; /// @param points external point-buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/KDTree.h:76,reduce,reduce,76,math/mathcore/src/CDT/KDTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/KDTree.h,1,['reduce'],['reduce']
Energy Efficiency,/// Insert an entry into the table.; ///; /// Uses the provided Info instead of a stack allocated one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:88,allocate,allocated,88,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Insert code in the prolog/epilog code when unrolling a loop with a; /// run-time trip-count.; ///; /// This method assumes that the loop unroll factor is total number; /// of loop bodies in the loop after unrolling. (Some folks refer; /// to the unroll factor as the number of *extra* copies added).; /// We assume also that the loop unroll factor is a power-of-two. So, after; /// unrolling the loop, the number of loop bodies executed is 2,; /// 4, 8, etc. Note - LLVM converts the if-then-sequence to a switch; /// instruction in SimplifyCFG.cpp. Then, the backend decides how code for; /// the switch instruction is generated.; ///; /// ***Prolog case***; /// extraiters = tripcount % loopfactor; /// if (extraiters == 0) jump Loop:; /// else jump Prol:; /// Prol: LoopBody;; /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Prol: // Omitted if unroll factor is 2.; /// if (tripcount < loopfactor) jump End:; /// Loop:; /// ...; /// End:; ///; /// ***Epilog case***; /// extraiters = tripcount % loopfactor; /// if (tripcount < loopfactor) jump LoopExit:; /// unroll_iters = tripcount - extraiters; /// Loop: LoopBody; (executes unroll_iter times);; /// unroll_iter -= 1; /// if (unroll_iter != 0) jump Loop:; /// LoopExit:; /// if (extraiters == 0) jump EpilExit:; /// Epil: LoopBody; (executes extraiters times); /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Epil: // Omitted if unroll factor is 2.; /// EpilExit:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:357,power,power-of-two,357,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,1,['power'],['power-of-two']
Energy Efficiency,/// InsertCopiesAndMoveSuccs - Insert register copies and move all; /// scheduled successors of the given SUnit to the last copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:72,schedul,scheduled,72,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['schedul'],['scheduled']
Energy Efficiency,/// Instantiate a ScheduleDAGInstrs for PostRA scheduling that will be owned by; /// the caller. We don't have a command line option to override the postRA; /// scheduler. The Target must configure it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Schedul,ScheduleDAGInstrs,18,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,"['Schedul', 'schedul']","['ScheduleDAGInstrs', 'scheduler', 'scheduling']"
Energy Efficiency,/// Instantiate a ScheduleDAGInstrs that will be owned by the caller.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Schedul,ScheduleDAGInstrs,18,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Schedul'],['ScheduleDAGInstrs']
Energy Efficiency,/// Instructions to change when emitting the final schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:51,schedul,schedule,51,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,2,['schedul'],['schedule']
Energy Efficiency,"/// Instructions which will become dead if we rewrite the alloca.; ///; /// Note that these are not separated by slice. This is because we expect an; /// alloca to be completely rewritten or not rewritten at all. If rewritten,; /// all these instructions can simply be removed and replaced with poison as; /// they come from outside of the allocated space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:340,allocate,allocated,340,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Interface to connect the parser with the registry and more.; ///; /// The parser uses the Sema instance passed into; /// parseMatcherExpression() to handle all matcher tokens. The simplest; /// processor implementation would simply call into the registry to create; /// the matchers.; /// However, a more complex processor might decide to intercept the matcher; /// creation and do some extra work. For example, it could apply some; /// transformation to the matcher by adding some id() nodes, or could detect; /// specific matcher nodes for more efficient lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h:551,efficient,efficient,551,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h,1,['efficient'],['efficient']
Energy Efficiency,/// Intern - Copy this node's data to a memory region allocated from the; /// given allocator and return a FoldingSetNodeIDRef describing the; /// interned data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:54,allocate,allocated,54,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,2,['allocate'],['allocated']
Energy Efficiency,/// Is the triple powerpc[64][le]-*-none-eabi?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/BareMetal.cpp:18,power,powerpc,18,interpreter/llvm-project/clang/lib/Driver/ToolChains/BareMetal.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/BareMetal.cpp,1,['power'],['powerpc']
Energy Efficiency,/// Is there an llvm.stacksave or llvm.stackrestore in the scheduling; /// region? Used to optimize the dependence calculation for the; /// common case where there isn't.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:59,schedul,scheduling,59,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// IsOverriderUsed - Returns whether the overrider will ever be used in this; /// part of the vtable.; ///; /// Itanium C++ ABI 2.5.2:; ///; /// struct A { virtual void f(); };; /// struct B : virtual public A { int i; };; /// struct C : virtual public A { int j; };; /// struct D : public B, public C {};; ///; /// When B and C are declared, A is a primary base in each case, so although; /// vcall offsets are allocated in the A-in-B and A-in-C vtables, no this; /// adjustment is required and no thunk is generated. However, inside D; /// objects, A is no longer a primary base of C, so if we allowed calls to; /// C::f() to use the copy of A's vtable in the C subobject, we would need; /// to adjust this from C* to B::A*, which would require a third-party; /// thunk. Since we require that a call to C::f() first convert to A*,; /// C-in-D's copy of A's vtable is never referenced, so this is not; /// necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:413,allocate,allocated,413,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// IssueCount - Count instructions issued in this cycle; /// Currently valid only for bottom-up scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:97,schedul,scheduling,97,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Items with different bunch ids are scheduled for different vector reads",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:39,schedul,scheduled,39,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['schedul'],['scheduled']
Energy Efficiency,/// Iterate over each DAG node and see if we can change any dependences; /// in order to reduce the recurrence MII.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,reduce,reduce,89,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// Iteration adapter for range-for loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:14,adapt,adapter,14,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,2,['adapt'],['adapter']
Energy Efficiency,"/// Iteration over the elements in the vector.; ///; /// In a complete iteration, the iterator walks the range [-M, N),; /// where negative values are used to indicate elements; /// loaded from the external source while non-negative values are used to; /// indicate elements added via \c push_back().; /// However, to provide iteration in source order (for, e.g., chained; /// precompiled headers), dereferencing the iterator flips the negative; /// values (corresponding to loaded entities), so that position -M; /// corresponds to element 0 in the loaded entities vector, position -M+1; /// corresponds to element 1 in the loaded entities vector, etc. This; /// gives us a reasonably efficient, source-order walk.; ///; /// We define this as a wrapping iterator around an int. The; /// iterator_adaptor_base class forwards the iterator methods to basic integer; /// arithmetic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:686,efficient,efficient,686,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Iteration over the preprocessed entities.; ///; /// In a complete iteration, the iterator walks the range [-M, N),; /// where negative values are used to indicate preprocessed entities; /// loaded from the external source while non-negative values are used to; /// indicate preprocessed entities introduced by the current preprocessor.; /// However, to provide iteration in source order (for, e.g., chained; /// precompiled headers), dereferencing the iterator flips the negative; /// values (corresponding to loaded entities), so that position -M; /// corresponds to element 0 in the loaded entities vector, position -M+1; /// corresponds to element 1 in the loaded entities vector, etc. This; /// gives us a reasonably efficient, source-order walk.; ///; /// We define this as a wrapping iterator around an int. The; /// iterator_adaptor_base class forwards the iterator methods to basic; /// integer arithmetic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:725,efficient,efficient,725,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['efficient'],['efficient']
Energy Efficiency,/// Iterator adaptor that invents template argument location information; /// for each of the template arguments in its underlying iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:13,adapt,adaptor,13,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['adapt'],['adaptor']
Energy Efficiency,"/// Iterators over the materialized elements of the vector.; ///; /// This includes all the elements belonging to allocated pages,; /// even if they have not been accessed yet. It's enough to access; /// one element of a page to materialize all the elements of the page.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:114,allocate,allocated,114,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,1,['allocate'],['allocated']
Energy Efficiency,/// Keep dynamically allocated InstructionMapping in a separate map.; /// This shouldn't be needed when everything gets TableGen'ed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:21,allocate,allocated,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Keep dynamically allocated PartialMapping in a separate map.; /// This shouldn't be needed when everything gets TableGen'ed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:21,allocate,allocated,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Keep dynamically allocated ValueMapping in a separate map.; /// This shouldn't be needed when everything gets TableGen'ed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:21,allocate,allocated,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Keep dynamically allocated array of ValueMapping in a separate map.; /// This shouldn't be needed when everything gets TableGen'ed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:21,allocate,allocated,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Keep track of the first cycle value in the schedule. It starts; /// as zero, but the algorithm allows negative values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:47,schedul,schedule,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['schedule']
Energy Efficiency,/// Keep track of the last cycle value in the schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:46,schedul,schedule,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['schedule']
Energy Efficiency,/// Keeps all the allocated nodes and their intermediate data structures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:18,allocate,allocated,18,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Known operand bundle tag IDs, which always have the same value. All; /// operand bundle tags that LLVM has special knowledge of are listed here.; /// Additionally, this scheme allows LLVM to efficiently check for specific; /// operand bundle tags without comparing strings. Keep this in sync with; /// LLVMContext::LLVMContext().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:195,efficient,efficiently,195,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// Known synchronization scope IDs, which always have the same value. All; /// synchronization scope IDs that LLVM has special knowledge of are listed; /// here. Additionally, this scheme allows LLVM to efficiently check for; /// specific synchronization scope ID without comparing strings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:204,efficient,efficiently,204,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// LastDecl - The last declaration stored within this declaration; /// context. FIXME: We could probably cache this value somewhere; /// outside of the DeclContext, to reduce the size of DeclContext by; /// another pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:169,reduce,reduce,169,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['reduce'],['reduce']
Energy Efficiency,/// LastFPdOpCycleIdx stores the numbeer returned by getCurrCycleIdx(); /// when a stalling operation is scheduled (which uses the FPd resource).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:105,schedul,scheduled,105,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Layout pointer alignment element.; ///; /// Stores the alignment data associated with a given pointer and address space.; ///; /// \note The unusual order of elements in the structure attempts to reduce; /// padding and make the structure slightly more cache friendly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:200,reduce,reduce,200,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,1,['reduce'],['reduce']
Energy Efficiency,"/// Like set, but only supports initializing a newly-allocated; /// SDUse with a non-null value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:53,allocate,allocated,53,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Limit generated debug info for classes to reduce size. This emits class; /// type info only where the constructor is emitted, if it is a class that; /// has a constructor.; /// FIXME: Consider combining this with LimitedDebugInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/Debug/Options.h:46,reduce,reduce,46,interpreter/llvm-project/llvm/include/llvm/Frontend/Debug/Options.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/Debug/Options.h,1,['reduce'],['reduce']
Energy Efficiency,/// Limit generated debug info to reduce size (-fno-standalone-debug). This; /// emits forward decls for types that could be replaced with forward decls in; /// the source code. For dynamic C++ classes type info is only emitted into; /// the module that contains the classe's vtable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/Debug/Options.h:34,reduce,reduce,34,interpreter/llvm-project/llvm/include/llvm/Frontend/Debug/Options.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/Debug/Options.h,1,['reduce'],['reduce']
Energy Efficiency,/// Limits the size of scheduling regions in a block.; /// It avoid long compile times for _very_ large blocks where vector; /// instructions are spread over a wide range.; /// This limit is way higher than needed by real-world functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:23,schedul,scheduling,23,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:110,schedul,scheduled,110,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduled']
Energy Efficiency,/// List of possibly reduced values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,reduce,reduced,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,"/// List of pressure sets that exceed the target's pressure limit before; /// scheduling, listed in increasing set ID order. Each pressure set is paired; /// with its max pressure in the currently scheduled regions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:78,schedul,scheduling,78,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,/// List of users to ignore during scheduling and that don't need extracting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,schedul,scheduling,35,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// ListScheduleBottomUp - The main loop of list scheduling for bottom-up; /// schedulers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:49,schedul,scheduling,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,4,['schedul'],"['schedulers', 'scheduling']"
Energy Efficiency,/// ListScheduleTopDown - The main loop of list scheduling for top-down; /// schedulers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:48,schedul,scheduling,48,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['schedul'],"['schedulers', 'scheduling']"
Energy Efficiency,"/// LiveRegDefs - A set of physical registers and their definition; /// that are ""live"". These nodes must be scheduled before any other nodes that; /// modifies the registers can be scheduled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:109,schedul,scheduled,109,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,4,['schedul'],['scheduled']
Energy Efficiency,"/// Load the features of the given VirtReg (allocated or not) at column Pos,; /// but if that can't be evicted, return false instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:44,allocate,allocated,44,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Local packet/bundle model. Purely; /// internal to the MI scheduler at the time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:62,schedul,scheduler,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,/// LocalStackSlotAllocation - This pass assigns local frame indices to stack; /// slots relative to one another and allocates base registers to access them; /// when it is estimated by the target to be out of range of normal frame; /// pointer or stack pointer index addressing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:117,allocate,allocates,117,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['allocate'],['allocates']
Energy Efficiency,/// Look for allocation functions in both the global scope; /// and in the scope of the allocated class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:88,allocate,allocated,88,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Looks through shuffles trying to reduce final number of shuffles in the; /// code. The function looks through the previously emitted shuffle; /// instructions and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and select vectors %0 and %1 with mask; /// <0, 1, 2, 3> for the shuffle.; /// So, it tries to transform permutations to simple vector merge, if; /// possible.; /// \param V The input vector which must be shuffled using the given \p Mask.; /// If the better candidate is found, \p V is set to this best candidate; /// vector.; /// \param Mask The input mask for the shuffle. If the best candidate is found; /// during looking-through-shuffles attempt, it is updated accordingly.; /// \param SinglePermute true if the shuffle operation is originally a; /// single-value-permutation. In this case the look-through-shuffles procedure; /// may look for resizing shuffles as the best candidates.; /// \return true if the shuffle results in the non-resizing identity shuffle; /// (and thus can be ignored), false - otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:37,reduce,reduce,37,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Lookup a single address within the inline info data.; ///; /// Clients have the option to decode an entire InlineInfo object (using; /// InlineInfo::decode() ) or just find the matching inline info using this; /// function. The benefit of using this function is that only the information; /// needed for the lookup will be extracted, other info can be skipped and; /// parsing can stop as soon as the deepest match is found. This allows; /// symbolication tools to be fast and efficient and avoid allocation costs; /// when doing lookups.; ///; /// This function will augment the SourceLocations array \a SrcLocs with any; /// inline information that pertains to \a Addr. If no inline information; /// exists for \a Addr, then \a SrcLocs will be left untouched. If there is; /// inline information for \a Addr, then \a SrcLocs will be modifiied to; /// contain the deepest most inline function's SourceLocation at index zero; /// in the array and proceed up the concrete function source file and; /// line at the end of the array.; ///; /// \param GR The GSYM reader that contains the string and file table that; /// will be used to fill in the source locations.; ///; /// \param Data The binary stream to read the data from. This object must; /// have the data for the LineTable object starting at offset zero. The data; /// can contain more data than needed.; ///; /// \param BaseAddr The base address to use when decoding the line table.; /// This will be the FunctionInfo's start address and will be used to; /// decode the correct addresses for the inline information.; ///; /// \param Addr The address to lookup.; ///; /// \param SrcLocs The inline source locations that matches \a Addr. This; /// array must be initialized with the matching line entry; /// from the line table upon entry. The name of the concrete; /// function must be supplied since it will get pushed to; /// the last SourceLocation entry and the inline information; /// will fill in the source file and line from the inl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h:481,efficient,efficient,481,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Lower a memory operation if the memory access size is not a round power of; /// 2 byte size. This is stricter than lowerIfMemSizeNotPow2, and more likely; /// what you want (e.g. this will lower s1, s7 and s24).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:70,power,power,70,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['power'],['power']
Energy Efficiency,"/// Lower a memory operation if the memory size, rounded to bytes, is not a; /// power of 2. For example, this will not trigger for s1 or s7, but will for; /// s24.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:81,power,power,81,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['power'],['power']
Energy Efficiency,/// Lower shuffles where an entire half of a 256 or 512-bit vector is UNDEF.; /// This allows for fast cases such as subvector extraction/insertion; /// or shuffling smaller vector types which can lower more efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:208,efficient,efficiently,208,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['efficient'],['efficiently']
Energy Efficiency,/// Lower the current thread's priority as much as possible. Can be used; /// for long-running tasks that are not time critical; more energy-; /// efficient than Low.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:134,energy,energy,134,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,2,"['efficient', 'energy']","['efficient', 'energy']"
Energy Efficiency,/// Lowers generic MASSV entries to PowerPC subtarget-specific MASSV entries.; /// e.g.: __sind2_massv --> __sind2_P9 for a Power9 subtarget.; /// Both function prototypes and their callsites are updated during lowering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp:36,Power,PowerPC,36,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLowerMASSVEntries.cpp,1,['Power'],['PowerPC']
Energy Efficiency,/// Lowest valid SDNodeOrder. The special case 0 is reserved for scheduling; /// nodes without a corresponding SDNode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:65,schedul,scheduling,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['schedul'],['scheduling']
Energy Efficiency,/// MLxHazardOpcodes - Set of add / sub and multiply opcodes that would cause; /// stalls when scheduled together with fp MLA / MLS opcodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:95,schedul,scheduled,95,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,1,['schedul'],['scheduled']
Energy Efficiency,/// MRVFunctionsTracked - Each function in TrackedMultipleRetVals is; /// represented here for efficient lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:95,efficient,efficient,95,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// Machine model for scheduling, bundling, and heuristics.; ///; /// The machine model directly provides basic information about the; /// microarchitecture to the scheduler in the form of properties. It also; /// optionally refers to scheduler resource tables and itinerary; /// tables. Scheduler resource tables model the latency and cost for each; /// instruction type. Itinerary tables are an independent mechanism that; /// provides a detailed reservation table describing each cycle of instruction; /// execution. Subtargets may define any or all of the above categories of data; /// depending on the type of CPU and selected scheduler.; ///; /// The machine independent properties defined here are used by the scheduler as; /// an abstract machine model. A real micro-architecture has a number of; /// buffers, queues, and stages. Declaring that a given machine-independent; /// abstract property corresponds to a specific physical property across all; /// subtargets can't be done. Nonetheless, the abstract model is; /// useful. Futhermore, subtargets typically extend this model with processor; /// specific resources to model any hardware features that can be exploited by; /// scheduling heuristics and aren't sufficiently represented in the abstract.; ///; /// The abstract pipeline is built around the notion of an ""issue point"". This; /// is merely a reference point for counting machine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: O",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:22,schedul,scheduling,22,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,6,"['Schedul', 'schedul']","['Scheduler', 'scheduler', 'scheduling']"
Energy Efficiency,"/// MachineFunctionPass - This class adapts the FunctionPass interface to; /// allow convenient creation of passes that operate on the MachineFunction; /// representation. Instead of overriding runOnFunction, subclasses; /// override runOnMachineFunction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:37,adapt,adapts,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,1,['adapt'],['adapts']
Energy Efficiency,/// MachineSchedContext provides enough context from the MachineScheduler pass; /// for the target to instantiate a scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:116,schedul,scheduler,116,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,/// MachineSchedOpt allows command line selection of the scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:57,schedul,scheduler,57,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,/// MachineSchedRegistry provides a selection of available machine instruction; /// schedulers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:84,schedul,schedulers,84,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['schedulers']
Energy Efficiency,/// MachineSchedStrategy - Interface to the scheduling algorithm used by; /// ScheduleDAGMI.; ///; /// Initialization sequence:; /// initPolicy -> shouldTrackPressure -> initialize(DAG) -> registerRoots,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:44,schedul,scheduling,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,"['Schedul', 'schedul']","['ScheduleDAGMI', 'scheduling']"
Energy Efficiency,/// MachineScheduler - This pass schedules machine instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:33,schedul,schedules,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['schedul'],['schedules']
Energy Efficiency,/// Main access point - returns next instructions; /// to be placed in scheduling sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:71,schedul,scheduling,71,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Maintain hazard recognizers for all blocks, so that the scheduler state; /// can be maintained past BB boundaries when appropariate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:60,schedul,scheduler,60,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,"/// Make the expected plot and the bands; /// nsig1 and nsig2 indicates the n-sigma value for the bands; /// if nsig1 = 0 no band is computed (only expected value); /// if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also done.; /// The first band is drawn in green while the second in yellow; /// The plot (expected value + bands) is returned as a TMultiGraph object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterPlot.h:281,green,green,281,roofit/roostats/inc/RooStats/HypoTestInverterPlot.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverterPlot.h,1,['green'],['green']
Energy Efficiency,/// Map for each register and the max difference between its uses and def.; /// The first element in the pair is the max difference in stages. The; /// second is true if the register defines a Phi value and loop value is; /// scheduled before the Phi.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:226,schedul,scheduled,226,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Map of backing storage to a set of variables that are stored to it.; /// TODO: Backing storage shouldn't be limited to allocas only. Some local; /// variables have their storage allocated by the calling function (addresses; /// passed in with sret & byval parameters).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h:182,allocate,allocated,182,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Map of global value GUID to its summary, used to identify values defined in; /// a particular module, and provide efficient access to their summary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:118,efficient,efficient,118,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['efficient'],['efficient']
Energy Efficiency,/// Map the OpenMP distribute schedule to the runtime enumeration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:30,schedul,schedule,30,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// Map the OpenMP loop schedule to the runtime enumeration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:24,schedul,schedule,24,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// Maps reduced value to the corresponding reduction operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,reduce,reduced,9,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduced']
Energy Efficiency,/// Maps vregs to the SUnits of their uses in the current scheduling region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:58,schedul,scheduling,58,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Mark PhysReg as reserved or free after spilling any virtregs. This is very; /// similar to defineVirtReg except the physreg is reserved instead of; /// allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:156,allocate,allocated,156,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Mark a register and all of its aliases as allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:46,allocate,allocated,46,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// MarkAllocated - Mark a register and all of its aliases as allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:62,allocate,allocated,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['allocate'],['allocated']
Energy Efficiency,/// Marks an instruction as scheduled and puts all dependent ready; /// instructions into the ready-list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,schedul,scheduled,28,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"/// Marks that the current location is not supposed to be reachable.; /// In !NDEBUG builds, prints the message and location info to stderr.; /// In NDEBUG builds, if the platform does not support a builtin unreachable; /// then we call an internal LLVM runtime function. Otherwise the behavior is; /// controlled by the CMake flag; /// -DLLVM_UNREACHABLE_OPTIMIZE; /// * When ""ON"" (default) llvm_unreachable() becomes an optimizer hint; /// that the current location is not supposed to be reachable: the hint; /// turns such code path into undefined behavior. On compilers that don't; /// support such hints, prints a reduced message instead and aborts the; /// program.; /// * When ""OFF"", a builtin_trap is emitted instead of an; // optimizer hint or printing a reduced message.; ///; /// Use this instead of assert(0). It conveys intent more clearly, suppresses; /// diagnostics for unreachable code paths, and allows compilers to omit; /// unnecessary code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:619,reduce,reduced,619,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,2,['reduce'],['reduced']
Energy Efficiency,"/// Match a binop + shuffle pyramid that represents a horizontal reduction; /// over the elements of a vector starting from the EXTRACT_VECTOR_ELT node /p; /// Extract. The reduction must use one of the opcodes listed in /p; /// CandidateBinOps and on success /p BinOp will contain the matching opcode.; /// Returns the vector that is being reduced on, or SDValue() if a reduction; /// was not matched. If \p AllowPartials is set then in the case of a; /// reduction pattern that only matches the first few stages, the extracted; /// subvector of the start of the reduction is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:341,reduce,reduced,341,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['reduce'],['reduced']
Energy Efficiency,"/// Match a integer or vector negated power-of-2.; /// For vectors, this includes constants with undefined elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h:38,power,power-of-,38,interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,1,['power'],['power-of-']
Energy Efficiency,"/// Match an integer or vector of 0 or power-of-2 values.; /// For vectors, this includes constants with undefined elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h:39,power,power-of-,39,interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,1,['power'],['power-of-']
Energy Efficiency,"/// Match an integer or vector power-of-2.; /// For vectors, this includes constants with undefined elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h:31,power,power-of-,31,interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,1,['power'],['power-of-']
Energy Efficiency,/// Matches enum types.; ///; /// Given; /// \code; /// enum C { Green };; /// enum class S { Red };; ///; /// C c;; /// S s;; /// \endcode; //; /// \c enumType() matches the type of the variable declarations of both \c c and; /// \c s.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h:65,Green,Green,65,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,1,['Green'],['Green']
Energy Efficiency,"/// MaxLookAhead - Indicate the number of cycles in the scoreboard; /// state. Important to restore the state after backtracking. Additionally,; /// MaxLookAhead=0 identifies a fake recognizer, allowing the client to; /// bypass virtual calls. Currently the PostRA scheduler ignores it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:265,schedul,scheduler,265,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['schedul'],['scheduler']
Energy Efficiency,/// Maximum number of micro-ops that may be scheduled per cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:44,schedul,scheduled,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Merge 2 debug locations and apply it to the Instruction. If the; /// instruction is a CallIns, we need to traverse the inline chain to find; /// the common scope. This is not efficient for N-way merging as each time; /// you merge 2 iterations, you need to rebuild the hashmap to find the; /// common scope. However, we still choose this API because:; /// 1) Simplicity: it takes 2 locations instead of a list of locations.; /// 2) In worst case, it increases the complexity from O(N*I) to; /// O(2*N*I), where N is # of Instructions to merge, and I is the; /// maximum level of inline stack. So it is still linear.; /// 3) Merging of call instructions should be extremely rare in real; /// applications, thus the N-way merging should be in code path.; /// The DebugLoc attached to this instruction will be overwritten by the; /// merged DebugLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:179,efficient,efficient,179,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:346,reduce,reduce,346,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Merges shuffle masks and emits final shuffle instruction, if required. It; /// supports shuffling of 2 input vectors. It implements lazy shuffles emission,; /// when the actual shuffle instruction is generated only if this is actually; /// required. Otherwise, the shuffle instruction emission is delayed till the; /// end of the process, to reduce the number of emitted instructions and further; /// analysis/transformations.; /// The class also will look through the previously emitted shuffle instructions; /// and properly mark indices in mask as undef.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 3, 2>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.; /// If 2 operands are of different size, the smallest one will be resized and; /// the mask recalculated properly.; /// For example, given the code; /// \code; /// %s1 = shufflevector <2 x ty> %0, poison, <1, 0, 1, 0>; /// %s2 = shufflevector <2 x ty> %1, poison, <1, 0, 1, 0>; /// \endcode; /// and if need to emit shuffle of %s1 and %s2 with mask <1, 0, 5, 4>, it will; /// look through %s1 and %s2 and emit; /// \code; /// %res = shufflevector <2 x ty> %0, %1, <0, 1, 2, 3>; /// \endcode; /// instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:346,reduce,reduce,346,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,"/// Merges together two TrieNodes with like function ids, aggregating their; /// callee lists and durations. The caller must provide storage where new merged; /// nodes can be allocated in the form of a linked list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/trie-node.h:176,allocate,allocated,176,interpreter/llvm-project/llvm/tools/llvm-xray/trie-node.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/trie-node.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Metadata node.; ///; /// Metadata nodes can be uniqued, like constants, or distinct. Temporary; /// metadata nodes (with full support for RAUW) can be used to delay uniquing; /// until forward references are known. The basic metadata node is an \a; /// MDTuple.; ///; /// There is limited support for RAUW at construction time. At construction; /// time, if any operand is a temporary node (or an unresolved uniqued node,; /// which indicates a transitive temporary operand), the node itself will be; /// unresolved. As soon as all operands become resolved, it will drop RAUW; /// support permanently.; ///; /// If an unresolved node is part of a cycle, \a resolveCycles() needs; /// to be called on some member of the cycle once all temporary nodes have been; /// replaced.; ///; /// MDNodes can be large or small, as well as resizable or non-resizable.; /// Large MDNodes' operands are allocated in a separate storage vector,; /// whereas small MDNodes' operands are co-allocated. Distinct and temporary; /// MDnodes are resizable, but only MDTuples support this capability.; ///; /// Clients can add operands to resizable MDNodes using push_back().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h:892,allocate,allocated,892,interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,2,['allocate'],['allocated']
Energy Efficiency,"/// Method Pool - allows efficient lookup when typechecking messages to ""id"".; /// We need to maintain a list, since selectors can have differing signatures; /// across classes. In Cocoa, this happens to be extremely uncommon (only 1%; /// of selectors are ""overloaded"").; /// At the head of the list it is recorded whether there were 0, 1, or >= 2; /// methods inside categories with a particular selector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:25,efficient,efficient,25,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Model functions with the ownership_returns attribute.; ///; /// User-defined function may have the ownership_returns attribute, which; /// annotates that the function returns with an object that was allocated on; /// the heap, and passes the ownertship to the callee.; ///; /// void __attribute((ownership_returns(malloc, 1))) *my_malloc(size_t);; ///; /// It has two parameters:; /// - first: name of the resource (e.g. 'malloc'); /// - (OPTIONAL) second: size of the allocated region; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Att The ownership_returns attribute.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:203,allocate,allocated,203,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,3,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] Size Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:77,allocate,allocates,77,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,4,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,"/// Models memory allocation.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] SizeEx Size of the memory that needs to be allocated.; /// \param [in] Init The value the allocated memory needs to be initialized.; /// with. For example, \c calloc initializes the allocated memory to 0,; /// malloc leaves it undefined.; /// \param [in] State The \c ProgramState right before allocation.; /// \returns The ProgramState right after allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:77,allocate,allocates,77,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,4,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,"/// Models memory deallocation.; ///; /// \param [in] ArgExpr The variable who's pointee needs to be freed.; /// \param [in] Call The expression that frees the memory.; /// \param [in] State The \c ProgramState right before allocation.; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:497,allocate,allocated,497,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,3,['allocate'],['allocated']
Energy Efficiency,"/// Models memory deallocation.; ///; /// \param [in] Call The expression that frees memory.; /// \param [in] State The \c ProgramState right before allocation.; /// \param [in] Num Index of the argument that needs to be freed. This is; /// normally 0, but for custom free functions it may be different.; /// \param [in] Hold Whether the parameter at \p Index has the ownership_holds; /// attribute.; /// \param [out] IsKnownToBeAllocated Whether the memory to be freed is known; /// to have been allocated, or in other words, the symbol to be freed was; /// registered as allocated by this checker. In the following case, \c ptr; /// isn't known to be allocated.; /// void Haha(int *ptr) {; /// ptr = realloc(ptr, 67);; /// // ...; /// }; /// \param [in] ReturnsNullOnFailure Whether the memory deallocation function; /// we're modeling returns with Null on failure.; /// \returns The ProgramState right after deallocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:497,allocate,allocated,497,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,3,['allocate'],['allocated']
Energy Efficiency,/// Modifiers for 'schedule' clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:19,schedul,schedule,19,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['schedul'],['schedule']
Energy Efficiency,/// Modifies the canonical loop a statically-scheduled workshare loop with a; /// user-specified chunk size.; ///; /// \param DL Debug location for instructions added for the; /// workshare-loop construct itself.; /// \param CLI A descriptor of the canonical loop to workshare.; /// \param AllocaIP An insertion point for Alloca instructions usable in; /// the preheader of the loop.; /// \param NeedsBarrier Indicates whether a barrier must be inserted after the; /// loop.; /// \param ChunkSize The user-specified chunk size.; ///; /// \returns Point where to insert code after the workshare construct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:45,schedul,scheduled,45,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Modifies the canonical loop to be a dynamically-scheduled workshare loop.; ///; /// This takes a \p LoopInfo representing a canonical loop, such as the one; /// created by \p createCanonicalLoop and emits additional instructions to; /// turn it into a workshare loop. In particular, it calls to an OpenMP; /// runtime function in the preheader to obtain, and then in each iteration; /// to update the loop counter.; ///; /// \param DL Debug location for instructions added for the; /// workshare-loop construct itself.; /// \param CLI A descriptor of the canonical loop to workshare.; /// \param AllocaIP An insertion point for Alloca instructions usable in the; /// preheader of the loop.; /// \param SchedType Type of scheduling to be passed to the init function.; /// \param NeedsBarrier Indicates whether a barrier must be insterted after; /// the loop.; /// \param Chunk The size of loop chunk considered as a unit when; /// scheduling. If \p nullptr, defaults to 1.; ///; /// \returns Point where to insert code after the workshare construct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:52,schedul,scheduled,52,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,3,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"/// Modifies the canonical loop to be a statically-scheduled workshare loop.; ///; /// This takes a \p LoopInfo representing a canonical loop, such as the one; /// created by \p createCanonicalLoop and emits additional instructions to; /// turn it into a workshare loop. In particular, it calls to an OpenMP; /// runtime function in the preheader to obtain the loop bounds to be used in; /// the current thread, updates the relevant instructions in the canonical; /// loop and calls to an OpenMP runtime finalization function after the loop.; ///; /// \param DL Debug location for instructions added for the; /// workshare-loop construct itself.; /// \param CLI A descriptor of the canonical loop to workshare.; /// \param AllocaIP An insertion point for Alloca instructions usable in the; /// preheader of the loop.; /// \param NeedsBarrier Indicates whether a barrier must be inserted after; /// the loop.; ///; /// \returns Point where to insert code after the workshare construct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:51,schedul,scheduled,51,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Modifies the canonical loop to be a statically-scheduled workshare loop; /// which is executed on the device; ///; /// This takes a \p CLI representing a canonical loop, such as the one; /// created by \see createCanonicalLoop and emits additional instructions to; /// turn it into a workshare loop. In particular, it calls to an OpenMP; /// runtime function in the preheader to call OpenMP device rtl function; /// which handles worksharing of loop body interations.; ///; /// \param DL Debug location for instructions added for the; /// workshare-loop construct itself.; /// \param CLI A descriptor of the canonical loop to workshare.; /// \param AllocaIP An insertion point for Alloca instructions usable in the; /// preheader of the loop.; /// \param LoopType Information about type of loop worksharing.; /// It corresponds to type of loop workshare OpenMP pragma.; ///; /// \returns Point where to insert code after the workshare construct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:51,schedul,scheduled,51,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Modifies the canonical loop to be a workshare loop.; ///; /// This takes a \p LoopInfo representing a canonical loop, such as the one; /// created by \p createCanonicalLoop and emits additional instructions to; /// turn it into a workshare loop. In particular, it calls to an OpenMP; /// runtime function in the preheader to obtain the loop bounds to be used in; /// the current thread, updates the relevant instructions in the canonical; /// loop and calls to an OpenMP runtime finalization function after the loop.; ///; /// The concrete transformation is done by applyStaticWorkshareLoop,; /// applyStaticChunkedWorkshareLoop, or applyDynamicWorkshareLoop, depending; /// on the value of \p SchedKind and \p ChunkSize.; ///; /// \param DL Debug location for instructions added for the; /// workshare-loop construct itself.; /// \param CLI A descriptor of the canonical loop to workshare.; /// \param AllocaIP An insertion point for Alloca instructions usable in the; /// preheader of the loop.; /// \param NeedsBarrier Indicates whether a barrier must be insterted after; /// the loop.; /// \param SchedKind Scheduling algorithm to use.; /// \param ChunkSize The chunk size for the inner loop.; /// \param HasSimdModifier Whether the simd modifier is present in the; /// schedule clause.; /// \param HasMonotonicModifier Whether the monotonic modifier is present in; /// the schedule clause.; /// \param HasNonmonotonicModifier Whether the nonmonotonic modifier is; /// present in the schedule clause.; /// \param HasOrderedClause Whether the (parameterless) ordered clause is; /// present.; /// \param LoopType Information about type of loop worksharing.; /// It corresponds to type of loop workshare OpenMP pragma.; ///; /// \returns Point where to insert code after the workshare construct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:1115,Schedul,Scheduling,1115,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,4,"['Schedul', 'schedul']","['Scheduling', 'schedule']"
Energy Efficiency,/// Move the boundary of scheduled code by one SUnit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:25,schedul,scheduled,25,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduled']
Energy Efficiency,/// Move the boundary of scheduled code by one cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:25,schedul,scheduled,25,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['scheduled']
Energy Efficiency,/// Move the scheduler state forward by the specified number of Cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:13,schedul,scheduler,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],['scheduler']
Energy Efficiency,/// Move the scheduler state forward until the specified node's dependents are; /// ready and can be scheduled with no resource conflicts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:13,schedul,scheduler,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['schedul'],"['scheduled', 'scheduler']"
Energy Efficiency,/// NeedLatency - True if the scheduler will make use of latency information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:30,schedul,scheduler,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"/// NextLeaf - This is a pointer to the next leaf in the tree, allowing; /// efficient in-order forward iteration of the tree without traversal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:77,efficient,efficient,77,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,1,['efficient'],['efficient']
Energy Efficiency,"/// No constructor needs to be called, i.e. any bit pattern in the allocated memory represents a valid type; /// A trivially constructible field has a no-op ConstructValue() implementation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:67,allocate,allocated,67,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['allocate'],['allocated']
Energy Efficiency,"/// NoAlloc memory should not be allocated by the JITLinkMemoryManager at; /// all. It is used for sections that don't need to be transferred to the; /// executor process, typically metadata sections.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h:33,allocate,allocated,33,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h,1,['allocate'],['allocated']
Energy Efficiency,/// Nodes are allocated on Arenas; the destructor is never called.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:14,allocate,allocated,14,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,1,['allocate'],['allocated']
Energy Efficiency,/// Notify MachineSchedStrategy that ScheduleDAGMI has scheduled an; /// instruction and updated scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:37,Schedul,ScheduleDAGMI,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,3,"['Schedul', 'schedul']","['ScheduleDAGMI', 'scheduled']"
Energy Efficiency,/// Notify that the scheduler has finished scheduling the current region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:20,schedul,scheduler,20,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,/// NumBuckets - Length of the Buckets array. Always a power of 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:55,power,power,55,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['power'],['power']
Energy Efficiency,"/// NumUnexpArgTokens - The number of raw, unexpanded tokens for the; /// arguments. All of the actual argument tokens are allocated immediately; /// after the MacroArgs object in memory. This is all of the arguments; /// concatenated together, with 'EOF' markers at the end of each argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MacroArgs.h:123,allocate,allocated,123,interpreter/llvm-project/clang/include/clang/Lex/MacroArgs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MacroArgs.h,1,['allocate'],['allocated']
Energy Efficiency,/// Number of bytes allocated in the prologue for all local stack objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:20,allocate,allocated,20,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,1,['allocate'],['allocated']
Energy Efficiency,/// Number of bytes allocated statically by the callee.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:20,allocate,allocated,20,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Number of bytes in the LDS allocated statically. This field is only used; /// in the instruction selector and not part of the machine function info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h:31,allocate,allocated,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.h,1,['allocate'],['allocated']
Energy Efficiency,/// Number of cycles it takes to issue the instructions scheduled in this; /// zone. It is defined as: scheduled-micro-ops / issue-width + stalls.; /// See getStalls().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:56,schedul,scheduled,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],"['scheduled', 'scheduled-micro-ops']"
Energy Efficiency,/// Number of cycles to issue the instructions scheduled in this zone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:47,schedul,scheduled,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Number of fbarrier's used in the kernel and all functions it; /// calls. If the implementation uses group memory to allocate the; /// fbarriers then that amount must already be included in the; /// workgroup_group_segment_byte_size total.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:120,allocate,allocate,120,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['allocate'],['allocate']
Energy Efficiency,"/// ObjCCategoryDecl - Represents a category declaration. A category allows; /// you to add methods to an existing class (without subclassing or modifying; /// the original class interface or implementation:-). Categories don't allow; /// you to add instance data. The following example adds ""myMethod"" to all; /// NSView's within a process:; ///; /// \@interface NSView (MyViewMethods); /// - myMethod;; /// \@end; ///; /// Categories also allow you to split the implementation of a class across; /// several files (a feature more naturally supported in C++).; ///; /// Categories were originally inspired by dynamic languages such as Common; /// Lisp and Smalltalk. More traditional class-based languages (C++, Java); /// don't support this level of dynamism, which is both powerful and dangerous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:776,power,powerful,776,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['power'],['powerful']
Energy Efficiency,"/// Observe - Update liveness information to account for the current; /// instruction, which will not be scheduled.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:105,schedul,scheduled,105,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['schedul'],['scheduled']
Energy Efficiency,/// Obtain the size of the area allocated by the callee for arguments.; /// CallingConv::FastCall affects the value for O32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h:32,allocate,allocated,32,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsABIInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Offsets to the stored exprs.; /// This enumeration contains offsets to all the pointers to children; /// expressions stored in OMPLoopDirective.; /// The first 9 children are necessary for all the loop directives,; /// the next 8 are specific to the worksharing ones, and the next 11 are; /// used for combined constructs containing two pragmas associated to loops.; /// After the fixed children, three arrays of length NumAssociatedLoops are; /// allocated: loop counters, their updates and final values.; /// PrevLowerBound and PrevUpperBound are used to communicate blocking; /// information in composite constructs which require loop blocking; /// DistInc is used to generate the increment expression for the distribute; /// loop when combined with a further nested loop; /// PrevEnsureUpperBound is used as the EnsureUpperBound expression for the; /// for loop when combined with a previous distribute loop in the same pragma; /// (e.g. 'distribute parallel for'); ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:452,allocate,allocated,452,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['allocate'],['allocated']
Energy Efficiency,"/// On PowerPC, we leverage machine combiner pass to reduce register pressure; /// when the register pressure is high for one BB.; /// Return true if register pressure for \p MBB is high and ABI is supported; /// to reduce register pressure. Otherwise return false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:7,Power,PowerPC,7,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,3,"['Power', 'reduce']","['PowerPC', 'reduce']"
Energy Efficiency,"/// On PowerPC, we try to reassociate FMA chain which will increase; /// instruction size. Set extension resource length limit to 1 for edge case.; /// Resource Length is calculated by scaled resource usage in getCycles().; /// Because of the division in getCycles(), it returns different cycles due to; /// legacy scaled resource usage. So new resource length may be same with; /// legacy or 1 bigger than legacy.; /// We need to execlude the 1 bigger case even the resource length is not; /// perserved for more FMA chain reassociations on PowerPC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:7,Power,PowerPC,7,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,2,['Power'],['PowerPC']
Energy Efficiency,/// Only allocate objects in the tail padding of a base class if; /// the base class is not POD according to the rules of C++ TR1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h:9,allocate,allocate,9,interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,1,['allocate'],['allocate']
Energy Efficiency,/// Only allocate objects in the tail padding of a base class if; /// the base class is not POD according to the rules of C++11.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h:9,allocate,allocate,9,interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,1,['allocate'],['allocate']
Energy Efficiency,/// Only look for allocation functions in the scope of the; /// allocated class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:64,allocate,allocated,64,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Only reduce the size if significant enough?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:9,reduce,reduce,9,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['reduce'],['reduce']
Energy Efficiency,/// Opcode of the current instruction in the schedule data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:45,schedul,schedule,45,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// OpcodeOffset - This is a cache used to dispatch efficiently into isel; /// state machines that start with a OPC_SwitchOpcode node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:52,efficient,efficiently,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,1,['efficient'],['efficiently']
Energy Efficiency,/// OpenMP attributes for 'schedule' clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenMPKinds.h:27,schedul,schedule,27,interpreter/llvm-project/clang/include/clang/Basic/OpenMPKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenMPKinds.h,1,['schedul'],['schedule']
Energy Efficiency,/// OpenMP modifiers for 'schedule' clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenMPKinds.h:26,schedul,schedule,26,interpreter/llvm-project/clang/include/clang/Basic/OpenMPKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/OpenMPKinds.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Optimize a series of operands to an 'add' instruction. This; /// optimizes based on identities. If it can be reduced to a single Value, it; /// is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:113,reduce,reduced,113,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['reduce'],['reduced']
Energy Efficiency,"/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.; /// This optimizes based on identities. If it can be reduced to a single Value,; /// it is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:129,reduce,reduced,129,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['reduce'],['reduced']
Energy Efficiency,"/// Optimize a series of operands to an 'xor' instruction. If it can be reduced; /// to a single Value, it is returned, otherwise the Ops list is mutated as; /// necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:72,reduce,reduced,72,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['reduce'],['reduced']
Energy Efficiency,"/// Optimize quickly without destroying debuggability.; ///; /// This level is tuned to produce a result from the optimizer as quickly; /// as possible and to avoid destroying debuggability. This tends to result; /// in a very good development mode where the compiled code will be; /// immediately executed as part of testing. As a consequence, where; /// possible, we would like to produce efficient-to-execute code, but not; /// if it significantly slows down compilation or would prevent even basic; /// debugging of the resulting binary.; ///; /// As an example, complex loop transformations such as versioning,; /// vectorization, or fusion don't make sense here due to the degree to; /// which the executed code differs from the source code, and the compile; /// time cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:391,efficient,efficient-to-execute,391,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,1,['efficient'],['efficient-to-execute']
Energy Efficiency,"/// Optimized method to evaluate at the same time the function value and derivative at a point x.; /// Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; /// Derived class should implement this method if performances play an important role and if it is faster to; /// evaluate value and derivative at the same time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:168,efficient,efficient,168,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Optimized method to evaluate at the same time the function value and derivative at a point x.; /// Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; /// Derived class should implement this method if performances play an important role and if it is faster to; /// evaluate value and derivative at the same time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:168,efficient,efficient,168,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,1,['efficient'],['efficient']
Energy Efficiency,/// Optionally override the per-region scheduling policy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:39,schedul,scheduling,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Orders nodes according to selected style.; ///; /// Typically, a scheduling algorithm will implement schedule() without; /// overriding enterRegion() or exitRegion().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:69,schedul,scheduling,69,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,2,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"/// Output all diffs in \p DiffsByFilesPresent as a JSON report. This is; /// intended for consumption by external tools.; ///; /// \p InputFileNameA - File A used to produce the report.; /// \p InputFileNameB - File B used ot produce the report.; /// \p OS - Output stream.; ///; /// JSON output includes:; /// - \p InputFileNameA and \p InputFileNameB under ""Files"".; /// - Functions present in both files under ""InBoth"".; /// - Functions present only in A in ""OnlyInA"".; /// - Functions present only in B in ""OnlyInB"".; /// - Instruction count and stack size differences for each function.; ///; /// Differences are represented using [count_a, count_b]. The actual difference; /// can be computed via count_b - count_a.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp:91,consumption,consumption,91,interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-remarkutil/RemarkSizeDiff.cpp,1,['consumption'],['consumption']
Energy Efficiency,/// Override generic scheduling policy within a region.; ///; /// This is a convenient way for targets that don't provide any custom; /// scheduling heuristics (no custom MachineSchedStrategy) to make; /// changes to the generic scheduling policy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:21,schedul,scheduling,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,3,['schedul'],['scheduling']
Energy Efficiency,/// Override the contents of the given source file by providing an; /// already-allocated buffer.; ///; /// \param SourceFile the source file whose contents will be overridden.; ///; /// \param Buffer the memory buffer whose contents will be used as the; /// data in the given source file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:80,allocate,allocated,80,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,2,['allocate'],['allocated']
Energy Efficiency,"/// Override to return false to tell LLVM no stub space will be needed.; /// This requires some guarantees depending on architecuture, but when; /// you know what you are doing it saves allocated space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:186,allocate,allocated,186,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['allocate'],['allocated']
Energy Efficiency,/// PDBContext; /// This data structure is the top level entity that deals with PDB debug; /// information parsing. This data structure exists only when there is a; /// need for a transparent interface to different debug information formats; /// (e.g. PDB and DWARF). More control and power over the debug information; /// access can be had by using the PDB interfaces directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBContext.h:285,power,power,285,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBContext.h,1,['power'],['power']
Energy Efficiency,/// PPC32_SVR4_ABIInfo - The 32-bit PowerPC ELF (SVR4) ABI information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:36,Power,PowerPC,36,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['Power'],['PowerPC']
Energy Efficiency,/// PPC64LinuxTargetObjectFile - This implementation is used for; /// 64-bit PowerPC Linux.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h:77,Power,PowerPC,77,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetObjectFile.h,1,['Power'],['PowerPC']
Energy Efficiency,/// PPC64_SVR4_ABIInfo - The 64-bit PowerPC ELF (SVR4) ABI information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:36,Power,PowerPC,36,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['Power'],['PowerPC']
Energy Efficiency,/// PPCFunctionInfo - This class is derived from MachineFunction private; /// PowerPC target-specific information for each MachineFunction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:78,Power,PowerPC,78,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,1,['Power'],['PowerPC']
Energy Efficiency,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:115,Power,PowerPC,115,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,1,['Power'],['PowerPC']
Energy Efficiency,/// PPCII - This namespace holds all of the PowerPC target-specific; /// per-instruction flags. These must match the corresponding definitions in; /// PPC.td and PPCInstrFormats.td.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h:44,Power,PowerPC,44,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.h,1,['Power'],['PowerPC']
Energy Efficiency,"/// PPCLinuxAsmPrinter - PowerPC assembly printer, customized for Linux",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:25,Power,PowerPC,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['Power'],['PowerPC']
Energy Efficiency,/// PPCOperand - Instances of this class represent a parsed PowerPC machine; /// instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:60,Power,PowerPC,60,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,1,['Power'],['PowerPC']
Energy Efficiency,/// PPCTargetInfo::getTargetDefines - Return a set of the PowerPC-specific; /// #defines that are not tied to a specific subtarget.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:58,Power,PowerPC-specific,58,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,1,['Power'],['PowerPC-specific']
Energy Efficiency,/// Pad with zeroes at the current file position until the current file; /// position matches the specified alignment.; ///; /// \param Align An integer speciying the desired alignment. This does not; /// need to be a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FileWriter.h:218,power,power,218,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FileWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FileWriter.h,1,['power'],['power']
Energy Efficiency,"/// Parallel decompression and unpacking of the pages in the given cluster. The unzipped pages are supposed; /// to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's; /// unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the; /// actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set; /// if implicit multi-threading is turned on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:369,schedul,scheduler,369,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,2,['schedul'],['scheduler']
Energy Efficiency,"/// ParamInfo - An array of paraminfo objects is allocated whenever a function; /// declarator is parsed. There are two interesting styles of parameters; /// here:; /// K&R-style identifier lists and parameter type lists. K&R-style identifier; /// lists will have information about the identifier, but no type information.; /// Parameter type lists will have type info (if the actions module provides; /// it), but may have null identifier info: e.g. for 'void foo(int X, int)'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:49,allocate,allocated,49,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Parse a textual pass pipeline description into a \c; /// ModulePassManager.; ///; /// The format of the textual pass pipeline description looks something like:; ///; /// module(function(instcombine,sroa),dce,cgscc(inliner,function(...)),...); ///; /// Pass managers have ()s describing the nest structure of passes. All passes; /// are comma separated. As a special shortcut, if the very first pass is not; /// a module pass (as a module pass manager is), this will automatically form; /// the shortest stack of pass managers that allow inserting that first pass.; /// So, assuming function passes 'fpassN', CGSCC passes 'cgpassN', and loop; /// passes 'lpassN', all of these are valid:; ///; /// fpass1,fpass2,fpass3; /// cgpass1,cgpass2,cgpass3; /// lpass1,lpass2,lpass3; ///; /// And they are equivalent to the following (resp.):; ///; /// module(function(fpass1,fpass2,fpass3)); /// module(cgscc(cgpass1,cgpass2,cgpass3)); /// module(function(loop(lpass1,lpass2,lpass3))); ///; /// This shortcut is especially useful for debugging and testing small pass; /// combinations.; ///; /// The sequence of passes aren't necessarily the exact same kind of pass.; /// You can mix different levels implicitly if adaptor passes are defined to; /// make them work. For example,; ///; /// mpass1,fpass1,fpass2,mpass2,lpass1; ///; /// This pipeline uses only one pass manager: the top-level module manager.; /// fpass1,fpass2 and lpass1 are added into the top-level module manager; /// using only adaptor passes. No nested function/loop pass managers are; /// added. The purpose is to allow easy pass testing when the user; /// specifically want the pass to run under a adaptor directly. This is; /// preferred when a pipeline is largely of one type, but one or just a few; /// passes are of different types(See PassBuilder.cpp for examples).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:1210,adapt,adaptor,1210,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,3,['adapt'],['adaptor']
Energy Efficiency,"/// Parse either a function-definition or a declaration. We can't tell which; /// we have until we read up to the compound-statement in function-definition.; /// TemplateParams, if non-NULL, provides the template parameters when we're; /// parsing a C++ template-declaration.; ///; /// function-definition: [C99 6.9.1]; /// decl-specs declarator declaration-list[opt] compound-statement; /// [C90] function-definition: [C99 6.7.1] - implicit int result; /// [C90] decl-specs[opt] declarator declaration-list[opt] compound-statement; ///; /// declaration: [C99 6.7]; /// declaration-specifiers init-declarator-list[opt] ';'; /// [!C99] init-declarator-list ';' [TODO: warn in c99 mode]; /// [OMP] threadprivate-directive; /// [OMP] allocate-directive [TODO]; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:731,allocate,allocate-directive,731,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['allocate'],['allocate-directive']
Energy Efficiency,"/// ParseCXXDeleteExpression - Parse a C++ delete-expression. Delete is used; /// to free memory allocated by new.; ///; /// This method is called to parse the 'delete' expression after the optional; /// '::' has been already parsed. If the '::' was present, ""UseGlobal"" is true; /// and ""Start"" is its location. Otherwise, ""Start"" is the location of the; /// 'delete' token.; ///; /// delete-expression:; /// '::'[opt] 'delete' cast-expression; /// '::'[opt] 'delete' '[' ']' cast-expression",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:97,allocate,allocated,97,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// ParseCXXNewExpression - Parse a C++ new-expression. New is used to allocate; /// memory in a typesafe manner and call constructors.; ///; /// This method is called to parse the new expression after the optional :: has; /// been already parsed. If the :: was present, ""UseGlobal"" is true and ""Start""; /// is its location. Otherwise, ""Start"" is the location of the 'new' token.; ///; /// new-expression:; /// '::'[opt] 'new' new-placement[opt] new-type-id; /// new-initializer[opt]; /// '::'[opt] 'new' new-placement[opt] '(' type-id ')'; /// new-initializer[opt]; ///; /// new-placement:; /// '(' expression-list ')'; ///; /// new-type-id:; /// type-specifier-seq new-declarator[opt]; /// [GNU] attributes type-specifier-seq new-declarator[opt]; ///; /// new-declarator:; /// ptr-operator new-declarator[opt]; /// direct-new-declarator; ///; /// new-initializer:; /// '(' expression-list[opt] ')'; /// [C++0x] braced-init-list; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:71,allocate,allocate,71,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['allocate'],['allocate']
Energy Efficiency,"/// Parsed a C++ 'new' expression (C++ 5.3.4).; ///; /// E.g.:; /// @code new (memory) int[size][4] @endcode; /// or; /// @code ::new Foo(23, ""hello"") @endcode; ///; /// \param StartLoc The first location of the expression.; /// \param UseGlobal True if 'new' was prefixed with '::'.; /// \param PlacementLParen Opening paren of the placement arguments.; /// \param PlacementArgs Placement new arguments.; /// \param PlacementRParen Closing paren of the placement arguments.; /// \param TypeIdParens If the type is in parens, the source range.; /// \param D The type to be allocated, as well as array dimensions.; /// \param Initializer The initializing expression or initializer-list, or null; /// if there is none.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:573,allocate,allocated,573,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['allocate'],['allocated']
Energy Efficiency,"/// Parsing of OpenMP clauses with single expressions and some additional; /// argument like 'schedule' or 'dist_schedule'.; ///; /// schedule-clause:; /// 'schedule' '(' [ modifier [ ',' modifier ] ':' ] kind [',' expression ]; /// ')'; ///; /// if-clause:; /// 'if' '(' [ directive-name-modifier ':' ] expression ')'; ///; /// defaultmap:; /// 'defaultmap' '(' modifier [ ':' kind ] ')'; ///; /// device-clause:; /// 'device' '(' [ device-modifier ':' ] expression ')'; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:94,schedul,schedule,94,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,3,['schedul'],"['schedule', 'schedule-clause']"
Energy Efficiency,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:335,schedul,schedule-clause,335,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,2,"['allocate', 'schedul']","['allocate-clause', 'schedule-clause']"
Energy Efficiency,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:182,allocate,allocate-directive,182,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,2,['allocate'],"['allocate', 'allocate-directive']"
Energy Efficiency,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:196,allocate,allocate-directive,196,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,2,['allocate'],"['allocate', 'allocate-directive']"
Energy Efficiency,"/// Partially unroll a loop.; ///; /// The CanonicalLoopInfo of the unrolled loop for use with chained; /// loop-associated directive can be requested using \p UnrolledCLI. Not; /// needing the CanonicalLoopInfo allows more efficient code generation by; /// deferring the actual unrolling to the LoopUnrollPass using loop metadata.; /// A loop-associated directive applied to the unrolled loop needs to know the; /// new trip count which means that if using a heuristically determined unroll; /// factor (\p Factor == 0), that factor must be computed immediately. We are; /// using the same logic as the LoopUnrollPass to derived the unroll factor,; /// but which assumes that some canonicalization has taken place (e.g.; /// Mem2Reg, LICM, GVN, Inlining, etc.). That is, the heuristic will perform; /// better when the unrolled loop's CanonicalLoopInfo is not needed.; ///; /// \param DL Debug location for instructions added by unrolling.; /// \param Loop The loop to unroll. The loop will be invalidated.; /// \param Factor The factor to unroll the loop by. A factor of 0; /// indicates that a heuristic should be used to determine; /// the unroll-factor.; /// \param UnrolledCLI If non-null, receives the CanonicalLoopInfo of the; /// partially unrolled loop. Otherwise, uses loop metadata; /// to defer unrolling to the LoopUnrollPass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:224,efficient,efficient,224,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Per-region scheduling driver, called back from; /// PostMachineScheduler::runOnMachineFunction. This is a simplified driver; /// that does not consider liveness or register pressure. It is useful for; /// PostRA scheduling and potentially other custom schedulers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,schedul,scheduling,15,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,['schedul'],"['schedulers', 'scheduling']"
Energy Efficiency,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:84,allocate,allocates,84,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,3,['allocate'],"['allocated', 'allocates']"
Energy Efficiency,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:60,schedul,schedule,60,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,2,['schedul'],['schedule']
Energy Efficiency,"/// PerformVCVTCombine - VCVT (floating-point to fixed-point, Advanced SIMD); /// can replace combinations of VMUL and VCVT (floating-point to integer); /// when the VMUL has a constant operand that is a power of 2.; ///; /// Example (assume d17 = <float 8.000000e+00, float 8.000000e+00>):; /// vmul.f32 d16, d17, d16; /// vcvt.s32.f32 d16, d16; /// becomes:; /// vcvt.s32.f32 d16, d16, #3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:204,power,power,204,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['power'],['power']
Energy Efficiency,"/// PerformVDIVCombine - VCVT (fixed-point to floating-point, Advanced SIMD); /// can replace combinations of VCVT (integer to floating-point) and VDIV; /// when the VDIV has a constant operand that is a power of 2.; ///; /// Example (assume d17 = <float 8.000000e+00, float 8.000000e+00>):; /// vcvt.f32.s32 d16, d16; /// vdiv.f32 d16, d17, d16; /// becomes:; /// vcvt.f32.s32 d16, d16, #3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:204,power,power,204,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['power'],['power']
Energy Efficiency,/// Performs Loop Strength Reduce Pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:27,Reduce,Reduce,27,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,1,['Reduce'],['Reduce']
Energy Efficiency,"/// Performs the ""real"" scheduling. Done before vectorization is actually; /// performed in a basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,schedul,scheduling,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:176,schedul,scheduling,176,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:180,schedul,scheduling,180,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,/// Pick the best node to balance the schedule. Implements MachineSchedStrategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:38,schedul,schedule,38,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['schedul'],['schedule']
Energy Efficiency,"/// Pick the next node to schedule, or return NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:26,schedul,schedule,26,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Pick the next node to schedule, or return NULL. Set IsTopNode to true to; /// schedule the node at the top of the unscheduled region. Otherwise it will; /// be scheduled at the bottom.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:26,schedul,schedule,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,3,['schedul'],"['schedule', 'scheduled']"
Energy Efficiency,/// Pick the next node to schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,schedul,schedule,26,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// Pointer to the HazardRecognizer that tracks the scheduler state for; /// the current region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:52,schedul,scheduler,52,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,/// Pointer to the buffer allocated by caller for bitcode writing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:26,allocate,allocated,26,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,2,['allocate'],['allocated']
Energy Efficiency,/// Points just beyond the last slot known to have been allocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h:56,allocate,allocated,56,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,1,['allocate'],['allocated']
Energy Efficiency,/// Policy for scheduling the next instruction in the candidate's zone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:15,schedul,scheduling,15,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Pops up a GraphViz/gv window with the ScheduleDAG rendered using 'dot'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:42,Schedul,ScheduleDAG,42,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['Schedul'],['ScheduleDAG']
Energy Efficiency,/// Populate the BundleOpInfo instances and the Use& vector from \p; /// Bundles. Return the op_iterator pointing to the Use& one past the last; /// last bundle operand use.; ///; /// Each \p OperandBundleDef instance is tracked by a OperandBundleInfo; /// instance allocated in this User's descriptor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:266,allocate,allocated,266,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Populate the IC worklist from a function, by walking it in reverse; /// post-order and adding all reachable code to the worklist.; ///; /// This has a couple of tricks to make the code faster and more powerful. In; /// particular, we constant fold and DCE instructions as we go, to avoid adding; /// them to the worklist (this significantly speeds up instcombine on code where; /// many instructions are dead or constant). Additionally, if we find a branch; /// whose condition is a known constant, we only visit the reachable successors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:205,power,powerful,205,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['power'],['powerful']
Energy Efficiency,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:537,schedul,scheduling,537,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,2,['schedul'],"['scheduler', 'scheduling']"
Energy Efficiency,"/// Populates fNextRanges with the next set of entry ranges. Moves files from the staging area as necessary; /// and aligns ranges with cluster boundaries for scheduling the tail of files.; /// Upon return, the fNextRanges list is ordered. It has usually fNSlots elements; fewer if there; /// is not enough work to give at least one cluster to every slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:159,schedul,scheduling,159,tree/dataframe/inc/ROOT/RNTupleDS.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx,1,['schedul'],['scheduling']
Energy Efficiency,"/// Post-allocation passes.; ///; /// These passes are called on the graph after memory has been allocated and; /// defined nodes have been assigned their final addresses, but before the; /// context has been notified of these addresses. At this point externals; /// have not been resolved, and symbol content has not yet been copied into; /// working memory.; ///; /// Notable use cases: Setting up data structures associated with addresses; /// of defined symbols (e.g. a mapping of __dso_handle to JITDylib* for the; /// JIT runtime) -- using a PostAllocationPass for this ensures that the; /// data structures are in-place before any query for resolved symbols; /// can complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:97,allocate,allocated,97,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Post-prune passes.; ///; /// These passes are called on the graph after dead stripping, but before; /// memory is allocated or nodes assigned their final addresses.; ///; /// Notable use cases: Building GOT, stub, and TLV symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:118,allocate,allocated,118,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Post-visit the C++ operator new's allocation call.; ///; /// Execution of C++ operator new consists of the following phases: (1) call; /// default or overridden operator new() to allocate memory (2) cast the; /// return value of operator new() from void pointer type to class pointer; /// type, (3) assuming that the value is non-null, call the object's; /// constructor over this pointer, (4) declare that the value of the; /// new-expression is this pointer. This callback is called between steps; /// (2) and (3). Post-call for the allocator is called after step (1).; /// Pre-statement for the new-expression is called on step (4) when the value; /// of the expression is evaluated.; /// \param NE The C++ new-expression that triggered the allocation.; /// \param Target The allocated region, casted to the class type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:183,allocate,allocate,183,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,/// PostGenericScheduler - Interface to the scheduling algorithm used by; /// ScheduleDAGMI.; ///; /// Callbacks from ScheduleDAGMI:; /// initPolicy -> initialize(DAG) -> registerRoots -> pickNode ...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:44,schedul,scheduling,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,3,"['Schedul', 'schedul']","['ScheduleDAGMI', 'scheduling']"
Energy Efficiency,/// PostMachineScheduler - This pass schedules machine instructions postRA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:37,schedul,schedules,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['schedul'],['schedules']
Energy Efficiency,/// PostRA scheduling does not track pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:11,schedul,scheduling,11,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduling']
Energy Efficiency,/// PostRAScheduler - This pass performs post register allocation; /// scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:71,schedul,scheduling,71,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['schedul'],['scheduling']
Energy Efficiency,/// PowerPC instructions that have SCALAR_TO_VECTOR semantics tend to; /// place the value into the least significant element of the most; /// significant doubleword in the vector. This is not element zero for; /// anything smaller than a doubleword on either endianness. This node has; /// the same semantics as SCALAR_TO_VECTOR except that the value remains in; /// the aforementioned location in the vector register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:4,Power,PowerPC,4,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['Power'],['PowerPC']
Energy Efficiency,"/// Pre-fixup passes.; ///; /// These passes are called on the graph after memory has been allocated,; /// content copied into working memory, and all nodes (including externals); /// have been assigned their final addresses, but before any fixups have been; /// applied.; ///; /// Notable use cases: Late link-time optimizations like GOT and stub; /// elimination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:91,allocate,allocated,91,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['allocate'],['allocated']
Energy Efficiency,/// PreEmitNoops - This callback is invoked prior to emitting an instruction.; /// It should return the number of noops to emit prior to the provided; /// instruction.; /// Note: This is only used during PostRA scheduling. EmitNoop is not called; /// for these noops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:211,schedul,scheduling,211,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Predicate canonicalization reduces the number of patterns that need to be; /// matched by other transforms. For example, we may swap the operands of a; /// conditional branch or select to create a compare with a canonical; /// (inverted) predicate which is then more likely to be matched with other; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:31,reduce,reduces,31,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['reduce'],['reduces']
Energy Efficiency,/// Prepares to perform scheduling in the given block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:24,schedul,scheduling,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// PrescheduleNodesWithMultipleUses - Nodes with multiple uses; /// are not handled well by the general register pressure reduction; /// heuristics. When presented with code like this:; ///; /// N; /// / |; /// / |; /// U store; /// |; /// ...; ///; /// the heuristics tend to push the store up, but since the; /// operand of the store has another use (U), this would increase; /// the length of that other use (the U->N edge).; ///; /// This function transforms code like the above to route U's; /// dependence through the store when possible, like this:; ///; /// N; /// ||; /// ||; /// store; /// |; /// U; /// |; /// ...; ///; /// This results in the store being scheduled immediately; /// after N, which shortens the U->N live range, reducing; /// register pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:668,schedul,scheduled,668,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"/// Preserved analyses across SCCs.; ///; /// We specifically want to allow CGSCC passes to mutate ancestor IR; /// (changing both the CG structure and the function IR itself). However,; /// this means we need to take special care to correctly mark what analyses; /// are preserved *across* SCCs. We have to track this out-of-band here; /// because within the main `PassManager` infrastructure we need to mark; /// everything within an SCC as preserved in order to avoid repeatedly; /// invalidating the same analyses as we unnest pass managers and adaptors.; /// So we track the cross-SCC version of the preserved analyses here from any; /// code that does direct invalidation of SCC analyses, and then use it; /// whenever we move forward in the post-order walk of SCCs before running; /// passes over the new SCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:549,adapt,adaptors,549,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['adapt'],['adaptors']
Energy Efficiency,"/// PrevEUB - expression similar to EUB but to be used when loop; /// scheduling uses PrevLB and PrevUB (e.g. in 'distribute parallel for'; /// when ensuring that the UB is either the calculated UB by the runtime or; /// the end of the assigned distribute chunk); /// expression UB = min (UB, PrevUB)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:70,schedul,scheduling,70,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['schedul'],['scheduling']
Energy Efficiency,/// PreviousLowerBound - local variable passed to runtime in the; /// enclosing schedule or null if that does not apply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:80,schedul,schedule,80,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['schedul'],['schedule']
Energy Efficiency,/// PreviousUpperBound - local variable passed to runtime in the; /// enclosing schedule or null if that does not apply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:80,schedul,schedule,80,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['schedul'],['schedule']
Energy Efficiency,/// Print adaptors and pass managers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/StandardInstrumentations.h:10,adapt,adaptors,10,interpreter/llvm-project/llvm/include/llvm/Passes/StandardInstrumentations.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/StandardInstrumentations.h,1,['adapt'],['adaptors']
Energy Efficiency,/// Print execution trace of the schedule top-down or bottom-up.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:33,schedul,schedule,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['schedule']
Energy Efficiency,/// Print the schedule before exiting the region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:14,schedul,schedule,14,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['schedul'],['schedule']
Energy Efficiency,/// Print the schedule information to the given output.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,schedul,schedule,14,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['schedule']
Energy Efficiency,"/// Process the nodes in the computed order and create the pipelined schedule; /// of the instructions, if possible. Return true if a schedule is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:69,schedul,schedule,69,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['schedul'],['schedule']
Energy Efficiency,"/// Produce a map of the last lexical scope that uses a block, using the; /// scopes DFSOut number. Mapping is block-number to DFSOut.; /// \p EjectionMap Pre-allocated vector in which to install the built ma.; /// \p ScopeToDILocation Mapping of LexicalScopes to their DILocations.; /// \p AssignBlocks Map of blocks where assignments happen for a scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:159,allocate,allocated,159,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['allocate'],['allocated']
Energy Efficiency,/// Produce the code to do a primitive release.; /// [tmp drain];,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:58,drain,drain,58,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['drain'],['drain']
Energy Efficiency,/// ProgramState traits to store the currently allocated (and not yet freed); /// symbols. This is a map from the allocated content symbol to the; /// corresponding AllocationState.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:47,allocate,allocated,47,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,2,['allocate'],['allocated']
Energy Efficiency,/// Provide an instruction scheduling machine model to CodeGen passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:27,schedul,scheduling,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Provide extra details about the machine processor.; ///; /// This is a collection of ""optional"" processor information that is not; /// normally used by the LLVM machine schedulers, but that can be consumed by; /// external tools like llvm-mca to improve the quality of the peformance; /// analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:173,schedul,schedulers,173,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['schedul'],['schedulers']
Energy Efficiency,/// Provide more efficient getOperand methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:17,efficient,efficient,17,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Provides a cast trait that strips `const` from types to make it easier to; /// implement a const-version of a non-const cast. It just removes boilerplate; /// and reduces the amount of code you as the user need to implement. You can; /// use it like this:; ///; /// template<> struct CastInfo<foo, bar> {; /// ...verbose implementation...; /// };; ///; /// template<> struct CastInfo<foo, const bar> : public; /// ConstStrippingForwardingCast<foo, const bar, CastInfo<foo, bar>> {};; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:167,reduce,reduces,167,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,1,['reduce'],['reduces']
Energy Efficiency,"/// Provides notifications for file changes in a directory.; ///; /// Invokes client-provided function on every filesystem event in the watched; /// directory. Initially the watched directory is scanned and for every file; /// found, an event is synthesized as if the file was added.; ///; /// This is not a general purpose directory monitoring tool - list of; /// limitations follows.; ///; /// Only flat directories with no subdirectories are supported. In case; /// subdirectories are present the behavior is unspecified - events *might* be; /// passed to Receiver on macOS (due to FSEvents being used) while they; /// *probably* won't be passed on Linux (due to inotify being used).; ///; /// Known potential inconsistencies; /// - For files that are deleted befor the initial scan processed them, clients; /// might receive Removed notification without any prior Added notification.; /// - Multiple notifications might be produced when a file is added to the; /// watched directory during the initial scan. We are choosing the lesser evil; /// here as the only known alternative strategy would be to invalidate the; /// watcher instance and force user to create a new one whenever filesystem; /// event occurs during the initial scan but that would introduce continuous; /// restarting failure mode (watched directory is not always ""owned"" by the same; /// process that is consuming it). Since existing clients can handle duplicate; /// events well, we decided for simplicity.; ///; /// Notifications are provided only for changes done through local user-space; /// filesystem interface. Specifically, it's unspecified if notification would; /// be provided in case of a:; /// - a file mmap-ed and changed; /// - a file changed via remote (NFS) or virtual (/proc) FS access to monitored; /// directory; /// - another filesystem mounted to the watched directory; ///; /// No support for LLVM VFS.; ///; /// It is unspecified whether notifications for files being deleted are sent in; /// case the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h:334,monitor,monitoring,334,interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/DirectoryWatcher/DirectoryWatcher.h,1,['monitor'],['monitoring']
Energy Efficiency,/// Put all instructions into the ReadyList which are ready for scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:64,schedul,scheduling,64,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Query kd-tree for a nearest neighbor point; /// @note external point-buffer is used to reduce kd-tree's memory footprint; /// @param point query point position; /// @param points external point-buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/KDTree.h:91,reduce,reduce,91,math/mathcore/src/CDT/KDTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/KDTree.h,1,['reduce'],['reduce']
Energy Efficiency,"/// RBDT uses a more efficient representation of the BDT in flat arrays. This; /// function translates the indices to the RBDT indices. In RBDT, leaf nodes; /// are stored in separate arrays. To encode this, the sign of the index is; /// flipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RBDT.cxx:21,efficient,efficient,21,tmva/tmva/src/RBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RBDT.cxx,1,['efficient'],['efficient']
Energy Efficiency,"/// ROOT-3579 Binned clone seemed to create problems with chains.; /// Code adapted from example in JIRA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx:76,adapt,adapted,76,roofit/roofitcore/test/testRooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataSet.cxx,1,['adapt'],['adapted']
Energy Efficiency,"/// Read the packed and compressed bytes of a page into the memory buffer provided by `sealedPage`. The sealed page; /// can be used subsequently in a call to `RPageSink::CommitSealedPage`.; /// The `fSize` and `fNElements` member of the sealedPage parameters are always set. If `sealedPage.fBuffer` is; /// `nullptr`, no data will be copied but the returned size information can be used by the caller to allocate a large; /// enough buffer and call `LoadSealedPage` again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:405,allocate,allocate,405,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['allocate'],['allocate']
Energy Efficiency,"/// Reads the array cookie associated with the given pointer,; /// if it has one.; ///; /// \param Ptr - a pointer to the first element in the array; /// \param ElementType - the base element type of elements of the array; /// \param NumElements - an out parameter which will be initialized; /// with the number of elements allocated, or zero if there is no; /// cookie; /// \param AllocPtr - an out parameter which will be initialized; /// with a char* pointing to the address returned by the allocation; /// function; /// \param CookieSize - an out parameter which will be initialized; /// with the size of the cookie, or zero if there is no cookie",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:324,allocate,allocated,324,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,1,['allocate'],['allocated']
Energy Efficiency,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:36,monitor,monitoring,36,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,1,['monitor'],['monitoring']
Energy Efficiency,"/// RecedeCycle - This callback is invoked whenever the next bottom-up; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:94,schedul,scheduled,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Reclaim all the attributes in the given pool chain, which is; /// non-empty. Note that the current implementation is safe; /// against reclaiming things which were not actually allocated; /// with the allocator, although of course it's important to make; /// sure that their allocator lives at least as long as this one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:181,allocate,allocated,181,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['allocate'],['allocated']
Energy Efficiency,/// Record how resources have been allocated across the cycles of; /// the execution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:35,allocate,allocated,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['allocate'],['allocated']
Energy Efficiency,/// Record of what frame index has been allocated to specified allocas for; /// this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:40,allocate,allocated,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,1,['allocate'],['allocated']
Energy Efficiency,/// Record the next node in a scheduled cluster.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:30,schedul,scheduled,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree in file order and (though the mediation of; /// its helper) call hasValidRelocation() on each DIE that might be a 'root; /// DIE' (See DwarfLinker class comment).; ///; /// While walking the dependencies of root DIEs, this function is also called,; /// but during these dependency walks the file order is not respected. The; /// TF_DependencyWalk flag tells us which kind of traversal we are currently; /// doing.; ///; /// The recursive algorithm is implemented iteratively as a work list because; /// very deep recursion could exhaust the stack for large projects. The work; /// list acts as a scheduler for different types of work that need to be; /// performed.; ///; /// The recursive nature of the algorithm is simulated by running the ""main""; /// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs; /// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or; /// fixing up a computed property (UpdateChildIncompleteness,; /// UpdateRefIncompleteness).; ///; /// The return value indicates whether the DIE is incomplete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:824,schedul,scheduler,824,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['schedul'],['scheduler']
Energy Efficiency,"/// Recycle small arrays allocated from a BumpPtrAllocator.; ///; /// Arrays are allocated in a small number of fixed sizes. For each supported; /// array size, the ArrayRecycler keeps a free list of available arrays.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h:25,allocate,allocated,25,interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,2,['allocate'],['allocated']
Energy Efficiency,"/// Reduce a node of degree one.; ///; /// Propagate costs from the given node, which must be of degree one, to its; /// neighbor. Notify the problem domain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,1,['Reduce'],['Reduce']
Energy Efficiency,"/// Reduce a pair of compares that check if a value has exactly 1 bit set.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,/// Reduce a sequence of masked half-width multiplies to a single multiply.; /// ((XLow * YHigh) + (YLow * XHigh)) << HalfBits) + (XLow * YLow) --> X * Y,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,/// Reduce a sequence of min/max intrinsics with a common operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,/// Reduce a shift by a constant to an unmerge and a shift on a half sized; /// type. This will not produce a shift smaller than \p TargetShiftSize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['Reduce'],['Reduce']
Energy Efficiency,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:4,Reduce,Reduce,4,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,/// Reduce integer multiplication patterns that contain a (+/-1 << Z) factor.; /// Callers are expected to call this twice to handle commuted patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,/// Reduce logic-of-compares with equality to a constant by substituting a; /// common operand with the constant. Callers are expected to call this with; /// Cmp0/Cmp1 switched to handle logic op commutativity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"/// Reduce the number of arguments in this call expression. This is used for; /// example during error recovery to drop extra arguments. There is no way; /// to perform the opposite because: 1.) We don't track how much storage; /// we have for the argument array 2.) This would potentially require growing; /// the argument array, something we cannot support since the arguments are; /// stored in a trailing array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:4,Reduce,Reduce,4,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['Reduce'],['Reduce']
Energy Efficiency,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,/// Reduce the set \p Out to have at most one element for each mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['Reduce'],['Reduce']
Energy Efficiency,/// Reduce two-address instructions to two operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:4,Reduce,Reduce,4,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,"/// ReduceCrashingBlocks reducer - This works by setting the terminators of; /// all terminators except the specified basic blocks to a 'ret' instruction,; /// then running the simplifycfg pass. This has the effect of chopping up; /// the CFG really fast which can reduce large functions quickly.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Reduce,ReduceCrashingBlocks,4,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,3,"['Reduce', 'reduce']","['ReduceCrashingBlocks', 'reduce', 'reducer']"
Energy Efficiency,"/// ReduceCrashingConditionals reducer - This works by changing; /// conditional branches to unconditional ones, then simplifying the CFG; /// This has the effect of chopping up the CFG really fast which can reduce; /// large functions quickly.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Reduce,ReduceCrashingConditionals,4,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,3,"['Reduce', 'reduce']","['ReduceCrashingConditionals', 'reduce', 'reducer']"
Energy Efficiency,"/// ReduceCrashingFunctionAttributes reducer - This works by removing; /// attributes on a particular function and seeing if the program still crashes.; /// If it does, then keep the newer, smaller program.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Reduce,ReduceCrashingFunctionAttributes,4,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,2,"['Reduce', 'reduce']","['ReduceCrashingFunctionAttributes', 'reducer']"
Energy Efficiency,"/// ReduceCrashingFunctions reducer - This works by removing functions and; /// seeing if the program still crashes. If it does, then keep the newer,; /// smaller program.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Reduce,ReduceCrashingFunctions,4,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,2,"['Reduce', 'reduce']","['ReduceCrashingFunctions', 'reducer']"
Energy Efficiency,"/// ReduceCrashingGlobalInitializers - This works by removing global variable; /// initializers and seeing if the program still crashes. If it does, then we; /// keep that program and try again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Reduce,ReduceCrashingGlobalInitializers,4,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['Reduce'],['ReduceCrashingGlobalInitializers']
Energy Efficiency,/// ReduceCrashingInstructions reducer - This works by removing the specified; /// non-terminator instructions and replacing them with undef.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Reduce,ReduceCrashingInstructions,4,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,2,"['Reduce', 'reduce']","['ReduceCrashingInstructions', 'reducer']"
Energy Efficiency,/// ReduceCrashingMetadata reducer - This works by removing all metadata from; /// the specified instructions.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:4,Reduce,ReduceCrashingMetadata,4,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,2,"['Reduce', 'reduce']","['ReduceCrashingMetadata', 'reducer']"
Energy Efficiency,/// ReduceMBB - Reduce width of instructions in the specified basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Reduce,ReduceMBB,4,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,['Reduce'],"['Reduce', 'ReduceMBB']"
Energy Efficiency,"/// ReduceMI - Attempt to reduce MI, return true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Reduce,ReduceMI,4,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,"['Reduce', 'reduce']","['ReduceMI', 'reduce']"
Energy Efficiency,/// ReduceOpcodeMap - Maps wide opcode to index of entry in ReduceTable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Reduce,ReduceOpcodeMap,4,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,['Reduce'],"['ReduceOpcodeMap', 'ReduceTable']"
Energy Efficiency,/// ReduceTable - A static table with information on mapping from wide; /// opcodes to narrow,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Reduce,ReduceTable,4,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,['Reduce'],['ReduceTable']
Energy Efficiency,/// ReduceTo2Addr - Reduce a 32-bit instruction to a 16-bit two-address; /// instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:20,Reduce,Reduce,20,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['Reduce'],['Reduce']
Energy Efficiency,/// ReduceToNarrow - Reduce a 32-bit instruction to a 16-bit; /// non-two-address instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:4,Reduce,ReduceToNarrow,4,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,['Reduce'],"['Reduce', 'ReduceToNarrow']"
Energy Efficiency,"/// Reduces maps in FIFO order, by N SUs. This is better than turning; /// every Nth memory SU into BarrierChain in buildSchedGraph(), since; /// it avoids unnecessary edges between seen SUs above the new BarrierChain,; /// and those below it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:4,Reduce,Reduces,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['Reduce'],['Reduces']
Energy Efficiency,"/// Reduces the number of fp-to-int conversion when building a vector.; ///; /// If this vector is built out of floating to integer conversions,; /// transform it to a vector built out of floating point values followed by a; /// single floating to integer conversion of the vector.; /// Namely (build_vector (fptosi $A), (fptosi $B), ...); /// becomes (fptosi (build_vector ($A, $B, ...)))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:4,Reduce,Reduces,4,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Reduce'],['Reduces']
Energy Efficiency,/// Reduces width of instructions in the specified basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:4,Reduce,Reduces,4,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['Reduce'],['Reduces']
Energy Efficiency,"/// ReductionInfo maps from %ReductionOp to %PHInode and Instruction; /// %OutsideUser as it is shown in the IR:; ///; /// vector.body:; /// %PHInode = phi <vector type> [ zeroinitializer, %entry ],; /// [ %ReductionOp, %vector.body ]; /// ...; /// %ReductionOp = fadd i64 ...; /// ...; /// br i1 %condition, label %vector.body, %middle.block; ///; /// middle.block:; /// %OutsideUser = llvm.vector.reduce.fadd(..., %ReductionOp); ///; /// %OutsideUser can be `llvm.vector.reduce.fadd` or `fadd` preceding; /// `llvm.vector.reduce.fadd` when unroll factor isn't one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:399,reduce,reduce,399,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,3,['reduce'],['reduce']
Energy Efficiency,/// Reference to the item shared between tasks to reduce into.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:50,reduce,reduce,50,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['reduce'],['reduce']
Energy Efficiency,"/// RegAllocHints - This vector records register allocation hints for; /// virtual registers. For each virtual register, it keeps a pair of hint; /// type and hints vector making up the allocation hints. Only the first; /// hint may be target specific, and in that case this is reflected by the; /// first member of the pair being non-zero. If the hinted register is; /// virtual, it means the allocator should prefer the physical register; /// allocated to it if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:445,allocate,allocated,445,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:48,schedul,scheduling,48,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,5,['schedul'],['scheduling']
Energy Efficiency,/// Register an alternate mapping context.; ///; /// Returns a MappingContextID that can be used with the various schedule*(); /// API to switch in a different value map on-the-fly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:114,schedul,schedule,114,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Reinsert any remaining debug_values, just like the PostRA scheduler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:62,schedul,scheduler,62,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['schedul'],['scheduler']
Energy Efficiency,/// Reinsert debug_values recorded in ScheduleDAGInstrs::DbgValues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:38,Schedul,ScheduleDAGInstrs,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['Schedul'],['ScheduleDAGInstrs']
Energy Efficiency,/// Release ExitSU predecessors and setup scheduler queues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:42,schedul,scheduler,42,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduler']
Energy Efficiency,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:42,schedul,scheduler,42,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['schedul'],['scheduler']
Energy Efficiency,/// Release allocated arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h:12,allocate,allocated,12,interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h,1,['allocate'],['allocated']
Energy Efficiency,/// ReleaseModeModelRunner - production mode implementation of the; /// MLModelRunner. It uses an AOT-compiled SavedModel for efficient execution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:126,efficient,efficient,126,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,1,['efficient'],['efficient']
Energy Efficiency,/// Remember a generic side-effecting instruction as we proceed.; /// No other SU ever gets scheduled around it (except in the special; /// case of a huge region that gets reduced).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:92,schedul,scheduled,92,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,2,"['reduce', 'schedul']","['reduced', 'scheduled']"
Energy Efficiency,/// Remember instruction that precedes DBG_VALUE.; /// These are generated by buildSchedGraph but persist so they can be; /// referenced when emitting the final schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:161,schedul,schedule,161,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['schedul'],['schedule']
Energy Efficiency,/// Remove nodes that have been scheduled in previous NodeSets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:32,schedul,scheduled,32,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['schedul'],['scheduled']
Energy Efficiency,"/// Reorders the current graph to the most profitable order starting from; /// leaves to the root. It allows to rotate small subgraphs and reduce the; /// number of reshuffles if the leaf nodes use the same order. In this case we; /// can merge the orders and just shuffle user node instead of shuffling its; /// operands. Plus, even the leaf nodes have different orders, it allows to; /// sink reordering in the graph closer to the root node and merge it later; /// during analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:139,reduce,reduce,139,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['reduce'],['reduce']
Energy Efficiency,/// Replace all allocas in \p DynamicAllocas with code to allocate; /// space dynamically on the unsafe stack and store the dynamic unsafe stack; /// top to \p DynamicTop if non-null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:58,allocate,allocate,58,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['allocate'],['allocate']
Energy Efficiency,"/// Replace csincr-branch sequence by simple conditional branch; ///; /// Examples:; /// 1. \code; /// csinc w9, wzr, wzr, <condition code>; /// tbnz w9, #0, 0x44; /// \endcode; /// to; /// \code; /// b.<inverted condition code>; /// \endcode; ///; /// 2. \code; /// csinc w9, wzr, wzr, <condition code>; /// tbz w9, #0, 0x44; /// \endcode; /// to; /// \code; /// b.<condition code>; /// \endcode; ///; /// Replace compare and branch sequence by TBZ/TBNZ instruction when the; /// compare's constant operand is power of 2.; ///; /// Examples:; /// \code; /// and w8, w8, #0x400; /// cbnz w8, L1; /// \endcode; /// to; /// \code; /// tbnz w8, #10, L1; /// \endcode; ///; /// \param MI Conditional Branch; /// \return True when the simple conditional branch is generated; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:511,power,power,511,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['power'],['power']
Energy Efficiency,"/// Replaceable canonical proxy adaptor class that provides the link; /// between a canonical type and the accessors of the type.; ///; /// The CanProxyAdaptor is a replaceable class template that is instantiated; /// as part of each canonical proxy type. The primary template merely provides; /// redirection to the underlying type (T), e.g., @c PointerType. One can; /// provide specializations of this class template for each underlying type; /// that provide accessors returning canonical types (@c CanQualType) rather; /// than the more typical @c QualType, to propagate the notion of ""canonical""; /// through the system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h:32,adapt,adaptor,32,interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,1,['adapt'],['adaptor']
Energy Efficiency,"/// Represent the ILP of the subDAG rooted at a DAG node.; ///; /// ILPValues summarize the DAG subtree rooted at each node. ILPValues are; /// valid for all nodes regardless of their subtree membership.; ///; /// When computed using bottom-up DFS, this metric assumes that the DAG is a; /// forest of trees with roots at the bottom of the schedule branching upward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:340,schedul,schedule,340,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,1,['schedul'],['schedule']
Energy Efficiency,/// Represents a schedule for a single-block loop. For every instruction we; /// maintain a Cycle and Stage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:17,schedul,schedule,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Represents a type template specialization; the template; /// must be a class template, a type alias template, or a template; /// template parameter. A template which cannot be resolved to one of; /// these, e.g. because it is written with a dependent scope; /// specifier, is instead represented as a; /// @c DependentTemplateSpecializationType.; ///; /// A non-dependent template specialization type is always ""sugar"",; /// typically for a \c RecordType. For example, a class template; /// specialization type of \c vector<int> will refer to a tag type for; /// the instantiation \c std::vector<int, std::allocator<int>>; ///; /// Template specializations are dependent if either the template or; /// any of the template arguments are dependent, in which case the; /// type may also be canonical.; ///; /// Instances of this type are allocated with a trailing array of; /// TemplateArguments, followed by a QualType representing the; /// non-canonical aliased type when the template is a type alias; /// template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:839,allocate,allocated,839,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Represents immediate initialization of memory allocated by operator new,; /// eg. new T(123);.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/ConstructionContext.h:50,allocate,allocated,50,interpreter/llvm-project/clang/include/clang/Analysis/ConstructionContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/ConstructionContext.h,1,['allocate'],['allocated']
Energy Efficiency,/// Represents required padding such that a particular other set of fragments; /// does not cross a particular power-of-two boundary. The other fragments must; /// follow this one within the same section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h:111,power,power-of-two,111,interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h,1,['power'],['power-of-two']
Energy Efficiency,"/// Reserves buffer and LSUnit queue resources that are necessary to issue; /// this instruction.; ///; /// Returns true if instruction IR is ready to be issued to the underlying; /// pipelines. Note that this operation cannot fail; it assumes that a; /// previous call to method `isAvailable(IR)` returned `SC_AVAILABLE`.; ///; /// If IR is a memory operation, then the Scheduler queries the LS unit to; /// obtain a LS token. An LS token is used internally to track memory; /// dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:371,Schedul,Scheduler,371,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['Schedul'],['Scheduler']
Energy Efficiency,/// Reset - This callback is invoked when a new block of; /// instructions is about to be schedule. The hazard state should be; /// set to an initialized state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:90,schedul,schedule,90,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['schedul'],['schedule']
Energy Efficiency,/// Resolve a variant scheduling class for the given MCInst and CPU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:22,schedul,scheduling,22,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Resolves and cache a resolved scheduling class for an SUnit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:34,schedul,scheduling,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,2,['schedul'],['scheduling']
Energy Efficiency,/// Resource allocation strategy used by hardware scheduler resources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:50,schedul,scheduler,50,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['schedul'],['scheduler']
Energy Efficiency,/// Restore the current thread's priority to default scheduling priority.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:53,schedul,scheduling,53,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Retain/Release only useful when we allocate a AttrListInfo from the; /// BumpPtrAllocator, and not from the stack; so that we keep a pointer; // in the EntityInfo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h:39,allocate,allocate,39,interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXIndexDataConsumer.h,1,['allocate'],['allocate']
Energy Efficiency,/// Retrieve the allocator into which the code completion; /// strings should be allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:81,allocate,allocated,81,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['allocate'],['allocated']
Energy Efficiency,/// Retrieve the allocator used to allocate code completion strings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:35,allocate,allocate,35,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['allocate'],['allocate']
Energy Efficiency,"/// Retrieve the proxy-adaptor type.; ///; /// This arrow operator is used when CanProxyAdaptor has been specialized; /// for the given type T. In that case, we reference members of the; /// CanProxyAdaptor specialization. Otherwise, this operator will be hidden; /// by the arrow operator in the primary CanProxyAdaptor template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h:23,adapt,adaptor,23,interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,1,['adapt'],['adaptor']
Energy Efficiency,"/// Retrieves a pointer to the underlying (unqualified) type.; ///; /// This function requires that the type not be NULL. If the type might be; /// NULL, use the (slightly less efficient) \c getTypePtrOrNull().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:177,efficient,efficient,177,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Retrieves the ""common"" pointer shared by all (re-)declarations of; /// the same template. Calling this routine may implicitly allocate memory; /// for the common pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:130,allocate,allocate,130,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Return a Constant for a specified index's element.; /// Note that this has to compute a new constant to return, so it isn't as; /// efficient as getElementAsInteger/Float/Double.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:136,efficient,efficient,136,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,1,['efficient'],['efficient']
Energy Efficiency,/// Return a SCEV for the constant \p Power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:38,Power,Power,38,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['Power'],['Power']
Energy Efficiency,"/// Return a direct, mutable handle to the blocks set so that we can; /// mutate it efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h:84,efficient,efficiently,84,interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// Return a direct, mutable handle to the blocks vector so that we can; /// mutate it efficiently with techniques like `std::remove`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h:87,efficient,efficiently,87,interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,1,['efficient'],['efficiently']
Energy Efficiency,/// Return a heuristic for the machine scheduler to compare the profitability; /// of increasing one register pressure set versus another. The scheduler; /// will prefer increasing the register pressure of the set which returns; /// the largest value for this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:39,schedul,scheduler,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,2,['schedul'],['scheduler']
Energy Efficiency,"/// Return a list of unique pointers to Instruments, where each Instrument; /// is allocated by this function. See createInstrument to create Instrument; /// from a description and data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h:83,allocate,allocated,83,interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,1,['allocate'],['allocated']
Energy Efficiency,/// Return a node that can be scheduled in this cycle. Requirements:; /// (1) Ready: latency has been satisfied; /// (2) No Hazards: resources are available; /// (3) No Interferences: may unschedule to break register interferences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:30,schedul,scheduled,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['schedul'],['scheduled']
Energy Efficiency,/// Return a non-null DFS result if the scheduling strategy initialized it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:40,schedul,scheduling,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Return a non-zero value if the field is non-zero.; /// It is more efficient than `getField`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h:70,efficient,efficient,70,interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Bitfields.h,1,['efficient'],['efficient']
Energy Efficiency,/// Return a pass that reduces the size of vector constant pool loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:23,reduce,reduces,23,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,1,['reduce'],['reduces']
Energy Efficiency,"/// Return a reduction priority for @p V. A higher values means ""more reduced"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp:70,reduce,reduced,70,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOperandsSkip.cpp,1,['reduce'],['reduced']
Energy Efficiency,"/// Return a type that is \p Factor times smaller. Reduces the number of; /// elements if this is a vector, or the bitwidth for scalar/pointers. Does; /// not attempt to handle cases that aren't evenly divisible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:51,Reduce,Reduces,51,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,1,['Reduce'],['Reduces']
Energy Efficiency,/// Return allocated size by all allocators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PerThreadBumpPtrAllocator.h:11,allocate,allocated,11,interpreter/llvm-project/llvm/include/llvm/Support/PerThreadBumpPtrAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PerThreadBumpPtrAllocator.h,1,['allocate'],['allocated']
Energy Efficiency,/// Return an efficient buffer size for the underlying output mechanism.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:14,efficient,efficient,14,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['efficient'],['efficient']
Energy Efficiency,/// Return an iterator at the first process resource consumed by the given; /// scheduling class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:80,schedul,scheduling,80,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Return process memory usage.; /// This static function will return the total amount of memory allocated; /// by the process. This only counts the memory allocated via the malloc,; /// calloc and realloc functions and includes any ""free"" holes in the; /// allocated space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:98,allocate,allocated,98,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,3,['allocate'],['allocated']
Energy Efficiency,/// Return target scheduling preference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:18,schedul,scheduling,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['schedul'],['scheduling']
Energy Efficiency,"/// Return the *capacity* of the collection, i.e. the current total amount of space that has been allocated so far.; /// Same as `Capacity`. Use `GetEntries` to get the number of elements currently in the collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h:98,allocate,allocated,98,core/cont/inc/TCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Return the LLVM address of the given global entity.; ///; /// \param isForDefinition If true, the caller intends to define the; /// entity; the object returned will be an llvm::GlobalValue of; /// some sort. If false, the caller just intends to use the entity;; /// the object returned may be any sort of constant value, and the; /// code generator will schedule the entity for emission if a; /// definition has been registered with this code generator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ModuleBuilder.h:358,schedul,schedule,358,interpreter/llvm-project/clang/include/clang/CodeGen/ModuleBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ModuleBuilder.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Return the LLVM name for an intrinsic, such as ""llvm.ppc.altivec.lvx"" or; /// ""llvm.ssa.copy.p0s_s.1"". Note, this version of getName supports overloads.; /// This is less efficient than the StringRef version of this function. If no; /// overloads are required, it is safe to use this version, but better to use; /// the StringRef version. If one of the types is based on an unnamed type, a; /// function type will be computed. Providing FT will avoid this computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Intrinsics.h:175,efficient,efficient,175,interpreter/llvm-project/llvm/include/llvm/IR/Intrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Intrinsics.h,1,['efficient'],['efficient']
Energy Efficiency,"/// Return the alignment (in bits) of the thrown exception object. This is; /// only meaningful for targets that allocate C++ exceptions in a system; /// runtime, such as those using the Itanium C++ ABI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:113,allocate,allocate,113,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['allocate'],['allocate']
Energy Efficiency,"/// Return the alignment (in bytes) of the thrown exception object. This is; /// only meaningful for targets that allocate C++ exceptions in a system; /// runtime, such as those using the Itanium C++ ABI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:114,allocate,allocate,114,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['allocate'],['allocate']
Energy Efficiency,/// Return the alignment from an allocate directive if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:33,allocate,allocate,33,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['allocate'],['allocate']
Energy Efficiency,/// Return the alignment of the memory that is being allocated by the; /// instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:53,allocate,allocated,53,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,3,['allocate'],['allocated']
Energy Efficiency,"/// Return the alignment specified in an allocate directive, if present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:41,allocate,allocate,41,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['allocate'],['allocate']
Energy Efficiency,/// Return the basic block label. It is not necessarilly unique because a block; /// contains multiple scheduling regions. But it is fine for visualization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:103,schedul,scheduling,103,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['schedul'],['scheduling']
Energy Efficiency,"/// Return the basic size of this type if it is a primitive type. These are; /// fixed by LLVM and are not target-dependent.; /// This will return zero if the type does not have a size or is not a; /// primitive type.; ///; /// If this is a scalable vector type, the scalable property will be set and; /// the runtime size will be a positive integer multiple of the base size.; ///; /// Note that this may not reflect the size of memory allocated for an; /// instance of the type or the number of bytes that are written when an; /// instance of the type is stored to memory. The DataLayout class provides; /// additional query functions to provide this information.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h:437,allocate,allocated,437,interpreter/llvm-project/llvm/include/llvm/IR/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Return the constant as an llvm::Align, interpreting `0` as `Align(1)`.; /// Note that this method can assert if the value does not fit in 64 bits or; /// is not a power of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:167,power,power,167,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,1,['power'],['power']
Energy Efficiency,/// Return the constant as an llvm::MaybeAlign.; /// Note that this method can assert if the value does not fit in 64 bits or; /// is not a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:140,power,power,140,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,1,['power'],['power']
Energy Efficiency,"/// Return the cost of SU in regards to processor resources usage.; /// A positive value means it would be better to wait with SU, while; /// a negative value means it would be good to schedule SU next.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:185,schedul,schedule,185,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,1,['schedul'],['schedule']
Energy Efficiency,/// Return the cost of spilling clearing out PhysReg and aliases so it is free; /// for allocation. Returns 0 when PhysReg is free or disabled with all aliases; /// disabled - it can be allocated directly.; /// \returns spillImpossible when PhysReg or an alias can't be spilled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:186,allocate,allocated,186,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['allocate'],['allocated']
Energy Efficiency,/// Return the cycle for a scheduled instruction. This function normalizes; /// the first cycle to be 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:27,schedul,scheduled,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Return the cycle of the earliest scheduled instruction in the dependence; /// chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:37,schedul,scheduled,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Return the cycle of the latest scheduled instruction in the dependence; /// chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:35,schedul,scheduled,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Return the cycle that MI is scheduled at, or -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:32,schedul,scheduled,32,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Return the earliest time an instruction may be scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:51,schedul,scheduled,51,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Return the final cycle in the schedule, which is the cycle index of the; /// last instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:34,schedul,schedule,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['schedul'],['schedule']
Energy Efficiency,/// Return the first cycle in the completed schedule. This; /// can be a negative value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:44,schedul,schedule,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['schedule']
Energy Efficiency,"/// Return the first cycle in the schedule, which is the cycle index of the; /// first instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:34,schedul,schedule,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['schedul'],['schedule']
Energy Efficiency,/// Return the in-memory size to write for the argument at \p VA. This may; /// be smaller than the allocated stack slot size.; ///; /// This is overridable primarily for targets to maintain compatibility with; /// hacks around the existing DAG call lowering infrastructure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:100,allocate,allocated,100,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['allocate'],['allocated']
Energy Efficiency,/// Return the initiation interval for this schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:44,schedul,schedule,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['schedule']
Energy Efficiency,/// Return the instructions that are scheduled at the specified cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:37,schedul,scheduled,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Return the last cycle in the finalized schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:43,schedul,schedule,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['schedule']
Energy Efficiency,/// Return the latest time an instruction my be scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:48,schedul,scheduled,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['scheduled']
Energy Efficiency,"/// Return the maximum size of a call frame that must be; /// allocated for an outgoing function call. This is only available if; /// CallFrameSetup/Destroy pseudo instructions are used by the target, and; /// then only during or after prolog/epilog code insertion.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:62,allocate,allocated,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Return the maximum stage count needed for this schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:51,schedul,schedule,51,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['schedul'],['schedule']
Energy Efficiency,/// Return the name of a covarage mapping variable (internal linkage); /// for each instrumented source module. Such variables are allocated; /// in the __llvm_covmap section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:131,allocate,allocated,131,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Return the next power of two (in 64-bits) that is strictly greater than A.; /// Return zero on overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:20,power,power,20,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['power'],['power']
Energy Efficiency,/// Return the number of bytes that must be allocated to hold; /// all of the fixed size frame objects. This is only valid after; /// Prolog/Epilog code insertion has finalized the stack frame layout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:44,allocate,allocated,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Return the number of objects allocated into the local object block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:33,allocate,allocated,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['allocate'],['allocated']
Energy Efficiency,"/// Return the number of stages contained in this schedule, which is the; /// largest stage index + 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:50,schedul,schedule,50,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['schedul'],['schedule']
Energy Efficiency,/// Return the preferred operand type if the target has a quick way to compare; /// integer values of the given size. Assume that any legal integer type can; /// be compared efficiently. Targets may override this to allow illegal wide; /// types to return a vector type if there is support to compare that type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:174,efficient,efficiently,174,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['efficient'],['efficiently']
Energy Efficiency,"/// Return the register pressure ""high water mark"" for the specific register; /// class. The scheduler is in high register pressure mode (for the specific; /// register class) if it goes over the limit.; ///; /// Note: this is the old register pressure model that relies on a manually; /// specified representative register class per value type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:93,schedul,scheduler,93,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['schedul'],['scheduler']
Energy Efficiency,"/// Return the resource length of the trace. This is the number of cycles; /// required to execute the instructions in the trace if they were all; /// independent, exposing the maximum instruction-level parallelism.; ///; /// Any blocks in Extrablocks are included as if they were part of the; /// trace. Likewise, extra resources required by the specified scheduling; /// classes are included. For the caller to account for extra machine; /// instructions, it must first resolve each instruction's scheduling class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:357,schedul,scheduling,357,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,2,['schedul'],['scheduling']
Energy Efficiency,/// Return the scheduling class for this instruction. The; /// scheduling class is an index into the InstrItineraryData table. This; /// returns zero if there is no known scheduling information for the; /// instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h:15,schedul,scheduling,15,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,3,['schedul'],['scheduling']
Energy Efficiency,/// Return the set of ReadAdvance entries declared by the scheduling class; /// descriptor in input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:58,schedul,scheduling,58,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['schedul'],['scheduling']
Energy Efficiency,/// Return the single-block loop being scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:39,schedul,scheduled,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['schedul'],['scheduled']
Energy Efficiency,/// Return the size in bytes needed for the trailing objects.; /// Used by the derived classes to allocate the right amount of storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:98,allocate,allocate,98,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['allocate'],['allocate']
Energy Efficiency,/// Return the size in bytes needed for the trailing objects.; /// Used to allocate the right amount of storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:75,allocate,allocate,75,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['allocate'],['allocate']
Energy Efficiency,/// Return the size in bytes of the stack slot allocated to hold a spilled; /// copy of a register from class RC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:47,allocate,allocated,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['allocate'],['allocated']
Energy Efficiency,/// Return the size in bytes of the trailing objects. Used by; /// CXXTemporaryObjectExpr to allocate the right amount of storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:93,allocate,allocate,93,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['allocate'],['allocate']
