quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety,"le>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:19836,avoid,avoid,19836,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,2,['avoid'],['avoid']
Safety,"leBytesRead();; 318 static Long64_t GetFileBytesWritten();; 319 static Int_t GetFileReadCalls();; 320 static Int_t GetReadaheadSize();; 321 ; 322 static void SetFileBytesRead(Long64_t bytes = 0);; 323 static void SetFileBytesWritten(Long64_t bytes = 0);; 324 static void SetFileReadCalls(Int_t readcalls = 0);; 325 static void SetReadaheadSize(Int_t bufsize = 256000);; 326 static void SetReadStreamerInfo(Bool_t readinfo=kTRUE);; 327 static Bool_t GetReadStreamerInfo();; 328 ; 329 static Long64_t GetFileCounter();; 330 static void IncrementFileCounter();; 331 ; 332 static Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected = kTRUE,; 333 Bool_t forceCacheread = kFALSE);; 334 static const char *GetCacheFileDir();; 335 static Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0);; 336 static Bool_t Cp(const char *src, const char *dst, Bool_t progressbar = kTRUE,; 337 UInt_t buffersize = 1000000);; 338 ; 339 static UInt_t SetOpenTimeout(UInt_t timeout); // in ms; 340 static UInt_t GetOpenTimeout(); // in ms; 341 static Bool_t SetOnlyStaged(Bool_t onlystaged);; 342 static Bool_t GetOnlyStaged();; 343 ; 344 ClassDefOverride(TFile,8) //ROOT file; 345};; 346 ; 347#define gFile (TFile::CurrentFile()); 348 ; 349/**; 350\class TFileOpenHandle; 351\ingroup IO; 352Class holding info about the file being opened; 353*/; 354class TFileOpenHandle : public TNamed {; 355 ; 356friend class TFile;; 357 ; 358private:; 359 TString fOpt; ///< Options; 360 Int_t fCompress{0}; ///< Compression level and algorithm; 361 Int_t fNetOpt{0}; ///< Network options; 362 TFile *fFile{nullptr}; ///< TFile instance of the file being opened; 363 ; 364 TFileOpenHandle(TFile *f) : TNamed("""",""""), fOpt(""""), fCompress(ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault),; 365 fNetOpt(0), fFile(f) { }; 366 TFileOpenHandle(const char *n, const char *o, const char *t, Int_t cmp,; 367 Int_t no) : TNamed(n,t), fOpt(o), fCompress(cmp),; 368 fNetOpt(no), fFile(nullptr)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:17031,timeout,timeout,17031,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['timeout'],['timeout']
Safety,"le_t *h=nullptr) override;  Redirect standard output (stdout, stderr) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of file handlers. ;  ; TSignalHandler * RemoveSignalHandler (TSignalHandler *sh) override;  Remove a signal handler from list of signal handlers. ;  ; TTimer * RemoveTimer (TTimer *ti) override;  Remove timer from list of system timers. ;  ; int Rename (const char *from, const char *to) override;  Rename a file. Returns 0 when successful, -1 in case of failure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. The timeout to is in millisec. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDynamicPath (const char *path) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetGUIThreadMsgHandler (ThreadMsgFunc_t func);  Set the (static part of) the event handler func for GUI messages. ;  ; int SetNonBlock (int fd);  Make descriptor fd non-blocking. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int opt, int val) override;  Set sock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:11376,timeout,timeout,11376,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['timeout'],['timeout']
Safety,"le_t *norm) override;  Normal computation. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside this shape. ;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; TGeoVolume * Divide (TGeoVolume *, const char *, Int_t, Int_t, Double_t, Double_t) override;  ; void Draw (Option_t *option="""") override;  Draw this shape. ;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; const char * GetName () const override;  Get the shape name. ;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; TGeoShape * GetShape () const;  ; vecgeom::cxx::VPlacedVolume * GetVGShape () const;  ; void InspectShape () const override;  Print info about the VecGeom solid. ;  ; Bool_t IsAssembly () const override;  ; Bool_t IsComposite () const override;  ; Bool_t IsCylType () const override;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVGShape.html:1917,avoid,avoid,1917,doc/master/classTGeoVGShape.html,https://root.cern,https://root.cern/doc/master/classTGeoVGShape.html,1,['avoid'],['avoid']
Safety,"le_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDz () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Double_t GetRmax () const;  ; virtual Double_t GetRmin () const;  ; Bool_t HasRmin () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void SetTubeDimensions (Double_t rmin, Double_t rmax, Double_t dz);  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:5853,safe,safe,5853,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,3,['safe'],['safe']
Safety,"le_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-par[3])*(x-par[3]);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, par[1]); + par[2] / 2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; return res;; }; ; //_____________________________________________________________________; Double_t fdm2(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-0.1454)*(x-0.1454);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957, 0.25); + par[1] / 2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; return res;; }; //_____________________________________________________________________; Bool_t h1analysisTreeReader::Process(Long64_t entry){; // entry is the entry number in the current Tree; // Selection function to select D* and D0.; myTreeReader.SetLocalEntry(entry);; fProcessed++;; //in case one entry list is given in input, the selection has already been done.; if (!useList) {; // Return as soon as a bad entry is detected; if (TMath::Abs(*fMd0_d-1.8646) >= 0.04) return kFALSE;; if (*fPtds_d <= 2.5) return kFALSE;; if (TMath::Abs(*fEtads_d) >= 1.5) return kFALSE;; (*fIk)--; //original fIk used f77 convention starting at 1; (*fIpi)--;; ; ; if (fNhitrp.At(*fIk)* fNhitrp.At(*fIpi) <= 1) return kFALSE;; ; ; if (fRend.At(*fIk) -fRstart.At(*fIk) <= 22) return kFALSE;; if (fRend.At(*fIpi)-fRstart.At(*fIpi) <= 22) return kFALSE;; if (fNlhk.At(*fIk) <= 0.1) return kFALSE;; if (fNlhpi.At(*fIpi) <= 0.1) return kFALSE;; (*fIpis)--; if (fNlhpi.At(*fIpis) <= 0.1) return kFALSE;; if (*fNjets < 1) return kFALSE;; }; // if option fillList, fill the entry list; if (fillList) elist->Enter(entry);; ; //fill some histograms; hdmd->Fill(*fDm_d);; h2->Fill(*fDm_d,*fRpd0_t/0.029979*1.8646/ *fPtd0_d);; ; return kTRUE;; }; ; void h1analysisTreeReader::Begin(TTree* /*myTree*/) {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:1683,detect,detected,1683,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['detect'],['detected']
Safety,"le_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetParErrorsvirtual const Double_t * GetParErrors() constDefinition TF1.h:566; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11)Type safe interface (static method) The number of sampling points are taken from the TGraph.Definition TF1.cxx:3826; TF1::AbsValuestatic void AbsValue(Bool_t reject=kTRUE)Static function: set the fgAbsValue flag.Definition TF1.cxx:984; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetFormulavirtual const TFormula * GetFormula() constDefinition TF1.h:485; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::fNparInt_t fNparNumber of parameters.Definition TF1.h:265; TF1::GetParametervirtual Double_t GetParameter(const TString &name) constDefinition TF1.h:544; TF1::GetYaxisTAxis * GetYaxis() constGet y axis of the function.Definition TF1.cxx:2411; TF1::GetParametersvirtual void GetParameters(Double_t *params)Definition TF1.h:552; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:48556,safe,safe,48556,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['safe'],['safe']
Safety,"le_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTubeSeg.html:15185,safe,safe,15185,root/html528/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoTubeSeg.html,4,['safe'],['safe']
Safety,"le_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoConeSeg&operator=(const TGeoConeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidTGeoCone::SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidSetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoConeSeg.html:9188,Safe,SafetyPhi,9188,root/html532/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html,1,['Safe'],['SafetyPhi']
Safety,"le_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTubeSeg&operator=(const TGeoTubeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTubeSeg.html:9168,Safe,SafetyPhi,9168,root/html532/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html532/TGeoTubeSeg.html,1,['Safe'],['SafetyPhi']
Safety,"le_t dz, Double_t *vertices=nullptr);  ;  TGeoArb8 (Double_t dz, Double_t *vertices=nullptr);  ;  ~TGeoArb8 () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; void ComputeTwist ();  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistToPlane (const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetClosestEdge (const Double_t *point, Double_t *vert, Int_t &isegment) const;  ; Double_t GetDz () const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; Bool_t GetPointsOnFacet (Int_t, Int_t, Double_t *) const override;  ; Double_t GetTwist (Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:1437,safe,safe,1437,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,1,['safe'],['safe']
Safety,"le_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:16988,safe,safe,16988,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,6,['safe'],['safe']
Safety,"le_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:15450,safe,safe,15450,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,4,['safe'],['safe']
Safety,"le_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHype.html:14884,safe,safe,14884,root/html528/TGeoHype.html,https://root.cern,https://root.cern/root/html528/TGeoHype.html,1,['safe'],['safe']
Safety,"le_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoHype.html:15083,safe,safe,15083,root/html530/TGeoHype.html,https://root.cern,https://root.cern/root/html530/TGeoHype.html,3,['safe'],['safe']
Safety,"le_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Int_t GetNumberOfDivisions () const;  ; Int_t GetNz () const;  ; Double_t GetPhi1 () const;  ; Double_t GetPhi2 () const;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; virtual Double_t GetRmax () const;  ; virtual Double_t GetRmin () const;  ; Double_t GetTheta1 () const;  ; Double_t GetTheta2 () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Int_t IsOnBoundary (const Double_t *point) const;  ; Bool_t IsPointInside (const Double_t *point, Bool_t checkR=kTRUE, Bool_t checkTh=kTRUE, Bool_t checkPh=kTRUE) const;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetDimensions (Double_t *param, Int_t nparam);  ; virtual void SetNumberOfDivisions (Int_t p);  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void SetSphDimensions (Double_t rmin, Double_t rmax, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:3562,safe,safe,3562,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,1,['safe'],['safe']
Safety,"le_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); Static method to compute the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Set dimensions of the cone segment. void SetDimensions(Double_t* param); Set dimensions of the cone segment from an array. void SetPoints(Double_t* points) const; Create cone segment mesh points. void SetPoints(Float_t* points) const; Create cone segment mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!pain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoConeSeg.html:17744,Safe,SafetyS,17744,root/html532/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html532/TGeoConeSeg.html,1,['Safe'],['SafetyS']
Safety,"le_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPara.html:2820,safe,safe,2820,root/html534/TGeoPara.html,https://root.cern,https://root.cern/root/html534/TGeoPara.html,18,['safe'],['safe']
Safety,"le_t* local) const; Convert the point coordinates from mother reference to local reference system. void MasterToLocalVect(const Double_t* master, Double_t* local) const; Convert a vector from mother reference to local reference system. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert the point coordinates from local reference system to mother reference. void LocalToMasterVect(const Double_t* local, Double_t* master) const; Convert a vector from local reference system to mother reference. void ls(Option_t* option = """") const; Print the path (A/B/C/...) to this node on stdout. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void PrintCandidates() const; print daughters candidates for containing current point; cd();. void PrintOverlaps() const; print possible overlapping nodes; if (!IsOverlapping()) {printf(""node %s is ONLY\n"", GetName()); return;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape. void SetOverlaps(Int_t* ovlp, Int_t novlp); set the list of overlaps for this node (ovlp must be created with operator new). void SetVisibility(Bool_t vis = kTRUE); Set visibility of the node (obsolete). void VisibleDaughters(Bool_t vis = kTRUE); Set visibility of the daughters (obsolete). void cd() const; {;}. Int_t GetByteCount() const; {return 44;}. TGeoNode * GetDaughter(Int_t ind) const; {return fVolume->GetNode(ind);}. TGeoMatrix * GetMatrix() const. Int_t GetColour() const; {return fVolume->GetLineColor();}. Int_t GetIndex() const; {return 0;}. TGeoPatternFinder * GetFinder() const; {return 0;}. TGeoMedium * GetMedium() const; {return fVolume->GetMedium();}. TGeoVolume * GetMotherVolume() const; {return fMother;}. Int_t GetNdaughters() const; {return fVolume->GetNdaughters();}. TObjArray * GetNodes() const; {return fVolume->GetNodes();}. Int_t GetNumber() const; {return fNumber;}. Int_t * GetOverlaps(Int_t& novlp) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNode.html:14817,Safe,Safety,14817,root/html532/TGeoNode.html,https://root.cern,https://root.cern/root/html532/TGeoNode.html,1,['Safe'],['Safety']
Safety,"le_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. TGeoPgon(); constructors. Int_t GetByteCount() const; {return 64+12*fNz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNedges() const; {return fNedges;}. Int_t GetNsegments() const; {return fNedges;}. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; {return TGeoBBox::GetPointsOnSegments(npoints,array);}. void SetNedges(Int_t ne); {if (ne>2) fNedges=ne;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:22450,safe,safe,22450,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"le_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. TGeoPgon(); constructors. Int_t GetByteCount() const; {return 64+12*fNz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNedges() const; {return fNedges;}. Int_t GetNsegments() const; {return fNedges;}. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; {return TGeoBBox::GetPointsOnSegments(npoints,array);}. void SetNedges(Int_t ne); {if (ne>2) fNedges=ne;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoPgon.html:24200,safe,safe,24200,root/html604/TGeoPgon.html,https://root.cern,https://root.cern/root/html604/TGeoPgon.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"le_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. TGeoPgon(); constructors. Int_t GetByteCount() const; {return 64+12*fNz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNedges() const; {return fNedges;}. Int_t GetNsegments() const; {return fNedges;}. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; {return TGeoBBox::GetPointsOnSegments(npoints,array);}. void SetNedges(Int_t ne); {if (ne>2) fNedges=ne;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPgon.html:24200,safe,safe,24200,root/html602/TGeoPgon.html,https://root.cern,https://root.cern/root/html602/TGeoPgon.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"le_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:7825,safe,safe,7825,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,1,['safe'],['safe']
Safety,"le_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& b); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TShape.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TShape.html:8707,avoid,avoid,8707,root/html528/TShape.html,https://root.cern,https://root.cern/root/html528/TShape.html,1,['avoid'],['avoid']
Safety,"le_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& b); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TShape.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TShape.html:8776,avoid,avoid,8776,root/html530/TShape.html,https://root.cern,https://root.cern/root/html530/TShape.html,1,['avoid'],['avoid']
Safety,"le_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& b); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TShape.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TShape.html:8776,avoid,avoid,8776,root/html532/TShape.html,https://root.cern,https://root.cern/root/html532/TShape.html,2,['avoid'],['avoid']
Safety,"le_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←. TBRIK; ←. TGTRA. TPARA. TTRAP. TTRD1. TTRD2. TPCON; ←. TPGON. TPolyLineShape. TSPHE.  [more...]. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& ); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TShape.html:9551,avoid,avoid,9551,root/html604/TShape.html,https://root.cern,https://root.cern/root/html604/TShape.html,2,['avoid'],['avoid']
Safety,"le_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←. TBRIK; ←. TGTRA. TPARA. TTRAP. TTRD1. TTRD2. TPCON; ←. TPGON. TPolyLineShape. TSPHE.  [more...]. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& ); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TShape.html:9551,avoid,avoid,9551,root/html602/TShape.html,https://root.cern,https://root.cern/root/html602/TShape.html,2,['avoid'],['avoid']
Safety,"lection status ;; 2202 if (haveCompSel) plotOnCompSelect(nullptr) ;; 2203 ; 2204 return ret ;; 2205}; 2206 ; 2207 ; 2208//_____________________________________________________________________________; 2209/// Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; 2210/// the scale factor for a PDF can be interpreted in three different ways. The interpretation; 2211/// is controlled by ScaleType; 2212/// ```; 2213/// Relative - Scale factor is applied on top of PDF normalization scale factor; 2214/// NumEvent - Scale factor is interpreted as a number of events. The surface area; 2215/// under the PDF curve will match that of a histogram containing the specified; 2216/// number of event; 2217/// Raw - Scale factor is applied to the raw (projected) probability density.; 2218/// Not too useful, option provided for completeness.; 2219/// ```; 2220// coverity[PASS_BY_VALUE]; 2221RooPlot* RooAbsPdf::plotOn(RooPlot *frame, PlotOpt o) const; 2222{; 2223 ; 2224 // Sanity checks; 2225 if (plotSanityChecks(frame)) return frame ;; 2226 ; 2227 // More sanity checks; 2228 double nExpected(1) ;; 2229 if (o.stype==RelativeExpected) {; 2230 if (!canBeExtended()) {; 2231 coutE(Plotting) << ""RooAbsPdf::plotOn("" << GetName(); 2232 << ""): ERROR the 'Expected' scale option can only be used on extendable PDFs"" << endl ;; 2233 return frame ;; 2234 }; 2235 frame->updateNormVars(*frame->getPlotVar()) ;; 2236 nExpected = expectedEvents(frame->getNormVars()) ;; 2237 }; 2238 ; 2239 // Adjust normalization, if so requested; 2240 if (o.stype != Raw) {; 2241 ; 2242 if (frame->getFitRangeNEvt() && o.stype==Relative) {; 2243 // If non-default plotting range is specified, adjust number of events in fit range; 2244 o.scaleFactor *= frame->getFitRangeNEvt()/nExpected ;; 2245 } else if (o.stype==RelativeExpected) {; 2246 o.scaleFactor *= nExpected ;; 2247 } else if (o.stype==NumEvent) {; 2248 o.scaleFactor /= nExpected ;; 2249 }; 2250 o.scaleFactor *= frame->getFitRangeBinW() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:108466,sanity check,sanity checks,108466,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['sanity check'],['sanity checks']
Safety,"lel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.cxx:8966; TTree::SortBranchesByTimevoid SortBranchesByTime()Sorts top-level branches by the last average task time recorded per branch.Definition TTree.cxx:5834; TTree::Deletevoid Delete(Option_t *option="""") overrideDelete this tree from memory or/and disk.Definition TTree.cxx:3747; TTree::GetIndexvirtual Int_t * GetIndex()Definition TTree.h:521; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::GetV3virtual Double_t * GetV3()Definition TTree.h:580; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::BranchImpRefvirtual TBranch * BranchImpRef(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch but automatic detection of the class name.Definition TTree.cxx:1635; TTree::SetEventListvirtual void SetEventList(TEventList *list)This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TT...Definition TTree.cxx:9069; TTree::BranchTBranch * Branch(const char *name, int address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:389; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::operator=TTree & operator=(const TTree &tt)=delete; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:69734,detect,detection,69734,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['detect'],['detection']
Safety,"lemented in RooLognormal, RooPoisson, RooHistFunc, RooHistPdf, RooBernstein, RooBifurGauss, RooCBShape, RooChebychev, RooExponential, RooGamma, RooGaussian, RooLandau, RooPolynomial, RooUniform, RooEfficiency, and RooPolyVar.; Definition at line 4425 of file RooAbsReal.cxx. ◆ chi2FitTo() [1/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Perform a \( \chi^2 \) fit to given histogram. ; By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession; The following named arguments are supported. Options to control construction of chi2 . Extended(bool flag) Only applicable when fitting a RooAbsPdf. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight. This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:68253,predict,predicted,68253,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['predict'],['predicted']
Safety,"lemented in RooLognormal, RooPoisson, RooHistFunc, RooHistPdf, RooBernstein, RooBifurGauss, RooCBShape, RooChebychev, RooExponential, RooGamma, RooGaussian, RooLandau, RooPolynomial, RooUniform, RooEfficiency, and RooPolyVar.; Definition at line 4501 of file RooAbsReal.cxx. ◆ chi2FitTo() [1/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Perform a \( \chi^2 \) fit to given histogram. ; By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession; The following named arguments are supported. Options to control construction of chi2 . Extended(bool flag) Only applicable when fitting a RooAbsPdf. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight. This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:69521,predict,predicted,69521,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['predict'],['predicted']
Safety,"lementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); Absolute Tolerance is not used in this class. . double Result() const; Returns the result of the last integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; This method is not implemented. . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface; Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. . void SetFunction(const ROOT::Math::IGenFunction& , bool copy = false); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations.; \@param copy Indicates whether the function has to be copied. double Integral(); This method is not implemented. . double IntegralUp(double a); This method is not implemented. . double IntegralLow(double b); This method is not implemented. . double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void CalcGaussLegendreSamplingPoints(); Middle functions. Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition. » Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 22728 2008-03-19 10:05:41Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GaussLegendreIntegrator.html:4027,unsafe,unsafe,4027,root/html526/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GaussLegendreIntegrator.html,1,['unsafe'],['unsafe']
Safety,"length bytes into buffer. ;  ; Int_t RedirectOutput (const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) override;  Redirect standard output (stdout, stderr) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of file handlers. ;  ; TSignalHandler * RemoveSignalHandler (TSignalHandler *sh) override;  Remove a signal handler from list of signal handlers. ;  ; TTimer * RemoveTimer (TTimer *ti) override;  Remove timer from list of system timers. ;  ; int Rename (const char *from, const char *to) override;  Rename a file. Returns 0 when successful, -1 in case of failure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. The timeout to is in millisec. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDynamicPath (const char *path) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetGUIThreadMsgHandler (ThreadMsgFunc_t func);  Set the (static part of) the event handler func for GUI messages. ;  ; int SetNonBlock (int fd);  Make descriptor fd non-blocking. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:11258,timeout,timeout,11258,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['timeout'],['timeout']
Safety,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:2356,abort,abort,2356,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,3,['abort'],"['abort', 'aborting']"
Safety,"les = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTubeSeg.html:2718,safe,safe,2718,root/html530/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html530/TGeoTubeSeg.html,1,['safe'],['safe']
Safety,"lete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTorus.html:8588,Safe,SafetySeg,8588,root/html602/TGeoTorus.html,https://root.cern,https://root.cern/root/html602/TGeoTorus.html,2,['Safe'],['SafetySeg']
Safety,"level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.372361 cHl3=0.491134 cHq3=-0.886807; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=5.8312, denominator=wrap_pdf_Int[pTV]=12183.6; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:Input",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:15646,recover,recover,15646,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"lf-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:12996,safe,safe,12996,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,6,['safe'],['safe']
Safety,"lfSpace::Contains_v ; (; const Double_t * ; points, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Check the inside status for each of the points in the array. ; Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point ; Reimplemented from TGeoBBox.; Definition at line 249 of file TGeoHalfSpace.cxx. ◆ DeclFileName(). static const char * TGeoHalfSpace::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 66 of file TGeoHalfSpace.h. ◆ DistancetoPrimitive(). Int_t TGeoHalfSpace::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . A half-space does not have a mesh primitive. ; Reimplemented from TGeoBBox.; Definition at line 105 of file TGeoHalfSpace.cxx. ◆ DistFromInside(). Double_t TGeoHalfSpace::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . compute distance from inside point to the plane ; Reimplemented from TGeoBBox.; Definition at line 113 of file TGeoHalfSpace.cxx. ◆ DistFromInside_v(). void TGeoHalfSpace::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 269 of file TGeoHalfSpace.cxx. ◆ DistFromOutside(). Double_t TGeoHalfSpace::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . compute distance from inside point to the plane ; Reimplemented from TGeoBBox.; Definition at line 142 of file TGeoHalfSpace.cxx. ◆ DistFromOutside_v(). void TGeoHalfSpace::DistFromOutside_v ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHalfSpace.html:27304,safe,safe,27304,doc/master/classTGeoHalfSpace.html,https://root.cern,https://root.cern/doc/master/classTGeoHalfSpace.html,1,['safe'],['safe']
Safety,"lid_col_y = df.FilterMissing(""x"");; auto display_x = df_valid_col_x.Display<int>({""x""});; auto display_y = df_valid_col_y.Display<int>({""y""});; NoteSee FilterAvailable() if you want to discard the entries in case there is a missing value instead. ; Definition at line 388 of file RInterface.hxx. ◆ Foreach(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::Foreach ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. The callable f is invoked once per entry. This is an instant action: upon invocation, an event loop as well as execution of all scheduled actions is triggered. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT). Example usage:; myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});. Definition at line 1611 of file RInterface.hxx. ◆ ForeachSlot(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::ForeachSlot ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function requiring a processing slot index on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. Same as Foreach, but the user-defined function takes an extra unsigned int as its first parameter, the processing slot index. This slot index will be assigned a different value, 0 to poolSize - 1, for each thread of execution. This is meant as a h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:76538,safe,safety,76538,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safety']
Safety,"like resetting the buffer; 1490 // (it will not be used anymore the next time BufferEmpty is called); 1491 if (nbentries == (Int_t)fEntries); 1492 fBuffer[0] = -nbentries;; 1493 else; 1494 fBuffer[0] = 0;; 1495 }; 1496 return nbentries;; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// accumulate arguments in buffer. When buffer is full, empty the buffer; 1501///; 1502/// - `fBuffer[0]` = number of entries in buffer; 1503/// - `fBuffer[1]` = w of first entry; 1504/// - `fBuffer[2]` = x of first entry; 1505 ; 1506Int_t TH1::BufferFill(Double_t x, Double_t w); 1507{; 1508 if (!fBuffer) return -2;; 1509 Int_t nbentries = (Int_t)fBuffer[0];; 1510 ; 1511 ; 1512 if (nbentries < 0) {; 1513 // reset nbentries to a positive value so next time BufferEmpty() is called; 1514 // the histogram will be refilled; 1515 nbentries = -nbentries;; 1516 fBuffer[0] = nbentries;; 1517 if (fEntries > 0) {; 1518 // set fBuffer to zero to avoid calling BufferEmpty in Reset; 1519 Double_t *buffer = fBuffer; fBuffer=nullptr;; 1520 Reset(""ICES""); // do not reset list of functions; 1521 fBuffer = buffer;; 1522 }; 1523 }; 1524 if (2*nbentries+2 >= fBufferSize) {; 1525 BufferEmpty(1);; 1526 if (!fBuffer); 1527 // to avoid infinite recursion Fill->BufferFill->Fill; 1528 return Fill(x,w);; 1529 // this cannot happen; 1530 R__ASSERT(0);; 1531 }; 1532 fBuffer[2*nbentries+1] = w;; 1533 fBuffer[2*nbentries+2] = x;; 1534 fBuffer[0] += 1;; 1535 return -2;; 1536}; 1537 ; 1538////////////////////////////////////////////////////////////////////////////////; 1539/// Check bin limits.; 1540 ; 1541bool TH1::CheckBinLimits(const TAxis* a1, const TAxis * a2); 1542{; 1543 const TArrayD * h1Array = a1->GetXbins();; 1544 const TArrayD * h2Array = a2->GetXbins();; 1545 Int_t fN = h1Array->fN;; 1546 if ( fN != 0 ) {; 1547 if ( h2Array->fN != fN ) {; 1548 return false;; 1549 }; 1550 else {; 1551 for ( int i = 0; i < fN; ++i ) {; 1552 // for i==fN (nbin+1) a->GetB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:59329,avoid,avoid,59329,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['avoid'],['avoid']
Safety,"limit OVLP by sampling npoints inside the volume shape. ; Definition at line 1196 of file TGeoChecker.cxx. ◆ CheckPoint(). void TGeoChecker::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ; Generates a report regarding the path to the node containing this point and the distance to the closest boundary. ; Definition at line 1692 of file TGeoChecker.cxx. ◆ CheckShape(). void TGeoChecker::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety . Definition at line 1752 of file TGeoChecker.cxx. ◆ CheckVoxels(). Double_t TGeoChecker::CheckVoxels ; (; TGeoVolume * ; vol, . TGeoVoxelFinder * ; voxels, . Double_t * ; xyz, . Int_t ; npoints . ). count voxel timing ; Definition at line 2967 of file TGeoChecker.cxx. ◆ Class(). static TClass * TGeoChecker::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoChecker::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoChecker::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TGeoChecker.h. ◆ CleanPoints(). void TGeoChecker::CleanPoints ; (; Double_t * ; points, . Int_t & ; numPoints . ); const. private . Number of points on mesh to be checked. ; Clean-up the mesh of pcon/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:21845,safe,safety,21845,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety,"limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2175 of file TBufferFile.cxx. ◆ WriteFastArray() [7/15]. void TBufferFile::WriteFastArray ; (; const Long_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n longs into the I/O buffer with 8-byte width. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2129 of file TBufferFile.cxx. ◆ WriteFastArray() [8/15]. void TBufferFile::WriteFastArray ; (; const Short_t * ; h, . Long64_t ; n . ). overridevirtual . Write array of n shorts into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2063 of file TBufferFile.cxx. ◆ WriteFastArray() [9/15]. void TBufferFile::WriteFastArray ; (; const UChar_t * ; c, . Long64_t ; n . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 517 of file TBufferFile.h. ◆ WriteFastArray() [10/15]. void TBufferFile::WriteFastArray ; (; const UInt_t * ; i, . Long64_t ; n . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 523 of file TBufferFile.h. ◆ WriteFastArray() [11/15]. void TBufferFile::WriteFastArray ; (; const ULong64_t * ; l, . Long64_t ; n . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 526 of file TBufferFile.h. ◆ WriteFastArray() [12/15]. void TBufferFile::WriteFastArray ; (; const ULong",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:84277,abort,aborts,84277,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"line width. ;  ; virtual TClass * IsA () const;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetLineAttributes ();  Invoke the DialogCanvas Line attributes. ;  ; virtual void SetLineColorAlpha (Color_t lcolor, Float_t lalpha);  Set a transparent line color. ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Protected Member Functions; void FindMomentumLimits (REveElement *el, Bool_t recurse=kTRUE);  Loop over track elements of argument el and find highest pT and p. ;  ; Double_t RoundMomentumLimit (Double_t x);  Round the momentum limit up to a nice value. ;  ; void SanitizeMinMaxCuts ();  Set Min/Max cuts so that they are within detected limits. ;  ;  Protected Member Functions inherited from ROOT::Experimental::REveElement; virtual void AnnihilateRecursively ();  Protected member function called from REveElement::Annihilate(). ;  ; void assign_element_id_recurisvely ();  ; void assign_scene_recursively (REveScene *s);  ; ElementId_t get_mother_id () const;  ; ElementId_t get_scene_id () const;  ; virtual void PreDeleteElement ();  Vertex / normal / triangle index information for rendering. ;  ; virtual void RemoveElementsInternal ();  Remove all elements. ;  . Protected Attributes; Double_t fLimP;  ; Double_t fLimPt;  ; Double_t fMaxP;  ; Double_t fMaxPt;  ; Double_t fMinP;  ; Double_t fMinPt;  ; REveTrackPropagator * fPropagator {nullptr};  ; Bool_t fRecurse;  ; Bool_t fRnrLine;  ; Bool_t fRnrPoints;  ;  Protected Attributes inherited from ROOT::Experimental::REveElement; AuntList_t fAunts;  ; Bool_t fCanEditMainColor {kFALSE};  ; Bool_t fCanEditMainTrans {kFALSE};  ; Bool_t fCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrackList.html:19916,detect,detected,19916,doc/master/classROOT_1_1Experimental_1_1REveTrackList.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveTrackList.html,1,['detect'],['detected']
Safety,"line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Historyoption. You can also turn off the command logging in the system.rootrc file with the option: Rint.History: -; The number of history lines to be kept can be set also in .rootrc by:; Rint.HistSize: 500; Rint.HistSave: 400; The first value defines the maximum of lines kept; once it is reached all, the last HistSave lines will be removed. One can set HistSize to 0 to disable history line management. There is also implemented an environment variable called ROOT_HIST. By setting ROOT_HIST=300:200 the above values can be overriden - the first value corresponds to HistSize, the (optional) second one to HistSave. You can set ROOT_HIST=0 to disable the history.; 2.7.3 Tracking Memory Leaks; You can track memory usage and detect leaks by monitoring the number of objects that are created and deleted (see TObjectTable). To use this facility, edit the file $ROOTSYS/etc/system.rootrc or .rootrc if you have this file and add the two following lines:; Root.ObjectStat: 1; In your code or on the command line you can type the line:; gObjectTable->Print();; This line will print the list of all active classes and the number of instances for each class. By comparing consecutive print outs, you can see objects that you forgot to delete. Note that this method cannot show leaks coming from the allocation of non-objects or classes unknown to ROOT.; 2.8 Converting from PAW to ROOT; The web page at: http://root.cern.ch/root/HowtoConvertFromPAW.html#TABLE gives the “translation” table of some commonly used PAW commands into ROOT. If you move the mouse cursor over the picture at: http://root.cern.ch/root/HowtoConvertFromPAW.html#SET, you will get the corresponding ROOT commands as tooltips.; 2.8.1 Converting HBOOK/PAW Files; ROOT has a utility",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:66403,detect,detect,66403,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['detect'],['detect']
Safety,"lineprivate . Definition at line 3151 of file RInterface.hxx. ◆ DefinePerSample() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename RetType_t = typename TTraits::CallableTraits<F>::ret_type> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefinePerSample ; (; std::string_view ; name, . F ; expression . ). inline . Define a new column that is updated when the input sample changes. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionA C++ callable that computes the new value of the defined column. . Returnsthe first node of the computation graph for which the new quantity is defined.; The signature of the callable passed as second argument should be T(unsigned int slot, const ROOT::RDF::RSampleInfo &id) where:; T is the type of the defined column; slot is a number in the range [0, nThreads) that is different for each processing thread. This can simplify the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; id is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is being processed (see the class docs for more information). DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being processed or to inject a callback into the event loop that is only called when the processing of a new sample starts rather than at every entry.; The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often. Example usage:; ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; df.DefinePerSample(""weightbysample"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; ROOT::RDF::RInterface::DefinePerSampleRInterface< Proxied, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:54349,safe,safe,54349,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safe']
Safety,"linevirtual . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 287 of file TFile.h. ◆ SetFileBytesRead(). void TFile::SetFileBytesRead ; (; Long64_t ; bytes = 0). static . Definition at line 4608 of file TFile.cxx. ◆ SetFileBytesWritten(). void TFile::SetFileBytesWritten ; (; Long64_t ; bytes = 0). static . Definition at line 4611 of file TFile.cxx. ◆ SetFileReadCalls(). void TFile::SetFileReadCalls ; (; Int_t ; readcalls = 0). static . Definition at line 4614 of file TFile.cxx. ◆ SetOffset(). void TFile::SetOffset ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). virtual . Set position from where to start reading. ; Definition at line 2253 of file TFile.cxx. ◆ SetOnlyStaged(). Bool_t TFile::SetOnlyStaged ; (; Bool_t ; onlystaged). static . Sets only staged flag. ; Returns previous value of flag. When true we check before opening the file if it is staged, if not, the open fails. ; Definition at line 4744 of file TFile.cxx. ◆ SetOpenTimeout(). UInt_t TFile::SetOpenTimeout ; (; UInt_t ; timeout). static . Sets open timeout time (in ms). Returns previous timeout value. ; Definition at line 4724 of file TFile.cxx. ◆ SetOption(). virtual void TFile::SetOption ; (; Option_t * ; option = "">""). inlinevirtual . Definition at line 289 of file TFile.h. ◆ SetReadaheadSize(). void TFile::SetReadaheadSize ; (; Int_t ; bufsize = 256000). static . Definition at line 4605 of file TFile.cxx. ◆ SetReadCalls(). virtual void TFile::SetReadCalls ; (; Int_t ; readcalls = 0). inlinevirtual . Definition at line 290 of file TFile.h. ◆ SetReadStreamerInfo(). void TFile::SetReadStreamerInfo ; (; Bool_t ; readinfo = kTRUE). static . Specify if the streamerinfos must be read at file opening. ; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called when opening the file. It may be interesting to set fgReadInfo to false to speedup the file opening time or in case libraries containing classes referenced by the file have not yet been loaded. if fgReadInfo is false, one ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:95038,timeout,timeout,95038,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['timeout'],['timeout']
Safety,"ling.cxx. ◆ TCling_GenerateDictionary() [1/2]. int TCling_GenerateDictionary ; (; const std::string & ; className, . const std::vector< std::string > & ; headers, . const std::vector< std::string > & ; fwdDecls, . const std::vector< std::string > & ; unknown . ). Definition at line 820 of file TCling.cxx. ◆ TCling_GenerateDictionary() [2/2]. int TCling_GenerateDictionary ; (; const std::vector< std::string > & ; classes, . const std::vector< std::string > & ; headers, . const std::vector< std::string > & ; fwdDecls, . const std::vector< std::string > & ; unknown . ). Definition at line 699 of file TCling.cxx. ◆ TClingLookupHelper__AutoParse(). bool TClingLookupHelper__AutoParse ; (; const char * ; cname). Allow calling autoparsing from TMetaUtils. ; Definition at line 894 of file TCling.cxx. ◆ TClingLookupHelper__ExistingTypeCheck(). bool TClingLookupHelper__ExistingTypeCheck ; (; const std::string & ; tname, . std::string & ; result . ). Try hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing. ; Definition at line 903 of file TCling.cxx. Variable Documentation. ◆ fantomline. const char* fantomline = ""TRint::EndOfLineAction();"". Definition at line 841 of file TCling.cxx. ◆ gIgnoredPCMNames. const std::unordered_set<std::string> gIgnoredPCMNames. static . Initial value:= {""libCore"",; ""libRint"",; ""libThread"",; ""libRIO"",; ""libImt"",; ""libMultiProc"",; ""libcomplexDict"",; ""libdequeDict"",; ""liblistDict"",; ""libforward_listDict"",; ""libvectorDict"",; ""libmapDict"",; ""libmultimap2Dict"",; ""libmap2Dict"",; ""libmultimapDict"",; ""libsetDict"",; ""libmultisetDict"",; ""libunordered_setDict"",; ""libunordered_multisetDict"",; ""libunordered_mapDict"",; ""libunordered_multimapDict"",; ""libvalarrayDict"",; ""G__GenVector32"",; ""G__Smatrix32""}. List of dicts that have the PCM information already in the PCH. ; Definition at line 1939 of file TCling.cxx. ◆ HaveFullGlobalModuleIndex. bool HaveFullGlobalModuleIndex = false. static . Definition at line 1079 of file TClin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:23185,avoid,avoid,23185,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['avoid'],['avoid']
Safety,"ling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently running RegisterModule; 139 TClingCallbacks* fClingCallbacks; // cling::Interpreter owns it.; 140 struct CharPtrCmp_t {; 141 bool operator()(const char* a, const char *b) const {; 142 return strcmp(a, b) < 0;; 143 }; 144 };; 145 std::set<TClass*> fModTClasses;; 146 std::vector<std::pair<TClass*,DictFuncPtr_t> > fClassesToUpdate;; 147 void* fAutoLoadCallBack;; 148 ULong64_t fTransactionCount; // Cling counter for commited or unloaded transactions which changed the AST.; 149 std::vector<const char*> fCurExecutingMacros;; 150 ; 151 typedef void* SpecialObjectLookupCtx_t;; 152 typedef std::unordered_map<std::string, TObject*> SpecialObjectMap_t;; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:5104,avoid,avoid,5104,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['avoid'],['avoid']
Safety,"lipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:114583,detect,detector,114583,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,"lity, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:103536,avoid,avoid,103536,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"lizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075 ; 3076// This assertion currently fails because of; 3077// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3078// TClass *c2 = TClass::GetClass(""std::iostream"");; 3079// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3080// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3081// uses only 'part' of TMetaUtils::GetNormalizedName.; 3082 ; 3083// if (!cl) {; 3084// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3085// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3093 // and we want to make that the TClass for the pair goes through the regular creation; 3094 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3095 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3096 // will be used to create the TProtoClass (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:116582,avoid,avoid,116582,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"lizedName != name);; 3139 }; 3140 ; 3141 if (!load) return nullptr;; 3142 ; 3143// This assertion currently fails because of; 3144// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3145// TClass *c2 = TClass::GetClass(""std::iostream"");; 3146// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3147// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3148// uses only 'part' of TMetaUtils::GetNormalizedName.; 3149 ; 3150// if (!cl) {; 3151// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3152// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3153// if (altcl && normalizedName != altcl->GetName()); 3154// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3155// altcl->GetName(), name, normalizedName.c_str());; 3156// }; 3157 ; 3158 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3159 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3160 // and we want to make that the TClass for the pair goes through the regular creation; 3161 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3162 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3163 // will be used to create the TProtoClass (if one is requested for the pair).; 3164 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3165 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3166 ; 3167 TClass *loadedcl = nullptr;; 3168 if (checkTable) {; 3169 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3170 } else {; 3171 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3172 // At this point more information has been loaded. This; 3173 // information might be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:119333,avoid,avoid,119333,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ll base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3845 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3636 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3770 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3827 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:82789,safe,safe,82789,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['safe'],['safe']
Safety,"ll base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3912 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3703 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3837 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3894 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:82790,safe,safe,82790,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['safe'],['safe']
Safety,"ll be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 240 of file TSQLFile.h. ◆ ReOpen(). Int_t TSQLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 719 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [1/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const char * ; clname, . Int_t ; version . ). protected . Search in database tables for specified class and return TSQLClassInfo object. ; Definition at line 1800 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [2/2]. TSQLClassInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:85551,recover,recovered,85551,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Safety,"ll be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ◆ ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 372 of file TXMLFile.cxx. ◆ ResetErrno(). void TXMLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errno. ; Reimplemented from TFile.; Definition at line 64 of file TXMLFile.h. ◆ SaveToFile(). void TXMLFile::SaveToFile ; (; ). protected . Saves xml structures to the file xml elements are kept in list of TKeyXM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67602,recover,recovered,67602,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recovered']
Safety,"llTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:11188,avoid,avoid,11188,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,4,['avoid'],['avoid']
Safety,"lled when a mouse event occurs in a pad ;  fildir.py This macro displays the ROOT Directory data structure ;  file.py This macro displays the physical ROOT file structure ;  fillrandom.py FillRandom example ;  first.py My first PyROOT interactive session ;  fit1.py Fit example ;  fit1_py.py;  formula1.py TF1 example ;  framework.py The ROOT Framework ;  geometry.py Geometry ;  gerrors.py A Simple Graph with error bars ;  graph.py A Simple Graph Example ;  gui_ex.pyA Simple GUI Example ;  h1draw.py A Simple histogram drawing example ;  hsimple.py This program creates : ;  hsum.py Simple example illustrating how to use the C++ interpreter ;  mrt.py Build ROOT Ntuple from other source ;  multifit.py Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  na49geomfile.pyBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.pyThis macro generates two views of the NA49 detector ;  na49visible.pySet visibility attributes for the NA49 geometry Set Shape attributes ;  ntuple1.py Ntuple drawing example ;  numberEntry.py;  parse_CSV_file_with_TTree_ReadStream.pyThis function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream ;  pyroot001_arrayInterface.py This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data ;  pyroot002_TTreeAsMatrix.py This tutorial shows how a TTree can be quickly converted to a numpy array or a pandas.DataFrame ;  pyroot003_prettyPrinting.py This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement ;  qtexample.pyQt example ;  ratioplot.py Display two histograms and their ratio ;  rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:145458,detect,detector,145458,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,"lled when a mouse event occurs in a pad ;  fildir.py This macro displays the ROOT Directory data structure ;  file.py This macro displays the physical ROOT file structure ;  fillrandom.py FillRandom example ;  first.py My first PyROOT interactive session ;  fit1.py Fit example ;  fit1_py.py;  formula1.py TF1 example ;  framework.py The ROOT Framework ;  geometry.py Geometry ;  gerrors.py A Simple Graph with error bars ;  graph.py A Simple Graph Example ;  gui_ex.pyA Simple GUI Example ;  h1draw.py A Simple histogram drawing example ;  hsimple.py This program creates : ;  hsum.py Simple example illustrating how to use the C++ interpreter ;  mrt.py Build ROOT Ntuple from other source ;  multifit.py Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  na49geomfile.pyBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.pyThis macro generates two views of the NA49 detector ;  na49visible.pySet visibility attributes for the NA49 geometry Set Shape attributes ;  ntuple1.py Ntuple drawing example ;  numberEntry.py;  parse_CSV_file_with_TTree_ReadStream.pyThis function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream ;  pyroot001_arrayInterface.py This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data ;  pyroot002_TTreeAsMatrix.py This tutorial shows how a TTree can be quickly converted to a numpy array or a pandas.DataFrame ;  qtexample.pyQt example ;  ratioplot.py Display two histograms and their ratio ;  rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference to a Pentium IV 2.4 Ghz (with 512 MBytes memory and 120 GBytes IDE disk) taken by definition as 600 ROOTMARKS in batch mode in executing python benchmarks.py ;  shapes.py Draw the geometry using the x3d viewver ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:143270,detect,detector,143270,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['detect'],['detector']
Safety,"lled when a mouse event occurs in a pad ;  fildir.py This macro displays the ROOT Directory data structure ;  file.py This macro displays the physical ROOT file structure ;  fillrandom.py FillRandom example ;  first.py My first PyROOT interactive session ;  fit1.py Fit example ;  fit1_py.py;  formula1.py TF1 example ;  framework.py The ROOT Framework ;  geometry.py Geometry ;  gerrors.py A Simple Graph with error bars ;  graph.py A Simple Graph Example ;  gui_ex.pyA Simple GUI Example ;  h1draw.py A Simple histogram drawing example ;  hsimple.py This program creates : ;  hsum.py Simple example illustrating how to use the C++ interpreter ;  mrt.py Build ROOT Ntuple from other source ;  multifit.py Example showing how to fit in a sub-range of an histogram An histogram is created and filled with the bin contents and errors defined in the table below ;  na49geomfile.pyBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.pyThis macro generates two views of the NA49 detector ;  na49visible.pySet visibility attributes for the NA49 geometry Set Shape attributes ;  ntuple1.py Ntuple drawing example ;  numberEntry.py;  parse_CSV_file_with_TTree_ReadStream.pyThis function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream ;  qtexample.pyQt example ;  ratioplot.py Display two histograms and their ratio ;  rootmarks.pyPrints a summary of all ROOT benchmarks (must be run before) The ROOTMARK number printed is by reference to a Pentium IV 2.4 Ghz (with 512 MBytes memory and 120 GBytes IDE disk) taken by definition as 600 ROOTMARKS in batch mode in executing python benchmarks.py ;  shapes.py Draw the geometry using the x3d viewver ;  staff.py example of macro to read data from an ascii file and create a root file with a Tree ;  surfaces.py Surfaces example ;  test.py ;  tornado.pyTornado example ;  tree.py This macro displays the Tree data structures ;  zdemo.py This macro is an example of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:138575,detect,detector,138575,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,3,['detect'],['detector']
Safety,"lled. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; No mesh for assemblies. void SetPoints(Float_t* points) const; No mesh for assemblies. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:13821,Safe,Safety,13821,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,3,['Safe'],['Safety']
Safety,"llfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:179522,timeout,timeout,179522,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"llfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:179554,timeout,timeout,179554,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"llptr)Create helper TSystem to handle file and directory operations that might be special for remote file a...Definition TSystem.cxx:746; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::HostNamevirtual const char * HostName()Return the system's host name.Definition TSystem.cxx:303; TSystem::fDoneBool_t fDoneDefinition TSystem.h:291; TSystem::fTimersTList * fTimersDefinition TSystem.h:294; TSystem::fNfdInt_t fNfdSignals that were trapped.Definition TSystem.h:280; TSystem::Unsetenvvirtual void Unsetenv(const char *name)Unset environment variable.Definition TSystem.cxx:1657; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::AddDynamicPathvirtual void AddDynamicPath(const char *pathname)Add a new directory to the dynamic path.Definition TSystem.cxx:1787; TSystem::Selectvirtual Int_t Select(TList *active, Long_t timeout)Select on active file descriptors (called by TMonitor).Definition TSystem.cxx:445; TSystem::fInsideNotifystd::atomic< Bool_t > fInsideNotifyDefinition TSystem.h:286; TSystem::fOnExitListTSeqCollection * fOnExitListDefinition TSystem.h:298; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::AnnounceUnixServicevirtual int AnnounceUnixService(int port, int backlog)Announce unix domain service.Definition TSystem.cxx:2363; TSystem::fIncludePathTString fIncludePathDefinition TSystem.h:311; TSystem::GetUidvirtual Int_t GetUid(const char *user=nullptr)Returns the user's id. If user = 0, returns current user's id.Definition TSystem.cxx:1562; TSystem::GetEffectiveUidvirtual Int_t GetEffectiveUid()Returns the effective user id.Definition TSystem.cxx:1572; TSystem::fFlagsDebugTString fFlagsDebugDefinition TSystem.h:308; TSystem::GetLinkdefSuffixvirtual const char * GetLinkdefSuffix() constReturn the linkdef suffix c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:56545,timeout,timeout,56545,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['timeout'],['timeout']
Safety,"llptr)Create helper TSystem to handle file and directory operations that might be special for remote file a...Definition TSystem.cxx:746; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::HostNamevirtual const char * HostName()Return the system's host name.Definition TSystem.cxx:303; TSystem::fDoneBool_t fDoneDefinition TSystem.h:291; TSystem::fTimersTList * fTimersDefinition TSystem.h:294; TSystem::fNfdInt_t fNfdSignals that were trapped.Definition TSystem.h:280; TSystem::Unsetenvvirtual void Unsetenv(const char *name)Unset environment variable.Definition TSystem.cxx:1657; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::AddDynamicPathvirtual void AddDynamicPath(const char *pathname)Add a new directory to the dynamic path.Definition TSystem.cxx:1787; TSystem::Selectvirtual Int_t Select(TList *active, Long_t timeout)Select on active file descriptors (called by TMonitor).Definition TSystem.cxx:445; TSystem::fOnExitListTSeqCollection * fOnExitListDefinition TSystem.h:298; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::AnnounceUnixServicevirtual int AnnounceUnixService(int port, int backlog)Announce unix domain service.Definition TSystem.cxx:2363; TSystem::fIncludePathTString fIncludePathDefinition TSystem.h:311; TSystem::GetUidvirtual Int_t GetUid(const char *user=nullptr)Returns the user's id. If user = 0, returns current user's id.Definition TSystem.cxx:1562; TSystem::GetEffectiveUidvirtual Int_t GetEffectiveUid()Returns the effective user id.Definition TSystem.cxx:1572; TSystem::fFlagsDebugTString fFlagsDebugDefinition TSystem.h:308; TSystem::GetLinkdefSuffixvirtual const char * GetLinkdefSuffix() constReturn the linkdef suffix chosen by the user for ACLiC.Definition TSystem.cxx:4001; TSystem::SetDynamicPathvir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:187912,timeout,timeout,187912,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"lls a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true if the scaled shape is an assembly. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. TGeoShape * MakeScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Create a scaled shape starting from a non-scaled one. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Mesh points for scaled shapes. void SetPoints(Float_t* points) const; Mesh points for scaled shapes. TGeoScaledShape(); methods; constructors. Int_t GetNmeshVertices() const; {return fShape->GetNmeshVertices();}. TGeoShape * GetShape() const; {return fShape;}. TGeoScale * GetScale() const; {return fScale;}. Bool_t IsCylType() const; {return fShape->IsCylType();}. void SetScale(TGeoScale* scale); {fScale = scale;}. » Author: Andrei Gheata 26/09/05 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoScaledShape.h 40117 2011-07-04 12:17:06Z agheata $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoScaledShape.html:13708,Safe,Safety,13708,root/html532/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html532/TGeoScaledShape.html,1,['Safe'],['Safety']
Safety,"lnumnodes = 0;; 1259 ; 1260 // for (auto &node : fDesc); 1261 // node.SetDisplayed(false);; 1262 ; 1263 // build all shapes in volume decreasing order; 1264 for (auto &sid : fSortMap) {; 1265 fDrawIdCut++; //; 1266 auto &desc = fDesc[sid];; 1267 ; 1268 if ((viscnt[sid] <= 0) || (desc.vol <= 0)); 1269 continue;; 1270 ; 1271 auto shape = GetVolume(sid)->GetShape();; 1272 if (!shape); 1273 continue;; 1274 ; 1275 // now we need to create TEveGeoPolyShape, which can provide all rendering data; 1276 auto &shape_descr = MakeShapeDescr(shape);; 1277 ; 1278 // should not happen, but just in case; 1279 if (shape_descr.nfaces <= 0) {; 1280 R__LOG_ERROR(RGeomLog()) << ""No faces for the shape "" << shape->GetName() << "" class "" << shape->ClassName();; 1281 continue;; 1282 }; 1283 ; 1284 // check how many faces are created; 1285 totalnumfaces += shape_descr.nfaces * viscnt[sid];; 1286 if ((GetMaxVisFaces() > 0) && (totalnumfaces > GetMaxVisFaces())); 1287 break;; 1288 ; 1289 // also avoid too many nodes; 1290 totalnumnodes += viscnt[sid];; 1291 if ((GetMaxVisNodes() > 0) && (totalnumnodes > GetMaxVisNodes())); 1292 break;; 1293 ; 1294 // desc.SetDisplayed(true);; 1295 }; 1296 ; 1297 // finally we should create data for streaming to the client; 1298 // it includes list of visible nodes and rawdata; 1299 ; 1300 RGeomDrawing drawing;; 1301 ResetRndrInfos();; 1302 bool has_shape = false;; 1303 ; 1304 ScanNodes(true, level, [&, this](RGeomNode &node, std::vector<int> &stack, bool, int seqid) {; 1305 if ((node.sortid < fDrawIdCut) && (viscnt[node.id] > 0)) {; 1306 drawing.visibles.emplace_back(node.id, seqid, stack);; 1307 ; 1308 auto &item = drawing.visibles.back();; 1309 item.color = node.color;; 1310 item.opacity = node.opacity;; 1311 ; 1312 auto volume = GetVolume(node.id);; 1313 ; 1314 auto &sd = MakeShapeDescr(volume->GetShape());; 1315 ; 1316 item.ri = sd.rndr_info();; 1317 if (sd.has_shape()); 1318 has_shape = true;; 1319 }; 1320 return true;; 1321 });; 1322 ; 1323 CollectNodes(d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:39120,avoid,avoid,39120,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['avoid'],['avoid']
Safety,"lobal mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods autom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:17847,safe,safe,17847,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['safe'],['safe']
Safety,"local' is defined) checks file locality (i.e.; 870/// protocol 'file://') returning the result in '*local' .; 871 ; 872void TEntryList::GetFileName(const char *filename, TString &fn, bool *local); 873{; 874 TUrl u(filename, true);; 875 if (local) *local = (!strcmp(u.GetProtocol(), ""file"")) ? true : false;; 876 if (strlen(u.GetAnchor()) > 0) {; 877 fn.Form(""%s#%s"", u.GetFile(), u.GetAnchor());; 878 } else {; 879 fn = u.GetFile();; 880 }; 881 // Done; 882 return;; 883}; 884 ; 885////////////////////////////////////////////////////////////////////////////////; 886/// Return the entry list, corresponding to treename and filename; 887/// By default, the filename is first tried as is, and then, if the corresponding list; 888/// is not found, the filename is expanded to the absolute path, and compared again.; 889/// To avoid it, use option ""ne""; 890 ; 891TEntryList *TEntryList::GetEntryList(const char *treename, const char *filename, Option_t *opt); 892{; 893 if (gDebug > 1); 894 Info(""GetEntryList"",""tree: %s, file: %s"",; 895 (treename ? treename : ""-""), (filename ? filename : ""-""));; 896 ; 897 if (!treename || !filename) return nullptr;; 898 TString option = opt;; 899 option.ToUpper();; 900 bool nexp = option.Contains(""NE"");; 901 ; 902 TString fn;; 903 bool local;; 904 GetFileName(filename, fn, &local);; 905 if (nexp) local = false;; 906 ; 907 if (gDebug > 1); 908 Info(""GetEntryList"", ""file: %s, local? %d"", filename, local);; 909 ; 910 if (!fLists){; 911 //there are no sublists; 912 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))){; 913 return this;; 914 } else {; 915 //if the file is local, try the full name, unless ""ne"" option was specified; 916 if (!nexp && local){; 917 gSystem->ExpandPathName(fn);; 918 if (!gSystem->IsAbsoluteFileName(fn)); 919 gSystem->PrependPathName(gSystem->pwd(), fn);; 920 fn = gSystem->UnixPathName(fn);; 921 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))); 922 return this;; 923",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:30106,avoid,avoid,30106,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['avoid'],['avoid']
Safety,"lock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endif /* OPENSSL_API_1_1 */; 15666 ; 15667static int; 15668sslize(struct mg_connection *conn,; 15669 int (*func)(SSL *),; 15670 const struct mg_client_options *client_options); 15671{; 15672 int ret, err;; 15673 int short_trust;; 15674 unsigned timeout = 1024;; 15675 unsigned i;; 15676 ; 15677 if (!conn) {; 15678 return 0;; 15679 }; 15680 ; 15681 short_trust =; 15682 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:463056,timeout,timeout,463056,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"lock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endif /* OPENSSL_API_1_1 */; 15667 ; 15668static int; 15669sslize(struct mg_connection *conn,; 15670 int (*func)(SSL *),; 15671 const struct mg_client_options *client_options); 15672{; 15673 int ret, err;; 15674 int short_trust;; 15675 unsigned timeout = 1024;; 15676 unsigned i;; 15677 ; 15678 if (!conn) {; 15679 return 0;; 15680 }; 15681 ; 15682 short_trust =; 15683 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:463089,timeout,timeout,463089,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"log of the current value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:14323,safe,safely,14323,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,3,['safe'],['safely']
Safety,"long the dynamic path for library maps. ;  ; void Reset () final;  Pressing Ctrl+C should forward here. ;  ; void ResetAll () final;  Reset the Cling state to its initial state. ;  ; void ResetGlobals () final;  Reset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobalsContext(). ;  ; void ResetGlobalVar (void *obj) final;  Reset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::SaveGlobalsContext(). ;  ; void RewindDictionary () final;  Rewind Cling dictionary to the point where it was before executing the current macro. ;  ; void * RewindInterpreterMutex ();  Reset the interpreter lock to the state it had before interpreter-related calls happened. ;  ; void SaveContext () final;  Save the current Cling state. ;  ; void SaveGlobalsContext () final;  Save the current Cling state of global objects. ;  ; void SetAlloclockfunc (void(*)()) const final;  [Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect critical section of its code (non-thread safe parts). ;  ; void SetAllocunlockfunc (void(*)()) const final;  [Place holder for Mutex Unlock] Provide the interpreter with a way to release a lock used to protect critical section of its code (non-thread safe parts). ;  ; void * SetAutoLoadCallBack (void *cb) final;  ; int SetClassAutoLoading (int) const final;  Enable/Disable the AutoLoading of libraries. ;  ; int SetClassAutoparsing (int) final;  Enable/Disable the Autoparsing of headers. ;  ; void SetClassInfo (TClass *cl, Bool_t reload=kFALSE, Bool_t silent=kFALSE) final;  Set pointer to the TClingClassInfo in TClass. ;  ; Int_t SetClassSharedLibs (const char *cls, const char *libs) final;  Register the AutoLoading information for a class. ;  ; void SetDeclAttr (DeclId_t, const char *) final;  ; void SetErrmsgcallback (void *p) const final;  Set a callback to receive error messages. ;  ; Bool_t SetErrorMessages (Bool_t enable=kTRUE) fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:30123,safe,safe,30123,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['safe'],['safe']
Safety,"lot* frame, RooAbsData::PlotOpt o) const; Back end function to plotting functionality. Plot RooDataHist on given; frame in mode specified by plot options 'o'. The main purpose of; this function is to match the specified binning on 'o' to the; internal binning of the plot observable in this RooDataHist. Double_t weightSquared() const. Double_t weight(const RooArgSet& bin, Int_t intOrder = 1, Bool_t correctForBinSize = kFALSE, Bool_t cdfBoundaries = kFALSE, Bool_t oneSafe = kFALSE); Return the weight at given coordinates with optional; interpolation. If intOrder is zero, the weight; for the bin enclosing the coordinates; contained in 'bin' is returned. For higher values,; the result is interpolated in the real dimensions; of the dataset. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return the error on current weight. Double_t interpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim'; at current value 'xval'. void add(const RooArgSet& row, Double_t weight, Double_t sumw2); Increment the weight of the bin enclosing the coordinates given; by 'row' by the specified amount. Add the sum of weights squared; for the bin by 'sumw2' rather than wgt^2. void set(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:29621,safe,safe,29621,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,6,['safe'],['safe']
Safety,"lptr); ; # Use the histogram afterwards; print(hin.GetName()); NoteThe TFile::Close method automatically sets the current directory in the program to the gROOT object. If you want to restore the status of the current directory to some other file that was opened prior to the with statement, you can use the context manager functionality offered by TContext. Definition at line 53 of file TFile.h. Classes; struct  InfoListRet;  Simple struct of the return value of GetStreamerInfoListImpl. More...;  . Public Types; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:6103,timeout,timeout,6103,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['timeout'],['timeout']
Safety,"lres = 0 means timeout */; 6351 nread = 0;; 6352 }; 6353 }; 6354 ; 6355 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6356 return -2;; 6357 }; 6358 ; 6359 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:185858,timeout,timeout,185858,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"lres = 0 means timeout */; 6352 nread = 0;; 6353 }; 6354 }; 6355 ; 6356 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6357 return -2;; 6358 }; 6359 ; 6360 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:185890,timeout,timeout,185890,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ls = min->NCalls();; 111 fStatus = min->Status();; 112 fCovStatus= min->CovMatrixStatus();; 113 fVal = min->MinValue();; 114 fEdm = min->Edm();; 115 ; 116 fMinimizer= min;; 117 fFitFunc = func;; 118 ; 119 fMinimType = fconfig.MinimizerName();; 120 ; 121 // replace ncalls if minimizer does not support it (they are taken then from the FitMethodFunction); 122 if (fNCalls == 0) fNCalls = ncalls;; 123 ; 124 const unsigned int npar = min->NDim();; 125 if (npar == 0) return;; 126 ; 127 if (min->X() ); 128 fParams = std::vector<double>(min->X(), min->X() + npar);; 129 else {; 130 // case minimizer does not provide minimum values (it failed) take from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }; 135 }; 136 ; 137 if (sizeOfData > min->NFree() ) fNdf = sizeOfData - min->NFree();; 138 ; 139 ; 140 // set right parameters in function (in case minimizer did not do before); 141 // do also when fit is not valid; 142 if (func ) {; 143 // I think we can avoid cloning the model function; 144 //fFitFunc = dynamic_cast<IModelFunction *>( func->Clone() );; 145 //assert(fFitFunc);; 146 fFitFunc->SetParameters(&fParams.front());; 147 }; 148 else {; 149 // when no fFitFunc is present take parameters from FitConfig; 150 fParNames.resize( npar );; 151 for (unsigned int i = 0; i < npar; ++i ) {; 152 fParNames[i] = fconfig.ParSettings(i).Name();; 153 }; 154 }; 155 ; 156 ; 157 // check for fixed or limited parameters; 158 unsigned int nfree = 0;; 159 if (!fParamBounds.empty()) fParamBounds.clear();; 160 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:4775,avoid,avoid,4775,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:361465,timeout,timeout,361465,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:361498,timeout,timeout,361498,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"lsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TVirtualProofPlayer. ←. TProofPlayer; ←. TProofPlayerLocal. TProofPlayerRemote; ←. TProofPlayerLite. TProofPlayerSuperMaster. TProofPlayerSlave. Function documentation; TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0); Create a PROOF player. TVirtualProofPlayer(); { ResetBit(TVirtualProofPlayer::kIsSubmerger); }. virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Bool_t JoinProcess(TList* workers). Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualProofPlayer.html:14054,abort,abort,14054,root/html602/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualProofPlayer.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"lt matrix. . static void ActivationFunctionForward (Tensor_t &X, EActivationFunction activFunct, const ActivationDescriptor_t activationDescr, const double coef=0.0, const AFloat alpha=1, const AFloat beta=0);  ; static void ActivationFunctionBackward (Tensor_t &dX, const Tensor_t &Y, const Tensor_t &dY, const Tensor_t &X, EActivationFunction activFunct, const ActivationDescriptor_t activationDescr, const AFloat alpha=1, const AFloat beta=0);  Computes the gradient of the activation function. ;  ; static void IdentityDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Relu (Tensor_t &B);  ; static void ReluDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Sigmoid (Tensor_t &B);  ; static void SigmoidDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Tanh (Tensor_t &B);  ; static void TanhDerivative (Tensor_t &B, const Tensor_t &A);  ; static void FastTanh (Tensor_t &B);  ; static void FastTanhDerivative (Tensor_t &B, const Tensor_t &A);  ; static void SymmetricRelu (Tensor_t &B);  ; static void SymmetricReluDerivative (Tensor_t &B, const Tensor_t &A);  ; static void SoftSign (Tensor_t &B);  ; static void SoftSignDerivative (Tensor_t &B, const Tensor_t &A);  ; static void Gauss (Tensor_t &B);  ; static void GaussDerivative (Tensor_t &B, const Tensor_t &A);  ; Loss Functions; Loss functions compute a scalar value given the output of the network for a given training input and the expected network prediction Y that quantifies the quality of the prediction.; For each function also a routing that computes the gradients (suffixed by Gradients) must be provided for the starting of the backpropagation algorithm. . static Scalar_t MeanSquaredError (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static void MeanSquaredErrorGradients (Matrix_t &dY, const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static Scalar_t CrossEntropy (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  Sigmoid t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCuda.html:10247,predict,prediction,10247,doc/master/classTMVA_1_1DNN_1_1TCuda.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCuda.html,2,['predict'],['prediction']
Safety,"lt(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayer.html:10443,abort,abort,10443,root/html602/TProofPlayer.html,https://root.cern,https://root.cern/root/html602/TProofPlayer.html,2,['abort'],['abort']
Safety,"lternate(context, inside[1], newName);; 1671 ; 1672 if (altcl) {; 1673 std::string alternate = inside[0];; 1674 alternate.append(""<"");; 1675 alternate.append(newName);; 1676 // We are intentionally dropping any further arguments,; 1677 // they would be using the wrong typename and would also be; 1678 // somewhat superflous since this is for the old layout.; 1679 if (alternate[alternate.length()-1]=='>') {; 1680 alternate.append("" "");; 1681 }; 1682 alternate.append("">"");; 1683 return TClass::GetClass(alternate.c_str(),true,true);; 1684 }; 1685 }; 1686 return 0;; 1687 }; 1688 ; 1689 // Makes sure kBuildOldUsed set once BuildOld finishes; 1690 struct TBuildOldGuard {; 1691 TBuildOldGuard(TStreamerInfo* info): fInfo(info) {; 1692 fInfo->SetBit(TStreamerInfo::kBuildRunning);; 1693 }; 1694 ~TBuildOldGuard() {; 1695 fInfo->ResetBit(TStreamerInfo::kBuildRunning);; 1696 fInfo->SetBit(TStreamerInfo::kBuildOldUsed);; 1697 }; 1698 TStreamerInfo* fInfo;; 1699 };; 1700}; 1701 ; 1702////////////////////////////////////////////////////////////////////////////////; 1703/// rebuild the TStreamerInfo structure; 1704 ; 1705void TStreamerInfo::BuildOld(); 1706{; 1707 R__LOCKGUARD(gInterpreterMutex);; 1708 ; 1709 if ( TestBit(kBuildOldUsed) ) return;; 1710 ; 1711 // Are we recursing on ourself?; 1712 if (TestBit(TStreamerInfo::kBuildRunning)) return;; 1713 ; 1714 // This is used to avoid unwanted recursive call to Build and make sure; 1715 // that we record the execution of BuildOld.; 1716 TBuildOldGuard buildOldGuard(this);; 1717 ; 1718 if (gDebug > 0) {; 1719 printf(""\n====>Rebuilding TStreamerInfo for class: %s, version: %d\n"", GetName(), fClassVersion);; 1720 }; 1721 ; 1722 Bool_t wasCompiled = IsCompiled();; 1723 ; 1724 if (fClass->GetClassVersion() == fClassVersion) {; 1725 if (!fClass->HasInterpreterInfo() || fClass->GetCollectionType() || TClassEdit::IsSTLBitset(GetName())); 1726 {; 1727 // Handle emulated classes and STL containers specially.; 1728 // in this case BuildRealData w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:65799,avoid,avoid,65799,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ltiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(const ROOT::Math::DistSamplerOptions& opt). initialize the generators with the given option; which my include the algorithm but also more if; the method is re-impelmented by derived class; The default implementation calls the above method; passing just the algorithm name. void SetRandom(TRandom* ). Set the random engine to be used; To be implemented by the derived classes who provides; random sampling. {}. void SetSeed(unsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DistSampler.html:2542,avoid,avoid,2542,root/html528/ROOT__Math__DistSampler.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DistSampler.html,6,['avoid'],['avoid']
Safety,"lume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precision. void SetCerenkov(Int_t itmed, Int_t npckov, Float_t* ppckov, Float_t* absco, Float_t* effic, Float_t* rindex); Helper function for resolving MANY.; Specify the ONLY volume that overlaps with the; specified MANY and has to be substracted.; (Geant4 only); Define the tables for UV photon tracking in medium itmed.; Please note that it is the user's responsibility to; provide all the coefficients:; itmed Tracking medium number; npckov Number of bins of each table; ppckov Value of photon momentum (in GeV); absco Absorption coefficients; dielectric: absorption length in cm; metals : absorption fraction (0<=x<=1); effic Detection efficiency for UV photons; rindex Refraction index (if=0 metal). void DefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); The same as previous but in double precision. functions for definition of surfaces; and material properties for optical physics. Define the optical surface; name surface name; model selection of model (see #EMCOpSurfaceModel values); surfaceType surface type (see #EMCOpSurfaceType values); surfaceFinish surface quality (see #EMCOpSurfaceType values); sigmaAlpha an unified model surface parameter; (Geant4 only). void SetSkinSurface(const char* name, const char* volName, const char* opSurfaceName); Define the optical surface border; name border surface name; vol1Name first volume name; vol1CopyNo first volume copy number; vol2Name second volume name; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualMC.html:23248,Detect,Detection,23248,root/html532/TVirtualMC.html,https://root.cern,https://root.cern/root/html532/TVirtualMC.html,4,['Detect'],['Detection']
Safety,"ly (e.g. slicey). This should be done as if the coordinate system; 344of the generic slice was the same as the one of the divided volume. The generic; 345slice in case of PHI division is centered with respect to X axis. If the; 346family contains slices of different sizes, any volume positioned inside should; 347fit into the smallest one.; 348 Examples for specific divisions according to shape types can be found inside; 349shape classes.; 350 ; 351~~~ {.cpp}; 352 TGeoVolume::Divide(N, Xmin, Xmax, ""X"");; 353~~~; 354 ; 355 The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; 356volume is in fact a virtual container that does not represent a physical object.; 357It contains a list of nodes that are not its daughters but that must be checked; 358always before the container itself. This list must be defined by users and it; 359is checked and resolved in a priority order. Note that the feature is non-standard; 360to geometrical modelers and it was introduced just to support conversions of; 361GEANT3 geometries, therefore its extensive usage should be avoided.; 362*/; 363 ; 364/** \class TGeoVolumeAssembly; 365\ingroup Geometry_classes; 366 ; 367Volume assemblies; 368 ; 369Assemblies a volumes that have neither a shape or a material/medium. Assemblies; 370behave exactly like normal volumes grouping several daughters together, but; 371the daughters can never extrude the assembly since this has no shape. However,; 372a bounding box and a voxelization structure are built for assemblies as for; 373normal volumes, so that navigation is still optimized. Assemblies are useful; 374for grouping hierarchically volumes which are otherwise defined in a flat; 375manner, but also to avoid clashes between container shapes.; 376To define an assembly one should just input a name, then start adding other; 377volumes (or volume assemblies) as content.; 378*/; 379 ; 380#include <fstream>; 381#include <iomanip>; 382 ; 383#include ""TString.h""; 384#include ""TBuffer.h""; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:18763,avoid,avoided,18763,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['avoid'],['avoided']
Safety,"ly crash."");; 2154 element->SetOffset(0);; 2155 element->Init(this);; 2156 dmType = element->GetTypeName();; 2157 dmIsPtr = false;; 2158 }; 2159 }; 2160 } // Class corresponding to StreamerInfo is emulated or not.; 2161 ; 2162 // Now let's deal with Schema evolution; 2163 Int_t newType = -1;; 2164 TClassRef newClass;; 2165 ; 2166 if (dm && dm->IsPersistent()) {; 2167 auto theType = isStdArray ? dt : dm->GetDataType();; 2168 if (theType) {; 2169 Bool_t isArray = isStdArray || element->GetArrayLength() >= 1;; 2170 Bool_t hasCount = element->HasCounter();; 2171 // data member is a basic type; 2172 if ((fClass == TObject::Class()) && !strcmp(dm->GetName(), ""fBits"")) {; 2173 //printf(""found fBits, changing dtype from %d to 15\n"", dtype);; 2174 newType = kBits;; 2175 } else {; 2176 // All the values of EDataType have the same semantic in EReadWrite; 2177 newType = (EReadWrite)theType->GetType();; 2178 }; 2179 if ((newType == ::kChar_t) && dmIsPtr && !isArray && !hasCount) {; 2180 newType = ::kCharStar;; 2181 } else if (dmIsPtr) {; 2182 newType += kOffsetP;; 2183 } else if (isArray) {; 2184 newType += kOffsetL;; 2185 }; 2186 }; 2187 if (newType == -1) {; 2188 newClass = TClass::GetClass(dmType);; 2189 }; 2190 } else {; 2191 // Either the class is not loaded or the data member is gone; 2192 if (!fClass->IsLoaded()) {; 2193 TStreamerInfo* newInfo = (TStreamerInfo*) fClass->GetStreamerInfos()->At(fClass->GetClassVersion());; 2194 if (newInfo && (newInfo != this)) {; 2195 TStreamerElement* newElems = (TStreamerElement*) newInfo->GetElements()->FindObject(element->GetName());; 2196 newClass = newElems ? newElems->GetClassPointer() : 0;; 2197 if (newClass == 0) {; 2198 newType = newElems ? newElems->GetType() : -1;; 2199 if (!(newType < kObject)) {; 2200 // sanity check.; 2201 newType = -1;; 2202 }; 2203 }; 2204 } else {; 2205 newClass = element->GetClassPointer();; 2206 if (newClass.GetClass() == 0) {; 2207 newType = element->GetType();; 2208 if (!(newType < kObject)) {; 2209 //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:85889,sanity check,sanity check,85889,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"ly, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5115,avoid,avoid,5115,doc/master/df013__InspectAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html,1,['avoid'],['avoid']
Safety,"ly. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUDPSocket.html:13167,timeout,timeout,13167,root/html534/TUDPSocket.html,https://root.cern,https://root.cern/root/html534/TUDPSocket.html,6,['timeout'],['timeout']
Safety,"lysis bins in the proper order. Each node of the tree is responsible for a group of bins. That group may consist of . several unconnected bins, each with a dedicated name. . bins organized in a multidimensional distribution, defined by a set of axes. The axes are defined by a number of bins N and by (N+1) bin borders. In addition to the N bins inside there may be an underflow and an overflow bin . Each bin has a ""global"" bin number, which can be found using the GetGlobalBinNumber() methods. The global bin number 0 is reserved and corresponds to the case where no bin is found in the TUnfoldBinning tree.; Use in the analysis; Booking histograms: . Define binning schemes on detector level and on truth level. This can be done using the XML language, use the class TUnfoldBinningXML to read the binning scheme. The TUnfoldBinning objects can be written to a root file, preferentially together with the corresponding histograms. . For Monte Carlo, book histograms for the response matrix (detector vs truth level) using the method CreateHistogramOfMigrations() . For data and background, book histograms using the ""detector level"" binning scheme and the method CreateHistogram() . (if required) for the data covarianve matrix, book a histogram using the ""detector level"" binning scheme and the method CreateErrorMatrixHistogram() . For truth histograms, book histograms using the ""truth level"" binning scheme and the method CreateHistogram() . The histograms which are booked have all analysis bins arranged on one axis (global bin number). TUnfoldBinning provides methods to locate the global bin number: . Use the method FindNode() to locate a group of bins (e.g. signal, control distribution, etc) by their name, then: . Use the method GetGlobalBinNumber() to locate a bin in a distribution, then: . Use the TH1::Fill() method and the bin number to fill the appropriate bin in one of the histograms booked above. . Unfolding: Specify the response matrix and the binning schemes when constructi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinning.html:2042,detect,detector,2042,doc/master/classTUnfoldBinning.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinning.html,1,['detect'],['detector']
Safety,"l ; level, . const char * ; mess . ). overridevirtual . Send mess to syslog daemon. ; Level is the logging level and mess the message that will be written on the log. ; Reimplemented from TSystem.; Definition at line 2654 of file TUnixSystem.cxx. ◆ TempDirectory(). const char * TUnixSystem::TempDirectory ; (; ); const. overridevirtual . Return a user configured or systemwide directory to create temporary files in. ; Reimplemented from TSystem.; Definition at line 1503 of file TUnixSystem.cxx. ◆ TempFileName(). FILE * TUnixSystem::TempFileName ; (; TString & ; base, . const char * ; dir = nullptr, . const char * ; suffix = nullptr . ). overridevirtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented from TSystem.; Definition at line 1523 of file TUnixSystem.cxx. ◆ Umask(). int TUnixSystem::Umask ; (; Int_t ; mask). overridevirtual . Set the process file creation mode mask. ; Reimplemented from TSystem.; Definition at line 1901 of file TUnixSystem.cxx. ◆ UnixFilestat(). int TUnixSystem::UnixFilestat ; (; const char * ; fpath, . FileStat_t & ; buf . ). staticprotected . Get info about a file. ; Info is returned in the form of a FileStat_t structure (see TSystem.h). The function returns 0 in case of success and 1 if the file could not be stat'ed. ; Definition at line 4039 of file TUnixSystem.cxx. ◆ UnixFSstat(). int TUnixSystem::UnixFSstat ; (; const char * ; path, . Long_t * ; id, . Long_t * ; bsize, . Long_t * ; blocks, . Long_t * ; bfree . ). staticprotected . Get info about a file system: id, bsize, bfree, blocks. ; Id is file system type (machine dependend, see stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:71032,safe,safely,71032,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,2,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"m access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldBinningBinning schemes for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldBinningXMLXML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldDensityAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldSysAn algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties ;  CTUnixSystem;  CTUnuranTUnuran class ;  CTUnuranBaseDistTUnuranBaseDist, base class for Unuran distribution classees such as TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension) ;  CTUnuranContDistTUnuranContDist class describing one dimensional continuous distribution ;  CTUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution ;  CTUnuranEmpDistTUnuranEmpDist class for describing empiral distributions ;  CTUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:211204,detect,detector,211204,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,2,['detect'],['detector']
Safety,"m and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaboloid.html:13407,safe,safe,13407,root/html530/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html,6,['safe'],['safe']
Safety,"m, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tTGeoBBox::Safety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTGeoBBox::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFromFaceSet(TGLFaceSet* fs); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGeoBBox::SetPoints(Double_t* points) const; virtual voidTGeoBBox::SetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGeoPolyShape.html:8064,Safe,SafetyPhi,8064,root/html532/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html532/TEveGeoPolyShape.html,1,['Safe'],['SafetyPhi']
Safety,"m, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:4713,safe,safely,4713,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,4,['safe'],['safely']
Safety,"m::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer& ). virtual ~TTimer(); { Remove(); }. const char * GetCommand() const; { return fCommand.Data(); }. TObject * GetObject(); { return fObject; }. TTime GetTime() const; { return fTime; }. UInt_t GetTimerID(); { return fTimeID;}. TTime GetAbsTime() const; { return fAbsTime; }. Bool_t HasTimedOut() const; { return fTimeout; }. Bool_t IsSync() const; { return fSync; }. Bool_t IsAsync() const; { return !fSync; }. Bool_t IsInterruptingSyscalls() const; { return fIntSyscalls; }. void Add(); { TurnOn(); }. void Remove(); { TurnOff(); }. void SetTime(Long_t milliSec); { fTime = milliSec; }. void SetTimerID(UInt_t id = 0); { fTimeID = id; }. void Stop(); { TurnOff(); }. void Timeout(); { Emit(""Timeout()""); }. » Author: Fons Rademakers 28/11/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTimer.html:15434,Timeout,Timeout,15434,root/html534/TTimer.html,https://root.cern,https://root.cern/root/html534/TTimer.html,2,['Timeout'],['Timeout']
Safety,"m::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer& ). virtual ~TTimer(); { Remove(); }. const char * GetCommand() const; { return fCommand.Data(); }. TObject * GetObject(); { return fObject; }. TTime GetTime() const; { return fTime; }. UInt_t GetTimerID(); { return fTimeID;}. TTime GetAbsTime() const; { return fAbsTime; }. Bool_t HasTimedOut() const; { return fTimeout; }. Bool_t IsSync() const; { return fSync; }. Bool_t IsAsync() const; { return !fSync; }. Bool_t IsInterruptingSyscalls() const; { return fIntSyscalls; }. void Add(); { TurnOn(); }. void Remove(); { TurnOff(); }. void SetTime(Long_t milliSec); { fTime = milliSec; }. void SetTimerID(UInt_t id = 0); { fTimeID = id; }. void Stop(); { TurnOff(); }. void Timeout(); { Emit(""Timeout()""); }. » Author: Fons Rademakers 28/11/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTimer.html:15984,Timeout,Timeout,15984,root/html604/TTimer.html,https://root.cern,https://root.cern/root/html604/TTimer.html,2,['Timeout'],['Timeout']
Safety,"m::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer& ). virtual ~TTimer(); { Remove(); }. const char * GetCommand() const; { return fCommand.Data(); }. TObject * GetObject(); { return fObject; }. TTime GetTime() const; { return fTime; }. UInt_t GetTimerID(); { return fTimeID;}. TTime GetAbsTime() const; { return fAbsTime; }. Bool_t HasTimedOut() const; { return fTimeout; }. Bool_t IsSync() const; { return fSync; }. Bool_t IsAsync() const; { return !fSync; }. Bool_t IsInterruptingSyscalls() const; { return fIntSyscalls; }. void Add(); { TurnOn(); }. void Remove(); { TurnOff(); }. void SetTime(Long_t milliSec); { fTime = milliSec; }. void SetTimerID(UInt_t id = 0); { fTimeID = id; }. void Stop(); { TurnOff(); }. void Timeout(); { Emit(""Timeout()""); }. » Author: Fons Rademakers 28/11/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimer.html:15984,Timeout,Timeout,15984,root/html602/TTimer.html,https://root.cern,https://root.cern/root/html602/TTimer.html,2,['Timeout'],['Timeout']
Safety,"mInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(Double_t a, Double_t b, Double_t dz); Set dimensions of the eliptical tube. void SetDimensions(Double_t* param); Set shape dimensions starting from an array. void SetPoints(Double_t* points) const; Create eliptical tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Returns the number of vertices on the mesh. void SetPoints(Float_t* points) const; Create eliptical tube mesh points. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoEltu(); constructors. Double_t GetA() const; {return fRmin;}. Double_t Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoEltu.html:14096,Safe,Safety,14096,root/html532/TGeoEltu.html,https://root.cern,https://root.cern/root/html532/TGeoEltu.html,1,['Safe'],['Safety']
Safety,"mSetCache*_nsetCache! Normalization/Integration set manager; vector<double,allocator<double> >**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(Int_t index) const. const RooNameSet* nameSet1ByIndex(Int_t index) const. const RooNameSet* nameSet2ByIndex(Int_t index) const. void insertObjectHook(vector<double,allocator<double> >& ); Interface function to perform post-insert operations on cached object. template <> void RooCacheManager<RooAbsCacheElement> ShowMembers(TMemberInspector& insp, char* parent); needed to avoid 'specialization after instantiation' problem in gcc. » Last changed: Mon Dec 7 13:47:00 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_vector_double___.html:5039,avoid,avoid,5039,root/html526/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_vector_double___.html,1,['avoid'],['avoid']
Safety,"m[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd1.html:12871,safe,safe,12871,root/html528/TGeoTrd1.html,https://root.cern,https://root.cern/root/html528/TGeoTrd1.html,8,['safe'],['safe']
Safety,"macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; The last three options are only relevant in conjunction with TRint.; The following help and info arguments are supported:; -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; In addition to the above options the arguments that are not options,; i.e. they don't start with - or + are treated as follows:; <file>.root are considered ROOT files and added to the InputFiles() list; <macro>.C are considered ROOT macros and also added to the InputFiles() list; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; last one will prevail; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Help(const char* line); Print help on interpreter. void LoadGraphicsLibs(); Load shared libs neccesary for graphics. These libraries are only; loaded when gROOT->IsBatch() is kFALSE. void MakeBatch(); Switch to batch mode. Int_t ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); Parse the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplication.html:14935,timeout,timeout,14935,root/html526/TApplication.html,https://root.cern,https://root.cern/root/html526/TApplication.html,1,['timeout'],['timeout']
Safety,"make)Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode).Definition TTree.cxx:9177; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadCacheTTreeCache * GetReadCache(TFile *file) constFind and return the TTreeCache registered with the file and which may contain branches for us.Definition TTree.cxx:6318; TTree::fEntriesLong64_t fEntriesNumber of entries.Definition TTree.h:84; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::Resetvir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:148129,recover,recover,148129,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['recover'],['recover']
Safety,"mal TFile except that it may read and write its data via a dCache server (for more on the dCache daemon see http://www-dcache.desy.de/. ; Given a path which doesn't belong to the dCache managed filesystem, it falls back to the ordinary TFile behaviour. ; Definition at line 25 of file TDCacheFile.h. Public Types; enum  EOnErrorAction { kOnErrorRetry = 1; , kOnErrorFail = 0; , kOnErrorDefault = -1; };  Note: This must be kept in sync with values #defined in dcap.h. More...;  ;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibility = (1ULL << ( 2 )); , kRecovered = (1ULL << ( 10 )); , kHasReferences = (1ULL << ( 11 )); , kDevNull = (1ULL << ( 12 )); , ;   kWriteError = (1ULL << ( 14 )); , kBinaryFile = (1ULL << ( 15 )); , kRedirected = (1ULL << ( 16 )); , kReproducible = (1ULL << ( 17 )). };  TFile status bits. BIT(13) is taken up by TObject. More...;  ;  Public Types inherited from TDirectoryFile; enum  EStatusBits { kCloseDirectory = (1ULL << ( 7 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:1403,timeout,timeout,1403,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['timeout'],['timeout']
Safety,"mal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrap.html:3685,safe,safe,3685,root/html534/TGeoTrap.html,https://root.cern,https://root.cern/root/html534/TGeoTrap.html,6,['safe'],['safe']
Safety,"mal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:3664,safe,safe,3664,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,6,['safe'],['safe']
Safety,"mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:2084,safe,safe,2084,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,1,['safe'],['safe']
Safety,"match = -2,; 237 kClassMismatch = -1,; 238 kMatch = 0,; 239 kMatchConversion = 1,; 240 kMatchConversionCollection = 2,; 241 kMakeClass = 3,; 242 kVoidPtr = 4,; 243 kNoCheck = 5,; 244 kNeedEnableDecomposedObj = BIT(29), // DecomposedObj is the newer name of MakeClass mode; 245 kNeedDisableDecomposedObj = BIT(30),; 246 kDecomposedObjMask = kNeedEnableDecomposedObj | kNeedDisableDecomposedObj; 247 };; 248 ; 249 // TTree status bits; 250 enum EStatusBits {; 251 kForceRead = BIT(11),; 252 kCircular = BIT(12),; 253 /// If set, the branch's buffers will grow until an event cluster boundary is hit,; 254 /// guaranteeing a basket per cluster. This mode does not provide any guarantee on the; 255 /// memory bounds in the case of extremely large events.; 256 kOnlyFlushAtCluster = BIT(14),; 257 /// If set, signals that this TTree is the output of the processing of another TTree, and; 258 /// the entries are reshuffled w.r.t. to the original TTree. As a safety measure, a TTree; 259 /// with this bit set cannot add friends nor can be added as a friend. If you know what; 260 /// you are doing, you can manually unset this bit with `ResetBit(EStatusBits::kEntriesReshuffled)`.; 261 kEntriesReshuffled = BIT(19) // bits 15-18 are used by TChain; 262 };; 263 ; 264 // Split level modifier; 265 enum {; 266 kSplitCollectionOfPointers = 100; 267 };; 268 ; 269 class TClusterIterator; 270 {; 271 private:; 272 TTree *fTree; // TTree upon which we are iterating.; 273 Int_t fClusterRange; // Which cluster range are we looking at.; 274 Long64_t fStartEntry; // Where does the cluster start.; 275 Long64_t fNextEntry; // Where does the cluster end (exclusive).; 276 Long64_t fEstimatedSize; // If positive, the calculated estimated tree size.; 277 ; 278 Long64_t GetEstimatedClusterSize();; 279 ; 280 protected:; 281 friend class TTree;; 282 TClusterIterator(TTree *tree, Long64_t firstEntry);; 283 ; 284 public:; 285 // Intentionally used the default copy constructor and default destructor; 286 // as the T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:12532,safe,safety,12532,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['safe'],['safety']
Safety,"mation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively.; Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.; Important NOTE: Calling the Align() method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_t check=kFALSE, Double_t ovlp=0.001)Align a physical node with a new relative matrix/shape.Definition TGeoPhysicalNode.cxx:135; The c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:118680,avoid,avoid,118680,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"mation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively.; Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.; Important NOTE: Calling the Align() method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; The call to pn1->Align() will invalidate the pointer to the node B_1 in pn2 object.. The way out is to either call pn1->Align() before the creation of pn2, either to use a global method that will correct all existing physical nodes:; void RefreshPhysicalNodes(Bool_t lock = kTRUE); The method above will optionally lock the possibility of doing any further misalignment.; 18.9 Geometry I/O; Once geom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1016419,avoid,avoid,1016419,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avoid'],['avoid']
Safety,"mation(const TGeoMatrix *matrix)TGeoManager; AddVolume(TGeoVolume *volume)TGeoManager; AnimateTracks(Double_t tmin=0, Double_t tmax=5E-8, Int_t nframes=200, Option_t *option=""/*"")TGeoManager; AppendPad(Option_t *option="""")TObjectvirtual; BombTranslation(const Double_t *tr, Double_t *bombtr)TGeoManager; Browse(TBrowser *b) overrideTGeoManagervirtual; BuildDefaultMaterials()TGeoManager; cd(const char *path="""")TGeoManagervirtual; CdDown(Int_t index)TGeoManager; CdNext()TGeoManager; CdNode(Int_t nodeid)TGeoManager; CdTop()TGeoManager; CdUp()TGeoManager; CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)TGeoManager; CheckBoundaryReference(Int_t icheck=-1)TGeoManager; CheckedHash()TObjectinline; CheckGeometry(Option_t *option="""")TGeoManager; CheckGeometryFull(Int_t ntracks=1000000, Double_t vx=0., Double_t vy=0., Double_t vz=0., Option_t *option=""ob"")TGeoManager; CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")TGeoManager; CheckPath(const char *path) constTGeoManager; CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)TGeoManager; CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)TGeoManager; Class()TGeoManagerstatic; Class_Name()TGeoManagerstatic; Class_Version()TGeoManagerinlinestatic; ClassName() constTObjectvirtual; CleanGarbage()TGeoManager; Clear(Option_t *option="""") overrideTNamedvirtual; ClearAttributes()TGeoManager; ClearNavigators()TGeoManager; ClearOverlaps()TGeoManager; ClearPhysicalNodes(Bool_t mustdelete=kFALSE)TGeoManager; ClearShape(const TGeoShape *shape)TGeoManager; ClearThreadData() constTGeoManager; ClearThreadsMap()TGeoManagerstatic; ClearTracks()TGeoManagerinline; Clone(const char *newname="""") const overrideTNamedvirtual; CloseGeometry(Option_t *option=""d"")TGeoManager; Compare(const TObject *obj) const overrideTNamedvirtual; ConstPropMap_t typedefTGeoManagerprivate; ConvertReflections()TGeoManager; Copy(TObject &named) const overrideTNamedvirtual; CountLevels()TGeoM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager-members.html:2001,safe,safety,2001,doc/master/classTGeoManager-members.html,https://root.cern,https://root.cern/doc/master/classTGeoManager-members.html,1,['safe'],['safety']
Safety,"mawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__PDEFoamKernelGauss.html:7355,avoid,avoid,7355,root/html534/TMVA__PDEFoamKernelGauss.html,https://root.cern,https://root.cern/root/html534/TMVA__PDEFoamKernelGauss.html,2,['avoid'],['avoid']
Safety,"mawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html:7992,avoid,avoid,7992,root/html604/TMVA__PDEFoamKernelGauss.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelGauss.html,2,['avoid'],['avoid']
Safety,"mawidth of gauss curve. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamKernelGauss(Float_t sigma); Default constructor for streamer. PDEFoamKernelGauss(const TMVA::PDEFoamKernelGauss& ); Copy constructor. Float_t Estimate(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); Gaussian kernel estimator. It returns the cell value 'cv',; corresponding to the event vector 'txvec' (in foam coordinates); weighted by the cell values of all other cells, where the weight; is a gaussian function. Parameters:. - foam - the pdefoam to search in. - txvec - event vector in foam coordinates [0,1]. - cv - cell value to estimate. Float_t GetAverageNeighborsValue(TMVA::PDEFoam* , vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases when a cell value is; undefined and the cell value shall be estimated by the; (well-defined) cell values of the neighbor cells. Parameters:; - foam - the foam to search in; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. Float_t WeightGaus(TMVA::PDEFoam* , TMVA::PDEFoamCell* , vector<Float_t>& ); Returns the gauss weight between the 'cell' and a given coordinate 'txvec'. Parameters:; - cell - the cell. - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; set to 0, >1 are set to 1). Returns:; exp(-(d/sigma)^2/2), where; - d - is the euclidean distance between 'txvec' and the point of the 'cell'; which is most close to 'txvec' (in order to avoid artefacts because of the; form of the cells).; - sigma = 1/VolFrac. virtual ~PDEFoamKernelGauss(); {}. » Author: Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamKernelGauss.html:7984,avoid,avoid,7984,root/html602/TMVA__PDEFoamKernelGauss.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamKernelGauss.html,2,['avoid'],['avoid']
Safety,"may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441132,recover,recovery,441132,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Recover', 'recover']","['Recover', 'recovery']"
Safety,"may hold multi-dimensional distributions. ; For example, the ""measurement"" tree could have two leaves, one for the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the signal and one for the background. Each of the leaves may then have a multi-dimensional distribution. ; The class TUnfoldBinning takes care to map all bins of the ""measurement"" to a one-dimensional vector y. Similarly, the ""truth"" bins are mapped to the vector x.; How to choose the regularisation settings; In TUnfoldDensity, two methods are implemented to determine tau**2 . ScanLcurve() locate the tau where the L-curve plot has a ""kink"" this function is implemented in the TUnfold class . ScanTau() finds the solution such that some variable (e.g. global correlation coefficient) is minimized. This function is implemented in the TUnfoldDensity class . Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the MC prediction. Typical no-go cases of the L-curve scan are: . the number of measurements is too small (e.g. ny=nx) . the input data have no statistical fluctuations [identical MC events are used to fill the matrix of migrations and the vector y for a ""closure test""] . The algorithm (2) only works if the variable does have a real minimum as a function of tau. If global correlations are minimized, the situation is as follows: The matrix of migration typically introduces negative correlations. The area constraint introduces some positive correlation. Regularisation on the ""size"" introduces no correlation. Regularisation on 1st or 2nd derivatives adds positive correlations. ; For these reasons, ""size"" regularisation does not work well with the tau-scan: the higher tau, the smaller rho, but there is no minimum. As a result, large values of tau (too strong regularisation) are found. In contrast, the tau-scan is expected to work better with 1st or 2nd derivative ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:4144,predict,prediction,4144,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['predict'],['prediction']
Safety,"mber Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The accumulation of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasUpdates;  The accumulation of the square of the past bias updates associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The accumulation of the square of the past weight gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightUpdates;  The accumulation of the square of the past weight updates associated with the deep net. ;  ; Scalar_t fRho;  The Rho constant used by the optimizer. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor1;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor2;  working tensor used to keep a temporary copy of bias or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:2934,avoid,avoid,2934,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['avoid'],['avoid']
Safety,"mber Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The sum of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The sum of the square of the past weight gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor;  working tensor used to keep a temporary copy of weights or weight gradients ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/Adagrad.h>. Inheritance diagram for TMVA::DNN::TAdagr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html:2589,avoid,avoid,2589,doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,1,['avoid'],['avoid']
Safety,"mbers |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TTimer Class ReferenceCore ROOT classes » Base ROOT classes. ; Handles synchronous and a-synchronous timer events. . synchronous timer is registered into TSystem and is processed within the standard ROOT event-loop.; asynchronous timer is passed to the operating system which sends an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; Sub-class TTimer and override the Notify() method.; Re-implement the TObject::HandleTimer() method in your class and pass a pointer to this object to timer, see the SetObject() method.; Pass an interpreter command to timer, see SetCommand() method.; Create a TTimer, connect its Timeout() signal to the appropriate methods. Then when the time is up it will emit a Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as kItimerResolution (currently 10 ms).; Signal/slots example: TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; To emit the Timeout signal repeatedly with minimum timeout: timer->Start(0, kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94. Definition at line 51 of file TTimer.h. Public Member Functions;  TTimer (const char *command, Long_t milliSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:1085,timeout,timeout,1085,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['timeout'],['timeout']
Safety,"mbers; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKey.html:10495,avoid,avoid,10495,root/html602/TKey.html,https://root.cern,https://root.cern/root/html602/TKey.html,4,['avoid'],['avoid']
Safety,"mbie ();  . #include <TSelector.h>. Inheritance diagram for TSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EAbort. enum TSelector::EAbort. EnumeratorkContinue ; kAbortProcess ; kAbortFile . Definition at line 34 of file TSelector.h. Constructor & Destructor Documentation. ◆ TSelector() [1/2]. TSelector::TSelector ; (; const TSelector & ; ). private . ◆ TSelector() [2/2]. TSelector::TSelector ; (; ). Default selector ctor. ; Definition at line 89 of file TSelector.cxx. ◆ ~TSelector(). TSelector::~TSelector ; (; ). override . Selector destructor. ; Definition at line 102 of file TSelector.cxx. Member Function Documentation. ◆ Abort(). void TSelector::Abort ; (; const char * ; why, . EAbort ; what = kAbortProcess . ). virtual . Abort processing. ; If what = kAbortProcess, the Process() loop will be aborted. If what = kAbortFile, the current file in a chain will be aborted and the processing will continue with the next file, if there is no next file then Process() will be aborted. Abort() can also be called from Begin(), SlaveBegin(), Init() and Notify(). After abort the SlaveTerminate() and Terminate() are always called. The abort flag can be checked in these methods using GetAbort(). ; Definition at line 116 of file TSelector.cxx. ◆ Begin(). virtual void TSelector::Begin ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TProofDraw, h1analysisTreeReader, TProofDrawHist, TProofDrawProfile, TProofDrawProfile2D, TSelHist, TSelectorDraw, TSelectorEntries, and h1analysis.; Definition at line 54 of file TSelector.h. ◆ Class(). static TClass * TSelector::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSelector::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSelector::Class_Version ; (; ). inlinestaticconstexpr . R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:15573,abort,aborted,15573,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,2,['abort'],['aborted']
Safety,"md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/); 213{; 214 md5_word_t a = pms->abcd[0], b = pms->abcd[1], c = pms->abcd[2],; 215 d = pms->abcd[3];; 216 md5_word_t t;; 217#if BYTE_ORDER > 0; 218 /* Define storage only for big-endian CPUs. */; 219 md5_word_t X[16];; 220#else; 221 /* Define storage for little-endian or both types of CPUs. */; 222 md5_word_t xbuf[16];; 223 const md5_word_t *X;; 224#endif; 225 ; 226 {; 227#if BYTE_ORDER == 0; 228 /*; 229 * Determine dynamically whether this is a big-endian or; 230 * little-endian machine, since we can use a more efficient; 231 * algorithm on the latter.; 232 */; 233 static const int w = 1;; 234 ; 235 if (*((const md5_byte_t *)&w)) /* dynamic little-endian */; 236#endif; 237#if BYTE_ORDER <= 0 /* little-endian */; 238 {; 239 /*; 240 * On little-endian machines, we can process properly aligned; 241 * data without copying it.; 242 */; 243 if (!(((uintptr_t) data) & 3)) {; 244 /* data are properly aligned, a direct assignment is possible */; 245 /* cast through a (void *) should avoid a compiler warning,; 246 see; 247 https://github.com/bel2125/civetweb/issues/94#issuecomment-98112861; 248 */; 249 X = (const md5_word_t *)(const void *)data;; 250 } else {; 251 /* not aligned */; 252 memcpy(xbuf, data, 64);; 253 X = xbuf;; 254 }; 255 }; 256#endif; 257#if BYTE_ORDER == 0; 258 else /* dynamic big-endian */; 259#endif; 260#if BYTE_ORDER >= 0 /* big-endian */; 261 {; 262 /*; 263 * On big-endian machines, we must arrange the bytes in the; 264 * right order.; 265 */; 266 const md5_byte_t *xp = data;; 267 int i;; 268 ; 269#if BYTE_ORDER == 0; 270 X = xbuf; /* (dynamic only) */; 271#else; 272#define xbuf X /* (static only) */; 273#endif; 274 for (i = 0; i < 16; ++i, xp += 4); 275 xbuf[i] = (md5_word_t)(xp[0]) + (md5_word_t)(xp[1] << 8); 276 + (md5_word_t)(xp[2] << 16); 277 + (md5_word_t)(xp[3] << 24);; 278 }; 279#endif; 280 }; 281 ; 282#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n)))); 283 ; 284/* Round 1. *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:9974,avoid,avoid,9974,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['avoid'],['avoid']
Safety,"me in the list of memory objects of the current; directory or its sub-directories.; After this call the current directory is not changed.; To automatically set the current directory where the object is found,; use FindKeyAny(aname)->ReadObj(). TObject * Get(const char* namecycle); return pointer to object identified by namecycle. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. examples:; foo : get object named foo in memory; if object is not in memory, try with highest cycle from file; foo;1 : get cycle 1 of foo on file. The retrieved object should in principle derive from TObject.; If not, the function TDirectory::GetObject should be called.; However, this function will still work for a non-TObject, providing that; the calling application cast the return type to the correct type (which; is the actual type of the object). NOTE:; The method GetObject offer better protection and avoid the need; for any cast:; MyClass *obj;; directory->GetObject(""some object"",obj);; if (obj) { ... the object exist and inherits from MyClass ... }. VERY IMPORTANT NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must use dynamic_cast<>().; Example 1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");. Example 2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectory.html:15782,avoid,avoid,15782,root/html528/TDirectory.html,https://root.cern,https://root.cern/root/html528/TDirectory.html,10,['avoid'],['avoid']
Safety,"me into a static array. ;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void Streamer (TBuffer &) override;  Stream an object of class TStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBase.html:3885,detect,detected,3885,doc/master/classTStreamerBase.html,https://root.cern,https://root.cern/doc/master/classTStreamerBase.html,1,['detect'],['detected']
Safety,"me of an element.; Here we attempt to cast the assigned object into TNamed and call; SetName() there.; If you override this call NameTitleChanged() from there. void SetElementTitle(const char* title); Virtual function for setting of title of an element.; Here we attempt to cast the assigned object into TNamed and call; SetTitle() there.; If you override this call NameTitleChanged() from there. void SetElementNameTitle(const char* name, const char* title); Virtual function for setting of name and title of render element.; Here we attempt to cast the assigned object into TNamed and call; SetNameTitle() there.; If you override this call NameTitleChanged() from there. void NameTitleChanged(); Virtual function called when a name or title of the element has; been changed.; If you override this, call also the version of your direct base-class. void SetVizModel(TEveElement* model); Set visualization-parameter model element.; Calling of this function from outside of EVE should in principle; be avoided as it can lead to dis-synchronization of viz-tag and; viz-model. Bool_t FindVizModel(); Find model element in VizDB that corresponds to previously; assigned fVizTag and set fVizModel accordingly.; If the tag is not found in VizDB, the old model-element is kept; and false is returned. Bool_t ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Set the VizTag, find model-element from the VizDB and copy; visualization-parameters from it. If the model is not found and; fallback_tag is non-null, its search is attempted as well.; For example: ApplyVizTag(""TPC Clusters"", ""Clusters"");. If the model-element can not be found a warning is printed and; false is returned. void PropagateVizParamsToProjecteds(); Propagate visualization parameters to dependent elements. MainColor is propagated independently in SetMainColor().; In this case, as fMainColor is a pointer to Color_t, it should; be set in TProperClass::CopyVizParams(). Render state is not propagated. Maybe it should be,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveElement.html:13674,avoid,avoided,13674,root/html528/TEveElement.html,https://root.cern,https://root.cern/root/html528/TEveElement.html,10,['avoid'],['avoided']
Safety,"me of your last pull or clone. Get the current list of remotes (including URIs) with; git remote -v. Get the current list of defined branches with; git branch -a. Change to (creating if necessary) a local branch tracking an existing remote branch of the same name:; git checkout <branch>. Update your local repository ref database without altering the current working area:; git fetch <remote>. Update your current local branch with respect to your repository's current idea of a remote branch's status:; git merge <branch>. Pull remote ref information from all remotes and merge local branches with their remote tracking branches (if applicable):; git pull. Examine changes to the current local branch with respect to its tracking branch:; git cherry -v. Push changes to the remote tracking branch:; git push. Push all changes to all tracking branches:; git push --all. Some more advanced operations. Important tip: if you're going to do a git operation the outcome of which is even remotely uncertain to be the desired one: make a copy of your repository:; mkdir -p <path-to-safe-dir>; tar -cf - . | tar -xC <path-to-safe-dir>. Disk space is cheap and rm -rf is easy. Note that you must copy the entire repository, since all the important information is in the .git directory tree at the top level. Stashing; This is a good way quickly to get a clean tree if you want to merge or rebase (see below) to import changes from a branch without having to commit your current work. Save uncommitted changes to the current working area to the stash (not a commit operation):; git stash. Apply previously-saved stash:; git stash pop. (pops off the changes and applies them to the current working area) or; git stash apply. which applies the changes but retains them on the stack.; Examine the current state of the stash:; git stash list. Clear the entire stash:; git stash clear. Rebasing; Rebasing is changing history, if you think that git stores history. As mentioned above, it doesn't: it saves objects ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:10269,safe,safe-dir,10269,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['safe'],['safe-dir']
Safety,"me, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 146 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 147 void GetBoundingCylinder(Double_t *param) const override;; 148 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 149 Int_t GetByteCount() const override { return 56; }; 150 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 151 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 152 Int_t GetNmeshVertices() const override;; 153 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 154 Double_t GetPhi1() const { return fPhi1; }; 155 Double_t GetPhi2() const { return fPhi2; }; 156 void InspectShape() const override;; 157 TBuffer3D *MakeBuffer3D() const override;; 158 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 159 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 160 static Double_t SafetyS(const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1,; 161 Double_t phi2, Int_t skipz = 0);; 162 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 163 void SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2);; 164 void SetDimensions(Double_t *param) override;; 165 void SetPoints(Double_t *points) const override;; 166 void SetPoints(Float_t *points) const override;; 167 void SetSegsAndPols(TBuffer3D &buff) const override;; 168 void Sizeof3D() const override;; 169 ; 170 ClassDefOverride(TGeoTubeSeg, 2) // cylindrical tube segment class; 171};; 172 ; 173class TGeoCtub : public TGeoTubeSeg {; 174protected:; 175 // data members; 176 Double_t fNlow[3]; // normal to lower cut plane; 177 Double_t fNhigh[3]; // normal to higher cut plane; 178 ; 179public:; 180 // constructors; 181 TGeoCtub();; 182 TGeoCtub(Double_t rmin, Double_t rmax,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:8720,safe,safe,8720,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety,me::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 448 of file TSessionViewer.h. ◆ DeclFileName(). static const char * TSessionQueryFrame::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 448 of file TSessionViewer.h. ◆ Feedback(). void TSessionQueryFrame::Feedback ; (; TList * ; objs). Feedback function connected to Feedback signal. ; Used to update feedback histograms. ; Definition at line 2550 of file TSessionViewer.cxx. ◆ GetQueryEditFrame(). TEditQueryFrame * TSessionQueryFrame::GetQueryEditFrame ; (; ); const. inline . Definition at line 419 of file TSessionViewer.h. ◆ GetStatsCanvas(). TCanvas * TSessionQueryFrame::GetStatsCanvas ; (; ); const. inline . Definition at line 418 of file TSessionViewer.h. ◆ GetTab(). TGTab * TSessionQueryFrame::GetTab ; (; ); const. inline . Definition at line 420 of file TSessionViewer.h. ◆ IndicateStop(). void TSessionQueryFrame::IndicateStop ; (; Bool_t ; aborted). Indicate that Cancel or Stop was clicked. ; Definition at line 2878 of file TSessionViewer.cxx. ◆ IsA(). TClass * TSessionQueryFrame::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Definition at line 448 of file TSessionViewer.h. ◆ Modified(). void TSessionQueryFrame::Modified ; (; Bool_t ; mod = kTRUE). Notify changes in query editor settings. ; Definition at line 2531 of file TSessionViewer.cxx. ◆ OnBtnAbort(). void TSessionQueryFrame::OnBtnAbort ; (; ). Abort processing query. ; Definition at line 3070 of file TSessionViewer.cxx. ◆ OnBtnFinalize(). void TSessionQueryFrame::OnBtnFinalize ; (; ). Finalize query. ; Definition at line 2954 of file TSessionViewer.cxx. ◆ OnBtnRetrieve(). void TSessionQueryFrame::OnBtnRetrieve ; (; ). Retrieve query. ; Definition at line 3018 of file TSessionViewer.cxx. ◆ OnBtnShowLog(). void TSessionQueryFrame::OnBtnShowLog ; (; ). Show query log. ;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:35028,abort,aborted,35028,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,1,['abort'],['aborted']
Safety,"me::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK butto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleDialog.html:22155,avoid,avoid,22155,root/html528/TStyleDialog.html,https://root.cern,https://root.cern/root/html528/TStyleDialog.html,12,['avoid'],['avoid']
Safety,"me;; 469 errmsg += ""\"" does not correspond to column type, which is "";; 470 errmsg += GetTypeName(name);; 471 throw std::runtime_error(errmsg);; 472 }; 473 ; 474 fValues[index].fIsActive = true;; 475 return std::vector<void *>{fNSlots, &fValues[index].fPtr};; 476}; 477 ; 478////////////////////////////////////////////////////////////////////////////; 479/// Returns a range of size 1 as long as more rows are available in the SQL result set.; 480/// This inherently serialized the RDF independent of the number of slots.; 481std::vector<std::pair<ULong64_t, ULong64_t>> RSqliteDS::GetEntryRanges(); 482{; 483 std::vector<std::pair<ULong64_t, ULong64_t>> entryRanges;; 484 int retval = sqlite3_step(fDataSet->fQuery);; 485 switch (retval) {; 486 case SQLITE_DONE: return entryRanges;; 487 case SQLITE_ROW:; 488 entryRanges.emplace_back(fNRow, fNRow + 1);; 489 fNRow++;; 490 return entryRanges;; 491 default:; 492 SqliteError(retval);; 493 // Never here; 494 abort();; 495 }; 496}; 497 ; 498////////////////////////////////////////////////////////////////////////////; 499/// Returns the C++ type for a given column name, implemented as a linear search through all the columns.; 500std::string RSqliteDS::GetTypeName(std::string_view colName) const; 501{; 502 unsigned N = fColumnNames.size();; 503 ; 504 for (unsigned i = 0; i < N; ++i) {; 505 if (colName == fColumnNames[i]) {; 506 return fgTypeNames[static_cast<int>(fColumnTypes[i])];; 507 }; 508 }; 509 throw std::runtime_error(""Unknown column: "" + std::string(colName));; 510}; 511 ; 512////////////////////////////////////////////////////////////////////////////; 513/// A linear search through the columns for the given name; 514bool RSqliteDS::HasColumn(std::string_view colName) const; 515{; 516 return std::find(fColumnNames.begin(), fColumnNames.end(), colName) != fColumnNames.end();; 517}; 518 ; 519////////////////////////////////////////////////////////////////////////////; 520/// Resets the SQlite query engine at the beginning of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:20911,abort,abort,20911,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['abort'],['abort']
Safety,"means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 867 of file TUDPSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TUDPSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 898 of file TUDPSocket.cxx. ◆ Select(). Int_t TUDPSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 407 of file TUDPSocket.cxx. ◆ Send() [1/4]. Int_t TUDPSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Definition at line 464 of file TUDPSocket.cxx. ◆ Send() [2/4]. Int_t TUDPSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUDPSocket.html:29162,detect,detected,29162,doc/master/classTUDPSocket.html,https://root.cern,https://root.cern/doc/master/classTUDPSocket.html,3,"['detect', 'timeout']","['detected', 'timeout']"
Safety,"means that, for multi-thread event loops, there is no; 902guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 905a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 906~~~{.cpp}; 907ROOT::EnableImplicitMT(i); 908~~~; 909replacing `i` with the number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:51743,safe,safe,51743,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"means that, for multi-thread event loops, there is no; 942guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 945a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 946~~~{.cpp}; 947ROOT::EnableImplicitMT(i); 948~~~; 949replacing `i` with the number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53383,safe,safe,53383,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"med] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparsefAoriginal matrix; needed for the iterative solving procedure; Double_tfCntl[6]float control numbers; TArrayIfColFact; Int_tTDecompBase::fColLwbColumn lower bound of decomposed matrix; Double_tTDecompBase::fConditionmatrix condition number; Double_tTDecompBase::fDet1determinant mantissa; Double_tTDecompBase::fDet2determinant exponent for powers of 2; TArrayDfFactsize of fFact array; may be increased during the numerical factorization; Double_tfIPessimismamounts by which to increase allocated factorization space when; Int_tfIcntl[31]integer control numbers; TArrayIfIkeeppivot sequence and temporary storage information; Int_tfInfo[21]array used for communication between programs; TArrayIfIw; TArrayIfIw1; TArrayIfIw2; Int_tfMaxfrt; Int_tfNnonZeros; Int_tfNrows; Int_tfNsteps; Double_tfPrecisionprecision we demand from the linear system solver. If it isn't; Double_tfRPessimisminadequate space is detected. fIPessimism is for array ""fIw"",; TArrayIfRowFact; Int_tTDecompBase::fRowLwbRow lower bound of decomposed matrix; Double_tTDecompBase::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; Int_tfVerbose; TArrayDfWtemporary storage for the factorization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompSparse(); Default constructor. TDecompSparse(Int_t nRows, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with nrows and unspecified number of columns .; nr_nonZeros is the total number of non-zero entries in the matrix . TDecompSparse(Int_t row_lwb, Int_t row_upb, Int_t nr_nonZeros, Int_t verbose); Constructor for a matrix with row range, [row_lwb..row_upb] and unspecified column; range . nr_nonZeros is the total number of non-zero entries in the matrix . TDecompSparse(const TMatrixDSparse& a, Int_t verbose); Constructor for matrix A . TDecompSparse(const TDecompSparse& anoth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompSparse.html:10685,detect,detected,10685,root/html528/TDecompSparse.html,https://root.cern,https://root.cern/root/html528/TDecompSparse.html,6,['detect'],['detected']
Safety,"members ; TGeoCtub Class Reference. . Definition at line 173 of file TGeoTube.h. Public Member Functions;  TGeoCtub ();  ;  TGeoCtub (const char *name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);  ;  TGeoCtub (Double_t *params);  ;  TGeoCtub (Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);  ;  ~TGeoCtub () override;  ; Double_t Capacity () const override;  ; void ComputeBBox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:1322,safe,safe,1322,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"ment::EChangeBitsTEveElement::kCBVisibility; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TEveDigitSet::ERenderMode_ekRM_AsIs; static TEveDigitSet::ERenderMode_ekRM_Fill; static TEveDigitSet::ERenderMode_ekRM_Line; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTEveSecondarySelectable::fAlwaysSecSelectAlways do secondary-selection in GL.; Bool_tfAntiFlickMake extra render pass to avoid flickering when quads are too small.; Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); UChar_tTEveElement::fCSCBits; TEveDigitSet::Callback_foofCallbackFoo! Additional function to call on secondary-select.; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TEveElement::List_tTEveElement::fChildrenList of children.; Color_tfColorColor used for frame (or all digis with single-color).; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tfDefaultValueDefault signal value.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TRefArray*fDigitIdsArray holding references to external objects.; Bool_tfDisableLightingDis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveDigitSet.html:25028,avoid,avoid,25028,root/html602/TEveDigitSet.html,https://root.cern,https://root.cern/root/html602/TEveDigitSet.html,4,['avoid'],['avoid']
Safety,"mented based on TGeoVoxelGrid caching. ; Definition at line 245 of file TGeoParallelWorld.cxx. ◆ FindNodeLoop(). TGeoPhysicalNode * TGeoParallelWorld::FindNodeLoop ; (; Double_t ; point[3]). private . Finds physical node containing the point using simple algorithm (for debugging) ; Definition at line 353 of file TGeoParallelWorld.cxx. ◆ FindNodeOrig(). TGeoPhysicalNode * TGeoParallelWorld::FindNodeOrig ; (; Double_t ; point[3]). private . Finds physical node containing the point (original version based on TGeoVoxelFinder) ; Definition at line 318 of file TGeoParallelWorld.cxx. ◆ GetAccelerationMode(). AccelerationMode const & TGeoParallelWorld::GetAccelerationMode ; (; ); const. inline . Definition at line 96 of file TGeoParallelWorld.h. ◆ GetBVHSafetyCandidates(). std::pair< double, double > TGeoParallelWorld::GetBVHSafetyCandidates ; (; double ; point[3], . std::vector< int > & ; candidates, . double ; margin = 0. . ); const. private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses BVH to do so. ; Definition at line 802 of file TGeoParallelWorld.cxx. ◆ GetGeometry(). TGeoManager * TGeoParallelWorld::GetGeometry ; (; ); const. inline . Definition at line 142 of file TGeoParallelWorld.h. ◆ GetLoopSafetyCandidates(). std::pair< double, double > TGeoParallelWorld::GetLoopSafetyCandidates ; (; double ; point[3], . std::vector< int > & ; candidates, . double ; margin = 0. . ); const. private . Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ; Uses trivial algorithm to do so. ; Definition at line 740 of file TGeoParallelWorld.cxx. ◆ GetVolume(). TGeoVolume * TGeoParallelWorld::GetVolume ; (; ); const. inline . Definition at line 144 of file TGeoParallelWorld.h. ◆ InitSafetyVoxel(). void TGeoParallelWorld::InitSafetyVoxel ; (; TGeoVoxelGridIndex const & ; vi). private . Method to initialize the safety voxel at a specific 3D voxel (grid) index. ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:23323,safe,safety,23323,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"ments TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2404 of file TBufferFile.cxx. ◆ WriteFastArrayDouble32(). void TBufferFile::WriteFastArrayDouble32 ; (; const Double_t * ; d, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n doubles (as float) into the I/O buffer. ; see comments about Double32_t encoding at TBufferFile::WriteDouble32 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2331 of file TBufferFile.cxx. ◆ WriteFastArrayFloat16(). void TBufferFile::WriteFastArrayFloat16 ; (; const Float_t * ; f, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n floats (as truncated float) into the I/O buffer. ; see comments about Float16_t encoding at TBufferFile::WriteFloat16 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2265 of file TBufferFile.cxx. ◆ WriteFastArrayString(). void TBufferFile::WriteFastArrayString ; (; const Char_t * ; c, . Long64_t ; n . ). overridevirtual . Write array of n characters into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2033 of file TBufferFile.cxx. ◆ WriteFloat(). void TBufferFile::WriteFloat ; (; Float_t ; f). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 349 of file TBufferFile.h. ◆ WriteFloat16(). void TBufferFile::WriteFloat16 ; (; Float_t * ; f, . TStreamerElement * ; e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:88220,abort,aborts,88220,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"meric_limits<Double_t>::signaling_NaN();; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Returns an infinity as defined by the IEEE standard.; 916 ; 917inline Double_t TMath::Infinity() {; 918 return std::numeric_limits<Double_t>::infinity();; 919}; 920 ; 921////////////////////////////////////////////////////////////////////////////////; 922/// Returns maximum representation for type T.; 923 ; 924template<typename T>; 925inline T TMath::Limits<T>::Min() {; 926 return (std::numeric_limits<T>::min)(); //N.B. use this signature to avoid class with macro min() on Windows; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Returns minimum double representation.; 931 ; 932template<typename T>; 933inline T TMath::Limits<T>::Max() {; 934 return (std::numeric_limits<T>::max)(); //N.B. use this signature to avoid class with macro max() on Windows; 935}; 936 ; 937////////////////////////////////////////////////////////////////////////////////; 938/// Returns minimum double representation.; 939 ; 940template<typename T>; 941inline T TMath::Limits<T>::Epsilon() {; 942 return std::numeric_limits<T>::epsilon();; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946// Advanced.; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Calculates the Normalized Cross Product of two vectors.; 950 ; 951template <typename T> inline T TMath::NormCross(const T v1[3],const T v2[3],T out[3]); 952{; 953 return Normalize(Cross(v1,v2,out));; 954}; 955 ; 956////////////////////////////////////////////////////////////////////////////////; 957/// Returns minimum of array a of length n.; 958 ; 959template <typename T>; 960T TMath::MinElement(Long64_t n, const T *a) {; 961 return *std::min_element(a,a+n);; 962}; 963 ; 964////////////////////////////////////////////////////////////////////////////////; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:33977,avoid,avoid,33977,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['avoid'],['avoid']
Safety,"meters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big() ; The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1027819,safe,safe,1027819,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['safe'],['safe']
Safety,"meters theFitP = kNotEnforced;; 413 if (fAllVarsI[ivar] == """" || fAllVarsI[ivar] == ""NotEnforced"") theFitP = kNotEnforced;; 414 else if (fAllVarsI[ivar] == ""FMax"" ) theFitP = kForceMax;; 415 else if (fAllVarsI[ivar] == ""FMin"" ) theFitP = kForceMin;; 416 else if (fAllVarsI[ivar] == ""FSmart"" ) theFitP = kForceSmart;; 417 else {; 418 Log() << kFATAL << ""unknown value \'"" << fAllVarsI[ivar]; 419 << ""\' for fit parameter option "" << Form(""VarProp[%i]"",ivar) << Endl;; 420 }; 421 (*fFitParams)[ivar] = theFitP;; 422 ; 423 if (theFitP != kNotEnforced); 424 Log() << kINFO << ""Use \"""" << fAllVarsI[ivar]; 425 << ""\"" cuts for variable: "" << ""'"" << (*fInputVars)[ivar] << ""'"" << Endl;; 426 }; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430/// cut evaluation: returns 1.0 if event passed, 0.0 otherwise; 431 ; 432Double_t TMVA::MethodCuts::GetMvaValue( Double_t* err, Double_t* errUpper ); 433{; 434 // cannot determine error; 435 NoErrorCalc(err, errUpper);; 436 ; 437 // sanity check; 438 if (fCutMin == NULL || fCutMax == NULL || fNbins == 0) {; 439 Log() << kFATAL << ""<Eval_Cuts> fCutMin/Max have zero pointer. ""; 440 << ""Did you book Cuts ?"" << Endl;; 441 }; 442 ; 443 const Event* ev = GetEvent();; 444 ; 445 // sanity check; 446 if (fTestSignalEff > 0) {; 447 // get efficiency bin; 448 Int_t ibin = fEffBvsSLocal->FindBin( fTestSignalEff );; 449 if (ibin < 0 ) ibin = 0;; 450 else if (ibin >= fNbins) ibin = fNbins - 1;; 451 ; 452 Bool_t passed = kTRUE;; 453 for (UInt_t ivar=0; ivar<GetNvar(); ivar++); 454 passed &= ( (ev->GetValue(ivar) > fCutMin[ivar][ibin]) &&; 455 (ev->GetValue(ivar) <= fCutMax[ivar][ibin]) );; 456 ; 457 return passed ? 1. : 0. ;; 458 }; 459 else return 0;; 460}; 461 ; 462////////////////////////////////////////////////////////////////////////////////; 463/// print cuts; 464 ; 465void TMVA::MethodCuts::PrintCuts( Double_t effS ) const; 466{; 467 std::vector<Double_t> cutsMin;; 468 std::vector<Double_t> cutsMax;; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:16340,sanity check,sanity check,16340,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1738 of file TFumili.cxx. ◆ FitChisquareI(). void TFumili::FitChisquareI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Chisquare method. ; The ""I""ntegral method is used for each point the cache contains the following info; 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 2D : bc,e,xc,xw,yc,yw; 3D : bc,e,xc,xw,yc,yw,zc,zw . Definition at line 1809 of file TFumili.cxx. ◆ FitLikelihood(). void TFumili::FitLikelihood ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Likelihood method. ; Basically, it forms the likelihood by determining the Poisson probability that given a number of entries in a particular bin, the fit would predict it's value. This is then done for each bin, and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin) for each point the cache contains the following info; 1D : bc,e,xc (bin content, error, x of center of bin); 2D : bc,e,xc,yc; 3D : bc,e,xc,yc,zc . Definition at line 1884 of file TFumili.cxx. ◆ FitLikelihoodI(). void TFumili::FitLikelihoodI ; (; Int_t & ; npar, . Double_t * ; gin, . Double_t & ; f, . Double_t * ; u, . Int_t ; flag . ). virtual . Minimization function for H1s using a Likelihood method. ; Basically, it forms the likelihood by determining the Poisson probability that given a number of entries in a particular bin, the fit would predict it's value. This is then done for each bin, and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used for each point the cache contains the following info; 1D : bc,e,xc,xw (bin content, error, x of ce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:30928,predict,predict,30928,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['predict'],['predict']
Safety,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCtub&operator=(const TGeoCtub&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTubeSeg::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCtub.html:9523,Safe,SafetyS,9523,root/html532/TGeoCtub.html,https://root.cern,https://root.cern/root/html532/TGeoCtub.html,1,['Safe'],['SafetyS']
Safety,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoShapeAssembly&operator=(const TGeoShapeAssembly&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); voidRecomputeBoxLast(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:8320,safe,safe,8320,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,2,['safe'],['safe']
Safety,"method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(const Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoUnion& ). EGeoBoolType GetBooleanOperator() const. TGeoUnion(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoUnion.html:10105,safe,safe,10105,root/html604/TGeoUnion.html,https://root.cern,https://root.cern/root/html604/TGeoUnion.html,5,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"method. TGeoUnion(); Default constructor. TGeoUnion(const char* expr1, const char* expr2); Constructor. TGeoUnion(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoUnion(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a union of two shapes. Bool_t Contains(const Double_t* point) const; Find if a union of two shapes contains a given point. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Computes distance from a given point inside the shape to its boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given outside point to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this union. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoUnion& ). EGeoBoolType GetBooleanOperator() const. TGeoUnion(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoUnion.html:10105,safe,safe,10105,root/html602/TGeoUnion.html,https://root.cern,https://root.cern/root/html602/TGeoUnion.html,5,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"metimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX, halfY, halfZ);; TGeoVolume *vol_tub = gGeoManager->MakeTube(""TUB_VOL"", ""mat2"", rmin, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(const Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:4068,safe,safe,4068,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,6,['safe'],['safe']
Safety,"metry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape sur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:4484,safe,safe,4484,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,4,['safe'],['safe']
Safety,"milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The interpreter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:13348,timeout,timeout,13348,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,4,['timeout'],['timeout']
Safety,"min1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCone.html:2202,safe,safe,2202,root/html528/TGeoCone.html,https://root.cern,https://root.cern/root/html528/TGeoCone.html,1,['safe'],['safe']
Safety,"mits (most recent at the bottom) along with instructions on what to do. Commits can have their log messages reworded; commits can be removed entirely, combined with other commits or re-ordered. If you specified any rewording or squashing, you will be taken to an edit session for the commit message(s) after saving and exiting the current edit session.; Squash, re-order or reword commits since divergence from :; git rebase -i <branch>. Keep up to date with remote branches without merging.; git pull --rebase. or; git fetch <remote>; git rebase <remote>/<branch>. Resolving conflicts; Any pull, merge, or rebase operation can result in a conflict during the application of a particular change from the remote branch. Follow the on-screen instructions to resolve problems. This will usually consist of doing a git status to list conflicts, editing the files and using git add to mark each conflict resolved. The process must either be allowed to continue by issuing a git rebase --continue or git merge --continue command, or the operation can be reverted with --abort instead of --continue. If in doubt, copy your repository.; Making a new remote branch. Create a new local branch based on an existing one:; git checkout -b <branch>. Do stuff.; Push the branch to the remote:; git push <remote> <local-branch-name>[:<new-remote-branch-name>]. Tagging. Tag the current state of a branch (eg for release):; git tag -am <message> <version>. Note that the -a creates an annotated tag, which is itself a commit with a hash and a commit message. This is the closest analogue to the CVS tag command. Omitting the -a option will create a, ""simple tag"" which is actually a branch. In general, you will probably prefer annotated tags with version-branches created explicitly as desired.; Push the tag to the remote:; git push --tags. Special notes on mis-tagging.; There are several things that can go wrong with tagging:. One can omit an intended -a option;; One can misspell the tag; or; One can omit or (h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:13183,abort,abort,13183,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['abort'],['abort']
Safety,"mizer status. ;  ; void saveStatus (const char *label, int status);  ; int seek ();  Execute SEEK. ;  ; void setEps (double eps);  Change MINUIT epsilon. ;  ; void setErrorLevel (double level);  Set the level for MINUIT error analysis to the given value. ;  ; void setEvalErrorWall (bool flag);  ; bool setLogFile (const char *logf=nullptr);  ; void setMaxFunctionCalls (int n);  Change maximum number of likelihood function class from MINUIT (RooMinimizer default 500 * #parameters) ;  ; void setMaxIterations (int n);  Change maximum number of MINUIT iterations (RooMinimizer default 500 * #parameters) ;  ; void setMinimizerType (std::string const &type);  Choose the minimizer algorithm. ;  ; void setOffsetting (bool flag);  Enable internal likelihood offsetting for enhanced numeric precision. ;  ; void setPrintEvalErrors (int numEvalErrors);  ; void setPrintLevel (int newLevel);  Change the MINUIT internal printing level. ;  ; void setProfile (bool flag=true);  ; void setRecoverFromNaNStrength (double strength);  Try to recover from invalid function values. ;  ; void setStrategy (int istrat);  Change MINUIT strategy to istrat. ;  ; void setVerbose (bool flag=true);  ; int simplex ();  Execute SIMPLEX. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void zeroEvalCount ();  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:4960,recover,recover,4960,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['recover'],['recover']
Safety,"mment = 0;; 226 if (signalMethod != (TMethod *) -1) // -1 in case of interpreted class; 227 comment = signalMethod->GetCommentString();; 228 ; 229 if (!comment || !comment[0] || strstr(comment,""*SIGNAL"")){; 230 ::Error(""TQObject::CheckConnectArgs"",; 231 ""signal %s::%s(%s), to declare signal use comment //*SIGNAL*"",; 232 sender_class->GetName(), signal_method, signal_proto);; 233 delete [] signal_method;; 234 return -1;; 235 }; 236#endif; 237 ; 238 // cleaning; 239 delete [] signal_method;; 240 ; 241 auto len2 = strlen(slot)+1;; 242 char *slot_method = new char[len2];; 243 if (slot_method) strlcpy(slot_method, slot, len2);; 244 ; 245 char *slot_proto;; 246 char *slot_params = nullptr;; 247 ; 248 if ((slot_proto = strchr(slot_method,'('))) {; 249 ; 250 // substitute first '(' symbol with '\0'; 251 *slot_proto++ = '\0';; 252 ; 253 // substitute last ')' symbol with '\0'; 254 if ((tmp = strrchr(slot_proto,')'))) *tmp = '\0';; 255 }; 256 ; 257 if (!slot_proto) slot_proto = (char*)""""; // avoid zero strings; 258 if ((slot_params = strchr(slot_proto,'='))) *slot_params = ' ';; 259 ; 260 TFunction *slotMethod = nullptr;; 261 if (!receiver_class) {; 262 // case of slot_method is compiled/intrepreted function; 263 slotMethod = gROOT->GetGlobalFunction(slot_method,nullptr,kFALSE);; 264 } else {; 265 slotMethod = !slot_params ?; 266 GetMethodWithPrototype(receiver_class,; 267 slot_method,; 268 slot_proto,; 269 nargs) :; 270 GetMethod(receiver_class,; 271 slot_method, slot_params);; 272 }; 273 ; 274 if (!slotMethod) {; 275 if (!slot_params) {; 276 ::Error(""TQObject::CheckConnectArgs"", ""slot %s(%s) does not exist"",; 277 receiver_class ? Form(""%s::%s"", receiver_class->GetName(),; 278 slot_method) : slot_method, slot_proto);; 279 } else {; 280 ::Error(""TQObject::CheckConnectArgs"", ""slot %s(%s) does not exist"",; 281 receiver_class ? Form(""%s::%s"", receiver_class->GetName(),; 282 slot_method) : slot_method, slot_params);; 283 }; 284 delete [] slot_method;; 285 return -1;; 286 }; 287 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:8407,avoid,avoid,8407,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['avoid'],['avoid']
Safety,"mns second; - homogeneous == true means all table cells are the same size,; set by the widest and the highest child frame.; - s gives the amount of separation in pixels between cells; - h are the hints, see TGTableLayoutHints. ~TGTableLayout(); TGTableLayout constructor. void FindRowColSizes(); Find the sizes of rows and columns needed to statisfy; children's layout policies. void FindRowColSizesInit(); Initialize values needed to determine the size of rows and columns. void FindRowColSizesSinglyAttached(); Determine the size of rows/cols needed for singly attached children. void FindRowColSizesHomogeneous(); If the table is homogeneous make sure all col/rows are same; size as biggest col/row. void FindRowColSizesMultiplyAttached(); Checks any children which span multiple col/rows. void SetRowColResize(UInt_t real_size, UInt_t nthings, TGTableLayout::TableData_t* thing, Bool_t homogeneous); If main frame is bigger or smaller than all children,; expand/shrink to fill. This is symmetric under row<-->col; switching so it is abstracted out to a normal function to save typing. void SetRowColSizes(); This gets the new sizes needed to fit the table to the parent; frame. To be called after FindRowColSizes. void SetRowColSizesInit(); Initialize rows/cols. By default they do not expand and they; do shrink. What the children want determine what the rows/cols do. void CheckSanity(); Sanity check various values. void Layout(); Make a table layout of all frames in the list. TGDimension GetDefaultSize() const; Return default dimension of the table layout. void SavePrimitive(ostream& out, Option_t* = """"). TGTableLayoutHints& operator=(const TGTableLayout& ). TGTableLayout(const TGTableLayout& ). » Author: Brett Viren 04/15/2001 » Copyright (C) 2001, Brett Viren *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGTableLayout.html:9696,Sanity check,Sanity check,9696,root/html534/TGTableLayout.html,https://root.cern,https://root.cern/root/html534/TGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety,"mns second; - homogeneous == true means all table cells are the same size,; set by the widest and the highest child frame.; - s gives the amount of separation in pixels between cells; - h are the hints, see TGTableLayoutHints. ~TGTableLayout(); TGTableLayout constructor. void FindRowColSizes(); Find the sizes of rows and columns needed to statisfy; children's layout policies. void FindRowColSizesInit(); Initialize values needed to determine the size of rows and columns. void FindRowColSizesSinglyAttached(); Determine the size of rows/cols needed for singly attached children. void FindRowColSizesHomogeneous(); If the table is homogeneous make sure all col/rows are same; size as biggest col/row. void FindRowColSizesMultiplyAttached(); Checks any children which span multiple col/rows. void SetRowColResize(UInt_t real_size, UInt_t nthings, TGTableLayout::TableData_t* thing, Bool_t homogeneous); If main frame is bigger or smaller than all children,; expand/shrink to fill. This is symmetric under row<-->col; switching so it is abstracted out to a normal function to save typing. void SetRowColSizes(); This gets the new sizes needed to fit the table to the parent; frame. To be called after FindRowColSizes. void SetRowColSizesInit(); Initialize rows/cols. By default they do not expand and they; do shrink. What the children want determine what the rows/cols do. void CheckSanity(); Sanity check various values. void Layout(); Make a table layout of all frames in the list. TGDimension GetDefaultSize() const; Return default dimension of the table layout. void SavePrimitive(ostream& out, Option_t* = """"). TGTableLayoutHints& operator=(const TGTableLayout& ). TGTableLayout(const TGTableLayout& ). » Author: Brett Viren 04/15/2001 » Copyright (C) 2001, Brett Viren *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTableLayout.html:10148,Sanity check,Sanity check,10148,root/html604/TGTableLayout.html,https://root.cern,https://root.cern/root/html604/TGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety,"mns second; - homogeneous == true means all table cells are the same size,; set by the widest and the highest child frame.; - s gives the amount of separation in pixels between cells; - h are the hints, see TGTableLayoutHints. ~TGTableLayout(); TGTableLayout constructor. void FindRowColSizes(); Find the sizes of rows and columns needed to statisfy; children's layout policies. void FindRowColSizesInit(); Initialize values needed to determine the size of rows and columns. void FindRowColSizesSinglyAttached(); Determine the size of rows/cols needed for singly attached children. void FindRowColSizesHomogeneous(); If the table is homogeneous make sure all col/rows are same; size as biggest col/row. void FindRowColSizesMultiplyAttached(); Checks any children which span multiple col/rows. void SetRowColResize(UInt_t real_size, UInt_t nthings, TGTableLayout::TableData_t* thing, Bool_t homogeneous); If main frame is bigger or smaller than all children,; expand/shrink to fill. This is symmetric under row<-->col; switching so it is abstracted out to a normal function to save typing. void SetRowColSizes(); This gets the new sizes needed to fit the table to the parent; frame. To be called after FindRowColSizes. void SetRowColSizesInit(); Initialize rows/cols. By default they do not expand and they; do shrink. What the children want determine what the rows/cols do. void CheckSanity(); Sanity check various values. void Layout(); Make a table layout of all frames in the list. TGDimension GetDefaultSize() const; Return default dimension of the table layout. void SavePrimitive(ostream& out, Option_t* = """"). TGTableLayoutHints& operator=(const TGTableLayout& ). TGTableLayout(const TGTableLayout& ). » Author: Brett Viren 04/15/2001 » Copyright (C) 2001, Brett Viren *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTableLayout.html:10148,Sanity check,Sanity check,10148,root/html602/TGTableLayout.html,https://root.cern,https://root.cern/root/html602/TGTableLayout.html,1,['Sanity check'],['Sanity check']
Safety,"momentum (in GeV); values property values; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the material specified by; the material Id - NEW. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Return the material parameters for the volume specified by; the volumeName.; Return the medium parameters for the volume specified by the; volumeName. void SetRootGeometry(); Write out the geometry of the detector in EUCLID file format; filnam file name - will be with the extension .euc *; topvol volume name of the starting node; number copy number of topvol (relevant for gsposp); nlevel number of levels in the tree structure; to be written out, starting from topvol; (Geant3 only); Deprecated; Set geometry from Root (built via TGeo). void SetUserParameters(Bool_t isUserParameters); Activate the parameters defined in tracking media; (DEEMAX, STMIN, STEMAX), which are, be default, ignored.; In Geant4 case, only STEMAX is taken into account.; In FLUKA, all tracking media parameters are ignored. Int_t VolId(const char* volName) const. get methods. Return the unique numeric identifier for volume name volName. const char* VolName(Int_t id) const; Return the volume name for a given volume identifier id. Int_t MediumId(const char* mediumName) const; Return the unique numeric identifier for medium name mediumName. Int_t NofVolumes() const; Return total number of volumes in the geometry. Int_t VolId2Mate(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:26063,detect,detector,26063,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,3,['detect'],['detector']
Safety,"mory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Drawvoid Draw(Option_t *option="""") overrideFill Graphics Structure and Paint.Definition TFile.cxx:1111; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::IsATClass * IsA() const overrideDefinition TFile.h:344; TFile::fgReadCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:229202,recover,recover,229202,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recover']
Safety,"mory safe interfaces; If you define the ROOFIT_MEMORY_SAFE_INTERFACES preprocessor macro, the RooFit interface changes in a way such that memory leaks are avoided.; The most prominent effect of this change is that many functions that used to return an owning pointer (e.g., a pointer to an object that you need to manually delete) are then returning a std::unique_pt for automatic memory management.; For example this code would not compile anymore, because there is the risk that the caller forgets to delete params:; RooArgSet * params = pdf.getParameters(nullptr);; If you wrap such return values in a std::unique_ptr, then your code will compile both with and without memory safe interfaces:; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; Also some virtual RooFit functions like RooAbsReal::createIntegral() are returning a different type conditional on ROOFIT_MEMORY_SAFE_INTERFACES. If you are overriding such a function, you need to use the RooFit::OwningPtr return type, which is an alias for std::unique_ptr in memory-safe mode or an alias for a raw pointer otherwise.; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; The biggest application of the memory-safe interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is stro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:10231,safe,safe,10231,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['safe'],['safe']
Safety,"mpinfo,compinfo->fOffset) ); break;; 3257 case TStreamerInfo::kUInt: readSequence->AddAction( ReadBasicType<UInt_t>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3258 case TStreamerInfo::kULong: readSequence->AddAction( ReadBasicType<ULong_t>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3259 case TStreamerInfo::kULong64: readSequence->AddAction( ReadBasicType<ULong64_t>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3260 case TStreamerInfo::kBits: readSequence->AddAction( ReadBasicType<BitsMarker>, new TBitsConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3261 case TStreamerInfo::kFloat16: {; 3262 if (element->GetFactor() != 0) {; 3263 readSequence->AddAction( ReadBasicType_WithFactor<float>, new TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; 3264 } else {; 3265 Int_t nbits = (Int_t)element->GetXmin();; 3266 if (!nbits) nbits = 12;; 3267 readSequence->AddAction( ReadBasicType_NoFactor<float>, new TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; 3268 }; 3269 break;; 3270 }; 3271 case TStreamerInfo::kDouble32: {; 3272 if (element->GetFactor() != 0) {; 3273 readSequence->AddAction( ReadBasicType_WithFactor<double>, new TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; 3274 } else {; 3275 Int_t nbits = (Int_t)element->GetXmin();; 3276 if (!nbits) {; 3277 readSequence->AddAction( ConvertBasicType<float,double>::Action, new TConfiguration(this,i,compinfo,compinfo->fOffset) );; 3278 } else {; 3279 readSequence->AddAction( ReadBasicType_NoFactor<double>, new TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; 3280 }; 3281 }; 3282 break;; 3283 }; 3284 case TStreamerInfo::kTNamed: readSequence->AddAction( ReadTNamed, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; 3285 // Idea: We should calculate the CanIgnoreTObjectStreamer here and avoid calling the; 3286 // Streamer alltogether.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:145945,avoid,avoid,145945,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"mplate <typename T>; 919 INLINE_TEMPLATE_ARGS Int_t ReadBasicType_NoFactor(TBuffer &buf, void *addr, const TConfiguration *config); 920 {; 921 // Stream a Float16 or Double32 where a factor has not been specified.; 922 ; 923 TConfNoFactor *conf = (TConfNoFactor *)config;; 924 Int_t nbits = conf->fNbits;; 925 ; 926 buf.ReadWithNbits( (T*)( ((char*)addr) + config->fOffset ), nbits );; 927 return 0;; 928 }; 929 ; 930 INLINE_TEMPLATE_ARGS Int_t ReadTString(TBuffer &buf, void *addr, const TConfiguration *config); 931 {; 932 // Read in a TString object.; 933 ; 934 // Idea: We could separate the TString Streamer in its two parts and; 935 // avoid the if (buf.IsReading()) and try having it inlined.; 936 ((TString*)(((char*)addr)+config->fOffset))->TString::Streamer(buf);; 937 return 0;; 938 }; 939 ; 940 INLINE_TEMPLATE_ARGS Int_t ReadTObject(TBuffer &buf, void *addr, const TConfiguration *config); 941 {; 942 // Read in a TObject object part.; 943 ; 944 // Idea: We could separate the TObject Streamer in its two parts and; 945 // avoid the if (buf.IsReading()).; 946 ((TObject*)(((char*)addr)+config->fOffset))->TObject::Streamer(buf);; 947 return 0;; 948 }; 949 ; 950 INLINE_TEMPLATE_ARGS Int_t ReadTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 951 {; 952 // Read in a TNamed object part.; 953 // Since the TNamed streamer is solely delegating back to the StreamerInfo we; 954 // can skip the streamer.; 955 ; 956 // Idea: We could extract the code from ReadClassBuffer and avoid one function; 957 // code.; 958 static const TClass *TNamed_cl = TNamed::Class();; 959 return buf.ReadClassBuffer(TNamed_cl,(((char*)addr)+config->fOffset));; 960 }; 961 ; 962 class TConfigSTL : public TConfiguration {; 963 // Configuration object for the kSTL case; 964 private:; 965 void Init() {; 966 TVirtualCollectionProxy *proxy = fNewClass->GetCollectionProxy();; 967 if (proxy) {; 968 fCreateIterators = proxy->GetFunctionCreateIterators();; 969 fCreateWriteIterators = proxy->GetFunction",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:38385,avoid,avoid,38385,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"mplateProxy *pytmpl, bool use_targs, uint64_t sighash, CPPOverload *pymeth);  ; bool UseStrictOwnership (CallContext *ctxt);  ; static void vectoriter_dealloc (vectoriterobject *vi);  ; static PyObject * vectoriter_iternext (vectoriterobject *vi);  . Variables; PyTypeObject CPPDataMember_Type;  ; PyTypeObject CPPExcInstance_Type;  ; PyTypeObject CPPInstance_Type;  ; PyTypeObject CPPOverload_Type;  ; PyTypeObject CPPScope_Type;  ; PyTypeObject CustomInstanceMethod_Type;  ; static PyMemberDef dm_members [];  ; static PyMethodDef dm_methods [];  ; static PyNumberMethods ep_as_number;  ; static PyMethodObject * free_list;  ; PyObject * gAbrtException = nullptr;  ; PyObject * gBusException = nullptr;  ; std::ostringstream gCapturedError;  ; static ConvFactories_t gConvFactories;  ; PyObject * gDefaultObject = nullptr;  ; bool gDictLookupActive = false;  ; dict_lookup_func gDictLookupOrg = 0;  ; static ExecFactories_t gExecFactories;  ; PyObject * gIllException = nullptr;  ; std::set< std::string > gIteratorTypes;  ; PyObject * gNullPtrObject = nullptr;  ; std::streambuf * gOldErrorBuffer = nullptr;  ; std::set< Cppyy::TCppType_t > gPinnedTypes;  ; PyObject * gPyTypeMap = nullptr;  ; PyObject * gSegvException = nullptr;  ; PyObject * gThisModule = nullptr;  ; PyTypeObject IndexIter_Type;  ; PyTypeObject InstanceArrayIter_Type;  ; PyTypeObject LowLevelView_Type;  ; static PyGetSetDef meta_getset [];  ; static PyMethodDef meta_methods [];  ; static int numfree = 0;  ; static PyNumberMethods op_as_number;  ; static PySequenceMethods op_as_sequence;  ; static PyGetSetDef op_getset [];  ; static PyMethodDef op_methods [];  ; PyTypeObject RefFloat_Type;  Custom ""builtins,"" detectable by type, for pass by ref and improved performance. ;  ; PyTypeObject RefInt_Type;  ; const int SMALL_ARGS_N = 8;  ; PyTypeObject TemplateProxy_Type;  ; static PyMappingMethods tpp_as_mapping;  ; static PyGetSetDef tpp_getset [];  ; static PyMethodDef tpp_methods [];  ; static PyGetSetDef tptc_getset",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceCPyCppyy.html:20245,detect,detectable,20245,doc/master/namespaceCPyCppyy.html,https://root.cern,https://root.cern/doc/master/namespaceCPyCppyy.html,1,['detect'],['detectable']
Safety,"mplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFlatRandomGen;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates the seed generator and Minimum builder for the Fumili minimization method ;  CFumiliStandardChi2FCNClass implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation ;  CFumiliStandardMaximumLikelihoodFCNClass implementing the Elements member function for the standard maximum likelihood method ;  CFunctionGradient;  CFunctionMinimizerBase class for function minimizers; user may give FCN or FCN with Gradient, Parameter starting values and initial Error guess (sigma) (or ""step size""), or Parameter starting values and initial covariance matrix; covariance matrix is stored in Upper triangular packed storage format, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:56437,predict,predicted,56437,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,4,['predict'],['predicted']
Safety,"mporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:877466,safe,safely,877466,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['safe'],['safely']
Safety,"mpute bounding box of the assembly. ;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Compute normal to closest surface from POINT. Should not be called. ;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside the assembly. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  compute closest distance from point px,py to each vertex. Should not be called. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to surface of the hyperboloid. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  compute distance from outside point to surface of the hyperboloid. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Cannot divide assemblies. ;  ; TGeoS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:1756,safe,safe,1756,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"mpute stream, if it's not the default stream.Definition CudaMatrix.h:282; TMVA::DNN::TCudaMatrix::fNColssize_t fNColsDefinition CudaMatrix.h:118; TMVA::DNN::TCudaMatrix::GetOnesstatic AFloat * GetOnes()Definition CudaMatrix.h:125; TMVA::DNN::TCudaMatrix::~TCudaMatrix~TCudaMatrix()=default; TMVA::DNN::TCudaMatrix::fOnesstatic AFloat * fOnesVector used for summations of columns.Definition CudaMatrix.h:111; TMVA::DNN::TCudaMatrix::fCublasHandlestatic cublasHandle_t fCublasHandleDefinition CudaMatrix.h:109; TMVA::DNN::TCudaMatrix::fInstancesstatic size_t fInstancesCurrent number of matrix instances.Definition CudaMatrix.h:108; TMVA::DNN::TCudaMatrix::GetNrowssize_t GetNrows() constDefinition CudaMatrix.h:159; TMVA::DNN::TCudaMatrix::operator=TCudaMatrix & operator=(TCudaMatrix &&)=default; TMVA::DNN::TCudaMatrix::InitializeCurandStatesvoid InitializeCurandStates()Definition CudaMatrix.cu:140; TMVA::DNN::TCudaMatrix::GetDataPointerAFloat * GetDataPointer()Definition CudaMatrix.h:164; TMVA::DNN::TCudaMatrix::fNOnesstatic size_t fNOnesCurrent length of the one vector.Definition CudaMatrix.h:112; TMVA::DNN::TCudaMatrix::TCudaMatrixTCudaMatrix(TCudaMatrix &&)=default; TMVA::DNN::TCudaMatrix::GetCurandStatesPointerstatic curandState_t * GetCurandStatesPointer()Definition CudaMatrix.h:152; TMatrixTBase::Printvoid Print(Option_t *name="""") const overridePrint the matrix as a table of elements.Definition TMatrixTBase.cxx:636; TMatrixTTMatrixT.Definition TMatrixT.h:40; bool; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; TMVA::DNN::cudaErrorvoid cudaError(cudaError_t code, const char *file, int line, bool abort=true)Function to check cuda return code.Definition CudaMatrix.h:198; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; mTMarker mDefinition textangle.C:8. tmvatmvaincTMVADNNArchitecturesCudaCudaMatrix.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:57 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaMatrix_8h_source.html:17603,abort,abort,17603,doc/master/CudaMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaMatrix_8h_source.html,1,['abort'],['abort']
Safety,"mputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDz () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Double_t GetRmax () const;  ; virtual Double_t GetRmin () const;  ; Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:4111,safe,safe,4111,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,9,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"mputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDz () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Double_t GetRmax1 () const;  ; virtual Double_t GetRmax2 () const;  ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:1318,safe,safe,1318,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"mum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 63\anchor floatmax2 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 64\anchor doublemax2 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 65</sup>; 66 ; 67*/; 68 ; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// 2-D histogram default constructor.; 72 ; 73TH2::TH2(); 74{; 75 fDimension = 2;; 76 fScalefactor = 1;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78}; 79 ; 80 ; 81////////////////////////////////////////////////////////////////////////////////; 82/// Constructor for fix bin size 2-D histograms.; 83/// Creates the main histogram structure.; 84///; 85/// \param[in] name name of histogram (avoid blanks); 86/// \param[in] title histogram title.; 87/// If title is of the form `stringt;stringx;stringy;stringz`,; 88/// the histogram title is set to `stringt`,; 89/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 90/// \param[in] nbinsx number of bins along the X axis; 91/// \param[in] xlow low edge of the X axis first bin; 92/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 93/// \param[in] nbinsy number of bins along the Y axis; 94/// \param[in] ylow low edge of the Y axis first bin; 95/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 96 ; 97TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 98 ,Int_t nbinsy,Double_t ylow,Double_t yup); 99 :TH1(name,title,nbinsx,xlow,xup); 100{; 101 fDimension = 2;; 102 fScalefactor = 1;; 103 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 104 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 105 fYaxis.S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:3731,avoid,avoid,3731,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n *width and *height.; string – String whose dimensions are to be computed. numChars – Number of characters to consider from string, or < 0 for strlen(). wrapLength – Longest permissible line length, in pixels. <= 0 means no automatic wrapping: just let lines get as long as needed. justify – How to justify lines. flags – Flag bits OR-ed together. kTextIgnoreTabs means that tab characters should not be expanded. kTextIgnoreNewlines means that newline characters should not cause a line break. width – Filled with width of string. height – Filled with height of string. ; Definition at line 661 of file TGFont.cxx. ◆ DeclFileName(). static const char * TGFont::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 209 of file TGFont.h. ◆ DrawChars(). void TGFont::DrawChars ; (; Drawable_t ; dst, . GContext_t ; gc, . const char * ; source, . Int_t ; numChars, . Int_t ; x, . Int_t ; y . ); const. Perform a quick sanity check to ensure we won't overflow the X coordinate space. ; Definition at line 1493 of file TGFont.cxx. ◆ DrawCharsExp(). void TGFont::DrawCharsExp ; (; Drawable_t ; dst, . GContext_t ; gc, . const char * ; source, . Int_t ; numChars, . Int_t ; x, . Int_t ; y . ); const. Draw a string of characters on the screen. ; DrawCharsExp() expands control characters that occur in the string to \X or \xXX sequences. DrawChars() just draws the strings.; dst – Window or pixmap in which to draw. gc – Graphics context for drawing characters. source – Characters to be displayed. Need not be'\0' terminated. For DrawChars(), all meta-characters (tabs, control characters, and newlines) should be stripped out of the string that is passed to this function. If they are not stripped out, they will be displayed as regular printing characters. numChars – Number of characters in string. x, y – Coordinates at which to place origin of string when drawing. ; Definition at line 1463 of file TGFont.cxx. ◆ GetFontAttributes(). FontAt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFont.html:17557,sanity check,sanity check,17557,doc/master/classTGFont.html,https://root.cern,https://root.cern/doc/master/classTGFont.html,1,['sanity check'],['sanity check']
Safety,"n = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSuperMaster.html:11634,timeout,timeout,11634,root/html602/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSuperMaster.html,2,['timeout'],['timeout']
Safety,"n = kTRUE). overridevirtual . Switch on/off merge timer. ; Reimplemented from TProofPlayer.; Definition at line 1814 of file TProofPlayer.cxx. ◆ SetSelectorDataMembersFromOutputList(). void TProofPlayerRemote::SetSelectorDataMembersFromOutputList ; (; ). protected . Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ; Definition at line 2766 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerRemote::SetupFeedback ; (; ). overrideprotectedvirtual . Setup reporting of feedback objects. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 4095 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayerRemote::StopFeedback ; (; ). overrideprotectedvirtual . Stop reporting of feedback objects. ; Reimplemented from TProofPlayer.; Definition at line 4118 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayerRemote::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop process after this event. ; Reimplemented from TProofPlayer.; Definition at line 3325 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayerRemote::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback results from the specified slave. ; Reimplemented from TProofPlayer.; Definition at line 4034 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayerRemote::StoreOutput ; (; TList * ; out). overridevirtual . Store received output list. ; Reimplemented from TProofPlayer.; Definition at line 3852 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayerRemote::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster. ◆ StreamerNVirtual(). void TProofPlayerRemote::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 366 of file TProofPlayer.h. Member Data Docum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:37234,timeout,timeout,37234,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['timeout'],['timeout']
Safety,"n = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 287 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayer::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 689 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayer::StoreOutput ; (; TList * ; out). overridevirtual . Store output list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 681 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:42632,timeout,timeout,42632,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,2,['timeout'],['timeout']
Safety,"n = std::min(outAxis.GetLast(),outAxis.GetNbins() ) ;; 1902 ; 1903 if ( lastbin < firstbin && inAxis.TestBit(TAxis::kAxisRange) ) {; 1904 firstbin = inAxis.GetFirst();; 1905 lastbin = inAxis.GetLast();; 1906 // For special case of TAxis::SetRange, when first == 1 and last; 1907 // = N and the range bit has been set, the TAxis will return 0; 1908 // for both.; 1909 if (firstbin == 0 && lastbin == 0); 1910 {; 1911 firstbin = 1;; 1912 lastbin = inAxis.GetNbins();; 1913 }; 1914 }; 1915 if (firstbin < 0) firstbin = 1;; 1916 if (lastbin < 0) lastbin = inN;; 1917 if (lastbin > inN+1) lastbin = inN;; 1918 ; 1919 // Create the profile histogram; 1920 char *pname = (char*)name;; 1921 if (name && strcmp(name, expectedName) == 0) {; 1922 Int_t nch = strlen(GetName()) + 5;; 1923 pname = new char[nch];; 1924 snprintf(pname,nch,""%s%s"",GetName(),name);; 1925 }; 1926 TProfile *h1=nullptr;; 1927 //check if a profile with identical name exist; 1928 // if compatible reset and re-use previous histogram; 1929 TObject *h1obj = gROOT->FindObject(pname);; 1930 if (h1obj && h1obj->InheritsFrom(TH1::Class())) {; 1931 if (h1obj->IsA() != TProfile::Class() ) {; 1932 Error(""DoProfile"",""Histogram with name %s must be a TProfile and is a %s"",name,h1obj->ClassName());; 1933 return nullptr;; 1934 }; 1935 h1 = (TProfile*)h1obj;; 1936 // reset the existing histogram and set always the new binning for the axis; 1937 // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; 1938 // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 ); 1939 h1->Reset();; 1940 const TArrayD *xbins = outAxis.GetXbins();; 1941 if (xbins->fN == 0) {; 1942 if ( originalRange ); 1943 h1->SetBins(outAxis.GetNbins(),outAxis.GetXmin(),outAxis.GetXmax());; 1944 else; 1945 h1->SetBins(lastOutBin-firstOutBin+1,outAxis.GetBinLowEdge(firstOutBin),outAxis.GetBinUpEdge(lastOutBin));; 1946 } else {; 1947 // case variable bins; 1948 if (originalRange );",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:78028,avoid,avoid,78028,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:186020,timeout,timeout,186020,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"n == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:186052,timeout,timeout,186052,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:25554,safe,safety,25554,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,2,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 494 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:22354,safe,safety,22354,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 495 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:22315,safe,safety,22315,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:34672,safe,safety,34672,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,1,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the type of value. . Returnsreturn a EFromHumanReadableSize enum value indicating the success or failure of the parse. ; Definition at line 86 of file StringConv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:34460,safe,safety,34460,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,2,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 548 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 50 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:21625,safe,safety,21625,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['safe'],['safety']
Safety,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 549 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:21717,safe,safety,21717,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['safe'],['safety']
Safety,"n Z. When positioning volumes inside slices, one can do it using the generic volume family (e.g. slicey). This should be done as if the coordinate system of the generic slice was the same as the one of the divided volume. The generic slice in case of PHI division is centered with respect to X axis. If the family contains slices of different sizes, any volume positioned inside should fit into the smallest one. Examples for specific divisions according to shape types can be found inside shape classes.; TGeoVolume::Divide(N, Xmin, Xmax, ""X"");; The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping volume is in fact a virtual container that does not represent a physical object. It contains a list of nodes that are not its daughters but that must be checked always before the container itself. This list must be defined by users and it is checked and resolved in a priority order. Note that the feature is non-standard to geometrical modelers and it was introduced just to support conversions of GEANT3 geometries, therefore its extensive usage should be avoided. ; Definition at line 266 of file TGeoVolume.h. Public Member Functions;  TGeoVolumeMulti ();  dummy constructor ;  ;  TGeoVolumeMulti (const char *name, TGeoMedium *med=nullptr);  default constructor ;  ;  ~TGeoVolumeMulti () override;  Destructor. ;  ; TGeoNode * AddNode (TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat, Option_t *option="""") override;  Add a new node to the list of nodes. ;  ; void AddNodeOverlap (TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat, Option_t *option="""") override;  Add a new node to the list of nodes, This node is possibly overlapping with other daughters of the volume or extruding the volume. ;  ; void AddVolume (TGeoVolume *vol);  Add a volume with valid shape to the list of volumes. ;  ; TGeoVolume * Divide (const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""") override;  division of multiple volumes ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:8581,avoid,avoided,8581,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['avoid'],['avoided']
Safety,"n a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) ;  CMultPolicyMatrix-matrix multiplication policy ;  CNullTypeFunc1D;  COneDimMultiFunctionAdapterOneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one ;  COneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one ;  CParamFunctionBase template class for all Parametric Functions ;  CParamFunctionBaseClass defining the signature for multi-dim parametric functions ;  CParamFunctorParam Functor class for Multidimensional functions ;  ►CParamFunctorHandlerParamFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFuncEvaluator;  CFuncEvaluator< F * >;  CFuncEvaluator< F *const >;  CParamMemFunHandlerParamFunctor Handler to Wrap pointers to member functions ;  CPlaceExpr;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceExpr< T, D1, D2, D3, D4, A, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlaceMatrixStructure to deal when a submatrix is placed in a matrix ;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CPlaceMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CPlainParameters;  CPlane3DClass describing a geometrical plane in 3 dimensions ;  CPlusEqualsEvaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Specialization for symmetrix += general : NOT Allowed operation ;  CPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:45266,avoid,avoid,45266,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['avoid'],['avoid']
Safety,"n at line 3556 of file TBufferJSON.cxx. ◆ JsonReadCollection(). void TBufferJSON::JsonReadCollection ; (; TCollection * ; obj, . const TClass * ; objClass . ). protected . read content of ROOT collection ; Definition at line 1674 of file TBufferJSON.cxx. ◆ JsonReadFastArray(). template<typename T > . void TBufferJSON::JsonReadFastArray ; (; T * ; arr, . Int_t ; arrsize, . bool ; asstring = false . ). protected . Template method to read array from the JSON. ; Definition at line 2752 of file TBufferJSON.cxx. ◆ JsonReadObject(). void * TBufferJSON::JsonReadObject ; (; void * ; obj, . const TClass * ; objClass = nullptr, . TClass ** ; readClass = nullptr . ). protected . Read object from current JSON node. ; Definition at line 1772 of file TBufferJSON.cxx. ◆ JsonReadTObjectMembers(). void TBufferJSON::JsonReadTObjectMembers ; (; TObject * ; tobj, . void * ; node = nullptr . ). protected . Read TObject data members from JSON. ; Do not call TObject::Streamer() to avoid special tweaking of TBufferJSON interface ; Definition at line 1979 of file TBufferJSON.cxx. ◆ JsonSpecialClass(). Int_t TBufferJSON::JsonSpecialClass ; (; const TClass * ; cl); const. protected . return non-zero value when class has special handling in JSON it is TCollection (-130), TArray (100), TString (110), std::string (120) and STL containers (1..6) ; Definition at line 1285 of file TBufferJSON.cxx. ◆ JsonStartElement(). void TBufferJSON::JsonStartElement ; (; const TStreamerElement * ; elem, . const TClass * ; base_class . ). protected . Start new class member in JSON structures. ; Definition at line 1212 of file TBufferJSON.cxx. ◆ JsonStartObjectWrite(). TJSONStackObj * TBufferJSON::JsonStartObjectWrite ; (; const TClass * ; obj_class, . TStreamerInfo * ; info = nullptr . ). protected . Start object element with typeinfo. ; Definition at line 1178 of file TBufferJSON.cxx. ◆ JsonWriteArrayCompress(). template<typename T > . void TBufferJSON::JsonWriteArrayCompress ; (; const T * ; vname, . Int_t ; ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:63849,avoid,avoid,63849,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['avoid'],['avoid']
Safety,"n contain class version . *:object other object, column contain object id . *:rawdata raw data, column contains id of raw data from streamer table . *:Int_t column with integer value . Use TSQLFile::SetUseSuffixes(kFALSE) to disable suffixes usage. This and several other options can be changed only when TSQLFile created with options ""CREATE"" or ""RECREATE"" and only before first write operation. These options are: . Name Description . SetUseSuffixes() suffix usage in column names (default - on) . SetArrayLimit() defines maximum array size, which can has column for each element (default 21) . SetTablesType() table type name in MySQL database (default ""InnoDB"") . SetUseIndexes() usage of indexes in database (default kIndexesBasic) . Normally these functions should be called immediately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT SQL commands are used before and after data storage. If TSQLFile detects any problems, ROLLBACK command will be used to restore previous state of data base. If transactions not supported by SQL server, they can be disabled by SetUseTransactions(kTransactionsOff). Or user can take responsibility to use transactions function himself. By default only indexes for basic tables are created. In most cases usage of indexes increase performance to data reading, but it also can increase time of writing data to database. There are several modes of index usage available in SetUseIndexes() method There is MakeSelectQuery(TClass*) method, which produces SELECT statement to get objects data of specified class. Difference from simple statement like: mysql> SELECT * FROM TH1I_ver1 that not only data for that class, but also data from parent classes will be extracted from other tables and combined in single result table. Such select query can be useful for external access to objects data.; Up to now MySQL 4.1 and Oracle 9i were tested. Some extra work is required for other SQL databases. Hopefully, this s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:4490,detect,detects,4490,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['detect'],['detects']
Safety,"n detector level ;  ; void GetInput (TH1 *inputData, const Int_t *binMap=nullptr) const;  Input vector of measurements. ;  ; void GetInputInverseEmatrix (TH2 *ematrix);  get inverse of the measurement's covariance matrix ;  ; void GetL (TH2 *l) const;  get matrix of regularisation conditions ;  ; virtual Double_t GetLcurveX (void) const;  get value on x-axis of L-curve determined in recent unfolding ;  ; virtual Double_t GetLcurveY (void) const;  get value on y-axis of L-curve determined in recent unfolding ;  ; void GetLsquared (TH2 *lsquared) const;  get matrix of regularisation conditions squared ;  ; Int_t GetNdf (void) const;  get number of degrees of freedom determined in recent unfolding ;  ; void GetNormalisationVector (TH1 *s, const Int_t *binMap=nullptr) const;  histogram of truth bins, determined from suming over the response matrix ;  ; Int_t GetNpar (void) const;  get number of truth parameters determined in recent unfolding ;  ; Int_t GetNr (void) const;  get number of regularisation conditions ;  ; void GetOutput (TH1 *output, const Int_t *binMap=nullptr) const;  get output distribution, possibly cumulated over several bins ;  ; void GetProbabilityMatrix (TH2 *A, EHistMap histmap) const;  get matrix of probabilities ;  ; Double_t GetRhoAvg (void) const;  get average global correlation determined in recent unfolding ;  ; Double_t GetRhoI (TH1 *rhoi, const Int_t *binMap=nullptr, TH2 *invEmat=nullptr) const;  get global correlation coefficiencts, possibly cumulated over several bins ;  ; void GetRhoIJ (TH2 *rhoij, const Int_t *binMap=nullptr) const;  get correlation coefficiencts, possibly cumulated over several bins ;  ; Double_t GetRhoMax (void) const;  get maximum global correlation determined in recent unfolding ;  ; TVectorD GetSqrtEvEmatrix (void) const;  ; double GetSURE (void) const;  return Stein's unbiased risk estimator See e.g. ;  ; Double_t GetTau (void) const;  return regularisation parameter ;  ; Int_t RegularizeBins (int start, int step, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:20811,risk,risk,20811,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,2,['risk'],['risk']
Safety,"n detector level ;  ; void GetInput (TH1 *inputData, const Int_t *binMap=nullptr) const;  Input vector of measurements. ;  ; void GetInputInverseEmatrix (TH2 *ematrix);  get inverse of the measurement's covariance matrix ;  ; void GetL (TH2 *l) const;  get matrix of regularisation conditions ;  ; virtual Double_t GetLcurveX (void) const;  get value on x-axis of L-curve determined in recent unfolding ;  ; virtual Double_t GetLcurveY (void) const;  get value on y-axis of L-curve determined in recent unfolding ;  ; void GetLsquared (TH2 *lsquared) const;  get matrix of regularisation conditions squared ;  ; Int_t GetNdf (void) const;  get number of degrees of freedom determined in recent unfolding ;  ; void GetNormalisationVector (TH1 *s, const Int_t *binMap=nullptr) const;  histogram of truth bins, determined from suming over the response matrix ;  ; Int_t GetNpar (void) const;  get number of truth parameters determined in recent unfolding ;  ; Int_t GetNr (void) const;  get number of regularisation conditions ;  ; void GetOutput (TH1 *output, const Int_t *binMap=nullptr) const;  get output distribution, possibly cumulated over several bins ;  ; void GetProbabilityMatrix (TH2 *A, EHistMap histmap) const;  get matrix of probabilities ;  ; Double_t GetRhoAvg (void) const;  get average global correlation determined in recent unfolding ;  ; Double_t GetRhoI (TH1 *rhoi, const Int_t *binMap=nullptr, TH2 *invEmat=nullptr) const;  get global correlation coefficiencts, possibly cumulated over several bins ;  ; void GetRhoIJ (TH2 *rhoij, const Int_t *binMap=nullptr) const;  get correlation coefficiencts, possibly cumulated over several bins ;  ; Double_t GetRhoMax (void) const;  get maximum global correlation determined in recent unfolding ;  ; TVectorD GetSqrtEvEmatrix (void) const;  ; double GetSURE (void) const;  return Stein's unbiased risk estimator See e.g. ;  ; Double_t GetTau (void) const;  return regularisation parameter ;  ; TClass * IsA () const override;  ; Int_t Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:6897,risk,risk,6897,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['risk'],['risk']
Safety,"n entry- or event-list to be used as event selection. The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Definition at line 919 of file TDSet.cxx. ◆ Remove(). Int_t TDSet::Remove ; (; TDSetElement * ; elem, . Bool_t ; deleteElem = kTRUE . ). Remove TDSetElement 'elem' from the list. ; Return 0 on success, -1 if the element is not in the list ; Definition at line 1576 of file TDSet.cxx. ◆ Reset(). void TDSet::Reset ; (; ). virtual . Reset or initialize access to the elements. ; Reimplemented in TDSetProxy.; Definition at line 1369 of file TDSet.cxx. ◆ SetDirectory(). void TDSet::SetDirectory ; (; const char * ; dir). Set/change directory. ; Definition at line 1041 of file TDSet.cxx. ◆ SetEntryList(). void TDSet::SetEntryList ; (; TObject * ; aList). virtual . Set entry (or event) list for this data set. ; Definition at line 1893 of file TDSet.cxx. ◆ SetLookedUp(). void TDSet::SetLookedUp ; (; ). Flag all the elements as looked-up, so to avoid opening the files if the functionality is not supported. ; Definition at line 1657 of file TDSet.cxx. ◆ SetObjName(). void TDSet::SetObjName ; (; const char * ; objname). Set/change object name. ; Definition at line 1026 of file TDSet.cxx. ◆ SetSrvMaps(). void TDSet::SetSrvMaps ; (; TList * ; srvmaps = 0). Set (or unset) the list for mapping servers coordinate for files. ; Reinitialize the related iterator if needed. Used by TProof. ; Definition at line 1172 of file TDSet.cxx. ◆ SetWriteV3(). void TDSet::SetWriteV3 ; (; Bool_t ; on = kTRUE). Set/Reset the 'OldStreamer' bit in this instance and its elements. ; Needed for backward compatibility in talking to old client / masters. ; Definition at line 1874 of file TDSet.cxx. ◆ SplitEntryList(). void TDSet::SplitEntryList ; (; ). private . for browsing purposes ; Splits the main entry (or event) list into sub-lists for the elements of thet data set. ; Definition at line 1941 of file TDSet.cxx. ◆ StartViewer(). void TDSet::StartViewer ; (; ). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSet.html:28242,avoid,avoid,28242,doc/master/classTDSet.html,https://root.cern,https://root.cern/doc/master/classTDSet.html,1,['avoid'],['avoid']
Safety,"n false. ; Reimplemented from ROOT::v5::TFormula.; Definition at line 5078 of file TTreeFormula.cxx. ◆ SwitchToFormLeafInfo(). bool TTreeFormula::SwitchToFormLeafInfo ; (; Int_t ; code). protectedvirtual . Convert the underlying lookup method from the direct technique (dereferencing the address held by the branch) to the method using TFormLeafInfo. ; This is in particular useful in the case where we need to append an additional TFormLeafInfo (for example to call a method). Return false if the switch was unsuccessful (basically in the case of an old style split tree). ; Definition at line 5714 of file TTreeFormula.cxx. ◆ UpdateFormulaLeaves(). void TTreeFormula::UpdateFormulaLeaves ; (; ). virtual . This function is called TTreePlayer::UpdateFormulaLeaves, itself called by TChain::LoadTree when a new Tree is loaded. ; Because Trees in a TChain may have a different list of leaves, one must update the leaves numbers in the TTreeFormula used by the TreePlayer.; A safer alternative would be to recompile the whole thing .... However currently compile HAS TO be called from the constructor! ; Definition at line 5107 of file TTreeFormula.cxx. Friends And Related Symbol Documentation. ◆ TTreeFormulaManager. friend class TTreeFormulaManager. friend . Definition at line 60 of file TTreeFormula.h. Member Data Documentation. ◆ fAliases. TObjArray TTreeFormula::fAliases. protected . ! List of TTreeFormula for each alias used. ; Definition at line 107 of file TTreeFormula.h. ◆ fAliasesUsed. std::vector<std::string> TTreeFormula::fAliasesUsed. protected . ! List of aliases used during the parsing of the expression. ; Definition at line 128 of file TTreeFormula.h. ◆ fAxis. TAxis* TTreeFormula::fAxis. protected . ! pointer to histogram axis if this is a string ; Definition at line 122 of file TTreeFormula.h. ◆ fBranches. TObjArray TTreeFormula::fBranches. protected . ! List of branches to read. Similar to fLeaves but duplicates are zeroed out. ; Definition at line 109 of file TTreeForm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:50705,safe,safer,50705,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['safe'],['safer']
Safety,"n geometry. ; Definition at line 154 of file TGeoParallelWorld.cxx. ◆ Safety(). Double_t TGeoParallelWorld::Safety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). inline . Definition at line 118 of file TGeoParallelWorld.h. ◆ SafetyBVH(). double TGeoParallelWorld::SafetyBVH ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ; Definition at line 1027 of file TGeoParallelWorld.cxx. ◆ SafetyLoop(). Double_t TGeoParallelWorld::SafetyLoop ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (trivial loop version for comparison/debugging) ; Definition at line 1207 of file TGeoParallelWorld.cxx. ◆ SafetyOrig(). Double_t TGeoParallelWorld::SafetyOrig ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world (original version based on TGeoVoxelFinder) ; Definition at line 1145 of file TGeoParallelWorld.cxx. ◆ SetAccelerationMode(). void TGeoParallelWorld::SetAccelerationMode ; (; AccelerationMode const & ; mode). inline . Definition at line 95 of file TGeoParallelWorld.h. ◆ SetUseOverlaps(). void TGeoParallelWorld::SetUseOverlaps ; (; Bool_t ; flag). inline . Definition at line 80 of file TGeoParallelWorld.h. ◆ Streamer(). void TGeoParallelWorld::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoParallelWorld::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 184 of file TGeoParallelWorld.h. ◆ TestVoxelGrid(). void TGeoParallelWorld::TestVoxelGrid ; (; ). private . Definition at line 1425 of file TGeoParallelWorld.cxx. ◆ VoxelSafety(). double TGeoParallelWorld::VoxelSafety ; (; Double_t ; point[3], . Double_t ; safmax = 1.E30 . ). private . Compute safety for the parallel world use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:26549,safe,safety,26549,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"n in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode(const char* path); TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them. One can however create ""symbolic links"" to any complex path to make it more representable for the object it designates:; TGeoPNEntry(const char* unique_name, const char* path); void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node); TGeoPNEntryThe knowledge of the path to the objects that need to be misaligned is essential since there is no ot...Definition TGeoPhysicalNode.h:100; TGeoPNEntry::SetPhysicalNodevoid SetPhysicalNode(TGeoPhysicalNode *node)Setter ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:115437,detect,detector,115437,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detector']
Safety,"n is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In case of ambiguity, returns the first match. TLeaf* FindLeaf(const char* name); FIXME: Describe this function. Int_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:91213,recover,recoverable,91213,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['recover'],['recoverable']
Safety,"n matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag . Definition at line 1353 of file TGeoManager.cxx. ◆ operator=(). TGeoManager & TGeoManager::operator= ; (; const TGeoManager & ; ). protecteddelete . ◆ OptimizeVoxels(). void TGeoManager::OptimizeVoxels ; (; const char * ; filename = ""tgeovox.C""). Optimize voxelization type for all volumes. Save best choice in a macro. ; Definition at line 2484 of file TGeoManager.cxx. ◆ Parse(). Int_t TGeoManager::Parse ; (; const char * ; expr, . TString & ; expr1, . TString & ; expr2, . TString & ; expr3 . ). static . Parse a string boolean expression and do a syntax check. ; Find top level boolean operator and returns its type. Fill the two substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression. Parentheses should be used to avoid ambiguities. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C) eliminate not needed parentheses . Definition at line 2540 of file TGeoManager.cxx. ◆ PopDummy(). void TGeoManager::PopDummy ; (; Int_t ; ipop = 9999). inline . Definition at line 597 of file TGeoManager.h. ◆ PopPath() [1/2]. Bool_t TGeoManager::PopPath ; (; ). inline . Definition at line 592 of file TGeoManager.h. ◆ PopPath() [2/2]. Bool_t TGeoManager::PopPath ; (; Int_t ; index). inline . Definition at line 593 of file TGeoManager.h. ◆ PopPoint() [1/2]. Bool_t TGeoManager::PopPoint ; (; ). inline . Definition at line 595 of file TGeoManager.h. ◆ PopPoint() [2/2]. Bool_t TGeoManager::PopPoint ; (; Int_t ; index). inline . Definition at line 596 of file TGeoManager.h. ◆ PrintOverlaps(). void TGeoManager::PrintOverlaps ; (; ); const. Prints the current list of overlaps. ; Definition at line 3881 of file TGeoManager.cxx. ◆ PushPath(). Int_t TGeoManager::PushPath ; (; Int_t ; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:127243,avoid,avoid,127243,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['avoid'],['avoid']
Safety,"n of a section plane, rmin and rmax at this z. Double_t GetZ(Int_t ipl) const; Return the Z coordinate for segment ipl. void GetPlaneNormal(const Double_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz, iz+1); and polygon vertices (ivert, ivert+1). No range check. Bool_t IsPointInsidePlane(Double_t* point, Double_t* vert, Double_t* norm) const; Check if the quadrilateral defined by VERT contains a coplanar POINT. void InspectShape() const; Print actual Xtru parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSector(Double_t* point, Int_t iz, Double_t safmin, Bool_t in); Compute safety to sector iz, returning also the closest segment index. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetCurrentZ(Double_t z, Int_t iz); Recompute current section vertices for a given Z position within range of section iz. void SetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); Set current vertex coordinates according X0, Y0 and SCALE. void SetDimensions(Double_t* param); param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoXtru.html:17289,safe,safety,17289,root/html530/TGeoXtru.html,https://root.cern,https://root.cern/root/html530/TGeoXtru.html,4,"['Safe', 'safe']","['SafetyToSector', 'safety']"
Safety,"n or lambdas returns non-zero value Check function has following signature: int func(double spent_tm) Waiting will be continued, if function returns zero. ;  ; int WaitForTimed (WebWindowWaitFunc_t check, double duration);  Waits until provided check function or lambdas returns non-zero value Check function has following signature: int func(double spent_tm) Waiting will be continued, if function returns zero. ;  . Static Public Member Functions; static std::shared_ptr< RWebWindow > Create ();  Create new RWebWindow Using default RWebWindowsManager. ;  ; static bool EmbedFileDialog (const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args);  Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tries to call RFileDialog::Embedded() method Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embedded() providing received string as second argument. ;  ; static bool IsFileDialogMessage (const std::string &msg);  Check if this could be the message send by client to start new file dialog If returns true, one can call RWebWindow::EmbedFileDialog() to really create file dialog instance inside existing widget. ;  ; static unsigned ShowWindow (std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""");  Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ;  . Private Types; using ConnectionsList_t = std::vector< std::shared_ptr< WebConn > >;  ; enum  EQueueEntryKind { kind_None; , kind_Connect; , kind_Data; , kind_Disconnect; };  ; using timestamp_t = std::chrono::time_point< std::chrono::system_clock >;  . Private Member Functions; bool _CanTrustIn (std::shared_ptr< WebConn > &conn, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:11888,detect,detect,11888,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['detect'],['detect']
Safety,"n parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:33292,safe,safe,33292,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['safe'],['safe']
Safety,"n source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && !defined(R__WINGCC); 5178Bool_t TFile::ReadBufferAsync(Long64_t offset, Int_t len); 5179{; 5180 // Read specified byte range asynchronously. Actually we tell the kernel; 5181 // which blocks we are going to read so it can start loading these blocks; 5182 // in the buffer cache.; 5183 ; 5184 // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; 5185 // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.; 5186 if (IsA() != TFile::Class()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210{; 5211 // Not supported yet on non Linux systems.; 5212 ; 5213 return kTRUE;; 5214}; 5215#endif; 5216 ; 5217//////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:188529,avoid,avoid,188529,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n style. ;  . Static Public Attributes; static constexpr auto kBigNumber = TTree::kMaxEntries;  ;  Static Public Attributes inherited from TTree; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Member Functions; void InvalidateCurrentTree ();  Set the TTree to be reloaded as soon as possible. ;  ; void ReleaseChainProof ();  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:43667,detect,detection,43667,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['detect'],['detection']
Safety,"n the query result. ;  ; void RemoveQueryResult (const char *ref) override;  Remove all query result instances referenced 'ref' from the list of results. ;  ; void RestorePreviousQuery () override;  ; Int_t SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override;  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override;  Update automatic binning parameters for given object ""name"". ;  ; void UpdateProgressInfo () override;  Update fProgressStatus. ;  ;  Public Member Functions inherited from TVirtualProofPlayer;  TVirtualProofPlayer ();  ;  ~TVirtualProofPlayer () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:7785,abort,abort,7785,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,9,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"n will naturally belong to all overlapping partners. The answer provided by the modeller to ""Where am I?"" is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having Rmin=0,Rmax=inner/outer radius), then to make a composite:; C = (Tub1out+Tub2out)-(Tub1in+Tub2in); On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem is that in order to reproduce the honeycomb structure out of rows of cells, we have to overlap row containers. Whoops - we have not obeyed rule No. 2 in positioning. The way out is to position our rows with a special prototype:. ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; This will instruct the modeller that the daughter ROW inside CAL overlaps with something else. The modeller will check this at closure time and build a list of possibly overlapping candidates. This option is equivalent with the option MANY in GEANT3.; The modeller supports such cases ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:38242,avoid,avoid,38242,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"n will naturally belong to all overlapping partners. The answer provided by the modeller to “Where am I?” is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having Rmin=0,Rmax=inner/outer radius), then to make a composite:; C = (Tub1out+Tub2out)-(Tub1in+Tub2in); On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem is that in order to reproduce the honeycomb structure out of rows of cells, we have to overlap row containers. Whoops - we have not obeyed rule No. 2 in positioning. The way out is to position our rows with a special prototype:. ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; This will instruct the modeller that the daughter ROW inside CAL overlaps with something else. The modeller will check this at closure time and build a list of possibly overlapping candidates. This option is equivalent with the option MANY in GEANT3.; The modeller supports such cases ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:947046,avoid,avoid,947046,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avoid'],['avoid']
Safety,"n'. ; Definition at line 274 of file TProofPlayer.cxx. ◆ SetStopTimer(). void TProofPlayer::SetStopTimer ; (; Bool_t ; on = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 287 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayer::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 689 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayer::StoreOutput ; (; TList * ; out). overridevirtual . Store output list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 681 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemente",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:42556,timeout,timeout,42556,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['timeout'],['timeout']
Safety,"n(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:9015,safe,safety,9015,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,4,['safe'],['safety']
Safety,"n(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHelix.html:9113,safe,safety,9113,root/html534/TGeoHelix.html,https://root.cern,https://root.cern/root/html534/TGeoHelix.html,6,['safe'],['safety']
Safety,"n(void); 3481{; 3482 return CIVETWEB_VERSION;; 3483}; 3484 ; 3485 ; 3486const struct mg_request_info *; 3487mg_get_request_info(const struct mg_connection *conn); 3488{; 3489 if (!conn) {; 3490 return NULL;; 3491 }; 3492#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3493 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3494 char txt[16];; 3495 struct mg_workerTLS *tls =; 3496 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3497 ; 3498 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3499 if (strlen(txt) == 3) {; 3500 memcpy(tls->txtbuf, txt, 4);; 3501 } else {; 3502 strcpy(tls->txtbuf, ""ERR"");; 3503 }; 3504 ; 3505 ((struct mg_connection *)conn)->request_info.local_uri =; 3506 tls->txtbuf; /* use thread safe buffer */; 3507 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3508 tls->txtbuf; /* use the same thread safe buffer */; 3509 ((struct mg_connection *)conn)->request_info.request_uri =; 3510 tls->txtbuf; /* use the same thread safe buffer */; 3511 ; 3512 ((struct mg_connection *)conn)->request_info.num_headers =; 3513 conn->response_info.num_headers;; 3514 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3515 conn->response_info.http_headers,; 3516 sizeof(conn->response_info.http_headers));; 3517 } else; 3518#endif; 3519 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3520 return NULL;; 3521 }; 3522 return &conn->request_info;; 3523}; 3524 ; 3525 ; 3526const struct mg_response_info *; 3527mg_get_response_info(const struct mg_connection *conn); 3528{; 3529 if (!conn) {; 3530 return NULL;; 3531 }; 3532 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3533 return NULL;; 3534 }; 3535 return &conn->response_info;; 3536}; 3537 ; 3538 ; 3539static const char *; 3540get_proto_name(const struct mg_connection *conn); 3541{; 3542#if defined(__clang__); 3543#pragma clang diagnostic push; 3544#pragma clang diagnostic ignored ""-Wunreachable-code""; 3545 /* Depending on USE_WEBSOCKET and NO_SSL, s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:104346,safe,safe,104346,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"n(void); 3482{; 3483 return CIVETWEB_VERSION;; 3484}; 3485 ; 3486 ; 3487const struct mg_request_info *; 3488mg_get_request_info(const struct mg_connection *conn); 3489{; 3490 if (!conn) {; 3491 return NULL;; 3492 }; 3493#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3494 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3495 char txt[16];; 3496 struct mg_workerTLS *tls =; 3497 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3498 ; 3499 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3500 if (strlen(txt) == 3) {; 3501 memcpy(tls->txtbuf, txt, 4);; 3502 } else {; 3503 strcpy(tls->txtbuf, ""ERR"");; 3504 }; 3505 ; 3506 ((struct mg_connection *)conn)->request_info.local_uri =; 3507 tls->txtbuf; /* use thread safe buffer */; 3508 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3509 tls->txtbuf; /* use the same thread safe buffer */; 3510 ((struct mg_connection *)conn)->request_info.request_uri =; 3511 tls->txtbuf; /* use the same thread safe buffer */; 3512 ; 3513 ((struct mg_connection *)conn)->request_info.num_headers =; 3514 conn->response_info.num_headers;; 3515 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3516 conn->response_info.http_headers,; 3517 sizeof(conn->response_info.http_headers));; 3518 } else; 3519#endif; 3520 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3521 return NULL;; 3522 }; 3523 return &conn->request_info;; 3524}; 3525 ; 3526 ; 3527const struct mg_response_info *; 3528mg_get_response_info(const struct mg_connection *conn); 3529{; 3530 if (!conn) {; 3531 return NULL;; 3532 }; 3533 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3534 return NULL;; 3535 }; 3536 return &conn->response_info;; 3537}; 3538 ; 3539 ; 3540static const char *; 3541get_proto_name(const struct mg_connection *conn); 3542{; 3543#if defined(__clang__); 3544#pragma clang diagnostic push; 3545#pragma clang diagnostic ignored ""-Wunreachable-code""; 3546 /* Depending on USE_WEBSOCKET and NO_SSL, s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:104378,safe,safe,104378,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"n) ; Definition at line 987 of file MethodCuts.cxx. ◆ MatchCutsToPars() [2/2]. void TMVA::MethodCuts::MatchCutsToPars ; (; std::vector< Double_t > & ; pars, . Double_t * ; cutMin, . Double_t * ; cutMax . ). private . translates cuts into parameters ; Definition at line 1009 of file MethodCuts.cxx. ◆ MatchParsToCuts() [1/2]. void TMVA::MethodCuts::MatchParsToCuts ; (; const std::vector< Double_t > & ; pars, . Double_t * ; cutMin, . Double_t * ; cutMax . ). private . translates parameters into cuts ; Definition at line 974 of file MethodCuts.cxx. ◆ MatchParsToCuts() [2/2]. void TMVA::MethodCuts::MatchParsToCuts ; (; Double_t * ; , . Double_t * ; , . Double_t * ;  . ). private . ◆ PrintCuts(). void TMVA::MethodCuts::PrintCuts ; (; Double_t ; effS); const. print cuts ; Definition at line 465 of file MethodCuts.cxx. ◆ ProcessOptions(). void TMVA::MethodCuts::ProcessOptions ; (; ). virtual . process user options. ; sanity check, do not allow the input variables to be normalised, because this only creates problems when interpreting the cuts ; Implements TMVA::MethodBase.; Definition at line 363 of file MethodCuts.cxx. ◆ ReadWeightsFromStream() [1/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; std::istream & ; ). virtual . Implements TMVA::MethodBase. ◆ ReadWeightsFromStream() [2/3]. void TMVA::MethodCuts::ReadWeightsFromStream ; (; std::istream & ; i). virtual . read the cuts from stream ; Implements TMVA::MethodBase.; Definition at line 1217 of file MethodCuts.cxx. ◆ ReadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodCuts::ReadWeightsFromXML ; (; void * ; wghtnode). virtual . read coefficients from xml weight file ; Implements TMVA::MethodBase.; Definition at line 1327 of file MethodCuts.cxx. ◆ SetTestSignalEfficiency(). void TMVA::MethodCuts::SetTestSignalEfficiency ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:45958,sanity check,sanity check,45958,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['sanity check'],['sanity check']
Safety,"n), the object can be added (and constructed when needed) using ConstructedAt which only calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; Note: the only supported way to add objects to a TClonesArray is via the new with placement method or the ConstructedAt method. The other Add() methods ofTObjArray and its base classes are not allowed.; Considering that a new/delete costs about 70 mus on a 300 MHz HP, O(10^9) new/deletes will save about 19 hours. NOTE 1; C/C++ offers the possibility of allocating and deleting memory. Forgetting to delete allocated memory is a programming error called a ""memory leak"", i.e. the memory of your process grows and eventually your program crashes. Even if you always delete the allocated memory, the recovered space may not be efficiently reused. The process knows that there are portions of free memory, but when you allocate it again, a fresh piece of memory is grabbed. Your program is free from semantic errors, but the total memory of your process still grows, because your program's memory is full of ""holes"" which reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in terms of CPU time.; Without entering into technical details, TClonesArray allows you to ""reuse"" the same portion of memory for new/delete avoiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:2616,recover,recovered,2616,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['recover'],['recovered']
Safety,"n). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:18558,safe,safe,18558,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,10,['safe'],['safe']
Safety,"n, buf, (int)buflen);; 11472 if (i > 0) {; 11473 /* CGI program explicitly sent an error */; 11474 /* Write the error message to the internal log */; 11475 mg_cry_internal(conn,; 11476 ""Error: CGI program \""%s\"" sent error ""; 11477 ""message: [%.*s]"",; 11478 prog,; 11479 i,; 11480 buf);; 11481 /* Don't send the error message back to the client */; 11482 mg_send_http_error(conn,; 11483 500,; 11484 ""Error: CGI program \""%s\"" failed."",; 11485 prog);; 11486 } else {; 11487 /* CGI program did not explicitly send an error, but a broken; 11488 * respon header */; 11489 mg_cry_internal(conn,; 11490 ""Error: CGI program sent malformed or too big ""; 11491 ""(>%u bytes) HTTP headers: [%.*s]"",; 11492 (unsigned)buflen,; 11493 data_len,; 11494 buf);; 11495 ; 11496 mg_send_http_error(conn,; 11497 500,; 11498 ""Error: CGI program sent malformed or too big ""; 11499 ""(>%u bytes) HTTP headers: [%.*s]"",; 11500 (unsigned)buflen,; 11501 data_len,; 11502 buf);; 11503 }; 11504 ; 11505 /* in both cases, abort processing CGI */; 11506 goto done;; 11507 }; 11508 ; 11509 pbuf = buf;; 11510 buf[headers_len - 1] = '\0';; 11511 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11512 ; 11513 /* Make up and send the status line */; 11514 status_text = ""OK"";; 11515 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11516 != NULL) {; 11517 conn->status_code = atoi(status);; 11518 status_text = status;; 11519 while (isdigit((unsigned char)*status_text) || *status_text == ' ') {; 11520 status_text++;; 11521 }; 11522 } else if (get_header(ri.http_headers, ri.num_headers, ""Location""); 11523 != NULL) {; 11524 conn->status_code = 307;; 11525 } else {; 11526 conn->status_code = 200;; 11527 }; 11528 connection_state =; 11529 get_header(ri.http_headers, ri.num_headers, ""Connection"");; 11530 if (!header_has_option(connection_state, ""keep-alive"")) {; 11531 conn->must_close = 1;; 11532 }; 11533 ; 11534 DEBUG_TRACE(""CGI: response %u %s"", conn->status_code, status_text);; 11535 ; 11536 (v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:333011,abort,abort,333011,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"n, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11512 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11513 ; 11514 /* Make up and send the status line */; 11515 status_text = ""OK"";; 11516 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11517 != NULL) {; 11518 conn->status_code = atoi(status);; 11519 status_text = status;; 11520 while (isdigit((unsigned char)*status_text) || *status_text == ' ') {; 11521 status_text++;; 11522 }; 11523 } else if (get_header(ri.http_headers, ri.num_headers, ""Location""); 11524 != NULL) {; 11525 conn->status_code = 307;; 11526 } else {; 11527 conn->status_code = 200;; 11528 }; 11529 connection_state =; 11530 get_header(ri.http_headers, ri.num_headers, ""Connection"");; 11531 if (!header_has_option(connection_state, ""keep-alive"")) {; 11532 conn->must_close = 1;; 11533 }; 11534 ; 11535 DEBUG_TRACE(""CGI: response %u %s"", conn->status_code, status_text);; 11536 ; 11537 (v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:333044,abort,abort,333044,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"n, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ;  ; void BuildBVH ();  Build the BVH acceleration structure. ;  ; bool CheckBVH (void *, size_t) const;  Check/validate the BVH acceleration structure. ;  ; void CheckOverlaps (Double_t ovlp=0.001);  Check overlaps within a tolerance value. ;  ; Bool_t CloseGeometry ();  The main geometry must be closed. ;  ; void Draw (Option_t *option) override;  Draw the parallel world. ;  ; TGeoPhysicalNode * FindNextBoundary (Double_t point[3], Double_t dir[3], Double_t &step, Double_t stepmax=1.E30);  ; TGeoPhysicalNode * FindNode (Double_t point[3]);  ; AccelerationMode const & GetAccelerationMode () const;  ; TGeoManager * GetGeometry () const;  ; TGeoVolume * GetVolume () const;  ; TClass * IsA () const override;  ; Bool_t IsClosed () const;  ; Bool_t IsUsingOverlaps () const;  ; void PrintBVH () const;  Prints the BVH. ;  ; Int_t PrintDetectedOverlaps () const;  Print the overlaps which were detected during real tracking. ;  ; void RefreshPhysicalNodes ();  Refresh the node pointers and re-voxelize. ;  ; void ResetOverlaps () const;  Reset overlapflag for all volumes in geometry. ;  ; Double_t Safety (Double_t point[3], Double_t safmax=1.E30);  ; void SetAccelerationMode (AccelerationMode const &mode);  ; void SetUseOverlaps (Bool_t flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:3329,detect,detected,3329,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['detect'],['detected']
Safety,"n. ←; TProofServ. TXHandler. ←; TXProofServ. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. TXProofServ(Int_t* argc, char** argv, FILE* flog = 0). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXProofServ.html:19563,timeout,timeout,19563,root/html604/TXProofServ.html,https://root.cern,https://root.cern/root/html604/TXProofServ.html,4,['timeout'],['timeout']
Safety,"n. ←; TProofServ. TXHandler. ←; TXProofServ. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. TXProofServ(Int_t* argc, char** argv, FILE* flog = 0). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXProofServ.html:19562,timeout,timeout,19562,root/html602/TXProofServ.html,https://root.cern,https://root.cern/root/html602/TXProofServ.html,4,['timeout'],['timeout']
Safety,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:126194,avoid,avoid,126194,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n.; 3337 ; 3338 cl = GetIdMap()->Find(typeinfo.name());; 3339 ; 3340 if (cl) {; 3341 if (cl->IsLoaded()) return cl;; 3342 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3343 load = kTRUE;; 3344 } else {; 3345 // Note we might need support for typedefs and simple types!; 3346 ; 3347 // TDataType *objType = GetType(name, load);; 3348 //if (objType) {; 3349 // const char *typdfName = objType->GetTypeName();; 3350 // if (typdfName && strcmp(typdfName, name)) {; 3351 // cl = GetClass(typdfName, load);; 3352 // return cl;; 3353 // }; 3354 // }; 3355 }; 3356 ; 3357 if (!load) return nullptr;; 3358 ; 3359 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3360 if (dict) {; 3361 cl = (dict)();; 3362 if (cl) cl->PostLoadCheck();; 3363 return cl;; 3364 }; 3365 if (cl) return cl;; 3366 ; 3367 TIter next(gROOT->GetListOfClassGenerators());; 3368 TClassGenerator *gen;; 3369 while( (gen = (TClassGenerator*) next()) ) {; 3370 cl = gen->GetClass(typeinfo,load);; 3371 if (cl) {; 3372 cl->PostLoadCheck();; 3373 return cl;; 3374 }; 3375 }; 3376 ; 3377 // try AutoLoading the typeinfo; 3378 int autoload_old = gCling->SetClassAutoLoading(1);; 3379 if (!autoload_old) {; 3380 // Re-disable, we just meant to test; 3381 gCling->SetClassAutoLoading(0);; 3382 }; 3383 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3384 // Disable autoload to avoid potential infinite recursion; 3385 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3386 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3387 if (cl) {; 3388 return cl;; 3389 }; 3390 }; 3391 ; 3392 if (hint_pair_offset) {; 3393 int err = 0;; 3394 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3395 if (!err) {; 3396 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3397 free(demangled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:128945,avoid,avoid,128945,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"n::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgSet.html:13748,avoid,avoid,13748,root/html526/RooArgSet.html,https://root.cern,https://root.cern/root/html526/RooArgSet.html,3,['avoid'],['avoid']
Safety,"n::snapshot(Bool_t deepCopy = kTRUE) const; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooAbsCollection::sort(Bool_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgSet.html:12729,safe,safeDeleteList,12729,root/html526/RooArgSet.html,https://root.cern,https://root.cern/root/html526/RooArgSet.html,2,['safe'],['safeDeleteList']
Safety,"nCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBuffer.html:16730,avoid,avoiding,16730,root/html530/TBuffer.html,https://root.cern,https://root.cern/root/html530/TBuffer.html,5,['avoid'],['avoiding']
Safety,"nName(): it returns a string identifier for this type of action that RDataFrame will use in diagnostics, SaveGraph(), etc. Optional methods; If these methods are implemented they enable extra functionality as per the description below. Result_t &PartialUpdate(unsigned int slot): if present, it must return the value of the partial result of this action for the given 'slot'. Different threads might call this method concurrently, but will do so with different 'slot' numbers. RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; ROOT::RDF::SampleCallback_t GetSampleCallback(): if present, it must return a callable with the appropriate signature (see ROOT::RDF::SampleCallback_t) that will be invoked at the beginning of the processing of every sample, as in DefinePerSample().; Helper MakeNew(void *newResult): if implemented, it enables varying the action's result with VariationsFor(). It takes a type-erased new result that can be safely cast to a std::shared_ptr<Result_t> * (a pointer to shared pointer) and should be used as the action's output result. In case Book is called without specifying column types as template arguments, corresponding typed code will be just-in-time compiled by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Examples; See this tutorial for an example implementation of an action helper.; It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx. ; Definition at line 2984 of file RInterface.hxx. ◆ Cache() [1/4]. template<typename Proxied , typename DataSource = void> . template<typename... ColumnTypes> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; const ColumnNames_t & ; columnList). inline . Save selected columns in memory. ; Template Parameters. ColumnTypesvariadic list of branch/column types. .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:41018,safe,safely,41018,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['safe'],['safely']
Safety,"nOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id: VavilovAccurateCdf.h 34195 2010-06-30 04:33:36Z brun $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__VavilovAccurateCdf.html:2838,avoid,avoid,2838,root/html528/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety,"nOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id: VavilovAccurateCdf.h 34195 2010-06-30 04:33:36Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__VavilovAccurateCdf.html:2840,avoid,avoid,2840,root/html530/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety,"nOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id: VavilovAccurateCdf.h 34195 2010-06-30 04:33:36Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__VavilovAccurateCdf.html:2840,avoid,avoid,2840,root/html532/ROOT__Math__VavilovAccurateCdf.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__VavilovAccurateCdf.html,2,['avoid'],['avoid']
Safety,"nSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:9362,safe,safe,9362,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,2,['safe'],['safe']
Safety,"nSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT.html:14016,safe,safe,14016,doc/v632/namespaceROOT.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html,1,['safe'],['safe']
Safety,"nSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:28554,recover,recovery,28554,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,4,['recover'],['recovery']
Safety,"nSum::fSumT fSum[N]Definition Util.h:315; ROOT::Math::KahanSum::KahanSumKahanSum(T initialValue=T{})Initialise the sum.Definition Util.h:126; ROOT::Math::KahanSum::KahanSumKahanSum(T initialSumValue, T initialCarryValue)Initialise with a sum value and a carry value.Definition Util.h:135; ROOT::Math::KahanSum::Addvoid Add(T x)Single-element accumulation. Will not vectorise.Definition Util.h:165; ROOT::Math::KahanSum::operator-=KahanSum< T, N > & operator-=(KahanSum< U, M > const &other)Subtract other KahanSum.Definition Util.h:290; ROOT::Math::KahanSum::KahanSumKahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd)Initialise the sum with a pre-existing state.Definition Util.h:148; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; MathNamespace for new Math classes and functions.; ROOT::MacOSX::UtilDefinition CocoaUtils.h:22; ROOT::Math::Util::EvalLogT EvalLog(T x)safe evaluation of log(x) with a protections against negative or zero argument to the log smooth line...Definition Util.h:64; ROOT::Math::Util::ToStringstd::string ToString(const T &val)Utility function for conversion to strings.Definition Util.h:50; ROOT::Math::operator+DisplacementVector2D< CoordSystem1, U > operator+(DisplacementVector2D< CoordSystem1, U > v1, const DisplacementVector2D< CoordSystem2, U > &v2)Addition of DisplacementVector2D vectors.Definition DisplacementVector2D.h:440; ROOT::Math::operator-DisplacementVector2D< CoordSystem1, U > operator-(DisplacementVector2D< CoordSystem1, U > v1, DisplacementVector2D< CoordSystem2, U > const &v2)Difference between two DisplacementVector2D vectors.Definition DisplacementVector2D.h:453; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Types.h; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoreincMathUtil.h. ROOT master - Reference Guide Gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:17465,safe,safe,17465,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['safe'],['safe']
Safety,"n] xup upper edge of the X axis last bin (not included in last bin); 93/// \param[in] nbinsy number of bins along the Y axis; 94/// \param[in] ylow low edge of the Y axis first bin; 95/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 96 ; 97TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 98 ,Int_t nbinsy,Double_t ylow,Double_t yup); 99 :TH1(name,title,nbinsx,xlow,xup); 100{; 101 fDimension = 2;; 102 fScalefactor = 1;; 103 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 104 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 105 fYaxis.Set(nbinsy,ylow,yup);; 106 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 107}; 108 ; 109 ; 110////////////////////////////////////////////////////////////////////////////////; 111/// Constructor for variable bin size (along X axis) 2-D histograms using an input array; 112/// of type double.; 113///; 114/// \param[in] name name of histogram (avoid blanks); 115/// \param[in] title histogram title.; 116/// If title is of the form `stringt;stringx;stringy;stringz`; 117/// the histogram title is set to `stringt`,; 118/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 119/// \param[in] nbinsx number of bins; 120/// \param[in] xbins array of low-edges for each bin.; 121/// This is an array of type double and size nbinsx+1; 122/// \param[in] nbinsy number of bins along the Y axis; 123/// \param[in] ylow low edge of the Y axis first bin; 124/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 125 ; 126TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 127 ,Int_t nbinsy,Double_t ylow,Double_t yup); 128 :TH1(name,title,nbinsx,xbins); 129{; 130 fDimension = 2;; 131 fScalefactor = 1;; 132 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 133 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 134 fYaxis.Set(nbinsy,ylow,yup);; 135 fNcells = f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:5101,avoid,avoid,5101,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"nager::GetTmaxDouble_t GetTmax() constDefinition TGeoManager.h:214; TGeoManager::MakeVolumeAssemblyTGeoVolumeAssembly * MakeVolumeAssembly(const char *name)Make an assembly of volumes.Definition TGeoManager.cxx:3553; TGeoManager::GetBombModeInt_t GetBombMode() constDefinition TGeoManager.h:210; TGeoManager::GetListOfOpticalSurfacesTObjArray * GetListOfOpticalSurfaces() constDefinition TGeoManager.h:480; TGeoManager::AddRegionInt_t AddRegion(TGeoRegion *region)Add a new region of volumes.Definition TGeoManager.cxx:633; TGeoManager::SelectTrackingMediavoid SelectTrackingMedia()Define different tracking media.Definition TGeoManager.cxx:3708; TGeoManager::EnableInactiveVolumesvoid EnableInactiveVolumes()Definition TGeoManager.h:363; TGeoManager::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoManager.cxx:1698; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; TGeoManager::fKeyPNEIdInt_t * fKeyPNEIdDefinition TGeoManager.h:142; TGeoManager::DefaultAnglesvoid DefaultAngles()Set default angles for a given view.Definition TGeoManager.cxx:1818; TGeoManager::MixtureTGeoMaterial * Mixture(const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid)Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,...Definition TGeoManager.cxx:1296; TGeoManager::ThreadsMap_tstd::map< std::thread::id, Int_t > ThreadsMap_tDefinition TGeoManager.h:114; TGeoManager::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Classify a given point. See TGeoChecker::CheckPoint().Definition TGeoManager.cxx:3770; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8h_source.html:84662,safe,safe,84662,doc/master/TGeoManager_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html,1,['safe'],['safe']
Safety,"nal programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be associated to different threads over the course of a single event loop, but two threads will never receive the same slot at the same time. This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different processing slot, e.g. a different element of a list. See here for an example usage of ForeachSlot(). Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other. On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage. ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently: ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");; ; // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:47801,safe,safe,47801,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safe']
Safety,"nalysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 933event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 934On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 935ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 936~~~{.cpp}; 937ROOT::EnableImplicitMT();; 938ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 939ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 940auto histo1 = df1.Histo1D(""x"");; 941auto histo2 = df2.Histo1D(""y"");; 942 ; 943// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 944histo1->Draw(); // runs first multi-thread event loop; 945histo2->Draw(); // runs second multi-thread event loop; 946 ; 947// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 948ROOT::RDF::RunGraphs({histo1, histo2});; 949histo1->Draw(); // results can then be used as usual; 950~~~; 951 ; 952### Performance considerations; 953 ; 954To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 955For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 956Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 957should be preferred for performance-critical applications.; 958 ; 959Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 960See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 961 ; 962Just-in-time compilatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:54672,avoid,avoid,54672,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avoid'],['avoid']
Safety,"nalysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 973event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 974On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 975ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 976~~~{.cpp}; 977ROOT::EnableImplicitMT();; 978ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 979ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 980auto histo1 = df1.Histo1D(""x"");; 981auto histo2 = df2.Histo1D(""y"");; 982 ; 983// just accessing result pointers, the event loops of separate RDataFrames run one after the other; 984histo1->Draw(); // runs first multi-thread event loop; 985histo2->Draw(); // runs second multi-thread event loop; 986 ; 987// alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; 988ROOT::RDF::RunGraphs({histo1, histo2});; 989histo1->Draw(); // results can then be used as usual; 990~~~; 991 ; 992### Performance considerations; 993 ; 994To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 995For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 996Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 997should be preferred for performance-critical applications.; 998 ; 999Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 1000See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 1001 ; 1002Just-in-time compila",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:56312,avoid,avoid,56312,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avoid'],['avoid']
Safety,"nalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset); Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset). const RooArgList& pdfList() const; Return list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:47104,safe,safe,47104,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['safe'],['safe']
Safety,"name = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoArb8::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrap.html:3402,safe,safe,3402,root/html534/TGeoTrap.html,https://root.cern,https://root.cern/root/html534/TGeoTrap.html,6,['safe'],['safe']
Safety,"name = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoArb8::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:3381,safe,safe,3381,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,6,['safe'],['safe']
Safety,"name, const char *mode=""a"", RedirectHandle_t *h=nullptr) override;  Redirect standard output (stdout, stderr) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of file handlers. ;  ; TSignalHandler * RemoveSignalHandler (TSignalHandler *sh) override;  Remove a signal handler from list of signal handlers. ;  ; TTimer * RemoveTimer (TTimer *ti) override;  Remove timer from list of system timers. ;  ; int Rename (const char *from, const char *to) override;  Rename a file. Returns 0 when successful, -1 in case of failure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; void ResetTimer (TTimer *ti) override;  Reset a-sync timer. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDisplay () override;  Set DISPLAY environment variable based on utmp entry. Only for UNIX. ;  ; void SetDynamicPath (const char *lib) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int option, int val) override;  Set socket option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:10141,timeout,timeout,10141,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['timeout'],['timeout']
Safety,"nc);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; Bool_t IsAscending ();  ; TObject * Remove (const TObjLinkPtr_t &lnk);  ; void RemoveLast () override;  Remove the last object of the list. ;  ; virtual void Sort (Bool_t order=kSortAscending);  Sort linked list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSeqCollection; virtual ~TSeqCollection ();  ; void Add (TObject *obj) override;  ; TClass * IsA () const override;  ; virtual Bool_t IsSorted () const;  ; Int_t LastIndex () const;  ; Long64_t Merge (TCollection *list);  Merge this collection with all collections coming in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:6419,safe,safe,6419,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['safe'],['safe']
Safety,"nc);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; TObject * First () const override;  Return the first object in the list. Returns 0 when list is empty. ;  ; virtual TObjLink * FirstLink () const;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Bool_t IsAscending ();  ; TObject * La",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:4494,safe,safe,4494,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['safe'],['safe']
Safety,"nce which can be queried programmatically to get information about the effects of the individual cuts. . Stats() Return a TStatistic object filled with the input columns. . StdDev() Return the unbiased standard deviation of the processed column values. . Sum() Return the sum of the values in the column. If the type of the column is inferred, the return type is double, the type of the column otherwise. . Take() Extract a column from the dataset as a collection of values, e.g. a std::vector<float> for a column of type float. . Instant action Description . Foreach() Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. . ForeachSlot() Same as Foreach(), but the user-defined function must take an extra unsigned int slot as its first parameter. slot will take a different value, 0 to nThreads - 1, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case slot will always be 0. . Snapshot() Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made lazy setting the appropriate flag in the snapshot options. . Queries; These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. Operation Description . Describe() Get useful information describing the dataframe, e.g. columns and their types. . GetColumnNames() Get the names of all the available columns of the dataset. . GetColumnType() Return the type of a given column as a string. . GetColumnTypeNamesList() Return the list of type names of columns in the dataset. . GetDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:8351,safe,safe,8351,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safe']
Safety,"nce; Inherited Members; Includes; Libraries. Function documentation; TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(Double_t* point, Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(Double_t* point, Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(Double_t* point, Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:14510,safe,safe,14510,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,4,['safe'],['safe']
Safety,"nch *mother = br->GetMother();; 6124 if (strncmp(brname,branchname,nbch)) {; 6125 if (mother != br) {; 6126 const char *mothername = mother->GetName();; 6127 UInt_t motherlen = strlen(mothername);; 6128 if (!strcmp(mothername, branchname)) {; 6129 return leaf;; 6130 } else if (nbch > motherlen && strncmp(mothername,branchname,motherlen)==0 && (mothername[motherlen-1]=='.' || branchname[motherlen]=='.')) {; 6131 // The left part of the requested name match the name of the mother, let's see if the right part match the name of the branch.; 6132 if (strncmp(brname,branchname+motherlen+1,nbch-motherlen-1)) {; 6133 // No it does not; 6134 continue;; 6135 } // else we have match so we can proceed.; 6136 } else {; 6137 // no match; 6138 continue;; 6139 }; 6140 } else {; 6141 continue;; 6142 }; 6143 }; 6144 // The start of the branch name is identical to the content; 6145 // of 'aname' before the first '/'.; 6146 // Let's make sure that it is not longer (we are trying; 6147 // to avoid having jet2/value match the branch jet23; 6148 if ((strlen(brname) > nbch) && (brname[nbch] != '.') && (brname[nbch] != '[')) {; 6149 continue;; 6150 }; 6151 }; 6152 return leaf;; 6153 }; 6154 if (!fFriends) return nullptr;; 6155 TFriendLock lock(this,kGetLeaf);; 6156 TIter next(fFriends);; 6157 TFriendElement *fe;; 6158 while ((fe = (TFriendElement*)next())) {; 6159 TTree *t = fe->GetTree();; 6160 if (t) {; 6161 leaf = t->GetLeaf(branchname, leafname);; 6162 if (leaf) return leaf;; 6163 }; 6164 }; 6165 ; 6166 //second pass in the list of friends when the leaf name; 6167 //is prefixed by the tree name; 6168 TString strippedArg;; 6169 next.Reset();; 6170 while ((fe = (TFriendElement*)next())) {; 6171 TTree *t = fe->GetTree();; 6172 if (!t) continue;; 6173 const char *subname = strstr(leafname,fe->GetName());; 6174 if (subname != leafname) continue;; 6175 Int_t l = strlen(fe->GetName());; 6176 subname += l;; 6177 if (*subname != '.') continue;; 6178 subname++;; 6179 strippedArg += subname;; 6180",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:241733,avoid,avoid,241733,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"nch.cxx:2763; TBranch::UpdateAddressvirtual void UpdateAddress()Definition TBranch.h:290; TBranch::GetOffsetInt_t GetOffset() constDefinition TBranch.h:235; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fBulkBulkObj fBulk! Helper for performing bulk IODefinition TBranch.h:153; TBranch::GetReadEntryLong64_t GetReadEntry() constDefinition TBranch.h:237; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::SetSkipZipvoid SetSkipZip(bool skip=true)Definition TBranch.h:170; TBranch::GetReadBasketInt_t GetReadBasket() constDefinition TBranch.h:236; TBranch::fBasketBytesInt_t * fBasketBytes[fMaxBaskets] Length of baskets on fileDefinition TBranch.h:141; TBranch::fNextBasketEntryLong64_t fNextBasketEntry! Next entry that will re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8h_source.html:31981,avoid,avoid,31981,doc/master/TBranch_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html,1,['avoid'],['avoid']
Safety,"ncludes; Libraries. Function documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPara.html:12843,safe,safe,12843,root/html528/TGeoPara.html,https://root.cern,https://root.cern/root/html528/TGeoPara.html,8,['safe'],['safe']
Safety,"ncludes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKey.html:9987,avoid,avoid,9987,root/html532/TKey.html,https://root.cern,https://root.cern/root/html532/TKey.html,4,['avoid'],['avoid']
Safety,"nction documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true if the scaled shape is an assembly. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoScaledShape.html:12463,safe,safe,12463,root/html532/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html532/TGeoScaledShape.html,2,['safe'],['safe']
Safety,"nction documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. TGeoShape * MakeScaledShape(const char* name, TGeoShape* s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoScaledShape.html:12238,safe,safe,12238,root/html528/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html,2,['safe'],['safe']
Safety,"nction pbject implementing the operator()(const double * x, const double * p) in an interface-like IParamFunction with a vector storing and caching internally the parameter values ;  CWrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(const double * ) in an interface-like IParamFunction, by fixing some of the variables and define them as parameters ;  CWrappedTF1Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime ;  ►NMeta;  ►NSelection;  CClassAttributesUsed to specify attributes of classes in the ""DictSelection"" syntax ;  CKeepFirstTemplateArgumentsUsed to specify the number of arguments to be kept ;  CMemberAttributesUsed to specify attributes of data members in the ""DictSelection"" syntax ;  CSelectNoInstanceUsed to avoid to select all instances of a template ;  ►NMinuit2;  CABObj;  CABObj< sym, LASymMatrix, double >;  CABObj< vec, LAVector, double >;  CABProd;  CABSum;  CAlgebraicProdType;  CAlgebraicProdType< gen, gen >;  CAlgebraicProdType< gen, sym >;  CAlgebraicProdType< gen, vec >;  CAlgebraicProdType< sym, gen >;  CAlgebraicProdType< sym, sym >;  CAlgebraicProdType< sym, vec >;  CAlgebraicProdType< T, T >;  CAlgebraicProdType< vec, gen >;  CAlgebraicProdType< vec, sym >;  CAlgebraicSumType;  CAlgebraicSumType< gen, vec >;  CAlgebraicSumType< sym, vec >;  CAlgebraicSumType< T, T >;  CAlgebraicSumType< vec, gen >;  CAlgebraicSumType< vec, sym >;  CAnalyticalGradientCalculator;  CBasicFunctionGradient;  ►CBasicFunctionMinimumResult of the minimization; both internal and external (MnUserParameterState) representation available For the parameters at the Minimum ;  CMnAboveMaxEdm;  CMnReachedCallLimit;  ►CBasicMinimumErrorInternal Class containing the error information on the estimated minimum : Err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:53674,avoid,avoid,53674,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,7,['avoid'],['avoid']
Safety,"nction to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a non-positive–definite covariance matrix, this may be a sign of one or more of the following:. A non–physical region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the under-determinedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:73229,recover,recovers,73229,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['recover'],['recovers']
Safety,"nction to determine the current search direction, since this is the optimal strategy for quadratic functions and “physical” functions should be quadratic in the neighbourhood of the minimum at least. The search directions determined by \(\mbox{MIGRAD}\) are guaranteed to be downhill only if the covariance matrix is positive–definite, so in case this is not true, it makes a positive–definite approximation by adding an appropriate constant along the diagonal as determined by the eigenvalues of the matrix. Theoretically, the covariance matrix for a “physical” function must be positive–definite at the minimum, although it may not be so for all points far away from the minimum, even for a well–determined physical problem. Therefore, if \(\mbox{MIGRAD}\) reports that it has found a non-positive–definite covariance matrix, this may be a sign of one or more of the following:. A non–physical region. On its way to the minimum, \(\mbox{MIGRAD}\) may have traversed a region which has unphysical behaviour, which is of course not a serious problem as long as it recovers and leaves such a region.; An underdetermined problem. If the matrix is not positive–definite even at the minimum, this may mean that the solution is not well–defined, for example that there are more unknowns than there are data points, or that the parametrization of the fit contains a linear dependence. If this is the case, then M (or any other program) cannot solve your problem uniquely, and the error matrix will necessarily be largely meaningless, so the user must remove the underdeterminedness by reformulating the parametrization. M cannot do this itself, but it can provide some hints (contours, global correlation coefficients, eigenvalues) which can help the clever user to find out what is wrong.; Numerical inaccuracies. It is possible that the apparent lack of positive–definiteness is in fact only due to excessive roundoff errors in numerical calculations, either in \(\mbox{FCN}\) or in M . This is unlikely i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:77218,recover,recovers,77218,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['recover'],['recovers']
Safety,"ncy; 1548/// indicated in theString; 1549///; 1550/// ""theString"" must have two entries:; 1551/// - `[0]`: ""Efficiency""; 1552/// - `[1]`: the value of background efficiency at which the signal efficiency; 1553/// is to be returned; 1554 ; 1555Double_t TMVA::MethodCuts::GetEfficiency( const TString& theString, Types::ETreeType type, Double_t& effSerr ); 1556{; 1557 Data()->SetCurrentType(type);; 1558 ; 1559 Results* results = Data()->GetResults( GetMethodName(), Types::kTesting, GetAnalysisType() );; 1560 ; 1561 // parse input string for required background efficiency; 1562 TList* list = gTools().ParseFormatLine( theString, "":"" );; 1563 ; 1564 if (list->GetSize() > 2) {; 1565 delete list;; 1566 Log() << kFATAL << ""<GetEfficiency> wrong number of arguments""; 1567 << "" in string: "" << theString; 1568 << "" | required format, e.g., Efficiency:0.05, or empty string"" << Endl;; 1569 return -1;; 1570 }; 1571 ; 1572 // sanity check; 1573 Bool_t computeArea = (list->GetSize() < 2); // the area is computed; 1574 ; 1575 // that will be the value of the efficiency retured (does not affect; 1576 // the efficiency-vs-bkg plot which is done anyway.; 1577 Float_t effBref = (computeArea?1.:atof( ((TObjString*)list->At(1))->GetString() ));; 1578 ; 1579 delete list;; 1580 ; 1581 ; 1582 // first round ? --> create histograms; 1583 if (results->GetHist(""MVA_EFF_BvsS"")==0) {; 1584 ; 1585 if (fBinaryTreeS!=0) { delete fBinaryTreeS; fBinaryTreeS = 0; }; 1586 if (fBinaryTreeB!=0) { delete fBinaryTreeB; fBinaryTreeB = 0; }; 1587 ; 1588 // the variables may be transformed by a transformation method: to coherently; 1589 // treat signal and background one must decide which transformation type shall; 1590 // be used: our default is signal-type; 1591 fBinaryTreeS = new BinarySearchTree();; 1592 fBinaryTreeS->Fill( GetEventCollection(Types::kTesting), fSignalClass );; 1593 fBinaryTreeB = new BinarySearchTree();; 1594 fBinaryTreeB->Fill( GetEventCollection(Types::kTesting), fBackgroundClass );; 1595 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:60877,sanity check,sanity check,60877,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"nd = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgSet.html:13238,safe,safeDeleteList,13238,root/html534/RooArgSet.html,https://root.cern,https://root.cern/root/html534/RooArgSet.html,2,['safe'],['safeDeleteList']
Safety,"nd = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClassName; static RooPrintable::ContentsOptionRooPrintable::kCollectionHeader; static RooPrintable::ContentsOptionRooPrintable::kExtras; static TObject::EStatusBitsTObject::kHasUUID; static RooPrintable::StyleOptionRooPrintable::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:13272,safe,safeDeleteList,13272,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,4,['safe'],['safeDeleteList']
Safety,"nd Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TVirtualFFT; 13\ingroup Base; 14 ; 15TVirtualFFT is an interface class for Fast Fourier Transforms.; 16 ; 17The default FFT library is FFTW. To use it, FFTW3 library should already; 18be installed, and ROOT should be have fftw3 module enabled, with the directories; 19of fftw3 include file and library specified (see installation instructions).; 20Function SetDefaultFFT() allows to change the default library.; 21 ; 22## Available transform types:; 23FFT:; 24 - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 25 in one or more dimensions, -1 in the exponent; 26 - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 27 in one or more dimensions, +1 in the exponent; 28 - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 29 in one or more dimensions,; 30 - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 31 (storing the non-redundant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parameter kind of the SineCosine() static; 41function. 4 different kinds of sine and cosine transforms are available; 42 ; 43 - DCT-I (REDFT00 in FFTW3 notation)- kind=0; 44 - DCT-II (REDFT01 in FFTW3 notation)- kind=1; 45 - DCT-III(REDFT10 in FFTW3 notation)- kind=2; 46 - DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 47 - DST-I (RODFT00 in FFTW3 notation)- kind=4; 48 - DST-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:1544,redund,redundant,1544,doc/master/TVirtualFFT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html,1,['redund'],['redundant']
Safety,"nd Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoConeSeg.html:15854,safe,safe,15854,root/html528/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html528/TGeoConeSeg.html,8,['safe'],['safe']
Safety,"nd polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoCtub(); constructors. const Double_t * GetNlow() const; {return &fNlow[0];}. const Double_t * GetNhigh() const; {return &fNhigh[0];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:19583,safe,safe,19583,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nd polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoCtub(); constructors. const Double_t * GetNlow() const; {return &fNlow[0];}. const Double_t * GetNhigh() const; {return &fNhigh[0];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoCtub.html:21333,safe,safe,21333,root/html604/TGeoCtub.html,https://root.cern,https://root.cern/root/html604/TGeoCtub.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nd polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoCtub(); constructors. const Double_t * GetNlow() const; {return &fNlow[0];}. const Double_t * GetNhigh() const; {return &fNhigh[0];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCtub.html:21333,safe,safe,21333,root/html602/TGeoCtub.html,https://root.cern,https://root.cern/root/html602/TGeoCtub.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nd the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf302_utilfuncsDefinition rf302_utilfuncs.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWout",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8C.html:5859,safe,safe,5859,doc/master/rf302__utilfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html,1,['safe'],['safe']
Safety,"ndards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops and applies; 130/// `static_cast<T>` or `dynamic_cast<T>` to each element.; 131/// \tparam T The new type to convert to.; 132/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 133/// \tparam Range_t The type of the input range, which should be usually a reference type to avoid copying.; 134template <typename T, bool isDynamic, typename Range_t>; 135class RRangeCast {; 136 ; 137public:; 138 RRangeCast(Range_t &&inputRange) : fInputRange{inputRange}; 139 {; 140 static_assert(ROOT::Internal::hasBeginEnd<Range_t>(0),; 141 ""Type with no `begin` or `end` method passed to `RRangeCast`"");; 142 }; 143 ; 144 using const_iterator = Internal::TypedIter<T, decltype(std::cbegin(std::declval<Range_t>())), isDynamic>;; 145 const_iterator begin() const { return std::cbegin(fInputRange); }; 146 const_iterator end() const { return std::cend(fInputRange); }; 147 ; 148 using iterator = Internal::TypedIter<T, decltype(std::begin(std::declval<Range_t>())), isDynamic>;; 149 iterator begin() { return std::begin(fInputRange); }; 150 iterator end() { return std::end(fInputRange); }; 151 ; 152private:; 153 Range_t fInputRange;; 154};; 155 ; 156/// Takes any collection that can be used in range-based loops and applies; 157/// static_cast<T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RRangeCast_8hxx_source.html:4121,avoid,avoid,4121,doc/master/RRangeCast_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html,2,['avoid'],['avoid']
Safety,"ndary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; TGeoManager::FindNextBoundaryAndStepTGeoNode * FindNextBoundaryAndStep(Double_t stepmax=TGeoShape::Big(), Bool_t compsafe=kFALSE)Compute distance to next boundary within STEPMAX.Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:86358,safe,safe,86358,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safe']
Safety,"nder, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TQt5Timer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQt5Timer(). TQt5Timer::TQt5Timer ; (; Long_t ; milliSec, . Bool_t ; mode . ). inline . Definition at line 72 of file rootqt5.cpp. Member Function Documentation. ◆ Timeout(). void TQt5Timer::Timeout ; (; ). inlineoverridevirtual . timeout handler used to process all qt5 events in main ROOT thread ; Reimplemented from TTimer.; Definition at line 76 of file rootqt5.cpp. gui/qt5webdisplay/rootqt5.cpp. TQt5Timer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQt5Timer.html:17448,timeout,timeout,17448,doc/master/classTQt5Timer.html,https://root.cern,https://root.cern/doc/master/classTQt5Timer.html,1,['timeout'],['timeout']
Safety,"nder, TClass *sender_class, const char *signal, TClass *receiver_class, const char *slot);  Checking of consistency of sender/receiver methods/arguments. ;  ; static TString CompressName (const char *method_name);  Removes ""const"" words and blanks from full (with prototype) method name and resolve any typedefs in the method signature. ;  ; static Bool_t ConnectToClass (const char *sender_class, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  This method allows to make connection from any object of the same class to the receiver object. ;  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TQt6Timer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQt6Timer(). TQt6Timer::TQt6Timer ; (; Long_t ; milliSec, . Bool_t ; mode . ). inline . Definition at line 51 of file rootqt6.cpp. Member Function Documentation. ◆ Timeout(). void TQt6Timer::Timeout ; (; ). inlineoverridevirtual . timeout handler used to process all qt6 events in main ROOT thread ; Reimplemented from TTimer.; Definition at line 55 of file rootqt6.cpp. gui/qt6webdisplay/rootqt6.cpp. TQt6Timer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQt6Timer.html:17448,timeout,timeout,17448,doc/master/classTQt6Timer.html,https://root.cern,https://root.cern/doc/master/classTQt6Timer.html,1,['timeout'],['timeout']
Safety,"ndicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change parameter values, plotting; # -----------------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; sigma_g2.setConstant(True); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8py.html:3404,safe,safe,3404,doc/master/rf601__intminuit_8py.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html,1,['safe'],['safe']
Safety,"nding on the ROOT environment variable ""Root.ObjStat"" (see TEnv) the object is added to the global TObjectTable for bookkeeping. ; Definition at line 254 of file TObject.h. ◆ TObject() [2/2]. TObject::TObject ; (; const TObject & ; object). inline . TObject copy ctor. ; Definition at line 272 of file TObject.h. ◆ ~TObject(). TObject::~TObject ; (; ). virtual . TObject destructor. ; Removes object from all canvases and object browsers if observer bit is on and remove from the global object table. ; Definition at line 158 of file TObject.cxx. Member Function Documentation. ◆ AbstractMethod(). void TObject::AbstractMethod ; (; const char * ; method); const. Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Definition at line 1029 of file TObject.cxx. ◆ AddToTObjectTable(). void TObject::AddToTObjectTable ; (; TObject * ; op). staticprivate . Private helper function which will dispatch to TObjectTable::AddObj. ; Included here to avoid circular dependency between header files. ; Definition at line 175 of file TObject.cxx. ◆ AppendPad(). void TObject::AppendPad ; (; Option_t * ; option = """"). virtual . Append graphics object to current pad. ; In case no current pad is set yet, create a default canvas with the name ""c1"". ; Definition at line 184 of file TObject.cxx. ◆ Browse(). void TObject::Browse ; (; TBrowser * ; b). virtual . Browse object. May be overridden for another default action. ; Reimplemented in TASImage, TRecorder, TEfficiency, TGraph2D, TChain, TTree, TDirectory, TFolder, TMacro, TRemoteObject, TROOT, TStyle, TSystemDirectory, TSystemFile, TTask, TCollection, TPair, TBrowserObject, TBaseClass, TClass, TGeoManager, TGeoNode, TGeoVolume, TGeoOverlap, TGeoTrack, TCanvas, TPad, TAxis3D, TGeometry, TNode, TRootIconList, THbookBranch, THbookFile, THbookKey, TF1, TGraph, TH1, THnBase, ROOT::Internal::THnBaseBrowsable, THStack, TMultiDimFit, TMultiGraph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:19994,avoid,avoid,19994,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['avoid'],['avoid']
Safety,"nding on the ROOT environment variable ""Root.ObjStat"" (see TEnv) the object is added to the global TObjectTable for bookkeeping. ; Definition at line 254 of file TObject.h. ◆ TObject() [2/2]. TObject::TObject ; (; const TObject & ; object). inline . TObject copy ctor. ; Definition at line 272 of file TObject.h. ◆ ~TObject(). TObject::~TObject ; (; ). virtual . TObject destructor. ; Removes object from all canvases and object browsers if observer bit is on and remove from the global object table. ; Definition at line 164 of file TObject.cxx. Member Function Documentation. ◆ AbstractMethod(). void TObject::AbstractMethod ; (; const char * ; method); const. Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Definition at line 1035 of file TObject.cxx. ◆ AddToTObjectTable(). void TObject::AddToTObjectTable ; (; TObject * ; op). staticprivate . Private helper function which will dispatch to TObjectTable::AddObj. ; Included here to avoid circular dependency between header files. ; Definition at line 181 of file TObject.cxx. ◆ AppendPad(). void TObject::AppendPad ; (; Option_t * ; option = """"). virtual . Append graphics object to current pad. ; In case no current pad is set yet, create a default canvas with the name ""c1"". ; Definition at line 190 of file TObject.cxx. ◆ Browse(). void TObject::Browse ; (; TBrowser * ; b). virtual . Browse object. May be overridden for another default action. ; Reimplemented in TASImage, TRecorder, TEfficiency, TGraph2D, TChain, TTree, TDirectory, TFolder, TMacro, TRemoteObject, TROOT, TStyle, TSystemDirectory, TSystemFile, TTask, TCollection, TPair, TBrowserObject, TBaseClass, TClass, TGeoManager, TGeoNode, TGeoVolume, TGeoOverlap, TGeoTrack, TCanvas, TPad, TAxis3D, TGeometry, TNode, TRootIconList, THbookBranch, THbookFile, THbookKey, TF1, TGraph, TH1, THnBase, ROOT::Internal::THnBaseBrowsable, THStack, TMultiDimFit, TMultiGraph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:19995,avoid,avoid,19995,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['avoid'],['avoid']
Safety,"ndomRays (Int_t nrays=1000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Randomly shoot nrays and plot intersections with surfaces for current top node. ;  ; void RefreshPhysicalNodes (Bool_t lock=kTRUE);  Refresh physical nodes to reflect the actual geometry paths after alignment was applied. ;  ; void RegisterMatrix (const TGeoMatrix *matrix);  Register a matrix to the list of matrices. ;  ; void RemoveMaterial (Int_t index);  Remove material at given index. ;  ; void RemoveNavigator (const TGeoNavigator *nav);  Clear a single navigator. ;  ; Int_t ReplaceVolume (TGeoVolume *vorig, TGeoVolume *vnew);  Replaces all occurrences of VORIG with VNEW in the geometry tree. ;  ; void ResetState ();  Reset current state flags. ;  ; void ResetUserData ();  Sets all pointers TGeoVolume::fField to NULL. ;  ; void RestoreMasterVolume ();  Restore the master volume of the geometry. ;  ; Double_t Safety (Bool_t inside=kFALSE);  Compute safe distance from the current point. ;  ; TGeoNode * SamplePoints (Int_t npoints, Double_t &dist, Double_t epsil=1E-5, const char *g3path="""");  shoot npoints randomly in a box of 1E-5 around current point. ;  ; void SaveAttributes (const char *filename=""tgeoatt.C"");  Save current attributes in a macro. ;  ; TGeoNode * SearchNode (Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr);  Returns the deepest node containing fPoint, which must be set a priori. ;  ; void SelectTrackingMedia ();  Define different tracking media. ;  ; TGeoPNEntry * SetAlignableEntry (const char *unique_name, const char *path, Int_t uid=-1);  Creates an alignable object with unique name corresponding to a path and adds it to the list of alignables. ;  ; void SetAllIndex ();  Assigns uid's for all materials,media and matrices. ;  ; void SetAnimateTracks (Bool_t flag=kTRUE);  ; void SetBombFactors (Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3);  Set factors that wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:45343,safe,safe,45343,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safe']
Safety,"ne class member, from another. ;  ; void SetTypenameTag (const char *tag=""_typename"");  Configures _typename tag in JSON structures By default ""_typename"" field in JSON structures used to store class information One can specify alternative tag like ""$typename"" or ""xy"", but such JSON can not be correctly used in JSROOT If empty string is provided, class information will not be stored. ;  ; void SetTypeversionTag (const char *tag=nullptr);  Configures _typeversion tag in JSON One can specify name of the JSON tag like ""_typeversion"" or ""$tv"" which will be used to store class version Such tag can be used to correctly recover objects from JSON If empty string is provided (default), class version will not be stored. ;  ; void SkipObjectAny () final;  Skip any kind of object from buffer. ;  ; TString StoreObject (const void *obj, const TClass *cl);  Store provided object as JSON structure Allows to configure different TBufferJSON properties before converting object into JSON Actual object class must be specified here Method can be safely called once - after that TBufferJSON instance must be destroyed Code should look like: ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void StreamObject (TObject *obj) override;  ; void StreamObject (void *obj, const char *className, const TClass *onFileClass=nullptr) override;  stream object to/from buffer ;  ; void StreamObject (void *obj, const std::type_info &typeinfo, const TClass *onFileClass=nullptr) override;  stream object to/from buffer ;  ; void StreamObject (void *obj, const TClass *cl, const TClass *onFileClass=nullptr) final;  stream object to/from buffer ;  ; void WriteArray (const Bool_t *b, Int_t n) final;  Write array of Bool_t to buffer. ;  ; void WriteArray (const Char_t *c, Int_t n) final;  Write array of Char_t to buffer. ;  ; void WriteArray (const Double_t *d, Int_t n) final;  Write array of Double_t to buffer. ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:13842,safe,safely,13842,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['safe'],['safely']
Safety,"ne of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do to execute with native compiler: .x tree2a.C+ ; Note that since IO is involved, ACLiC has to be invoked to create the dictionary of class Gctrak. ; #include ""TROOT.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TBrowser.h""; #include ""TH2.h""; #include ""TMath.h""; #include ""TRandom.h""; #include ""TCanvas.h""; ; const Int_t MAXMEC = 30;; ; class Gctrak : public TObject {; public:; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7]; //! not persistent; Int_t nmec;; Int_t *lmec; //[nmec]; Int_t *namec; //[nmec]; Int_t nstep; //! not persistent; Int_t pid;; Float_t destep;; Float_t destel; //! not persistent; Float_t safety; //! not persistent; Float_t sleng; //! not persistent; Float_t step; //! not persistent; Float_t snext; //! not persistent; Float_t sfield; //! not persistent; Float_t tofg; //! not persistent; Float_t gekrat; //! not persistent; Float_t upwght; //! not persistent; ; Gctrak() {lmec=nullptr; namec=nullptr;}; ; ClassDefOverride(Gctrak,1); };; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2a_8C.html:1193,safe,safety,1193,doc/master/tree2a_8C.html,https://root.cern,https://root.cern/doc/master/tree2a_8C.html,1,['safe'],['safety']
Safety,"ne; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooDataSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataSet.html:17539,avoid,avoid,17539,root/html530/RooDataSet.html,https://root.cern,https://root.cern/root/html530/RooDataSet.html,1,['avoid'],['avoid']
Safety,"nect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; TString GetJobAd ();  Get job Ad. ;  ; Bool_t StartSlaves (Bool_t) override;  Setup Condor workers using dynamic information. ;  ;  Protected Member Functions inherited from TProof;  TProof ();  Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ;  ; Int_t AddWorkers (TList *wrks);  Works on the master node only. ;  ; Int_t AssertPath (const char *path, Bool_t writable);  Make sure that 'path' exists; if 'writable' is kTRUE, make also sure that the path is writable. ;  ; Int_t Collect (ESlaves list=kActive, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; Int_t Collect (TList *slaves, Long_t timeout=-1, Int_t endtype=-1, Bool_t deactonfail=kFALSE);  Collect responses from the slave servers. ;  ; TSlave * CreateSlave (const char *url, const char *ord, Int_t perf, const char *image, const char *workdir);  Create a new TSlave of type TSlave::kSlave. ;  ; TSlave * CreateSubmaster (const char *url, const char *ord, const char *image, const char *msd, Int_t nwk=1);  Create a new TSlave of type TSlave::kMaster. ;  ; TList * GetEnabledPackages () const;  ; TList * GetListOfActiveSlaves () const;  ; TVirtualProofPlayer * GetPlayer () const;  ; TPluginHandler * GetProgressDialog () const;  ; Int_t GetSandbox (TString &sb, Bool_t assert=kFALSE, const char *rc=0);  Set the sandbox path from ' Proof.Sandbox' or the alternative var 'rc'. ;  ; void HandleLibIncPath (const char *what, Bool_t add, const char *dirs);  Handle lib, inc search paths modification request. ;  ; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofCondor.html:35588,timeout,timeout,35588,doc/master/classTProofCondor.html,https://root.cern,https://root.cern/doc/master/classTProofCondor.html,1,['timeout'],['timeout']
Safety,"ned(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19991 mg_snprintf(NULL,; 19992 NULL, /* No truncation check for error buffers */; 19993 error->text,; 19994 error->text_buffer_size,; 19995 ""%s"",; 19996 err_msg);; 19997 }; 19998 free_context(ctx);; 19999 pthread_setspecific(sTlsKey, NULL);; 20000 return NULL;; 20001 }; 20002 ; 20003#elif !defined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snprintf(NULL,; 20011 NULL, /* No truncation check for error buffers */; 20012 error->text,; 20013 error->text_buffer_size,; 20014 ""%s"",; 20015 err_msg);; 20016 }; 20017 free_context(ctx);; 20018 pthread_setspecific(sTlsKey, NULL);; 20019 return NULL;; 20020 }; 20021#endif; 20022 ; 20023 if (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:598398,abort,abort,598398,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"ned(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:598431,abort,abort,598431,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"nel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticleType ParticleMCType(Int_t pdg) const; Return VMC type of the particle specified by pdg. void StopTrack(). methods for step management. action methods. Stop the transport of the current particle and skip to the next. void StopEvent(); Stop simulation of the current event and skip to the next. void StopRun(); Stop simulation of the current event and set the abort run flag to true. void SetMaxStep(Double_t ). set methods. Set the maximum step allowed till the particle is in the current medium. void SetMaxNStep(Int_t ); Set the maximum number of steps till the particle is in the current medium. void SetUserDecay(Int_t pdg); Force the decays of particles to be done with Pythia; and not with the Geant routines. void ForceDecayTime(Float_t ); Force the decay time of the current particle. Int_t CurrentVolID(Int_t& copyNo) const. tracking volume(s). Return the current volume ID and copy number. Int_t CurrentVolOffID(Int_t off, Int_t& copyNo) const; Return the current volume off upward in the geometrical tree; ID and copy number. const char* CurrentVolName() const; Return the current volume name. const char* CurrentVolOffName(Int_t off) const; Return the current volume off upward in the geometrical tree; name and copy number'; if name=0 no name is returned. const char* CurrentVolPath(); Return the path in geometry tree for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:30734,abort,abort,30734,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,9,['abort'],['abort']
Safety,"nerate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, Binning=50, YVar=dict(var=y, Binning=50)); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf301_composition"", ""rf301_composition"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf301_composition.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[y]_Norm[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); [#1] INFO:NumericIntegration -- RooRealIntegral::init",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf301__composition_8py.html:2270,safe,safe,2270,doc/master/rf301__composition_8py.html,https://root.cern,https://root.cern/doc/master/rf301__composition_8py.html,1,['safe'],['safe']
Safety,"nes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set polycone dimensions starting from an array. void SetPoints(Double_t* points) const; create polycone mesh points. void SetPoints(Float_t* points) const; create polycone mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomer();; if (!painter) return;; Int_t n;. n = gGeoManager->GetNsegments()+1;. Int_t numPoints = fNz*2*n;; Int_t numSegs = 4*(fNz*n-1+(fDphi == 360))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:15393,safe,safety,15393,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,5,"['Safe', 'safe']","['SafetyToSegment', 'safety']"
Safety,"nes; 3 - exclude spaces as much as possible; When member_name specified, converts only this data member. TString ConvertToJSON(const void* obj, TDataMember* member, Int_t compact = 0, Int_t arraylen = -1); Converts selected data member into json. Parameter ptr specifies address in memory, where data member is located; compact parameter defines compactness of produced JSON (from 0 to 3); arraylen (when specified) is array length for this data member, //[fN] case. TString JsonWriteMember(const void* ptr, TDataMember* member, TClass* memberClass, Int_t arraylen); Convert single data member to JSON structures; Returns string with converted member. Bool_t CheckObject(const TObject* ); Check that object already stored in the buffer. Bool_t CheckObject(const void* , const TClass* ); Check that object already stored in the buffer. void WriteObject(const TObject* obj); Convert object into json structures.; !!! Should be used only by TBufferJSON itself.; Use ConvertToJSON() methods to convert object to json; Redefined here to avoid gcc 3.x warning. TJSONStackObj * PushStack(Int_t inclevel = 0); add new level to the structures stack. TJSONStackObj * PopStack(); remove one level from stack. TJSONStackObj * Stack(Int_t depth = 0); return stack object of specified depth. void AppendOutput(const char* line0, const char* line1 = 0); Info(""AppendOutput"","" '%s' '%s'"", line0, line1?line1 : ""---"");. void JsonStartElement(const TStreamerElement* elem, const TClass* base_class = 0). void JsonDisablePostprocessing(). Int_t JsonSpecialClass(const TClass* cl) const; return non-zero value when class has special handling in JSON; it is TCollection (-130), TArray (100), TString (110), std::string (120) and STL containers (1..6). void JsonWriteObject(const void* obj, const TClass* objClass, Bool_t check_map = kTRUE); Write object to buffer; If object was written before, only pointer will be stored; If check_map==kFALSE, object will be stored in any case and pointer will not be registered in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:22150,avoid,avoid,22150,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,2,['avoid'],['avoid']
Safety,"nestatic . ReturnsName of the file containing the class declaration ; Definition at line 58 of file TMLPAnalyzer.h. ◆ DrawDInput(). void TMLPAnalyzer::DrawDInput ; (; Int_t ; i). Draws the distribution (on the test sample) of the impact on the network output of a small variation of the ith input. ; Definition at line 284 of file TMLPAnalyzer.cxx. ◆ DrawDInputs(). void TMLPAnalyzer::DrawDInputs ; (; ). Draws the distribution (on the test sample) of the impact on the network output of a small variation of each input. ; DrawDInputs() draws something that approximates the distribution of the derivative of the NN w.r.t. each input. That quantity is recognized as one of the measures to determine key quantities in the network.; What is done is to vary one input around its nominal value and to see how the NN changes. This is done for each entry in the sample and produces a distribution.; What you can learn from that is:; is variable a really useful, or is my network insensitive to it ?; is there any risk of big systematic ? Is the network extremely sensitive to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve as input for an ""educated guess"" when optimizing the network. ; Definition at line 311 of file TMLPAnalyzer.cxx. ◆ DrawNetwork(). void TMLPAnalyzer::DrawNetwork ; (; Int_t ; neuron, . const char * ; signal, . const char * ; bg . ). Draws the distribution of the neural network (using ith neuron). ; Two distributions are drawn, for events passing respectively the ""signal"" and ""background"" cuts. Only the test sample is used. ; Definition at line 337 of file TMLPAnalyzer.cxx. ◆ DrawTruthDeviation(). TProfile * TMLPAnalyzer::DrawTruthDeviation ; (; Int_t ; outnode = 0, . Option_t * ; option = """" . ). Create a profile of the difference of the MLP output minus the true value for a given output node outnode, vs the true value for outnode, for all test data events. ; This method is mainly useful when doing regress",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMLPAnalyzer.html:14558,risk,risk,14558,doc/master/classTMLPAnalyzer.html,https://root.cern,https://root.cern/doc/master/classTMLPAnalyzer.html,1,['risk'],['risk']
Safety,"new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tTWebFile::ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTWebFile::ReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTWebFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAS3File.html:11353,Recover,Recover,11353,root/html532/TAS3File.html,https://root.cern,https://root.cern/root/html532/TAS3File.html,2,['Recover'],['Recover']
Safety,"nexpected: {; 4016 Fatal(""TCling::SetClassInfo::AlternateTuple"",; 4017 ""Layout of std::tuple on this platform is unexpected."");; 4018 break;; 4019 }; 4020 }; 4021 ; 4022 alternateTuple << ""};\n"";; 4023 alternateTuple << ""}}\n"";; 4024 alternateTuple << ""#endif\n"";; 4025 if (!gCling->Declare(alternateTuple.str().c_str())); 4026 {; 4027 // Declare is not silent (yet?), so add an explicit error message; 4028 // to indicate the consequence of the syntax errors.; 4029 Error(""Load"",""Could not declare %s"",alternateName.c_str());; 4030 return """";; 4031 }; 4032 alternateName = ""ROOT::Internal::"" + alternateName;; 4033 return alternateName;; 4034}; 4035 ; 4036////////////////////////////////////////////////////////////////////////////////; 4037/// Set pointer to the TClingClassInfo in TClass.; 4038/// If 'reload' is true, (attempt to) generate a new ClassInfo even if we; 4039/// already have one.; 4040 ; 4041void TCling::SetClassInfo(TClass* cl, Bool_t reload, Bool_t silent); 4042{; 4043 // We are shutting down, there is no point in reloading, it only triggers; 4044 // redundant deserializations.; 4045 if (fIsShuttingDown) {; 4046 // Remove the decl_id from the DeclIdToTClass map; 4047 if (cl->fClassInfo) {; 4048 R__LOCKGUARD(gInterpreterMutex);; 4049 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4050 // Test again as another thread may have set fClassInfo to nullptr.; 4051 if (TClinginfo) {; 4052 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4053 }; 4054 delete TClinginfo;; 4055 cl->fClassInfo = nullptr;; 4056 }; 4057 return;; 4058 }; 4059 ; 4060 R__LOCKGUARD(gInterpreterMutex);; 4061 if (cl->fClassInfo && !reload) {; 4062 return;; 4063 }; 4064 //Remove the decl_id from the DeclIdToTClass map; 4065 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4066 if (TClinginfo) {; 4067 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4068 }; 4069 delete TClinginfo;; 4070 cl->fClassInfo = nullptr;; 4071 std::string name(cl->GetName());; 407",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:156333,redund,redundant,156333,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['redund'],['redundant']
Safety,"nformation about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3725,recover,recovery,3725,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"ng category sample as index:; // associate model with the physics state and model_ctl with the control state; RooSimultaneous simPdf(""simPdf"", ""simultaneous pdf"", {{""physics"", &model}, {""control"", &model_ctl}}, sample);; ; // P e r f o r m a s i m u l t a n e o u s f i t; // ---------------------------------------------------; ; // Perform simultaneous fit of model to data and model_ctl to data_ctl; std::unique_ptr<RooFitResult> fitResult{simPdf.fitTo(combData, PrintLevel(-1), Save(), PrintLevel(-1))};; fitResult->Print();; ; // P l o t m o d e l s l i c e s o n d a t a s l i c e s; // ----------------------------------------------------------------; ; // Make a frame for the physics sample; RooPlot *frame1 = x.frame(Title(""Physics sample""));; ; // Plot all data tagged as physics sample; combData.plotOn(frame1, Cut(""sample==sample::physics""));; ; // Plot ""physics"" slice of simultaneous pdf.; // NBL You _must_ project the sample index category with data using ProjWData; // as a RooSimultaneous makes no prediction on the shape in the index category; // and can thus not be integrated.; // In other words: Since the PDF doesn't know the number of events in the different; // category states, it doesn't know how much of each component it has to project out.; // This information is read from the data.; simPdf.plotOn(frame1, Slice(sample, ""physics""), ProjWData(sample, combData));; simPdf.plotOn(frame1, Slice(sample, ""physics""), Components(""px""), ProjWData(sample, combData), LineStyle(kDashed));; ; // The same plot for the control sample slice. We do this with a different; // approach this time, for illustration purposes. Here, we are slicing the; // dataset and then use the data slice for the projection, because then the; // RooFit::Slice() becomes unnecessary. This approach is more general,; // because you can plot sums of slices by using logical or in the Cut(); // command.; RooPlot *frame2 = x.frame(Bins(30), Title(""Control sample""));; std::unique_ptr<RooAbsData> slicedDat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html:4055,predict,prediction,4055,doc/master/rf501__simultaneouspdf_8C.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8C.html,1,['predict'],['prediction']
Safety,"ng custom variation tags.; 1026 /// \param[in] colNames set of names of the columns for which varied values are provided.; 1027 /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; 1028 /// take any column values as input, similarly to what happens during Filter and Define calls. It must; 1029 /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; 1030 /// \param[in] inputColumns the names of the columns to be passed to the callable.; 1031 /// \param[in] inputColumns the names of the columns to be passed to the callable.; 1032 /// \param[in] nVariations number of variations returned by the expression. The corresponding tags will be `""0""`,; 1033 /// `""1""`, etc. ; 1034 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 1035 /// colName is used if none is provided.; 1036 ///; 1037 /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; 1038 /// is avoided.; 1039 ///; 1040 /// \sa This Vary() overload for more information.; 1041 template <typename F>; 1042 RInterface<Proxied, DS_t>; 1043 Vary(std::initializer_list<std::string> colNames, F &&expression, const ColumnNames_t &inputColumns,; 1044 std::size_t nVariations, std::string_view variationName); 1045 {; 1046 return Vary(std::vector<std::string>(colNames), std::forward<F>(expression), inputColumns, nVariations, variationName);; 1047 }; 1048 ; 1049 /// \brief Register systematic variations for a single existing column using custom variation tags.; 1050 /// \param[in] colName name of the column for which varied values are provided.; 1051 /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; 1052 /// values for the specified column.; 1053 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 1054 /// \param[in] variati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:56789,avoid,avoided,56789,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['avoid'],['avoided']
Safety,"ng element with the same tag will be replaced.; If update is true, existing client of tag will be updated. TEveElement* GetMaster(); Returns the master element - that is:; - master of projectable, if this is a projected;; - master of compound, if fCompound is set;; - master of first compound parent, if kSCBTakeAnyParentAsMaster bit is set;; If non of the above is true, *this* is returned. void AddParent(TEveElement* re); Add re into the list parents.; Adding parent is subordinate to adding an element.; This is an internal function. void RemoveParent(TEveElement* re); Remove re from the list of parents.; Removing parent is subordinate to removing an element.; This is an internal function. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check external references to this and eventually auto-destruct; the render-element. void CollectSceneParents(TEveElement::List_t& scenes); Collect all parents of class TEveScene. This is needed to; automatically detect which scenes need to be updated. Overriden in TEveScene to include itself and return. void CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); Collect scene-parents from all children. This is needed to; automatically detect which scenes need to be updated during/after; a full sub-tree update.; Argument parent specifies parent in traversed hierarchy for which we can; skip the upwards search. void ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); Populates parent with elements.; parent must be an already existing representation of *this*.; Returns number of inserted elements.; If parent already has children, it does nothing. Element can be inserted in a list-tree several times, thus we can not; search through fItems to get parent here.; Anyhow, it is probably known as it must have been selected by the user. void DestroyListSubTree(TGListTree* ltree, TGListTreeItem* parent); Destroy sub-tree under item 'parent' in list-tree 'ltree'. TGListTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveElement.html:17709,detect,detect,17709,root/html528/TEveElement.html,https://root.cern,https://root.cern/root/html528/TEveElement.html,10,['detect'],['detect']
Safety,"ng example the options ""FB"" and ""BB"" suppress the ; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THistPainter.html:69960,avoid,avoid,69960,root/html530/THistPainter.html,https://root.cern,https://root.cern/root/html530/THistPainter.html,1,['avoid'],['avoid']
Safety,"ng exponential function"", x, tau);; ; // Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30);; x.setRange(""left"", 1, 10);; x.setRange(""right"", 20, 30);; ; // Generate toy data, and cut out the blinded region.; std::unique_ptr<RooDataSet> data{expo.generate(x, 1000)};; std::unique_ptr<RooAbsData> blindedData{data->reduce(CutRange(""left,right""))};; ; // Kick tau a bit, and run an unbinned fit where the blinded data are missing.; // ----------------------------------------------------------------------------------------------------------; // The fit should be done only in the unblinded regions, otherwise it would; // try to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.);; expo.fitTo(*blindedData, Range(""left,right""), PrintLevel(-1));; ; // Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would; // be automatically taken as the NormRange() for plotting. We want to avoid; // this, because the point of this tutorial is to show what can go wrong when; // the NormRange() is not specified.; expo.removeStringAttribute(""fitrange"");; ; ; // Here we will plot the results; TCanvas *canvas=new TCanvas(""canvas"",""canvas"",800,600);; canvas->Divide(2,1);; ; ; // Wrong:; // ----------------------------------------------------------------------------------------------------------; // Plotting each slice on its own normalises the PDF over its plotting range. For the full curve, that means; // that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; // comes out too low, and doesn't match up with the slices in the side bands, which are normalised to ""their"" data.; ; std::cout << ""Now plotting with unique normalisation for each slice."" << std::endl;; canvas->cd(1);; RooPlot* plotFrame = x.frame(RooFit::Title(""Wrong: Each slice normalised over its plotting range""));; ; // Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html:2142,avoid,avoid,2142,doc/master/rf212__plottingInRanges__blinding_8C.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html,1,['avoid'],['avoid']
Safety,"ng of the backpropagation algorithm. . static Scalar_t MeanSquaredError (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static void MeanSquaredErrorGradients (Matrix_t &dY, const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static Scalar_t CrossEntropy (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  Sigmoid transformation is implicitly applied, thus output should hold the linear activations of the last layer in the net. ;  ; static void CrossEntropyGradients (Matrix_t &dY, const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; static Scalar_t SoftmaxCrossEntropy (const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  Softmax transformation is implicitly applied, thus output should hold the linear activations of the last layer in the net. ;  ; static void SoftmaxCrossEntropyGradients (Matrix_t &dY, const Matrix_t &Y, const Matrix_t &output, const Matrix_t &weights);  ; Output Functions; Output functions transform the activations output of the output layer in the network to a valid prediction YHat for the desired usage of the network, e.g.; the identity function for regression or the sigmoid transformation for two-class classification. . static void Sigmoid (Matrix_t &YHat, const Matrix_t &);  ; static void Softmax (Matrix_t &YHat, const Matrix_t &);  ; Regularization; For each regularization type two functions are required, one named <Type>Regularization that evaluates the corresponding regularization functional for a given weight matrix and the Add<Type>RegularizationGradients, that adds the regularization component in the gradients to the provided matrix. . static Scalar_t L1Regularization (const Matrix_t &W);  ; static void AddL1RegularizationGradients (Matrix_t &A, const Matrix_t &W, Scalar_t weightDecay);  ; static Scalar_t L2Regularization (const Matrix_t &W);  ; static void AddL2RegularizationGradients (Matrix_t &A, const Matrix_t &W, Scalar_t weightDecay);  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html:9847,predict,prediction,9847,doc/master/classTMVA_1_1DNN_1_1TCpu.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCpu.html,2,['predict'],['prediction']
Safety,"ng of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 924where `slot` will be a number between 0 and `GetNSlots() - 1`.; 925In other words, within a slot, computation runs sequentially and events are processed sequentially.; 926Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 927will never receive the same slot at the same time.; 928This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 929processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 930 ; 931### Parallel execution of multiple RDataFrame event loops; 932A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 933event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 934On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 935ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 936~~~{.cpp}; 937ROOT::EnableImplicitMT();; 938ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 939ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 940auto histo1 = df1.Histo1D(""x"");; 941auto histo2 = df2.Histo1D(""y"");; 942 ; 943// just accessing result pointers, the event loops of sep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:53148,safe,safe,53148,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"ng of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 964where `slot` will be a number between 0 and `GetNSlots() - 1`.; 965In other words, within a slot, computation runs sequentially and events are processed sequentially.; 966Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 967will never receive the same slot at the same time.; 968This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 969processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 970 ; 971### Parallel execution of multiple RDataFrame event loops; 972A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; 973event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; 974On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; 975ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; 976~~~{.cpp}; 977ROOT::EnableImplicitMT();; 978ROOT::RDataFrame df1(""tree1"", ""f1.root"");; 979ROOT::RDataFrame df2(""tree2"", ""f2.root"");; 980auto histo1 = df1.Histo1D(""x"");; 981auto histo2 = df2.Histo1D(""y"");; 982 ; 983// just accessing result pointers, the event loops of sep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:54788,safe,safe,54788,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"ng over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 525 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:21244,safe,safe,21244,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['safe'],['safe']
Safety,"ng over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 526 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:21205,safe,safe,21205,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['safe'],['safe']
Safety,"ng over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 579 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:20515,safe,safe,20515,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['safe'],['safe']
Safety,"ng over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. ; Definition at line 580 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:20607,safe,safe,20607,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['safe'],['safe']
Safety,"ng the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daughters. The full prototype of the method is:; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; In the prototype above, besides the current point and direction that are supposed already initialized, the only input parameter is step. This represents the maximum step allowed by the tracking algorithm or the physical step. The modeller will search for a boundary crossing only up to a distance equal to this value. If a boundary is found, a pointer to the object (node) having it is returned; otherwise the method returns NULL.; The computed value for the computed distance can be subsequently retrieved from the manager class:; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; According the step value, two use cases are possible:. step = TGeoShape::kBig(default behavior; kBig = 1030). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to kBig and a NULL pointer returned. No additional quantity will be computed.; step < kBig. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the safety radius is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provided as input parameter in order to speed-up the search. In addition to the distance computation, the method sets an additional flag telling if the curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:985611,safe,safety,985611,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['safe'],['safety']
Safety,"ng with several lines ; Definition at line 967 of file TApplication.cxx. ◆ GetSignalHandler(). TSignalHandler * TApplication::GetSignalHandler ; (; ); const. inline . Definition at line 107 of file TApplication.h. ◆ GitHub(). void TApplication::GitHub ; (; const char * ; line). protectedvirtual . The function ("".gh <type>"") submits a new issue on GitHub via web browser. ; NoteYou can use ""bug"", ""feature"" or ""improvement"" as <type>. ; Parameters. [in]linecommand from the command line . Definition at line 1186 of file TApplication.cxx. ◆ HandleException(). void TApplication::HandleException ; (; Int_t ; sig). virtual . Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in TSystem. ; Specific TApplication implementations may want something different here. ; Reimplemented in TRint, and TProofServ.; Definition at line 590 of file TApplication.cxx. ◆ HandleIdleTimer(). void TApplication::HandleIdleTimer ; (; ). virtual . Handle idle timeout. ; When this timer expires the registered idle command will be executed by this routine and a signal will be emitted. ; Definition at line 577 of file TApplication.cxx. ◆ HandleTermInput(). virtual Bool_t TApplication::HandleTermInput ; (; ). inlinevirtual . Reimplemented in TRint.; Definition at line 116 of file TApplication.h. ◆ Help(). void TApplication::Help ; (; const char * ; line). protectedvirtual . The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ; NoteYou can use "".?"" as the short version of "".help"" ; Parameters. [in]linecommand from the command line . Definition at line 1208 of file TApplication.cxx. ◆ Hide(). virtual void TApplication::Hide ; (; ). inlinevirtual . Definition at line 130 of file TApplication.h. ◆ Iconify(). virtual void TApplication::Iconify ; (; ). inlinevirtual . Definition at line 131 of file TApplication.h. ◆ Init(). virtual void TApplication::Init",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:28540,timeout,timeout,28540,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['timeout'],['timeout']
Safety,"ng& e); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific grou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:28705,abort,abort,28705,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,4,['abort'],"['abort', 'aborts']"
Safety,"ng. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixTBase_double_.html:1682,AVOID,AVOID,1682,root/html532/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html,8,['AVOID'],['AVOID']
Safety,"ng::LoadText(const char* text) const; 7516{; 7517 return (fInterpreter->declare(text) == cling::Interpreter::kSuccess);; 7518}; 7519 ; 7520////////////////////////////////////////////////////////////////////////////////; 7521/// Interface to cling function; 7522 ; 7523const char* TCling::MapCppName(const char* name) const; 7524{; 7525 TTHREAD_TLS_DECL(std::string,buffer);; 7526 ROOT::TMetaUtils::GetCppName(buffer,name);; 7527 return buffer.c_str(); // NOLINT; 7528}; 7529 ; 7530////////////////////////////////////////////////////////////////////////////////; 7531/// [Place holder for Mutex Lock]; 7532/// Provide the interpreter with a way to; 7533/// acquire a lock used to protect critical section; 7534/// of its code (non-thread safe parts).; 7535 ; 7536void TCling::SetAlloclockfunc(void (* /* p */ )()) const; 7537{; 7538 // nothing to do for now.; 7539}; 7540 ; 7541////////////////////////////////////////////////////////////////////////////////; 7542/// [Place holder for Mutex Unlock] Provide the interpreter with a way to; 7543/// release a lock used to protect critical section; 7544/// of its code (non-thread safe parts).; 7545 ; 7546void TCling::SetAllocunlockfunc(void (* /* p */ )()) const; 7547{; 7548 // nothing to do for now.; 7549}; 7550 ; 7551////////////////////////////////////////////////////////////////////////////////; 7552/// Returns if class AutoLoading is currently enabled.; 7553 ; 7554bool TCling::IsClassAutoLoadingEnabled() const; 7555{; 7556 if (IsFromRootCling()); 7557 return false;; 7558 if (!fClingCallbacks); 7559 return false;; 7560 return fClingCallbacks->IsAutoLoadingEnabled();; 7561}; 7562 ; 7563////////////////////////////////////////////////////////////////////////////////; 7564/// Enable/Disable the AutoLoading of libraries.; 7565/// Returns the old value, i.e whether it was enabled or not.; 7566 ; 7567int TCling::SetClassAutoLoading(int autoload) const; 7568{; 7569 // If no state change is required, exit early.; 7570 // FIXME: In future ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:294442,safe,safe,294442,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['safe'],['safe']
Safety,"ng; 3750/// box will be sampled.; 3751 ; 3752void TGeoManager::CheckBoundaryErrors(Int_t ntracks, Double_t radius); 3753{; 3754 GetGeomPainter()->CheckBoundaryErrors(ntracks, radius);; 3755}; 3756 ; 3757////////////////////////////////////////////////////////////////////////////////; 3758/// Check the boundary errors reference file created by CheckBoundaryErrors method.; 3759/// The shape for which the crossing failed is drawn with the starting point in red; 3760/// and the extrapolated point to boundary (+/- failing push/pull) in yellow.; 3761 ; 3762void TGeoManager::CheckBoundaryReference(Int_t icheck); 3763{; 3764 GetGeomPainter()->CheckBoundaryReference(icheck);; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Classify a given point. See TGeoChecker::CheckPoint().; 3769 ; 3770void TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 3771{; 3772 GetGeomPainter()->CheckPoint(x, y, z, option, safety);; 3773}; 3774 ; 3775////////////////////////////////////////////////////////////////////////////////; 3776/// Test for shape navigation methods. Summary for test numbers:; 3777/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 3778/// directions randomly in cos(theta). Compute DistFromInside and move the; 3779/// point with bigger distance. Compute DistFromOutside back from new point.; 3780/// Plot d-(d1+d2); 3781///; 3782 ; 3783void TGeoManager::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 3784{; 3785 GetGeomPainter()->CheckShape(shape, testNo, nsamples, option);; 3786}; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Geometry checking.; 3790/// - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; 3791/// - if option contains 'b': Optional boundary crossing check + timing per volume.; 3792///; 3793/// STAGE 1: extensive overlap che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:137592,safe,safety,137592,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,['safe'],['safety']
Safety,"ngFiles=0);  Resolve the end-point URL for the current elements of this data set If the removeMissing option is set to kTRUE, remove the TDSetElements that can not be located. ;  ; void Print (Option_t *option="""") const override;  Print TDSet basic or full data. When option=""a"" print full data. ;  ; virtual Long64_t Process (const char *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Process TDSet on currently active PROOF session. ;  ; virtual Long64_t Process (TSelector *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Process TDSet on currently active PROOF session. ;  ; Int_t Remove (TDSetElement *elem, Bool_t deleteElem=kTRUE);  Remove TDSetElement 'elem' from the list. ;  ; void SetDirectory (const char *dir);  Set/change directory. ;  ; virtual void SetEntryList (TObject *aList);  Set entry (or event) list for this data set. ;  ; void SetLookedUp ();  Flag all the elements as looked-up, so to avoid opening the files if the functionality is not supported. ;  ; void SetObjName (const char *objname);  Set/change object name. ;  ; void SetSrvMaps (TList *srvmaps=0);  Set (or unset) the list for mapping servers coordinate for files. ;  ; void SetWriteV3 (Bool_t on=kTRUE);  Set/Reset the 'OldStreamer' bit in this instance and its elements. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this TTree. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Validate ();  Validate the TDSet by opening files. ;  ; void Validate (TDSet *dset);  Validate the TDSet against another TDSet. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDSetProxy.html:4512,avoid,avoid,4512,doc/master/classTDSetProxy.html,https://root.cern,https://root.cern/doc/master/classTDSetProxy.html,1,['avoid'],['avoid']
Safety,"nge the current resolution model to newModel. ;  ; virtual double coefAnalyticalIntegral (Int_t coef, Int_t code, const char *rangeName=nullptr) const;  Default implementation of function implementing advertised integrals. ;  ; virtual double coefficient (Int_t basisIndex) const =0;  ; virtual RooFit::OwningPtr< RooArgSet > coefVars (Int_t coefIdx) const;  Return set of parameters with are used exclusively by the coefficient functions. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; virtual Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Default implementation of function advertising integration capabilities. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; TClass * IsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsAnaConvPdf.html:4700,unsafe,unsafe,4700,doc/master/classRooAbsAnaConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsAnaConvPdf.html,1,['unsafe'],['unsafe']
Safety,"nge(thisRangeName)) {; 2088 coutE(Plotting) << ""Range '"" << rangeNameToken << ""' not defined for variable '""; 2089 << frame->getPlotVar()->GetName() << ""'. Ignoring ..."" << std::endl;; 2090 continue;; 2091 }; 2092 rangeLim.push_back(frame->getPlotVar()->getRange(thisRangeName));; 2093 }; 2094 adjustNorm = true ;; 2095 hasCustomRange = true ;; 2096 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") p.d.f. curve is normalized using explicit choice of ranges '"" << pc.getString(""normRangeName"", """", false) << ""'"" << endl ;; 2097 ; 2098 nameSuffix.append(""_NormRange["" + std::string(pc.getString(""rangeName"")) + ""]"");; 2099 ; 2100 }; 2101 ; 2102 if (hasCustomRange && adjustNorm) {; 2103 // If overlapping ranges were given, remove them now; 2104 const std::size_t oldSize = rangeLim.size();; 2105 removeRangeOverlap(rangeLim);; 2106 ; 2107 if (oldSize != rangeLim.size() && !pc.hasProcessed(""NormRange"")) {; 2108 // User gave overlapping ranges. This leads to double-counting events and integrals, and must; 2109 // therefore be avoided. If a NormRange has been given, the overlap is already gone.; 2110 // It's safe to plot even with overlap now.; 2111 coutE(Plotting) << ""Requested plot/integration ranges overlap. For correct plotting, new ranges ""; 2112 ""will be defined."" << std::endl;; 2113 auto plotVar = dynamic_cast<RooRealVar*>(frame->getPlotVar());; 2114 assert(plotVar);; 2115 std::string rangesNoOverlap;; 2116 for (auto it = rangeLim.begin(); it != rangeLim.end(); ++it) {; 2117 std::stringstream rangeName;; 2118 rangeName << ""Remove_overlap_range_"" << it - rangeLim.begin();; 2119 plotVar->setRange(rangeName.str().c_str(), it->first, it->second);; 2120 if (!rangesNoOverlap.empty()); 2121 rangesNoOverlap += "","";; 2122 rangesNoOverlap += rangeName.str();; 2123 }; 2124 ; 2125 auto rangeArg = static_cast<RooCmdArg*>(cmdList.FindObject(""RangeWithName""));; 2126 if (rangeArg) {; 2127 rangeArg->setString(0, rangesNoOverlap.c_str());; 2128 } else {; 2129 plotRange = std::make_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:103796,avoid,avoided,103796,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['avoid'],['avoided']
Safety,"nges to a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  ROOT::Experimental::Detail::RNTuplePerfCounter;  A performance counter with a name and a unit, which can be activated on demand. More...;  ; class  ROOT::Experimental::Detail::RNTuplePlainCounter;  A non thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experimental::RNTupleViewBase< T >;  An RNTupleView provides read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:10365,safe,safe,10365,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,2,['safe'],['safe']
Safety,"ngs (RCompressionSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel) R__DEPRECATED(6;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:13920,safe,safe,13920,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['safe'],['safe']
Safety,"ngth); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:11166,timeout,timeout,11166,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,6,['timeout'],['timeout']
Safety,"ngth. TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoParaboloid.html:13208,safe,safe,13208,root/html530/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html530/TGeoParaboloid.html,3,['safe'],['safe']
Safety,"nheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXProofServ.h 29233 2009-06-26 08:07:47Z brun $ » Last generated: 2010-11-11 15:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXProofServ.html:17909,timeout,timeout,17909,root/html528/TXProofServ.html,https://root.cern,https://root.cern/root/html528/TXProofServ.html,2,['timeout'],['timeout']
Safety,"nheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXProofServ.h 29233 2009-06-26 08:07:47Z brun $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXProofServ.html:18096,timeout,timeout,18096,root/html530/TXProofServ.html,https://root.cern,https://root.cern/root/html530/TXProofServ.html,2,['timeout'],['timeout']
Safety,"nheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXProofServ.h 29233 2009-06-26 08:07:47Z brun $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXProofServ.html:18096,timeout,timeout,18096,root/html532/TXProofServ.html,https://root.cern,https://root.cern/root/html532/TXProofServ.html,4,['timeout'],['timeout']
Safety,"nimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3073,recover,recovery,3073,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"nimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeShape(TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPara.html:13061,safe,safe,13061,root/html528/TGeoPara.html,https://root.cern,https://root.cern/root/html528/TGeoPara.html,4,['safe'],['safe']
Safety,nit vector to current checked shape; TGeoHMatrix*fCurrentMatrix! current stored global matrix; TGeoNode*fCurrentNode! current node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:10930,safe,safety,10930,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,8,['safe'],"['safe', 'safety']"
Safety,"nitTime ; (; ). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 213 of file TProofPlayer.h. ◆ SetMaxDrawQueries(). void TProofPlayer::SetMaxDrawQueries ; (; Int_t ; max). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 168 of file TProofPlayer.h. ◆ SetMerging(). void TProofPlayer::SetMerging ; (; Bool_t ; = kTRUE). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 215 of file TProofPlayer.h. ◆ SetOutputFilePath(). void TProofPlayer::SetOutputFilePath ; (; const char * ; fp). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 220 of file TProofPlayer.h. ◆ SetProcessing(). void TProofPlayer::SetProcessing ; (; Bool_t ; on = kTRUE). Set processing bit according to 'on'. ; Definition at line 274 of file TProofPlayer.cxx. ◆ SetStopTimer(). void TProofPlayer::SetStopTimer ; (; Bool_t ; on = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:41700,abort,abort,41700,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['abort'],['abort']
Safety,"nition RResultPtr.hxx:228; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; See the Book() method for more information and this tutorial for a more complete example.; Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and executes the callable on the values of those columns for each event that passes all upstream selections. It can be used to perform actions that are not already available in the interface. For example, the following snippet evaluates the root mean square of column ""x"": // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; nconst Int_t nDefinition legend1.C:16; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach(): thread will execute the expression concurrently. The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of rms; but this is probably too much head-scratch for such a simple operation.; ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame guarantees that ForeachSlot() will invoke the user expression with different slot parameters for different concurrent executions (see Special helper columns: rdfentry_ and rdfslot_ for more information on the slot parameter). We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"": // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:68235,safe,safety,68235,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safety']
Safety,"nition TGeoNavigator.cxx:523; TGeoNavigator::fLastPWSafetyDouble_t fLastPWSafetylast point for which parallel world safety was ""evaluated""Definition TGeoNavigator.h:53; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigator::fStartSafeBool_t fStartSafeflags the type of the current nodeDefinition TGeoNavigator.h:63; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoNavigator.h:154; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GetCldirCheckedconst Double_t * GetCldirChecked() constDefinition TGeoNavigator.h:164; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigator.cxx:2357; TGeoNavigator::fNormalDouble_t fNormal[3]last computed safety radiusDefinition TGeoNavigator.h:46; TGeoNavigator::GetLastSafetyDouble_t GetLastSafety() constDefinition TGeoNavigator.h:127; TGeoNavigator::PopPointBool_t PopPoint(Int_t index)Definition TGeoNavigator.h:272; TGeoNavigator::cdBool_t cd(const char *path="""")Browse the tree of nodes starting from top node according to pathname.Definition TGeoNavigator.cxx:210; TGeoNavigator::fLastPointDouble_t fLastPoint[3]current directionDefinition TGeoNavigator.h:51; TGeoNavigator::GetStepDouble_t GetStep() constDefinition TGeoNavigator.h:128; TGeoNavigator::IsSameLocationBool_t IsSameLocation() constDefinition TGeoNavig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:20638,safe,safe,20638,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safe']
Safety,"nition TGeoPolygon.h:52; TGeoPolygon::GetConvexVerticesvoid GetConvexVertices(Double_t *x, Double_t *y) constFill list of vertices of the convex outscribed polygon into provided arrays.Definition TGeoPolygon.cxx:252; TGeoShapeAssembly::Classstatic TClass * Class(); TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) override=0Computes distance from point (px,py) to the object.; TGeoShape::ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::GetTransformstatic TGeoMatrix * GetTransform()Returns current transformation matrix that applies to shape.Definition TGeoShape.cxx:574; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; TGeoShape::SetPointsvirtual void SetPoints(Double_t *points) const =0; TGeoShape::IsATClass * IsA() const overrideDefinition TGeoShape.h:171; TGeoTrackDefinition TGeoTrack.h:26; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::IsVisContainersBool_t IsVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:110046,safe,safe,110046,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['safe'],['safe']
Safety,"nition at line 227 of file TDCacheFile.cxx. ◆ ReadBuffers(). Bool_t TDCacheFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). overridevirtual . Read the nbuf blocks described in arrays pos and len, where pos[i] is the seek position of block i of length len[i]. ; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 247 of file TDCacheFile.cxx. ◆ ResetErrno(). void TDCacheFile::ResetErrno ; (; ); const. overridevirtual . Method resetting the dc_errno and errno. ; Reimplemented from TFile.; Definition at line 577 of file TDCacheFile.cxx. ◆ SetOnError(). void TDCacheFile::SetOnError ; (; EOnErrorAction ; a = kOnErrorDefault). static . Set on error handler. ; Definition at line 388 of file TDCacheFile.cxx. ◆ SetOpenTimeout(). void TDCacheFile::SetOpenTimeout ; (; UInt_t ; secs). static . Set file open timeout. ; Definition at line 380 of file TDCacheFile.cxx. ◆ SetReplyHostName(). void TDCacheFile::SetReplyHostName ; (; const char * ; host_name). static . Set reply host name. ; Definition at line 396 of file TDCacheFile.cxx. ◆ Stage(). Bool_t TDCacheFile::Stage ; (; const char * ; path, . UInt_t ; secs, . const char * ; location = 0 . ). static . Stage() returns kTRUE on success and kFALSE on failure. ; Definition at line 340 of file TDCacheFile.cxx. ◆ Streamer(). void TDCacheFile::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TDCacheFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 75 of file TDCacheFile.h. ◆ SysClose(). Int_t TDCacheFile::SysClose ; (; Int_t ; fd). overrideprivatevirtual . Interface to system close. All arguments like in POSIX close. ; Reimplemented from TFile.; Definition at line 436 of file TDCacheFile.cxx. ◆ SysOpen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:47014,timeout,timeout,47014,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['timeout'],['timeout']
Safety,"nlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:5030,abort,abort,5030,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,1,['abort'],['abort']
Safety,"nly 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440947,recover,recovery,440947,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['recover'],['recovery']
Safety,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_options->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:464274,timeout,timeout,464274,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_options->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:464307,timeout,timeout,464307,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"nnect its Timeout() signal to the appropriate methods. Then when the time is up it will emit a Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as kItimerResolution (currently 10 ms).; Signal/slots example: TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Startvirtual void Start(Long_t milliSec=-1, Bool_t singleShot=kFALSE)Starts the timer with a milliSec timeout.Definition TTimer.cxx:213; To emit the Timeout signal repeatedly with minimum timeout: timer->Start(0, kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94. Definition at line 51 of file TTimer.h. Public Member Functions;  TTimer (const char *command, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (Long_t milliSec=0, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ;  TTimer (TObject *obj, Long_t milliSec, Bool_t mode=kTRUE);  Create timer that times out in ms milliseconds. ;  ; virtual ~TTimer ();  ; void Add () override;  ; Bool_t CheckTimer (const TTime &now);  Check if timer timed out. ;  ; TTime GetAbsTime () const;  ; const char * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:1926,timeout,timeout,1926,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['timeout'],['timeout']
Safety,"nnection ; (; struct mg_connection * ; conn). static . Definition at line 18516 of file civetweb.c. ◆ produce_socket(). static void produce_socket ; (; struct mg_context * ; ctx, . const struct socket * ; sp . ). static . Definition at line 18809 of file civetweb.c. ◆ pull_all(). static int pull_all ; (; FILE * ; fp, . struct mg_connection * ; conn, . char * ; buf, . int ; len . ). static . Definition at line 6413 of file civetweb.c. ◆ pull_inner(). static int pull_inner ; (; FILE * ; fp, . struct mg_connection * ; conn, . char * ; buf, . int ; len, . double ; timeout . ). static . Definition at line 6184 of file civetweb.c. ◆ push_all(). static int push_all ; (; struct mg_context * ; ctx, . FILE * ; fp, . SOCKET ; sock, . SSL * ; ssl, . const char * ; buf, . int ; len . ). static . Definition at line 6136 of file civetweb.c. ◆ push_inner(). static int push_inner ; (; struct mg_context * ; ctx, . FILE * ; fp, . SOCKET ; sock, . SSL * ; ssl, . const char * ; buf, . int ; len, . double ; timeout . ). static . Definition at line 5970 of file civetweb.c. ◆ put_dir(). static int put_dir ; (; struct mg_connection * ; conn, . const char * ; path . ). static . Definition at line 10267 of file civetweb.c. ◆ put_file(). static void put_file ; (; struct mg_connection * ; conn, . const char * ; path . ). static . Definition at line 11670 of file civetweb.c. ◆ read_auth_file(). static int read_auth_file ; (; struct mg_file * ; filep, . struct read_auth_file_struct * ; workdata, . int ; depth . ). static . Definition at line 8505 of file civetweb.c. ◆ read_message(). static int read_message ; (; FILE * ; fp, . struct mg_connection * ; conn, . char * ; buf, . int ; bufsiz, . int * ; nread . ). static . Definition at line 10798 of file civetweb.c. ◆ redirect_to_https_port(). static void redirect_to_https_port ; (; struct mg_connection * ; conn, . int ; port . ). static . Definition at line 13543 of file civetweb.c. ◆ refresh_trust(). static int refresh_trust ; (; struct mg_connectio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:81732,timeout,timeout,81732,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['timeout'],['timeout']
Safety,"noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3611,recover,recovery,3611,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"normal directions. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside the assembly. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  compute closest distance from point px,py to each vertex. Should not be called. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to surface of the hyperboloid. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  compute distance from outside point to surface of the hyperboloid. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Cannot divide assemblies. ;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  in case shape has some negative parameters, these has to be computed in order to fit the mother ;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the shape mesh. ;  ; Int_t GetNmeshVertices () const override;  ; void InspectShape () const override;  print shape parameters ;  ; TClass * IsA () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShapeAssembly.html:2227,safe,safe,2227,doc/master/classTGeoShapeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoShapeAssembly.html,1,['safe'],['safe']
Safety,"not declarations, like ""Int_t x;"").; 3584 ; 3585Longptr_t TCling::Calc(const char* line, EErrorCode* error); 3586{; 3587#ifdef R__WIN32; 3588 // Test on ApplicationImp not being 0 is needed because only at end of; 3589 // TApplication ctor the IsLineProcessing flag is set to 0, so before; 3590 // we can not use it.; 3591 if (gApplication && gApplication->GetApplicationImp()) {; 3592 while (gROOT->IsLineProcessing() && !gApplication) {; 3593 Warning(""Calc"", ""waiting for cling thread to free"");; 3594 gSystem->Sleep(500);; 3595 }; 3596 gROOT->SetLineIsProcessing();; 3597 }; 3598#endif // R__WIN32; 3599 R__LOCKGUARD_CLING(gInterpreterMutex);; 3600 if (error) {; 3601 *error = TInterpreter::kNoError;; 3602 }; 3603 cling::Value valRef;; 3604 cling::Interpreter::CompilationResult cr = cling::Interpreter::kFailure;; 3605 try {; 3606 cr = fInterpreter->evaluate(line, valRef);; 3607 }; 3608 catch (cling::InterpreterException& ex); 3609 {; 3610 Error(""Calc"", ""%s.\n%s"", ex.what(), ""Evaluation of your expression was aborted."");; 3611 ex.diagnose();; 3612 cr = cling::Interpreter::kFailure;; 3613 }; 3614 ; 3615 if (cr != cling::Interpreter::kSuccess) {; 3616 // Failure in compilation.; 3617 if (error) {; 3618 // Note: Yes these codes are weird.; 3619 *error = TInterpreter::kRecoverable;; 3620 }; 3621 return 0L;; 3622 }; 3623 if (!valRef.isValid()) {; 3624 // Failure at runtime.; 3625 if (error) {; 3626 // Note: Yes these codes are weird.; 3627 *error = TInterpreter::kDangerous;; 3628 }; 3629 return 0L;; 3630 }; 3631 ; 3632 if (valRef.isVoid()) {; 3633 return 0;; 3634 }; 3635 ; 3636 RegisterTemporary(valRef);; 3637#ifdef R__WIN32; 3638 if (gApplication && gApplication->GetApplicationImp()) {; 3639 gROOT->SetLineHasBeenProcessed();; 3640 }; 3641#endif // R__WIN32; 3642 return valRef.castAs<Longptr_t>();; 3643}; 3644 ; 3645////////////////////////////////////////////////////////////////////////////////; 3646/// Set a getline function to call when input is needed.; 3647 ; 3648void TClin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:140348,abort,aborted,140348,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['abort'],['aborted']
Safety,"nputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←. RooProofDriverSelector. TProofDraw; ←. TProofDrawEntryList. TProofDrawEventList. TProofDrawGraph. TProofDrawHist. TProofDrawListOfGraphs. TProofDrawListOfPolyMarkers3D. TProofDrawPolyMarker3D. TProofDrawProfile.  [more...]. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (eithe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelector.html:10158,Abort,Abort,10158,root/html602/TSelector.html,https://root.cern,https://root.cern/root/html602/TSelector.html,2,['Abort'],['Abort']
Safety,"nr is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:37340,timeout,timeout,37340,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,4,['timeout'],['timeout']
Safety,"ns to stream out (read); void*TGenCollectionProxy::fResizeContainer accessors: resize container; intTGenCollectionProxy::fSTL_typeSTL container type; TGenCollectionProxy::MethodTGenCollectionProxy::fSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >TGenCollectionProxy::fStagedOptimization: Keep staged array once they were created; type_info&TGenCollectionProxy::fTypeinfoType information; TGenCollectionProxy::Value*TGenCollectionProxy::fValDescriptor of the Value_type; intTGenCollectionProxy::fValDiffOffset between two consecutive value_types (memory layout).; intTGenCollectionProxy::fValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*TGenCollectionProxy::fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*TGenCollectionProxy::fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenCollectionProxy* InitializeEx(Bool_t silent); Some hack to avoid const-ness. void ReadItems(int nElements, TBuffer& b); Object input streamer. void WriteItems(int nElements, TBuffer& b); Object output streamer. void Shrink(UInt_t nCurr, UInt_t left, Bool_t force); Shrink the container. void Expand(UInt_t nCurr, UInt_t left); Expand the container. TEmulatedCollectionProxy & operator=(const TEmulatedCollectionProxy& ). TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); Copy constructor. TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); Initializing constructor. virtual ~TEmulatedCollectionProxy(); Standard destructor. void* New() const; Virtual constructor. { return new Cont_t; }. void* New(void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t; }. void* NewArray(Int_t nElements) const; Virtual array constructor. { return new Cont_t[nElements]; }. void* NewArray(Int_t nElements, void* memory) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:7400,avoid,avoid,7400,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,2,['avoid'],['avoid']
Safety,"ns to stream out (read); void*TGenCollectionProxy::fResizeContainer accessors: resize container; intTGenCollectionProxy::fSTL_typeSTL container type; TGenCollectionProxy::MethodTGenCollectionProxy::fSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >TGenCollectionProxy::fStagedOptimization: Keep staged array once they were created; type_info&TGenCollectionProxy::fTypeinfoType information; TGenCollectionProxy::Value*TGenCollectionProxy::fValDescriptor of the Value_type; intTGenCollectionProxy::fValDiffOffset between two consecutive value_types (memory layout).; intTGenCollectionProxy::fValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*TGenCollectionProxy::fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*TGenCollectionProxy::fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenCollectionProxy* InitializeEx(Bool_t silent); Some hack to avoid const-ness. void ReadItems(int nElements, TBuffer& b); Object input streamer. void WriteItems(int nElements, TBuffer& b); Object output streamer. void Shrink(UInt_t nCurr, UInt_t left, Bool_t force); Shrink the container. void Expand(UInt_t nCurr, UInt_t left); Expand the container. TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); Copy constructor. TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); Initializing constructor. virtual ~TEmulatedCollectionProxy(); Standard destructor. void* New() const; Virtual constructor. { return new Cont_t; }. void* New(void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t; }. void* NewArray(Int_t nElements) const; Virtual array constructor. { return new Cont_t[nElements]; }. void* NewArray(Int_t nElements, void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t[nElements",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedCollectionProxy.html:7146,avoid,avoid,7146,root/html532/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedCollectionProxy.html,2,['avoid'],['avoid']
Safety,"ns, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an array of expected signal, expected background, and relative; background uncertainty (eg. 0.1 for 10% uncertainty), and the number of channels. void AddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); Arguements are an array of expected signal, expected background, and relative; ratio of background expected in the sideband to that expected in signal region, and the number of channels. RooRealVar* SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value); need to be careful here that the range of observable in the dataset is consistent with the one in the workspace; don't rescale unless necessary. If it is necessary, then rescale by x10 or a defined maximum. RooRealVar* SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value, Double_t maximum); need to be careful here that the range of observable in the dataset is consistent with the one in the workspace; don't rescale unless necessary. If it is necessary, then rescale by x10 or a defined maximum. void AddData(Double_t* mainMeas, Double_t* bkgMeas, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); Arguments are an array of results from a main measurement, a measured background,; and relative background uncertainty (eg. 0.1 for 10% uncertainty), and the number of channels. void AddDataWithSideband(Double_t* mainMeas, Double_t* sideband, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an array of expected signal, expected background, and relative; background uncertainty (eg. 0.1 for 10% uncertainty), and the number of channels. NumberCountingPdfFactory(); need one for expected and one for observed. » Author: Kyle Cranmer 28/07/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__NumberCountingPdfFactory.html:4246,Safe,SafeObservableCreation,4246,root/html532/RooStats__NumberCountingPdfFactory.html,https://root.cern,https://root.cern/root/html532/RooStats__NumberCountingPdfFactory.html,4,['Safe'],['SafeObservableCreation']
Safety,"ns. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); Paint the list of histograms.; By default, histograms are shown stacked.; - the first histogram is paint; - then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. If the option nostackb is specified histograms are all paint in the same pad; next to each other as bar plots. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoid this behaviour. This is useful; when drawing a THStack on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void RecursiveRemove(TObject* obj); Recursively remove object from the list of histograms. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetMaximum(Double_t maximum = -1111); Set maximum. void SetMinimum(Double_t minimum = -1111); Set minimum. THStack& operator=(const THStack& ). TList * GetHists() const; { return fHists; }. void SetHistogram(TH1* h); {fHistogram = h;}. » Author: Rene Brun 10/12/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:09; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THStack.html:15429,avoid,avoid,15429,root/html604/THStack.html,https://root.cern,https://root.cern/root/html604/THStack.html,2,['avoid'],['avoid']
Safety,"nserted object to back to drawing stack if requested; 2846 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 2847 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 2848 }; 2849 ; 2850 ; 2851 return frame ;; 2852}; 2853 ; 2854 ; 2855 ; 2856 ; 2857////////////////////////////////////////////////////////////////////////////////; 2858/// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations; 2859 ; 2860bool RooAbsReal::plotSanityChecks(RooPlot* frame) const; 2861{; 2862 // check that we are passed a valid plot frame to use; 2863 if(nullptr == frame) {; 2864 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: frame is null"" << std::endl;; 2865 return true;; 2866 }; 2867 ; 2868 // check that this frame knows what variable to plot; 2869 RooAbsReal* var = frame->getPlotVar() ;; 2870 if(!var) {; 2871 coutE(Plotting) << ClassName() << ""::"" << GetName(); 2872 << "":plotOn: frame does not specify a plot variable"" << std::endl;; 2873 return true;; 2874 }; 2875 ; 2876 // check that the plot variable is not derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:124702,sanity check,sanity check,124702,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"nside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. TH2Poly(); TH2Poly(const TH2Poly&); TH2Poly(const char* name, const char* title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup); TH2Poly(const char* name, const char* title, Int_t nX, Double_t xl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2Poly.html:4490,avoid,avoid,4490,root/html528/TH2Poly.html,https://root.cern,https://root.cern/root/html528/TH2Poly.html,6,['avoid'],['avoid']
Safety,"nside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. virtual~TH2Poly(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2Poly.html:4439,avoid,avoid,4439,root/html602/TH2Poly.html,https://root.cern,https://root.cern/root/html602/TH2Poly.html,4,['avoid'],['avoid']
Safety,"nside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. virtual~TH2PolyBin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2PolyBin.html:4452,avoid,avoid,4452,root/html602/TH2PolyBin.html,https://root.cern,https://root.cern/root/html602/TH2PolyBin.html,4,['avoid'],['avoid']
Safety,"nspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ IsA(). TClass * TGeoCone::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg.; Definition at line 96 of file TGeoCone.h. ◆ IsCylType(). Bool_t TGeoCone::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 82 of file TGeoCone.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoCone::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ operator=(). TGeoCone & TGeoCone::operator= ; (; const TGeoCone & ; ). protecteddelete . ◆ Safety(). Double_t TGeoCone::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ Safety_v(). void TGeoCone::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SafetyS(). static Double_t TGeoCone::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoCone::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SetConeDimensions(). void TGeoCone::SetConeDimensions ; (; Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2 . ). ◆ SetDimensions(). void TGeoCone::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ SetPoints() [1/2]. void TGeoCone::SetPoints ; (; Double_t * ; points); const. overridevirtual .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:31677,safe,safe,31677,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['safe'],['safe']
Safety,"nspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ IsA(). TClass * TGeoTube::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg.; Definition at line 91 of file TGeoTube.h. ◆ IsCylType(). Bool_t TGeoTube::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 77 of file TGeoTube.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoTube::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ operator=(). TGeoTube & TGeoTube::operator= ; (; const TGeoTube & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTube::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ Safety_v(). void TGeoTube::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SafetyS(). static Double_t TGeoTube::SafetyS ; (; const Double_t * ; point, . Bool_t ; in, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Int_t ; skipz = 0 . ). static . ◆ SavePrimitive(). void TGeoTube::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetDimensions(). void TGeoTube::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetPoints() [1/2]. void TGeoTube::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ SetPoints() [2/2]. void TGeoTube::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:30749,safe,safe,30749,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['safe'],['safe']
Safety,"nst Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetDx1 () const;  ; Double_t GetDx2 () const;  ; Double_t GetDy () const;  ; Double_t GetDz () const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetOppositeCorner (const Double_t *point, Int_t inorm, Double_t *vertex, Double_t *normals) const;  ; void GetVisibleCorner (const Double_t *point, Double_t *vertex, Double_t *normals) const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"".",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:2729,safe,safe,2729,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['safe'],['safe']
Safety,"nst Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetSphDimensions(Double_t rmin, Double_t rmax, Double_t theta1, Double_t theta2, Double_t phi1, Double_t phi2); Set spherical segment dimensions. void SetDimensions(Double_t* param, Int_t nparam); Set dimensions of the spherical segment starting from a list of parameters. void SetDimensions(Double_t* param); Set dimensions of the spherical segment starting from a list of parameters.; Only takes rmin and rmax. void SetNumberOfDivisions(Int_t p); Set the number of divisions of mesh circles keeping aspect ratio. void SetPoints(Double_t* points) const; create sphere mesh points. void SetPoints(Float_t* points) const; create sphere mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:16480,Safe,Safety,16480,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,3,['Safe'],['Safety']
Safety,"nst argv. ; Definition at line 1089 of file OptionParser.h. ◆ Parser() [4/5]. ROOT::option::Parser::Parser ; (; const Descriptor ; usage[], . int ; argc, . const char ** ; argv, . Option ; options[], . Option ; buffer[], . int ; min_abbr_len = 0, . bool ; single_minus_longopt = false, . int ; bufmax = -1 . ). inline . POSIX Parser(...) (gnu==false). ; Definition at line 1097 of file OptionParser.h. ◆ Parser() [5/5]. ROOT::option::Parser::Parser ; (; const Descriptor ; usage[], . int ; argc, . char ** ; argv, . Option ; options[], . Option ; buffer[], . int ; min_abbr_len = 0, . bool ; single_minus_longopt = false, . int ; bufmax = -1 . ). inline . POSIX Parser(...) (gnu==false) with non-const argv. ; Definition at line 1105 of file OptionParser.h. Member Function Documentation. ◆ error(). bool ROOT::option::Parser::error ; (; ). inline . Returns true if an unrecoverable error occurred while parsing options. ; An illegal argument to an option (i.e. CheckArg returns ARG_ILLEGAL) is an unrecoverable error that aborts the parse. Unknown options are only an error if their CheckArg function returns ARG_ILLEGAL. Otherwise they are collected. In that case if you want to exit the program if either an illegal argument or an unknown option has been passed, use code like this; if (parser.error() || options[UNKNOWN]); exit(1);. Definition at line 1264 of file OptionParser.h. ◆ instr(). static bool ROOT::option::Parser::instr ; (; char ; ch, . const char * ; st . ). inlinestaticprivate . Definition at line 1346 of file OptionParser.h. ◆ nonOption(). const char * ROOT::option::Parser::nonOption ; (; int ; i). inline . Returns nonOptions()[i] (without checking if i is in range!). ; Definition at line 1244 of file OptionParser.h. ◆ nonOptions(). const char ** ROOT::option::Parser::nonOptions ; (; ). inline . Returns a pointer to an array of non-option arguments (only valid if nonOptionsCount() >0 ). ; Note; parse() does not copy arguments, so this pointer points into the actual argum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1option_1_1Parser.html:10077,abort,aborts,10077,doc/v632/classROOT_1_1option_1_1Parser.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1option_1_1Parser.html,2,['abort'],['aborts']
Safety,"nst char *bname, T *add, TBranch **ptr=nullptr)Definition TTree.h:637; TTree::SetTargetMemoryRatiovoid SetTargetMemoryRatio(Float_t ratio)Definition TTree.h:692; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::DebugInt_t Debug() constDefinition TTree.h:429; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::GetClusterPrefetchvirtual bool GetClusterPrefetch() constDefinition TTree.h:457; TTree::BranchTBranch * Branch(const char *name, const char *classname, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:400; TTree::fMaxEntryLoopLong64_t fMaxEntryLoopMaximum number of entries to process.Definition TTree.h:98; TTree::TTreeBranchImpReffriend TBranch * TTreeBranchImpRef(TTree *tree, const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel); TTree::GetTargetMemoryRatioFloat_t GetTargetMemoryRatio() constDefinition TTree.h:560; TTree::SetParallelUnzipvirtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1)Enable or disable parallel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:67847,recover,recover,67847,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['recover'],['recover']
Safety,"nst char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&Rmax(Int_t ipl); Double_t&Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:8831,safe,safe,8831,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,2,['safe'],['safe']
Safety,"nst; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooAbsCollection::sort(Bool_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooArgSet.html:12966,safe,safeDeleteList,12966,root/html530/RooArgSet.html,https://root.cern,https://root.cern/root/html530/RooArgSet.html,1,['safe'],['safeDeleteList']
Safety,"nst; Returns current depth to which geometry is drawn. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. TVirtualGeoTrack * FindTrackWithId(Int_t id) const; Search the track hierarchy to find the track with the; given id. if 'primsFirst' is true, then:; first tries TGeoManager::GetTrackOfId, then does a; recursive search if that fails. this would be faster; if the track is somehow known to be a primary. TVirtualGeoTrack * GetTrackOfId(Int_t id) const; Get track with a given ID. TVirtualGeoTrack * GetParentTrackOfId(Int_t id) const; Get parent track with a given ID. Int_t GetTrackIndex(Int_t id) const; Get index for track id, -1 if not found. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void DefaultColors(); Set default volume colors according to A of material. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SetVolumeAttribute(const char* name, const char* att, Int_t val); Set volume attributes in G3 style. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); Set factors that will ""bomb"" all translations in cartesian and cylindrical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:47905,safe,safe,47905,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,14,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"nst; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual Bool_tPaintComposite(Option_t* option = """") const; virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:14432,Safe,SafetyPhi,14432,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,1,['Safe'],['SafetyPhi']
Safety,"nsverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: 464c29f33a8bbd8462a3e15b7e4c30c6f5b74a30 $ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_double_.html:8212,avoid,avoid,8212,root/html534/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_double_.html,2,['avoid'],['avoid']
Safety,"nt (e.g. Histo1D()), so we cannot deduce the type of the column at compile-time. In this case RDataFrame infers the type of the column from the TTree itself. This is why we never needed to specify the column types for all actions in the above snippets.; When the column type is not a common one such as int, double, char or float it is nonetheless good practice to specify it as a template parameter to the action itself, like this: df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal.; When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing x = 0 rather than x == 0:; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");. User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same time, it allows users to inject their own action code to perform arbitrarily complex data reductions.; Implementing custom actions with Book(); Through the Book() method, users can implement a custom action and have access to the same features that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:; #include <ROOT/RDataFrame.hxx>; #include <memory>; ; class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;; ; public:; // We use a public type alias to advertise the type of the result of this action;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:64740,avoid,avoids,64740,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['avoid'],['avoids']
Safety,"nt len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ; 6198 /* We need an additional wait loop around this, because in some cases; 6199 * with TLSwe may get data from the socket but not from SSL_read.; 6200 * In this case we need to repeat at least once.; 6201 */; 6202 ; 6203 if (fp != NULL) {; 6204 /* Use read() instead of fread(), because if we're reading from the; 6205 * CGI pipe, fread() may block until IO buffer is filled up. We; 6206 * cannot afford to block and must pass all read bytes immediately; 6207 * to the client. */; 6208 nread = (int)read(fileno(fp), buf, (size_t)len);; 6209 ; 6210 err = (nread < 0) ? ERRNO : 0;; 6211 if ((nread == 0) && (len > 0)) {; 6212 /* Should get data, but got EOL */; 6213 return -2;; 6214 }; 6215 ; 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:180251,timeout,timeout,180251,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"nt len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ; 6199 /* We need an additional wait loop around this, because in some cases; 6200 * with TLSwe may get data from the socket but not from SSL_read.; 6201 * In this case we need to repeat at least once.; 6202 */; 6203 ; 6204 if (fp != NULL) {; 6205 /* Use read() instead of fread(), because if we're reading from the; 6206 * CGI pipe, fread() may block until IO buffer is filled up. We; 6207 * cannot afford to block and must pass all read bytes immediately; 6208 * to the client. */; 6209 nread = (int)read(fileno(fp), buf, (size_t)len);; 6210 ; 6211 err = (nread < 0) ? ERRNO : 0;; 6212 if ((nread == 0) && (len > 0)) {; 6213 /* Should get data, but got EOL */; 6214 return -2;; 6215 }; 6216 ; 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:180283,timeout,timeout,180283,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"nt list of defined branches with; git branch -a. Change to (creating if necessary) a local branch tracking an existing remote branch of the same name:; git checkout <branch>. Update your local repository ref database without altering the current working area:; git fetch <remote>. Update your current local branch with respect to your repository's current idea of a remote branch's status:; git merge <branch>. Pull remote ref information from all remotes and merge local branches with their remote tracking branches (if applicable):; git pull. Examine changes to the current local branch with respect to its tracking branch:; git cherry -v. Push changes to the remote tracking branch:; git push. Push all changes to all tracking branches:; git push --all. Some more advanced operations. Important tip: if you're going to do a git operation the outcome of which is even remotely uncertain to be the desired one: make a copy of your repository:; mkdir -p <path-to-safe-dir>; tar -cf - . | tar -xC <path-to-safe-dir>. Disk space is cheap and rm -rf is easy. Note that you must copy the entire repository, since all the important information is in the .git directory tree at the top level. Stashing; This is a good way quickly to get a clean tree if you want to merge or rebase (see below) to import changes from a branch without having to commit your current work. Save uncommitted changes to the current working area to the stash (not a commit operation):; git stash. Apply previously-saved stash:; git stash pop. (pops off the changes and applies them to the current working area) or; git stash apply. which applies the changes but retains them on the stack.; Examine the current state of the stash:; git stash list. Clear the entire stash:; git stash clear. Rebasing; Rebasing is changing history, if you think that git stores history. As mentioned above, it doesn't: it saves objects with parent, child and other (eg date, author, etc) information. In a truly distributed environment, the actual hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:10311,safe,safe-dir,10311,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['safe'],['safe-dir']
Safety,"nt, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoShape.html:19100,avoid,avoid,19100,root/html532/TGeoShape.html,https://root.cern,https://root.cern/root/html532/TGeoShape.html,2,['avoid'],['avoid']
Safety,"nt, Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:18546,avoid,avoid,18546,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,2,['avoid'],['avoid']
Safety,"nt, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(Double_t a, Double_t b, Double_t dz); Set dimensions of the eliptical tube. void SetDimensions(Double_t* param); Set shape dimensions starting from an array. void SetPoints(Double_t* points) const; Create eliptical tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Returns the number of vertices on the mesh. void SetPoints(Float_t* points) const; Create eliptical tube mesh points. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoEltu.html:15086,Safe,Safety,15086,root/html534/TGeoEltu.html,https://root.cern,https://root.cern/root/html534/TGeoEltu.html,3,['Safe'],['Safety']
Safety,"nt.h""; 63#include ""RooMsgService.h""; 64#include ""RooNumIntConfig.h""; 65#include ""RooNumRunningInt.h""; 66#include ""RooParamBinning.h""; 67#include ""RooPlot.h""; 68#include ""RooProduct.h""; 69#include ""RooProfileLL.h""; 70#include ""RooRealBinding.h""; 71#include ""RooRealIntegral.h""; 72#include ""RooRealVar.h""; 73#include ""RooSecondMoment.h""; 74#include ""RooVectorDataStore.h""; 75#include ""TreeReadBuffer.h""; 76#include ""ValueChecking.h""; 77 ; 78#include ""ROOT/StringUtils.hxx""; 79#include ""Compression.h""; 80#include ""Math/IFunction.h""; 81#include ""TMath.h""; 82#include ""TObjString.h""; 83#include ""TTree.h""; 84#include ""TH1.h""; 85#include ""TH2.h""; 86#include ""TH3.h""; 87#include ""TBranch.h""; 88#include ""TLeaf.h""; 89#include ""TAttLine.h""; 90#include ""TF1.h""; 91#include ""TF2.h""; 92#include ""TF3.h""; 93#include ""TMatrixD.h""; 94#include ""TVector.h""; 95#include ""strlcpy.h""; 96#ifndef NDEBUG; 97#include <TSystem.h> // To print stack traces when caching errors are detected; 98#endif; 99 ; 100#include <iomanip>; 101#include <iostream>; 102#include <limits>; 103#include <sstream>; 104#include <sys/types.h>; 105 ; 106namespace {; 107 ; 108// Internal helper RooAbsFunc that evaluates the scaled data-weighted average of; 109// given RooAbsReal as a function of a single variable using the RooFit::Evaluator.; 110class ScaledDataWeightedAverage : public RooAbsFunc {; 111public:; 112 ScaledDataWeightedAverage(RooAbsReal const &arg, RooAbsData const &data, double scaleFactor, RooAbsRealLValue &var); 113 : RooAbsFunc{1}, _var{var}, _dataWeights{data.getWeightBatch(0, data.numEntries())}, _scaleFactor{scaleFactor}; 114 {; 115 _arg = RooFit::Detail::compileForNormSet(arg, *data.get());; 116 _arg->recursiveRedirectServers(RooArgList{var});; 117 _evaluator = std::make_unique<RooFit::Evaluator>(*_arg);; 118 std::stack<std::vector<double>>{}.swap(_vectorBuffers);; 119 auto dataSpans = RooFit::BatchModeDataHelpers::getDataSpans(data, """", nullptr, /*skipZeroWeights=*/false,; 120 /*takeGlobalObservablesFromD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:3295,detect,detected,3295,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['detect'],['detected']
Safety,"ntRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives); virtual voidSetMakeSharedLib(const char* directives)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:11037,timeout,timeout,11037,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,6,['timeout'],['timeout']
Safety,"ntStyle(); Int_tWait(Int_t millisec = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSemaphore(const TSemaphore& s); TSemaphore&operator=(const TSemaphore& s). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSemaphore.html:5672,timeout,timeout,5672,root/html534/TSemaphore.html,https://root.cern,https://root.cern/root/html534/TSemaphore.html,2,['timeout'],['timeout']
Safety,"nt_t f)Definition TGeoShape.h:166; TGeoShape::GetNmeshVerticesvirtual Int_t GetNmeshVertices() constDefinition TGeoShape.h:127; TGeoShape::GetMeshNumbersvirtual void GetMeshNumbers(Int_t &, Int_t &, Int_t &) constDefinition TGeoShape.h:125; TGeoShape::DistToPhiMinstatic Double_t DistToPhiMin(const Double_t *point, const Double_t *dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in=kTRUE)compute distance from point (inside phi) to both phi planes. Return minimum.Definition TGeoShape.cxx:426; TGeoShape::SetSegsAndPolsvirtual void SetSegsAndPols(TBuffer3D &buff) const =0; TGeoShape::SetShapeBitvoid SetShapeBit(UInt_t f)Definition TGeoShape.h:165; TGeoShape::DistFromOutside_vvirtual void DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) constDefinition TGeoShape.h:108; TGeoShape::TGeoShapeTGeoShape()Default constructor.Definition TGeoShape.cxx:167; TGeoShape::SafetyPhistatic Double_t SafetyPhi(const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2)Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1,...Definition TGeoShape.cxx:494; TGeoShape::SetDimensionsvirtual void SetDimensions(Double_t *param)=0; TGeoShape::Sizeof3Dvirtual void Sizeof3D() const =0; TGeoShape::fShapeIdInt_t fShapeIdDefinition TGeoShape.h:71; TGeoShape::GetAxisNamevirtual const char * GetAxisName(Int_t iaxis) const =0; TGeoShape::GetPointsOnSegmentsvirtual Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::DistFromInside_vvirtual void DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) constDefinition TGeoShape.h:105; TGeoShape::Dividevirtual TGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0; TGeoSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoShape_8h_source.html:13442,safe,safety,13442,doc/master/TGeoShape_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html,1,['safe'],['safety']
Safety,"nt_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; virtual Double_t GetA () const;  ; virtual Double_t GetB () const;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetEltuDimensions (Double_t a, Double_t b, Double_t dz);  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoTube;  TGeoTube ();  ;  TGeoTube (const char *name, Double_t rmin, Double_t rmax, Double_t dz);  ;  TGeoTube (Double_t *params);  ;  TGeoTube (Double_t rmin, Double_t rmax, Double_t dz);  ;  ~TGeoTube () override;  ; Double_t Ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoEltu.html:2640,safe,safe,2640,doc/master/classTGeoEltu.html,https://root.cern,https://root.cern/doc/master/classTGeoEltu.html,1,['safe'],['safe']
Safety,"nt_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; Double_t GetDphi () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; virtual Int_t GetNsegments () const;  ; Int_t GetNz () const;  ; Double_t GetPhi1 () const;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; Double_t * GetRmax () const;  ; Double_t GetRmax (Int_t ipl) const;  ; Double_t * GetRmin () const;  ; Double_t GetRmin (Int_t ipl) const;  ; Double_t * GetZ () const;  ; Double_t GetZ (Int_t ipl) const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t & Phi1 ();  ; Double_t & Rmax (Int_t ipl);  ; Double_t & Rmin (Int_t ipl);  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; Double_t SafetyToSegment (const Double_t *point, Int_t ipl, Bool_t in=kTRUE, Double_t safmin=TGeoShape::Big()) const;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:3469,safe,safe,3469,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['safe'],['safe']
Safety,"nt_t nsamples, Option_t *option)Test for shape navigation methods.Definition TGeoChecker.cxx:1752; TGeoChecker::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""")Check illegal overlaps for volume VOL within a limit OVLP.Definition TGeoChecker.cxx:1427; TGeoChecker::TestOverlapsvoid TestOverlaps(const char *path)Geometry overlap checker based on sampling.Definition TGeoChecker.cxx:2761; TGeoChecker::SetSelectedNodevoid SetSelectedNode(TGeoNode *node)Definition TGeoChecker.h:93; TGeoChecker::CheckGeometryFullvoid CheckGeometryFull(Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr)Geometry checking.Definition TGeoChecker.cxx:503; TGeoChecker::SamplePointsTGeoNode * SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path)shoot npoints randomly in a box of 1E-5 around current point.Definition TGeoChecker.cxx:2492; TGeoChecker::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Draw point (x,y,z) over the picture of the daughters of the volume containing this point.Definition TGeoChecker.cxx:1692; TGeoChecker::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""v"")Estimate weight of top level volume with a precision SIGMA(W)/W better than PRECISION.Definition TGeoChecker.cxx:2890; TGeoChecker::OpProgressvoid OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""")Print current operation progress.Definition TGeoChecker.cxx:151; TGeoChecker::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoChecker.cxx:809; TGeoChecker::CheckBoundaryReferencevirtual void CheckBoundaryReference(Int_t icheck=-1)Check the boundary errors ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:82597,safe,safety,82597,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['safe'],['safety']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &fXY[0][0];}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsSamePoint(const Double_t* p1, const Double_t* p2); {return (TMath::Abs(p1[0]-p2[0])<1.E-16 && TMath::Abs(p1[1]-p2[1])<1.E-16)?kTRUE:kFALSE;}. Bool_t IsTwisted() const; {return (fTwist==0)?kFALSE:kTRUE;}. void SetDz(Double_t dz); {fDz = dz;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:19255,safe,safe,19255,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &fXY[0][0];}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsSamePoint(const Double_t* p1, const Double_t* p2); {return (TMath::Abs(p1[0]-p2[0])<1.E-16 && TMath::Abs(p1[1]-p2[1])<1.E-16)?kTRUE:kFALSE;}. Bool_t IsTwisted() const; {return (fTwist==0)?kFALSE:kTRUE;}. void SetDz(Double_t dz); {fDz = dz;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 15:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoArb8.html:21042,safe,safe,21042,root/html604/TGeoArb8.html,https://root.cern,https://root.cern/root/html604/TGeoArb8.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &fXY[0][0];}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsSamePoint(const Double_t* p1, const Double_t* p2); {return (TMath::Abs(p1[0]-p2[0])<1.E-16 && TMath::Abs(p1[1]-p2[1])<1.E-16)?kTRUE:kFALSE;}. Bool_t IsTwisted() const; {return (fTwist==0)?kFALSE:kTRUE;}. void SetDz(Double_t dz); {fDz = dz;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoArb8.html:21042,safe,safe,21042,root/html602/TGeoArb8.html,https://root.cern,https://root.cern/root/html602/TGeoArb8.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 60+12*fNz;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Int_t GetNz() const; {return fNz;}. Double_t * GetRmin() const; {return fRmin;}. Double_t * GetRmax() const; {return fRmax;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Double_t & Phi1(); {return fPhi1;}. Double_t & Dphi(); {return fDphi;}. Double_t & Rmin(Int_t ipl); {return fRmin[ipl];}. Double_t & Rmax(Int_t ipl); {return fRmax[ipl];}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:19164,safe,safe,19164,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,12,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:20917,safe,safe,20917,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 15:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoBBox.html:22671,safe,safe,22671,root/html604/TGeoBBox.html,https://root.cern,https://root.cern/root/html604/TGeoBBox.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBBox.html:22671,safe,safe,22671,root/html602/TGeoBBox.html,https://root.cern,https://root.cern/root/html602/TGeoBBox.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCompositeShape(const TGeoCompositeShape& gcs); { }. TGeoCompositeShape& operator=(const TGeoCompositeShape& gcs). TGeoBoolNode * GetBoolNode() const; {return fNode;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsComposite() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void SetDimensions(Double_t* ); {;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:22275,safe,safe,22275,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCompositeShape(const TGeoCompositeShape& gcs); { }. TGeoCompositeShape& operator=(const TGeoCompositeShape& gcs). TGeoBoolNode * GetBoolNode() const; {return fNode;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsComposite() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void SetDimensions(Double_t* ); {;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoCompositeShape.html:24029,safe,safe,24029,root/html604/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html604/TGeoCompositeShape.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCompositeShape(const TGeoCompositeShape& gcs); { }. TGeoCompositeShape& operator=(const TGeoCompositeShape& gcs). TGeoBoolNode * GetBoolNode() const; {return fNode;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsComposite() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void SetDimensions(Double_t* ); {;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCompositeShape.html:24029,safe,safe,24029,root/html602/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHalfSpace.html:15059,safe,safe,15059,root/html534/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoHalfSpace.html:16813,safe,safe,16813,root/html604/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html604/TGeoHalfSpace.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHalfSpace.html:16813,safe,safe,16813,root/html602/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html602/TGeoHalfSpace.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoPara(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetX() const; {return fX;}. Double_t GetY() const; {return fY;}. Double_t GetZ() const; {return fZ;}. Double_t GetAlpha() const; {return fAlpha;}. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetTxy() const; {return fTxy;}. Double_t GetTxz() const; {return fTxz;}. Double_t GetTyz() const; {return fTyz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPara.html:17042,safe,safe,17042,root/html534/TGeoPara.html,https://root.cern,https://root.cern/root/html534/TGeoPara.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoPara(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetX() const; {return fX;}. Double_t GetY() const; {return fY;}. Double_t GetZ() const; {return fZ;}. Double_t GetAlpha() const; {return fAlpha;}. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetTxy() const; {return fTxy;}. Double_t GetTxz() const; {return fTxz;}. Double_t GetTyz() const; {return fTyz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoPara.html:18794,safe,safe,18794,root/html604/TGeoPara.html,https://root.cern,https://root.cern/root/html604/TGeoPara.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoPara(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetX() const; {return fX;}. Double_t GetY() const; {return fY;}. Double_t GetZ() const; {return fZ;}. Double_t GetAlpha() const; {return fAlpha;}. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetTxy() const; {return fTxy;}. Double_t GetTxz() const; {return fTxz;}. Double_t GetTyz() const; {return fTyz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPara.html:18794,safe,safe,18794,root/html602/TGeoPara.html,https://root.cern,https://root.cern/root/html602/TGeoPara.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:18898,safe,safe,18898,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:03; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoSphere.html:20652,safe,safe,20652,root/html604/TGeoSphere.html,https://root.cern,https://root.cern/root/html604/TGeoSphere.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:03; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoSphere.html:20652,safe,safe,20652,root/html602/TGeoSphere.html,https://root.cern,https://root.cern/root/html602/TGeoSphere.html,4,['safe'],['safe']
Safety,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. Int_t GetNz() const; virtual Int_t GetByteCount() const {return 60+12*fNz;}. {return fNz;}. Int_t GetNvert() const; {return fNvert;}. Double_t GetX(Int_t i) const; {return (i<fNvert&&i>-1 &&fX!=0) ? fX[i] : -1.0E10;}. Double_t GetY(Int_t i) const; {return (i<fNvert&&i>-1 &&fY!=0) ? fY[i] : -1.0E10;}. Double_t GetXOffset(Int_t i) const; {return (i<fNz&&i>-1 && fX0!=0) ? fX0[i] : 0.0;}. Double_t GetYOffset(Int_t i) const; {return (i<fNz&&i>-1 && fY0!=0) ? fY0[i] : 0.0;}. Double_t GetScale(Int_t i) const; {return (i<fNz&&i>-1 && fScale!=0) ? fScale[i] : 1.0;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Mihaela Gheata 24/01/04 » Cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoXtru.html:21369,safe,safe,21369,root/html534/TGeoXtru.html,https://root.cern,https://root.cern/root/html534/TGeoXtru.html,12,['safe'],['safe']
Safety,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFitter.html:16877,predict,predict,16877,root/html534/TFitter.html,https://root.cern,https://root.cern/root/html534/TFitter.html,2,['predict'],['predict']
Safety,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFitter.html:17450,predict,predict,17450,root/html604/TFitter.html,https://root.cern,https://root.cern/root/html604/TFitter.html,2,['predict'],['predict']
Safety,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFitter.html:17450,predict,predict,17450,root/html602/TFitter.html,https://root.cern,https://root.cern/root/html602/TFitter.html,2,['predict'],['predict']
Safety,"nt_t& npari, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:55493,safe,safely,55493,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,8,['safe'],['safely']
Safety,"nt_t ; iaxis); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoCone, TGeoPcon, TGeoSphere, TGeoTorus, TGeoTube, and TGeoVGShape. ◆ GetAxisRange(). Double_t TGeoBBox::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoCone, TGeoConeSeg, TGeoHype, TGeoPara, TGeoPcon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoVGShape. ◆ GetBoundingCylinder(). void TGeoBBox::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoCompositeShape, TGeoHalfSpace, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, and TGeoVGShape. ◆ GetBuffer3D(). const TBuffer3D & TGeoBBox::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoShape.; Reimplemented in TGeoTessellated, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoSphere, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ GetByteCount(). Int_t TGeoBBox::GetByteCount ; (; ); const. inlineoverridevirtual . Implements TGeoShape.; Reimplemented in TGeoCone, TGeoConeSeg, TGeoHype, TGeoPara, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoVGShape.; Definition at line 70 of file TGeoBBox.h. ◆ GetDX(). virtual Double_t TGeoBBox::GetDX ; (; ); const. inlinevirtual . Definition at line 79 of file TGeoBBox.h. ◆ GetDY(). virtual Double_t TGeoBBox::GetDY ; (; ); const. inlinevirtual . Definition at line 80 of file TGeoBBox.h. ◆ GetDZ(). virtual Double_t TGeoBBox::GetDZ ; (; ); const. inlinevirtual . Definition at line 81 of file TGeoBBox.h. ◆ GetFacetArea(). virtual Double_t TGeoBBox:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:30524,avoid,avoid,30524,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['avoid'],['avoid']
Safety,"ntains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAlpha () const;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi () const;  ; Double_t GetTheta () const;  ; Double_t GetTxy () const;  ; Double_t GetTxz () const;  ; Double_t GetTyz () const;  ; Double_t GetX () const;  ; Double_t GetY () const;  ; Double_t GetZ () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"".",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:2780,safe,safe,2780,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['safe'],['safe']
Safety,"ntains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:3694,safe,safe,3694,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,6,['safe'],['safe']
Safety,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear must; deallocate the memory.; * If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:3881,avoid,avoid,3881,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,2,['avoid'],['avoid']
Safety,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:3881,avoid,avoid,3881,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['avoid'],['avoid']
Safety,"ntation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:3881,avoid,avoid,3881,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,2,['avoid'],['avoid']
Safety,"nted in TEventIterUnit, TEventIterObj, and TEventIterTree. ◆ GetPackets(). TList * TEventIter::GetPackets ; (; ). inline . Definition at line 89 of file TEventIter.h. ◆ InvalidatePacket(). void TEventIter::InvalidatePacket ; (; ). virtual . Invalidated the current packet (if any) by setting the TDSetElement::kCorrupted bit. ; Definition at line 133 of file TEventIter.cxx. ◆ IsA(). TClass * TEventIter::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TEventIterUnit, TEventIterObj, and TEventIterTree.; Definition at line 93 of file TEventIter.h. ◆ LoadDir(). Int_t TEventIter::LoadDir ; (; ). protected . Load directory. ; Definition at line 163 of file TEventIter.cxx. ◆ PreProcessEvent(). virtual void TEventIter::PreProcessEvent ; (; Long64_t ; ). inlineprotectedvirtual . Reimplemented in TEventIterTree, and TEventIterObj.; Definition at line 74 of file TEventIter.h. ◆ StopProcess(). void TEventIter::StopProcess ; (; Bool_t ; abort). virtual . Set flag to stop the process. ; Definition at line 141 of file TEventIter.cxx. ◆ Streamer(). void TEventIter::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TEventIterUnit, TEventIterObj, and TEventIterTree. ◆ StreamerNVirtual(). void TEventIter::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 93 of file TEventIter.h. Member Data Documentation. ◆ fCur. Long64_t TEventIter::fCur. protected . Definition at line 64 of file TEventIter.h. ◆ fDir. TDirectory* TEventIter::fDir. protected . Definition at line 56 of file TEventIter.h. ◆ fDSet. TDSet* TEventIter::fDSet. protected . Definition at line 48 of file TEventIter.h. ◆ fElem. TDSetElement* TEventIter::fElem. protected . Definition at line 50 of file TEventIter.h. ◆ fElemCur. Long64_t TEventIter::fElemCur. protected . Definition at line 59 of file TEventIter.h. ◆ fElemFirst.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIter.html:14804,abort,abort,14804,doc/master/classTEventIter.html,https://root.cern,https://root.cern/doc/master/classTEventIter.html,1,['abort'],['abort']
Safety,"nted in TProofPlayerRemote.; Definition at line 213 of file TProofPlayer.h. ◆ SetMaxDrawQueries(). void TProofPlayer::SetMaxDrawQueries ; (; Int_t ; max). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 168 of file TProofPlayer.h. ◆ SetMerging(). void TProofPlayer::SetMerging ; (; Bool_t ; = kTRUE). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 215 of file TProofPlayer.h. ◆ SetOutputFilePath(). void TProofPlayer::SetOutputFilePath ; (; const char * ; fp). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 220 of file TProofPlayer.h. ◆ SetProcessing(). void TProofPlayer::SetProcessing ; (; Bool_t ; on = kTRUE). Set processing bit according to 'on'. ; Definition at line 274 of file TProofPlayer.cxx. ◆ SetStopTimer(). void TProofPlayer::SetStopTimer ; (; Bool_t ; on = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:41794,abort,abort,41794,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['abort'],['abort']
Safety,"ntent; if fname is null, send the full list of files. ; Definition at line 951 of file TApplicationServer.cxx. ◆ BrowseKey(). Int_t TApplicationServer::BrowseKey ; (; const char * ; keyname). Read key object and send it back to client. ; Definition at line 1010 of file TApplicationServer.cxx. ◆ Class(). static TClass * TApplicationServer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TApplicationServer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TApplicationServer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 94 of file TApplicationServer.h. ◆ DeclFileName(). static const char * TApplicationServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 94 of file TApplicationServer.h. ◆ ErrorHandler(). void TApplicationServer::ErrorHandler ; (; Int_t ; level, . Bool_t ; abort, . const char * ; location, . const char * ; msg . ). staticprotected . The error handler function. ; It prints the message on stderr and if abort is set it aborts the application. ; Definition at line 1088 of file TApplicationServer.cxx. ◆ ExecLogon(). void TApplicationServer::ExecLogon ; (; ). private . Execute logon macro's. ; There are three levels of logon macros that will be executed: the system logon etc/system.rootlogon.C, the global user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward compatibility also the logon macro as specified by the Rint.Logon environment setting, by default ./rootlogon.C, will be executed. No logon macros will be executed when the system is started with the -n option. ; Definition at line 1277 of file TApplicationServer.cxx. ◆ GetHost(). const char * TApplicationServer::GetHost ; (; ); const. inline . Definition at line 73 of file TApplicationServer.h. ◆ GetOptions(). void TApplicationServer::GetOptions ; (; Int_t * ; argc, . char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:24909,abort,abort,24909,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['abort'],['abort']
Safety,"ntents and errors defined in the table below ;  myfit.C Get in memory an histogram from a root file and fit a user defined function ;  NumericalMinimization.C Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers ;  qa2.C Test generation of random numbers distributed according to a function defined by the user ;  TestBinomial.C Perform a fit to a set of data with binomial errors like those derived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:110702,detect,detector,110702,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,"nterface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface filling the arrays x and w (static method); 3807///; 3808/// Given the number of sampling points this routine fills the arrays x and w; 3809/// of length num, containing the abscissa and weight of the Gauss-Legendre; 3810/// n-point quadrature formula.; 3811///; 3812/// Gauss-Legendre:; 3813/** \f[; 3814 W(x)=1 -1<x<1 \\; 3815 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; 3816 \f]; 3817**/; 3818/// num is the number of sampling points (>0); 3819/// x and w are arrays of size num; 3820/// eps is the relative precision; 3821///; 3822/// If num<=0 or eps<=0 no action is done.; 3823///; 3824/// Reference: Numerical Recipes in C, Second Edition; 3825 ; 3826void TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps); 3827{; 3828 // This function is just kept like this for backward compatibility!; 3829 ; 3830 ROOT::Math::GaussLegendreIntegrator gli(num, eps);; 38",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:144661,unsafe,unsafe,144661,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['unsafe'],['unsafe']
Safety,"nterface to basic system I/O routines. { return 0; }. Int_t SysClose(Int_t ); { return 0; }. Int_t SysRead(Int_t , void* , Int_t ); { return 0; }. Int_t SysWrite(Int_t , const void* , Int_t ); { return 0; }. Long64_t SysSeek(Int_t , Long64_t , Int_t ); { return 0; }. Int_t SysStat(Int_t , Long_t* , Long64_t* , Long_t* , Long_t* ); { return 0; }. Int_t SysSync(Int_t ); { return 0; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. Int_t GetIOVersion() const; { return fIOVersion; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Paint(Option_t* = """"); {}. void Print(Option_t* = """") const; {}. Bool_t ReadBuffer(char* , Int_t ); { return kFALSE; }. Bool_t ReadBuffer(char* , Long64_t , Int_t ); { return kFALSE; }. void ReadFree(); {}. Int_t Recover(); { return 0; }. void Seek(Long64_t , TFile::ERelativeTo = kBeg); {}. void SetEND(Long64_t ); {}. Int_t Sizeof() const; { return 0; }. void UseCache(Int_t = 10, Int_t = 0); {}. Bool_t WriteBuffer(const char* , Int_t ); { return kFALSE; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0); { return 0; }. Int_t Write(const char* = 0, Int_t = 0, Int_t = 0) const; { return 0; }. void WriteFree(); {}. void WriteHeader(); {}. » Author: Sergey Linev 10.05.2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/xml:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLFile.html:34950,Recover,Recover,34950,root/html534/TXMLFile.html,https://root.cern,https://root.cern/root/html534/TXMLFile.html,1,['Recover'],['Recover']
Safety,"nterleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_t_numSetsTotal number of partitions in parallel calculation mode; Double_t_offset! Offset; Double_t_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_t_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:37054,avoid,avoids,37054,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,2,['avoid'],['avoids']
Safety,"ntf(NULL,; 21331 NULL,; 21332 block,; 21333 sizeof(block),; 21334 ""%s%s\""data\"" : {%s""; 21335 ""\""read\"" : %"" INT64_FMT "",%s""; 21336 ""\""written\"" : %"" INT64_FMT ""%s""; 21337 ""}"",; 21338 (connection_info_length > 1 ? "","" : """"),; 21339 eol,; 21340 eol,; 21341 conn->consumed_content,; 21342 eol,; 21343 conn->num_bytes_sent,; 21344 eol);; 21345 connection_info_length += mg_str_append(&buffer, end, block);; 21346 }; 21347 ; 21348 /* State */; 21349 mg_snprintf(NULL,; 21350 NULL,; 21351 block,; 21352 sizeof(block),; 21353 ""%s%s\""state\"" : \""%s\"""",; 21354 (connection_info_length > 1 ? "","" : """"),; 21355 eol,; 21356 state_str);; 21357 connection_info_length += mg_str_append(&buffer, end, block);; 21358 ; 21359 /* Terminate string */; 21360 if (append_eoobj) {; 21361 strcat(append_eoobj, eoobj);; 21362 }; 21363 connection_info_length += sizeof(eoobj) - 1;; 21364 ; 21365 return (int)connection_info_length;; 21366}; 21367#endif; 21368 ; 21369 ; 21370/* Initialize this library. This function does not need to be thread safe.; 21371 */; 21372unsigned; 21373mg_init_library(unsigned features); 21374{; 21375 unsigned features_to_init = mg_check_feature(features & 0xFFu);; 21376 unsigned features_inited = features_to_init;; 21377 ; 21378 if (mg_init_library_called <= 0) {; 21379 /* Not initialized yet */; 21380 if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {; 21381 return 0;; 21382 }; 21383 }; 21384 ; 21385 mg_global_lock();; 21386 ; 21387 if (mg_init_library_called <= 0) {; 21388#if defined(_WIN32); 21389 int file_mutex_init = 1;; 21390 int wsa = 1;; 21391#else; 21392 int mutexattr_init = 1;; 21393#endif; 21394 int failed = 1;; 21395 int key_create = pthread_key_create(&sTlsKey, tls_dtor);; 21396 ; 21397 if (key_create == 0) {; 21398#if defined(_WIN32); 21399 file_mutex_init =; 21400 pthread_mutex_init(&global_log_file_lock, &pthread_mutex_attr);; 21401 if (file_mutex_init == 0) {; 21402 /* Start WinSock */; 21403 WSADATA data;; 21404 failed = wsa = WSAStartup(MAKEWORD(2, 2), &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:636615,safe,safe,636615,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"ntf(NULL,; 21332 NULL,; 21333 block,; 21334 sizeof(block),; 21335 ""%s%s\""data\"" : {%s""; 21336 ""\""read\"" : %"" INT64_FMT "",%s""; 21337 ""\""written\"" : %"" INT64_FMT ""%s""; 21338 ""}"",; 21339 (connection_info_length > 1 ? "","" : """"),; 21340 eol,; 21341 eol,; 21342 conn->consumed_content,; 21343 eol,; 21344 conn->num_bytes_sent,; 21345 eol);; 21346 connection_info_length += mg_str_append(&buffer, end, block);; 21347 }; 21348 ; 21349 /* State */; 21350 mg_snprintf(NULL,; 21351 NULL,; 21352 block,; 21353 sizeof(block),; 21354 ""%s%s\""state\"" : \""%s\"""",; 21355 (connection_info_length > 1 ? "","" : """"),; 21356 eol,; 21357 state_str);; 21358 connection_info_length += mg_str_append(&buffer, end, block);; 21359 ; 21360 /* Terminate string */; 21361 if (append_eoobj) {; 21362 strcat(append_eoobj, eoobj);; 21363 }; 21364 connection_info_length += sizeof(eoobj) - 1;; 21365 ; 21366 return (int)connection_info_length;; 21367}; 21368#endif; 21369 ; 21370 ; 21371/* Initialize this library. This function does not need to be thread safe.; 21372 */; 21373unsigned; 21374mg_init_library(unsigned features); 21375{; 21376 unsigned features_to_init = mg_check_feature(features & 0xFFu);; 21377 unsigned features_inited = features_to_init;; 21378 ; 21379 if (mg_init_library_called <= 0) {; 21380 /* Not initialized yet */; 21381 if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {; 21382 return 0;; 21383 }; 21384 }; 21385 ; 21386 mg_global_lock();; 21387 ; 21388 if (mg_init_library_called <= 0) {; 21389#if defined(_WIN32); 21390 int file_mutex_init = 1;; 21391 int wsa = 1;; 21392#else; 21393 int mutexattr_init = 1;; 21394#endif; 21395 int failed = 1;; 21396 int key_create = pthread_key_create(&sTlsKey, tls_dtor);; 21397 ; 21398 if (key_create == 0) {; 21399#if defined(_WIN32); 21400 file_mutex_init =; 21401 pthread_mutex_init(&global_log_file_lock, &pthread_mutex_attr);; 21402 if (file_mutex_init == 0) {; 21403 /* Start WinSock */; 21404 WSADATA data;; 21405 failed = wsa = WSAStartup(MAKEWORD(2, 2), &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:636648,safe,safe,636648,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"ntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buffer) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Set cone dimensions. void SetDimensions(Double_t* param); Set cone dimensions from an array. void SetPoints(Double_t* points) const; Create cone mesh points. void SetPoints(Float_t* points) const; Create cone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoMana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:17876,Safe,SafetyS,17876,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,['Safe'],['SafetyS']
Safety,"nts, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Check the inside status for each of the points in the array. ; Input: Array of point coordinates + vector size Output: Array of Booleans for the inside of each point ; Reimplemented from TGeoBBox.; Definition at line 382 of file TGeoScaledShape.cxx. ◆ DeclFileName(). static const char * TGeoScaledShape::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 71 of file TGeoScaledShape.h. ◆ DistancetoPrimitive(). Int_t TGeoScaledShape::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . compute closest distance from point px,py to each vertex. Should not be called. ; Reimplemented from TGeoBBox.; Definition at line 134 of file TGeoScaledShape.cxx. ◆ DistFromInside(). Double_t TGeoScaledShape::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from inside point to surface of the scaled shape. ; Reimplemented from TGeoBBox.; Definition at line 143 of file TGeoScaledShape.cxx. ◆ DistFromInside_v(). void TGeoScaledShape::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Compute distance from array of input points having directions specified by dirs. Store output in dists. ; Reimplemented from TGeoBBox.; Definition at line 402 of file TGeoScaledShape.cxx. ◆ DistFromOutside(). Double_t TGeoScaledShape::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from outside point to surface of the scaled shape. ; Reimplemented from TGeoBBox.; Definition at line 162 of file TGeoScaledShape.cxx. ◆ DistFromOutsid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:27281,safe,safe,27281,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['safe'],['safe']
Safety,"nts, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 127 Double_t *step) const override;; 128 TGeoVolume *; 129 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 130 Double_t GetTheta() const { return fTheta; }; 131 Double_t GetPhi() const { return fPhi; }; 132 Double_t GetH1() const { return fH1; }; 133 Double_t GetBl1() const { return fBl1; }; 134 Double_t GetTl1() const { return fTl1; }; 135 Double_t GetAlpha1() const { return fAlpha1; }; 136 Double_t GetH2() const { return fH2; }; 137 Double_t GetBl2() const { return fBl2; }; 138 Double_t GetTl2() const { return fTl2; }; 139 Double_t GetAlpha2() const { return fAlpha2; }; 140 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 141 void SetDimensions(Double_t *param) override;; 142 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 143 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 163 Double_t *safe = nullptr) const override;; 164 void DistFro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:7640,safe,safe,7640,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"ntstatic Bool_t IsSamePoint(const Double_t *p1, const Double_t *p2)Definition TGeoArb8.h:74; TGeoArb8::~TGeoArb8~TGeoArb8() override; TGeoArb8::IsCylTypeBool_t IsCylType() const overrideDefinition TGeoArb8.h:73; TGeoArb8::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *) const overrideDefinition TGeoArb8.h:69; TGeoArb8::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoArb8::SetPlaneVerticesvoid SetPlaneVertices(Double_t zpl, Double_t *vertices) const; TGeoArb8::ComputeBBoxvoid ComputeBBox() override; TGeoArb8::GetFittingBoxInt_t GetFittingBox(const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; TGeoBBoxDefinition TGeoBBox.h:17; TGeoGtraDefinition TGeoArb8.h:149; TGeoGtra::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoGtra::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoGtra::fTwistAngleDouble_t fTwistAngleDefinition TGeoArb8.h:152; TGeoGtra::TGeoGtraTGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoGtra::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoGtra::TGeoGtraTGeoGtra(); TGeoGtra::TGeoGtraTGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:15355,safe,safe,15355,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"nue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:9159,abort,aborted,9159,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,8,['abort'],['aborted']
Safety,"num TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Atom_tfAcceptedAction; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotx; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSource; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPic; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSource; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelist; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDNDManager destructor. Atom_t GetDNDAware(); { return fgDNDAware; }. Atom_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDNDManager.html:7386,timeout,timeout,7386,root/html528/TGDNDManager.html,https://root.cern,https://root.cern/root/html528/TGDNDManager.html,6,['timeout'],['timeout']
Safety,"number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 924where `slot` will be a number between 0 and `GetNSlots() - 1`.; 925In other words, within a slot, computation runs sequentially and events are processed sequentially.; 926Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 927will never receive the same slot at the same time.; 928This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 929processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 930 ; 931### Parallel e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:52180,safe,safe,52180,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 964where `slot` will be a number between 0 and `GetNSlots() - 1`.; 965In other words, within a slot, computation runs sequentially and events are processed sequentially.; 966Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; 967will never receive the same slot at the same time.; 968This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; 969processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot().; 970 ; 971### Parallel e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53820,safe,safe,53820,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13122,recover,recover,13122,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"nvas.cxx. ◆ ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2440 of file TCanvas.cxx. ◆ ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2418 of file TCanvas.cxx. ◆ ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2429 of file TCanvas.cxx. ◆ ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2451 of file TCanvas.cxx. ◆ Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2476 of file TCanvas.cxx. ◆ UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2532 of file TCanvas.cxx. ◆ UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1183 of file TCanvas.cxx. ◆ UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. ◆ TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. ◆ TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. ◆ TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. ◆ TWebCanvas. friend class TWebCanvas. friend . Definition at line 26 of file TCanvas.h. Member Data Documentation. ◆ fBatch. Bool_t TCanvas::fBatch. protected . ! True when in batchmode ; Definition at line 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:93441,avoid,avoid,93441,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['avoid'],['avoid']
Safety,"nvas.cxx. ◆ ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2453 of file TCanvas.cxx. ◆ ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2431 of file TCanvas.cxx. ◆ ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2442 of file TCanvas.cxx. ◆ ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2464 of file TCanvas.cxx. ◆ Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2489 of file TCanvas.cxx. ◆ UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2545 of file TCanvas.cxx. ◆ UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1185 of file TCanvas.cxx. ◆ UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. ◆ TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. ◆ TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. ◆ TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. ◆ TWebCanvas. friend class TWebCanvas. friend . Definition at line 26 of file TCanvas.h. Member Data Documentation. ◆ fBatch. Bool_t TCanvas::fBatch. protected . ! True when in batchmode ; Definition at line 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:93886,avoid,avoid,93886,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['avoid'],['avoid']
Safety,"nverter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoManager.h:512; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; For any questions or comments about the GDML->ROOT binding please contact ben.l.nosp@m.loyd.nosp@m.@cern.nosp@m..ch. ROOT->GDML; The TGeo to GDML converter allows to export ROOT geometries (TGeo geomet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry__gdml.html:1427,detect,detecting,1427,doc/master/group__Geometry__gdml.html,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html,1,['detect'],['detecting']
Safety,"o TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:1394,timeout,timeout,1394,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,8,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"o TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimer.html:1418,timeout,timeout,1418,root/html602/TTimer.html,https://root.cern,https://root.cern/root/html602/TTimer.html,6,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"o a subset of the methods in GetListOfMethods() so don't do GetListOfAllPublicMethods()->Delete(). Algorithm used to get the list is:; put all methods of the class in the list (also protected and private ones).; loop over all base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3845 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3636 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3770 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:82442,safe,safe,82442,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['safe'],['safe']
Safety,"o a subset of the methods in GetListOfMethods() so don't do GetListOfAllPublicMethods()->Delete(). Algorithm used to get the list is:; put all methods of the class in the list (also protected and private ones).; loop over all base classes and add only those methods not already in the list (also protected and private ones).; once finished, loop over resulting list and remove all private and protected methods. . Definition at line 3912 of file TClass.cxx. ◆ GetListOfBases(). TList * TClass::GetListOfBases ; (; ). Return list containing the TBaseClass(es) of a class. ; Definition at line 3703 of file TClass.cxx. ◆ GetListOfDataMembers(). TList * TClass::GetListOfDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of a class. ; Definition at line 3837 of file TClass.cxx. ◆ GetListOfEnums(). TList * TClass::GetListOfEnums ; (; Bool_t ; requestListLoading = kTRUE). Return a list containing the TEnums of a class. ; The list returned is safe to use from multiple thread without explicitly taking the ROOT global lock.; In the case the TClass represents a namespace, the returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:82443,safe,safe,82443,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['safe'],['safe']
Safety,"o build the computation graph for the final likelihood. ; Reimplemented from RooAbsPdf.; Definition at line 1681 of file RooProdPdf.cxx. ◆ DeclFileName(). static const char * RooProdPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 190 of file RooProdPdf.h. ◆ doEvalImpl(). void RooProdPdf::doEvalImpl ; (; RooAbsArg const * ; caller, . const RooProdPdf::CacheElem & ; cache, . RooFit::EvalContext & ; ctx . ); const. private . Evaluate product of PDFs in batch mode. ; Definition at line 413 of file RooProdPdf.cxx. ◆ evaluate(). double RooProdPdf::evaluate ; (; ); const. overrideprivatevirtual . Calculate current value of object. ; Implements RooAbsReal.; Definition at line 371 of file RooProdPdf.cxx. ◆ expectedEvents(). double RooProdPdf::expectedEvents ; (; const RooArgSet * ; nset); const. overridevirtual . Return the expected number of events associated with the extendable input PDF in the product. ; If there is no extendable term, abort. ; Reimplemented from RooAbsPdf.; Definition at line 1671 of file RooProdPdf.cxx. ◆ extendMode(). RooAbsPdf::ExtendMode RooProdPdf::extendMode ; (; ); const. overridevirtual . If this product contains exactly one extendable p.d.f return the extension abilities of that p.d.f, otherwise return CanNotBeExtended. ; Reimplemented from RooAbsPdf.; Definition at line 1660 of file RooProdPdf.cxx. ◆ factorizeProduct(). void RooProdPdf::factorizeProduct ; (; const RooArgSet & ; normSet, . const RooArgSet & ; intSet, . RooLinkedList & ; termList, . RooLinkedList & ; normList, . RooLinkedList & ; impDepList, . RooLinkedList & ; crossDepList, . RooLinkedList & ; intList . ); const. private . Factorize product in irreducible terms for given choice of integration/normalization. ; Definition at line 472 of file RooProdPdf.cxx. ◆ fillNormSetForServer(). std::unique_ptr< RooArgSet > RooProdPdf::fillNormSetForServer ; (; RooArgSet const & ; normSet, . RooAbsArg const & ; server . ); c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:89047,abort,abort,89047,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['abort'],['abort']
Safety,"o delete params:; RooArgSet * params = pdf.getParameters(nullptr);; If you wrap such return values in a std::unique_ptr, then your code will compile both with and without memory safe interfaces:; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; Also some virtual RooFit functions like RooAbsReal::createIntegral() are returning a different type conditional on ROOFIT_MEMORY_SAFE_INTERFACES. If you are overriding such a function, you need to use the RooFit::OwningPtr return type, which is an alias for std::unique_ptr in memory-safe mode or an alias for a raw pointer otherwise.; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; The biggest application of the memory-safe interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is strongly encouraged and appreciated.; Removal of some memory-unsafe interfaces. The final bool takeOwnership parameter of the RooAddition and RooStats::HistFactory::PiecewiseInterpolation constructors was removed. This is to avoid situations where ownership is not clear to the compiler. Now, ownership of the input RooAbsArgs is never passed in the constructor. If you want the pass input ownership to the created object, please use addOwnedComponents. If you want to be extra safe, make sure the inputs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:10707,safe,safe,10707,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['safe'],['safe']
Safety,"o put a timeout on an I/O operation. By default interrupted syscalls will be restarted. ; Definition at line 199 of file TTimer.cxx. ◆ SetObject(). void TTimer::SetObject ; (; TObject * ; object). Set the object to be notified at time out. ; Removes the command to be executed (if it was set). ; Definition at line 186 of file TTimer.cxx. ◆ SetTime(). void TTimer::SetTime ; (; Long_t ; milliSec). inline . Definition at line 91 of file TTimer.h. ◆ SetTimerID(). void TTimer::SetTimerID ; (; UInt_t ; id = 0). inline . Definition at line 92 of file TTimer.h. ◆ SingleShot(). void TTimer::SingleShot ; (; Int_t ; milliSec, . const char * ; receiver_class, . void * ; receiver, . const char * ; method . ). static . This static function calls a slot after a given time interval. ; Created internal timer will be deleted after that. ; Definition at line 258 of file TTimer.cxx. ◆ Start(). void TTimer::Start ; (; Long_t ; milliSec = -1, . Bool_t ; singleShot = kFALSE . ). virtual . Starts the timer with a milliSec timeout. ; If milliSec is 0 then the timeout will be the minimum timeout (see TSystem::ESysConstants, i.e. 10 ms), if milliSec is -1 then the time interval as previously specified (in ctor or SetTime()) will be used. If singleShot is kTRUE, the timer will be activated only once, otherwise it will continue until it is stopped. See also TurnOn(), Stop(), TurnOff(). ; Definition at line 213 of file TTimer.cxx. ◆ Stop(). virtual void TTimer::Stop ; (; ). inlinevirtual . Reimplemented in TGLRedrawTimer.; Definition at line 94 of file TTimer.h. ◆ Streamer(). void TTimer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TSysEvtHandler. ◆ StreamerNVirtual(). void TTimer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 102 of file TTimer.h. ◆ Timeout(). virtual void TTimer::Timeout ; (; ). inlinevirtual . Reimplemented in ROOT::RBrowserTimer, TCefTimer, TQt5Timer, TQt6Timer, TWebCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTimer.html:24934,timeout,timeout,24934,doc/master/classTTimer.html,https://root.cern,https://root.cern/doc/master/classTTimer.html,1,['timeout'],['timeout']
Safety,"o that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeaves(TBuffer& b); -- Read leaves into i/o buffers for this branch. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:22886,detect,detect,22886,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['detect'],['detect']
Safety,"o that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeavesImpl(TBuffer& b); -- Unconfiguration Read Leave function. void ReadLeavesMakeClass(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void ReadLeavesCollection(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void ReadLeavesCollectionSplitPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionSplitVectorPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionMember(TBuffer& b); -- Read lea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:24279,detect,detect,24279,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,10,['detect'],['detect']
Safety,"o the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2203 of file TBufferFile.cxx. ◆ WriteFastArray() [5/15]. void TBufferFile::WriteFastArray ; (; const Int_t * ; ii, . Long64_t ; n . ). overridevirtual . Write array of n ints into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2096 of file TBufferFile.cxx. ◆ WriteFastArray() [6/15]. void TBufferFile::WriteFastArray ; (; const Long64_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n long longs into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2175 of file TBufferFile.cxx. ◆ WriteFastArray() [7/15]. void TBufferFile::WriteFastArray ; (; const Long_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n longs into the I/O buffer with 8-byte width. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2129 of file TBufferFile.cxx. ◆ WriteFastArray() [8/15]. void TBufferFile::WriteFastArray ; (; const Short_t * ; h, . Long64_t ; n . ). overridevirtual . Write array of n shorts into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:83316,abort,aborts,83316,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"o the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:987822,safe,safe,987822,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Safe', 'safe']","['Safe', 'safe']"
Safety,"o the next cluster and return the starting entry; 294 // of this next cluster; 295 Long64_t Next();; 296 ; 297 // Move on to the previous cluster and return the starting entry; 298 // of this previous cluster; 299 Long64_t Previous();; 300 ; 301 // Return the start entry of the current cluster.; 302 Long64_t GetStartEntry() {; 303 return fStartEntry;; 304 }; 305 ; 306 // Return the first entry of the next cluster.; 307 Long64_t GetNextEntry() {; 308 return fNextEntry;; 309 }; 310 ; 311 Long64_t operator()() { return Next(); }; 312 };; 313 ; 314 TTree();; 315 TTree(const char* name, const char* title, Int_t splitlevel = 99, TDirectory* dir = gDirectory);; 316 ~TTree() override;; 317 ; 318 TTree(const TTree& tt) = delete;; 319 TTree& operator=(const TTree& tt) = delete;; 320 ; 321 virtual Int_t AddBranchToCache(const char *bname, bool subbranches = false);; 322 virtual Int_t AddBranchToCache(TBranch *branch, bool subbranches = false);; 323 virtual Int_t DropBranchFromCache(const char *bname, bool subbranches = false);; 324 virtual Int_t DropBranchFromCache(TBranch *branch, bool subbranches = false);; 325 void AddClone(TTree*);; 326 virtual TFriendElement *AddFriend(const char* treename, const char* filename = """");; 327 virtual TFriendElement *AddFriend(const char* treename, TFile* file);; 328 virtual TFriendElement *AddFriend(TTree* tree, const char* alias = """", bool warn = false);; 329 // As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; 330 // manner only when we are flushing multiple baskets in parallel.; 331 virtual void AddTotBytes(Int_t tot) { if (fIMTFlush) { fIMTTotBytes += tot; } else { fTotBytes += tot; } }; 332 virtual void AddZipBytes(Int_t zip) { if (fIMTFlush) { fIMTZipBytes += zip; } else { fZipBytes += zip; } }; 333// NOTE: these counters aren't thread safe like the ones above.; 334#ifdef R__TRACK_BASKET_ALLOC_TIME; 335 void AddAllocationTime(ULong64_t time) { fAllocationTime += time; }; 336#endif; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:15336,safe,safe,15336,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['safe'],['safe']
Safety,"o use this option, the PYTHONPATH must be defined like export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/geom/gdml . Definition at line 3975 of file TGeoManager.cxx. ◆ FindDuplicateMaterial(). TGeoMaterial * TGeoManager::FindDuplicateMaterial ; (; const TGeoMaterial * ; mat); const. Find if a given material duplicates an existing one. ; Definition at line 2992 of file TGeoManager.cxx. ◆ FindNextBoundary(). TGeoNode * TGeoManager::FindNextBoundary ; (; Double_t ; stepmax = TGeoShape::Big(), . const char * ; path = """", . Bool_t ; frombdr = kFALSE . ). Find distance to next boundary and store it in fStep. ; Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX represent the step to be made imposed by other reasons than geometry (usually physics processes). Therefore in this case this method provides the answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling fStep with a big number. In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is specified, otherwise users have to call explicitly TGeoManager::Safety() if they want this computed for the current point. ; Definition at line 2755 of file TGeoManager.cxx. ◆ FindNextBoundaryAndStep(). TGeoNode * TGeoManager::FindNextBoundaryAndStep ; (; Double_t ; stepmax = TGeoShape::Big(), . Bool_t ; compsafe = kFALSE . ). Compute distance to next boundary within STEPMAX. ; If no boundary is found, propagate current point along current direction with fStep=STEPMAX. Otherwise propagate with fStep=SNEXT (distance to boundary) and locate/return the next node. ; Definition at line 2736 of file TGeoManager.cxx. ◆ FindNextDaughterBoundary(). TGeoNode * TGeoManager::FindNextDaughterBoundary ; (; Double_t * ; point, . Double_t * ; dir, . Int_t & ; idaughter, . Bool_t ; co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:85690,safe,safe,85690,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['safe'],['safe']
Safety,"o). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. void LoadText(const char* ) const; {;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void (*)() ) const; {;}. void SetAllocunlockfunc(void (*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int ) const; {;}. int UnloadFile(const char* ) const; {retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TInterpreter.html:20530,avoid,avoids,20530,root/html528/TInterpreter.html,https://root.cern,https://root.cern/root/html528/TInterpreter.html,6,['avoid'],['avoids']
Safety,"o, double hi)Request uniform smearing of sum of parameters in paramSet uniform smearing in range [lo,...Definition RooRandomizeParamMCSModule.cxx:124; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf803_mcstudy_addons2Definition rf803_mcstudy_addons2.py:1; ; [#0] WARNING:InputArguments -- The parameter 'wtop' with range [-inf, inf] of the RooGaussian 'sig' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 495; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 490; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 485; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 480; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 475; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 470; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 465; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 460; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 455; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 450; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 445; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 440; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 435; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 430; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 425; [#0] PROGRESS:Generation -- RooMCStudy::run: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html:7912,safe,safe,7912,doc/master/rf803__mcstudy__addons2_8C.html,https://root.cern,https://root.cern/doc/master/rf803__mcstudy__addons2_8C.html,1,['safe'],['safe']
Safety,"o. ; Reimplemented from RooAbsReal.; Definition at line 136 of file RooRealSumFunc.cxx. ◆ binBoundaries(). std::list< double > * RooRealSumFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Retrieve bin boundaries if this distribution is binned in obs. ; Parameters. [in]obsObservable to retrieve boundaries for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented from RooAbsReal.; Definition at line 142 of file RooRealSumFunc.cxx. ◆ canNodeBeCached(). CacheMode RooRealSumFunc::canNodeBeCached ; (; ); const. inlineoverridevirtual . Reimplemented from RooAbsArg.; Definition at line 58 of file RooRealSumFunc.h. ◆ checkObservables(). bool RooRealSumFunc::checkObservables ; (; const RooArgSet * ; nset); const. overridevirtual . Overloadable function in which derived classes can implement consistency checks of the variables. ; If this function returns true, indicating an error, the fitter or generator will abort. ; Reimplemented from RooAbsArg.; Definition at line 123 of file RooRealSumFunc.cxx. ◆ Class(). static TClass * RooRealSumFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooRealSumFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooRealSumFunc::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file RooRealSumFunc.h. ◆ clone(). TObject * RooRealSumFunc::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 33 of file RooRealSumFunc.h. ◆ coefList(). const RooArgList & RooRealSumFunc::coefList ; (; ); const. inline . Definition at line 45 of file RooRealSumFunc.h. ◆ compileForNormSet(). std::unique_ptr< RooAbsArg > RooRealSumFunc::compileForNormSet ; (; RooArgSet const & ; normSet, . RooFit::Detail::CompileContext & ; ctx . ); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:64196,abort,abort,64196,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['abort'],['abort']
Safety,"o; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8py.html:3298,safe,safe,3298,doc/master/rf506__msgservice_8py.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html,1,['safe'],['safe']
Safety,"oAbsPdf.; Definition at line 1746 of file RooProdPdf.cxx. ◆ initializeFromCmdArgList(). void RooProdPdf::initializeFromCmdArgList ; (; const RooArgSet & ; fullPdfSet, . const RooLinkedList & ; l . ). private . Initialize RooProdPdf configuration from given list of RooCmdArg configuration arguments and set of 'regular' p.d.f.s in product. ; Definition at line 290 of file RooProdPdf.cxx. ◆ IsA(). TClass * RooProdPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 190 of file RooProdPdf.h. ◆ isBinnedDistribution(). bool RooProdPdf::isBinnedDistribution ; (; const RooArgSet & ; obs); const. overridevirtual . If all components that depend on obs are binned that so is the product. ; Reimplemented from RooAbsReal.; Definition at line 2122 of file RooProdPdf.cxx. ◆ isDirectGenSafe(). bool RooProdPdf::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. overridevirtual . Forward determination of safety of internal generator code to component p.d.f that would generate the given observable. ; Reimplemented from RooAbsPdf.; Definition at line 1825 of file RooProdPdf.cxx. ◆ makeCondPdfRatioCorr(). std::unique_ptr< RooAbsReal > RooProdPdf::makeCondPdfRatioCorr ; (; RooAbsReal & ; term, . const RooArgSet & ; termNset, . const RooArgSet & ; termImpSet, . const char * ; normRange, . const char * ; refRange . ); const. private . For single normalization ranges. ; Definition at line 971 of file RooProdPdf.cxx. ◆ makeRGPPName(). std::string RooProdPdf::makeRGPPName ; (; const char * ; pfx, . const RooArgSet & ; term, . const RooArgSet & ; iset, . const RooArgSet & ; nset, . const char * ; isetRangeName . ); const. private . Make an appropriate automatic name for a RooGenProdProj object in getPartIntList() ; Definition at line 1555 of file RooProdPdf.cxx. ◆ pdfList(). const RooArgList & RooProdPdf::pdfList ; (; ); const. inline . Definition at line 67 of file RooProdPdf.h. ◆ plotSamplingHint(). std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:96699,safe,safety,96699,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['safe'],['safety']
Safety,"oAbsPdf::createNLL(), where the pdf and some configuration options are retrieved from the ModelConfig. ; The options taken from the ModelConfig are:. ConditionalObservables(); GlobalObservables(); ExternalConstraints(). Except for the options above, you can still pass all the other command arguments supported by RooAbsPdf::createNLL(). ; Definition at line 318 of file ModelConfig.h. ◆ createNLLImpl(). std::unique_ptr< RooAbsReal > RooStats::ModelConfig::createNLLImpl ; (; RooAbsData & ; data, . const RooLinkedList & ; cmdList . ); const. private . Definition at line 447 of file ModelConfig.cxx. ◆ DeclFileName(). static const char * RooStats::ModelConfig::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 368 of file ModelConfig.h. ◆ DefineSetInWS(). void RooStats::ModelConfig::DefineSetInWS ; (; const char * ; name, . const RooArgSet & ; set . ). protected . helper functions to define a set in the WS ; helper functions to avoid code duplication ; Definition at line 289 of file ModelConfig.cxx. ◆ fitTo(). template<typename... CmdArgs_t> . RooStats::ModelConfig::fitTo ; (; RooAbsData & ; data, . CmdArgs_t const &... ; cmdArgs . ). inline . Wrapper around RooAbsPdf::fitTo(), where the pdf and some configuration options are retrieved from the ModelConfig. ; See ModelConfig::createNLL() for more information. ; Definition at line 324 of file ModelConfig.h. ◆ fitToImpl(). std::unique_ptr< RooFitResult > RooStats::ModelConfig::fitToImpl ; (; RooAbsData & ; data, . const RooLinkedList & ; cmdList . ). private . Definition at line 461 of file ModelConfig.cxx. ◆ GetConditionalObservables(). const RooArgSet * RooStats::ModelConfig::GetConditionalObservables ; (; ); const. inline . get RooArgSet for conditional observables (return nullptr if not existing) ; Definition at line 289 of file ModelConfig.h. ◆ GetConstraintParameters(). const RooArgSet * RooStats::ModelConfig::GetConstraintParameters ; (; ); const. inline ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html:23453,avoid,avoid,23453,doc/master/classRooStats_1_1ModelConfig.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html,1,['avoid'],['avoid']
Safety,"oAddPdf(""bkg"", ""Signal"", [bkg1, bkg2], [bkg1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Print composite tree in ASCII; # -----------------------------------------------------------; ; # Print tree to stdout; model.Print(""t""); ; # Print tree to file; model.printCompactTree("""", ""rf206_asciitree.txt""); ; # Draw composite tree graphically; # -------------------------------------------------------------; ; # Print GraphViz DOT file with representation of tree; model.graphVizTree(""rf206_model.dot""); ; # Make graphic output file with one of the GraphViz tools; # (freely available from www.graphviz.org); #; # 'Top-to-bottom graph'; # unix> dot -Tgif -o rf207_model_dot.gif rf207_model.dot; #; # 'Spring-model graph'; # unix> fdp -Tgif -o rf207_model_fdp.gif rf207_model.dot; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x788d230 RooAddPdf::model = 0.602695/1 [Auto,Clean] ; 0x73f4730/V- RooAddPdf::bkg = 0.20539/1 [Auto,Clean] ; 0x793f3e0/V- RooChebychev::bkg1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7539e30/V- RooRealVar::a0 = 0.5; 0x7496810/V- RooRealVar::a1 = 0; 0x7353b80/V- RooRealVar::bkg1frac = 0.2; 0x792d390/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x7429310/V- RooRealVar::alpha = -1; 0x2ee1ac0/V- RooRealVar::bkgfrac = 0.5; 0x4d76f30/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7444460/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x71161c0/V- RooRealVar::x = 5; 0x6dbe690/V- RooRealVar::mean = 5; 0x3bcf160/V- RooRealVar::sigma1 = 0.5; 0x736e030/V- RooRealVar::sig1frac = 0.8; 0x7422370/V- R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8py.html:2673,safe,safe,2673,doc/master/rf206__treevistools_8py.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8py.html,1,['safe'],['safe']
Safety,"oAddPdf.h; RooChebychev.h; RooDataSet.h; RooExponential.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf206_treevistoolsDefinition rf206_treevistools.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7ffd18ff9e50 RooAddPdf::model = 0.582695/1 [Auto,Clean] ; 0x7ffd18ff8f60/V- RooAddPdf::bkg = 0.16539/1 [Auto,Clean] ; 0x7ffd18ff65f8/V- RooChebychev::bkg1 = 0.8 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff7bd8/V- RooRealVar::a0 = 0.5; 0x7ffd18ff7fc0/V- RooRealVar::a1 = 0.2; 0x7ffd18ff8790/V- RooRealVar::bkg1frac = 0.2; 0x7ffd18ff6b28/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff83a8/V- RooRealVar::alpha = -1; 0x7ffd18ff9a68/V- RooRealVar::bkgfrac = 0.5; 0x7ffd18ff5428/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7ffd18ff5b48/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff8b78/V- RooRealVar::mean = 5; 0x7ffd18ff702",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8C.html:3856,safe,safe,3856,doc/master/rf206__treevistools_8C.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8C.html,1,['safe'],['safe']
Safety,"oBinSamplingPdf.h:110; This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped, depending on the value of precision:; precision < 0.: None of the PDFs are touched, bin sampling is off.; precision = 0.: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision forwarded to the integrator is 1.E-4 (the default argument of the constructor).; precision > 0.: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are fit to (see next paragraph). The same ‘'precision’` is used for all integrators. Simulating a binned fit using RooDataSet; Some frameworks use unbinned data (RooDataSet) to simulate binned datasets. By adding one entry for each bin centre with the appropriate weight, one can achieve the same result as fitting with RooDataHist. In this case, however, RooFit cannot auto-detect that a binned fit is running, and that an integration over the bin is desired (note that there are no bins to integrate over in this kind of dataset).; In this case, IntegrateBins(>0.) needs to be used, and the desired binning needs to be assigned to the observable of the dataset: RooRealVar x(""x"", ""x"", 0., 5.);; x.setBins(10);; ; // <create dataset and model>; ; model.fitTo(data, IntegrateBins(>0.));; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; See alsoRooAbsPdf::fitTo() . IntegrateBins(); NoteThis feature is currently limited to one-dimensional PDFs.; . Binned fit without RooBinSamplingPdf Binned fit with RooBinSamplingPdf . Definition at line 28 of file RooBinSamplingPdf.h. Public Member Functions;  RooBinSamplingPdf ();  ;  RooBinSamplingPdf (const char *name, const char *title, RooAbsRealLValue &observable, RooAbsPdf &inputPdf, double epsilon=1.E-4);  Construct a new RooBinSamplingPdf. ;  ;  RooBinSamplingPdf (const RooBinSamplingPdf &other, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:3775,detect,detect,3775,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['detect'],['detect']
Safety,"oChecker Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TGeoChecker Class ReferenceThe Geometry Package » Geometry painter. ; Geometry checking package. ; TGeoChecker class provides several geometry checking methods. There are two types of tests that can be performed. One is based on random sampling or ray-tracing and provides a visual check on how navigation methods work for a given geometry. The second actually checks the validity of the geometry definition in terms of overlapping/extruding objects. Both types of checks can be done for a given branch (starting with a given volume) as well as for the geometry as a whole.; TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z); This method can be called directly from the TGeoManager class and print a report on how a given point is classified by the modeller: which is the full path to the deepest node containing it, and the (under)estimation of the distance to the closest boundary (safety).; TGeoChecker::RandomPoints(Int_t npoints); Can be called from TGeoVolume class. It first draws the volume and its content with the current visualization settings. Then randomly samples points in its bounding box, plotting in the geometry display only the points classified as belonging to visible volumes.; TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz); Can be called and acts in the same way as the previous, but instead of points, rays having random isotropic directions are generated from the given point. A raytracing algorithm propagates all rays until they exit geometry, plotting all segments crossing visible nodes in the same color as these.; TGeoChecker::Test(Int_t npoints); Implementation of TGeoManager::Test(). Computes the time for the modeller to find out ""Where am I?"" for a given number of ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:1168,safe,safety,1168,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety,"oChecker::CheckPoint ; (; Double_t ; x = 0, . Double_t ; y = 0, . Double_t ; z = 0, . Option_t * ; option = """", . Double_t ; safety = 0. . ). Draw point (x,y,z) over the picture of the daughters of the volume containing this point. ; Generates a report regarding the path to the node containing this point and the distance to the closest boundary. ; Definition at line 1692 of file TGeoChecker.cxx. ◆ CheckShape(). void TGeoChecker::CheckShape ; (; TGeoShape * ; shape, . Int_t ; testNo, . Int_t ; nsamples, . Option_t * ; option . ). Test for shape navigation methods. ; Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate directions randomly in cos(theta). Compute DistFromInside and move the point with bigger distance. Compute DistFromOutside back from new point. Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate directions randomly in cos(theta) and compute distance to boundary. Check if distance to boundary is bigger than safety . Definition at line 1752 of file TGeoChecker.cxx. ◆ CheckVoxels(). Double_t TGeoChecker::CheckVoxels ; (; TGeoVolume * ; vol, . TGeoVoxelFinder * ; voxels, . Double_t * ; xyz, . Int_t ; npoints . ). count voxel timing ; Definition at line 2967 of file TGeoChecker.cxx. ◆ Class(). static TClass * TGeoChecker::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoChecker::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoChecker::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TGeoChecker.h. ◆ CleanPoints(). void TGeoChecker::CleanPoints ; (; Double_t * ; points, . Int_t & ; numPoints . ); const. private . Number of points on mesh to be checked. ; Clean-up the mesh of pcon/pgon from useless points. ; Definition at line 992 of file TGeoChecker.cxx. ◆ DeclFileName(). static const char * TGeoChecker::Decl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:21975,safe,safety,21975,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safety']
Safety,"oEventEntries* map.; 374 /// In the single threaded case, the two numbers are the same as the entry range corresponds; 375 /// to the number of events in an individual file (each sample is simply a single file).; 376 /// In the multithreaded case, the idea is to accumulate the higher event entry value until; 377 /// the total number of events in a given file is reached.; 378 void registerNewSample(unsigned int /*slot*/, const ROOT::RDF::RSampleInfo &id); 379 {; 380 std::lock_guard<std::mutex> lock(fSampleNameToEventEntriesMutex);; 381 fSampleNameToEventEntries[id.AsString()] =; 382 std::max(id.EntryRange().second, fSampleNameToEventEntries[id.AsString()]);; 383 }; 384 ; 385 /// Thread-safe callback for RDataFrame.; 386 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the; 387 /// fPrintInterval). \param slot Ignored. \param value Ignored.; 388 template <typename T>; 389 void operator()(unsigned int /*slot*/, T &value); 390 {; 391 operator()(value);; 392 }; 393 // clang-format off; 394 /// Thread-safe callback for RDataFrame.; 395 /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; 396 /// \param value Ignored.; 397 // clang-format on; 398 template <typename T>; 399 void operator()(T & /*value*/); 400 {; 401 using namespace std::chrono;; 402 // ***************************************************; 403 // Warning: Here, everything needs to be thread safe:; 404 // ***************************************************; 405 fProcessedEvents += fIncrement;; 406 ; 407 // We only print every n seconds.; 408 if (duration_cast<seconds>(system_clock::now() - fLastPrintTime) < fPrintInterval) {; 409 return;; 410 }; 411 ; 412 // ***************************************************; 413 // Protected by lock from here:; 414 // ***************************************************; 415 if (!fPrintMutex.try_lock()); 416 return;; 417 std::lock_guard<std::mutex> l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:18735,safe,safe,18735,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['safe'],['safe']
Safety,"oFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:128939,recover,recover,128939,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['recover'],['recover']
Safety,"oFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:127284,recover,recover,127284,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['recover'],['recover']
Safety,"oManager *manager);  Geometry painter default constructor. ;  ;  ~TVirtualGeoPainter () override;  Geometry painter default destructor. ;  ; virtual void AddSize3D (Int_t numpoints, Int_t numsegs, Int_t numpolys)=0;  ; virtual TVirtualGeoTrack * AddTrack (Int_t id, Int_t pdgcode, TObject *particle)=0;  ; virtual void AddTrackPoint (Double_t *point, Double_t *box, Bool_t reset=kFALSE)=0;  ; virtual void BombTranslation (const Double_t *tr, Double_t *bombtr)=0;  ; virtual void CheckBoundaryErrors (Int_t ntracks=1000000, Double_t radius=-1.)=0;  ; virtual void CheckBoundaryReference (Int_t icheck=-1)=0;  ; virtual void CheckGeometry (Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const =0;  ; virtual void CheckGeometryFull (Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr)=0;  ; virtual void CheckOverlaps (const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const =0;  ; virtual void CheckPoint (Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)=0;  ; virtual void CheckShape (TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)=0;  ; virtual Int_t CountVisibleNodes ()=0;  ; virtual void DefaultAngles ()=0;  ; virtual void DefaultColors ()=0;  ; virtual Int_t DistanceToPrimitiveVol (TGeoVolume *vol, Int_t px, Int_t py)=0;  ; virtual void DrawBatemanSol (TGeoBatemanSol *sol, Option_t *option="""")=0;  ; virtual void DrawCurrentPoint (Int_t color)=0;  ; virtual void DrawOnly (Option_t *option="""")=0;  ; virtual void DrawOverlap (void *ovlp, Option_t *option="""")=0;  ; virtual void DrawPanel ()=0;  ; virtual void DrawPath (const char *path, Option_t *option="""")=0;  ; virtual void DrawPolygon (const TGeoPolygon *poly)=0;  ; virtual void DrawShape (TGeoShape *shape, Option_t *option="""")=0;  ; virtual void DrawVolume (TGeoVolume *vol, Option_t *option="""")=0;  ; virtual void EditGeometry (Option_t *option="""")=0;  ; virtual void EstimateCameraMove (Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualGeoPainter.html:2505,safe,safety,2505,doc/master/classTVirtualGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTVirtualGeoPainter.html,1,['safe'],['safety']
Safety,"oManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:132488,safe,safety,132488,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"oNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigator.cxx:2357; TGeoNavigator::cdBool_t cd(const char *path="""")Browse the tree of nodes starting from top node according to pathname.Definition TGeoNavigator.cxx:210; TGeoNavigator::IsSameLocationBool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change=kFALSE)Checks if point (x,y,z) is still in the current node.Definition TGeoNavigator.cxx:2446; TGeoNavigator::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoNavigator.h:238; TGeoNavigator::GetVirtualLevelInt_t GetVirtualLevel()Find level of virtuality of current overlapping node (number of levels up having the same tracking me...Definition TGeoNavigator.cxx:2331; TGeoNavigator::InitTrackTGeoNode * InitTrack(const Double_t *point, const Double_t *dir)Initialize current poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:224621,safe,safe,224621,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['safe'],['safe']
Safety,"oShape.; Reimplemented in TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoShapeAssembly, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, TGeoVGShape, TGeoCone, TGeoConeSeg, and TGeoScaledShape. ◆ Sizeof3D(). void TGeoBBox::Sizeof3D ; (; ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoXtru, and TGeoVGShape. ◆ Streamer(). void TGeoBBox::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru. ◆ StreamerNVirtual(). void TGeoBBox::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 99 of file TGeoBBox.h. Member Data Documentation. ◆ cases. Bool_t DO NOT USE !The overlap detection does not work for all TGeoBBox::cases. Definition at line 41 of file TGeoBBox.h. ◆ DEPRECATED. Bool_t TGeoBBox::DEPRECATED. Definition at line 41 of file TGeoBBox.h. ◆ fDX. Double_t TGeoBBox::fDX. protected . Definition at line 20 of file TGeoBBox.h. ◆ fDY. Double_t TGeoBBox::fDY. protected . Definition at line 21 of file TGeoBBox.h. ◆ fDZ. Double_t TGeoBBox::fDZ. protected . Definition at line 22 of file TGeoBBox.h. ◆ fOrigin. Double_t TGeoBBox::fOrigin[3]. protected . Definition at line 23 of file TGeoBBox.h. Libraries for TGeoBBox:. [legend]; The documentation for this class was generated from the following file:; geom/geom/inc/TGeoBBox.h. TGeoBBox. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:40065,detect,detection,40065,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['detect'],['detection']
Safety,"oading...; Searching...; No Matches. TBuffer.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 6da0b5b613bbcfaa3a5cd4074e7b2be2448dfb31 $; 2// Author: Fons Rademakers 04/05/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TBuffer; 13\ingroup Base; 14 ; 15Buffer base class used for serializing objects.; 16*/; 17 ; 18#include ""TBuffer.h""; 19#include ""TClass.h""; 20#include ""TProcessID.h""; 21 ; 22constexpr Int_t kExtraSpace = 8; // extra space at end of buffer (used for free block count); 23constexpr Int_t kMaxBufferSize = 0x7FFFFFFE; // largest possible size.; 24 ; 25 ; 26ClassImp(TBuffer);; 27 ; 28/// Default streamer implementation used by ClassDefInline to avoid; 29/// requirement to include TBuffer.h; 30void ROOT::Internal::DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer); 31{; 32 if (R__b.IsReading()); 33 R__b.ReadClassBuffer(cl, objpointer);; 34 else; 35 R__b.WriteClassBuffer(cl, objpointer);; 36}; 37 ; 38////////////////////////////////////////////////////////////////////////////////; 39/// The user has provided memory than we don't own, thus we can not extent it; 40/// either.; 41 ; 42static char *R__NoReAllocChar(char *, size_t, size_t); 43{; 44 return nullptr;; 45}; 46 ; 47////////////////////////////////////////////////////////////////////////////////; 48/// Create an I/O buffer object. Mode should be either TBuffer::kRead or; 49/// TBuffer::kWrite. By default the I/O buffer has a size of; 50/// TBuffer::kInitialSize (1024) bytes.; 51 ; 52TBuffer::TBuffer(EMode mode); 53{; 54 fBufSize = kInitialSize;; 55 fMode = mode;; 56 fVersion = 0;; 57 fParent = nullptr;; 58 ; 59 SetBit(kIsOwner)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:1121,avoid,avoid,1121,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['avoid'],['avoid']
Safety,"oat_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:10109,abort,abort,10109,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"obal histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; 1242 Double_t c2sq = c2 * c2;; 1243 for (Int_t i = 0; i < fNcells; ++i) { // Loop on cells (bins including underflows/overflows); 1244 UpdateBinContent(i, c1 * h1->RetrieveBinContent(i) + c2 * h2->RetrieveBinContent(i));; 1245 if (fSumw2.fN) {; 1246 fSumw2.fArray[i] = c1sq * h1->GetBinErrorSqUnchecked(i) + c2sq * h2->GetBinErrorSqUnchecked(i);; 1247 }; 1248 }; 1249 }; 1250 ; 1251 if (resetStats) {; 1252 // statistics need to be reset in case coefficient are negative; 1253 ResetStats();; 1254 }; 1255 else {; 1256 // update statistics (do here to avoid changes by SetBinContent) FIXME remove???; 1257 PutStats(s3);; 1258 SetEntries(nEntries);; 1259 }; 1260 ; 1261 return kTRUE;; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// Increment bin content by 1.; 1266/// Passing an out-of-range bin leads to undefined behavior; 1267 ; 1268void TH1::AddBinContent(Int_t); 1269{; 1270 AbstractMethod(""AddBinContent"");; 1271}; 1272 ; 1273////////////////////////////////////////////////////////////////////////////////; 1274/// Increment bin content by a weight w.; 1275/// Passing an out-of-range bin leads to undefined behavior; 1276 ; 1277void TH1::AddBinContent(Int_t, Double_t); 1278{; 1279 AbstractMethod(""AddBinContent"");; 1280}; 1281 ; 1282////////////////////////////////////////////////////////////////////////////////; 1283/// Sets the flag controlling the automatic add of histograms in memory; 1284///; 1285/// By default (fAddDirectory = kTRUE), histograms are automatic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:49871,avoid,avoid,49871,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"obal mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:27379,safe,safe,27379,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['safe'],['safe']
Safety,"obal mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize() [1/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; ROOT::Internal::TStringView ; str, . T & ; value . ). Definition at line 158 of file StringConv.hxx. ◆ FromHumanReadableSize() [2/2]. template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:34606,safe,safe,34606,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,1,['safe'],['safe']
Safety,"obal mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:34394,safe,safe,34394,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,2,['safe'],['safe']
Safety,"obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCone.html:2484,safe,safe,2484,root/html528/TGeoCone.html,https://root.cern,https://root.cern/root/html528/TGeoCone.html,4,['safe'],['safe']
Safety,"obj) {; 809 return subobj;; 810 }; 811 }; 812 }; 813 return nullptr;; 814}; 815 ; 816////////////////////////////////////////////////////////////////////////////////; 817/// Return pointer to object identified by namecycle.; 818///; 819/// namecycle has the format name;cycle; 820/// - name = * is illegal, cycle = * is illegal; 821/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 822///; 823/// examples:; 824/// - foo : get object named foo in memory; 825/// if object is not in memory, try with highest cycle from file; 826/// - foo;1 : get cycle 1 of foo on file; 827///; 828/// The retrieved object should in principle derive from TObject.; 829/// If not, the function TDirectory::GetObject should be called.; 830/// However, this function will still work for a non-TObject, providing that; 831/// the calling application cast the return type to the correct type (which; 832/// is the actual type of the object).; 833///; 834/// NOTE:; 835///; 836/// The method GetObject offer better protection and avoid the need; 837/// for any cast:; 838/// ~~~ {.cpp}; 839/// MyClass *obj;; 840/// directory->GetObject(""some object"",obj);; 841/// if (obj) { ... the object exist and inherits from MyClass ... }; 842/// ~~~; 843///; 844/// VERY IMPORTANT NOTE:; 845///; 846/// In case the class of this object derives from TObject but not; 847/// as a first inheritance, one must use dynamic_cast<>().; 848/// #### Example 1: Normal case:; 849/// ~~~ {.cpp}; 850/// class MyClass : public TObject, public AnotherClass; 851/// ~~~; 852/// then on return, one can do:; 853/// ~~~ {.cpp}; 854/// MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");; 855/// ~~~; 856/// #### Example 2: Special case:; 857/// ~~~ {.cpp}; 858/// class MyClass : public AnotherClass, public TObject; 859/// ~~~; 860/// then on return, one must do:; 861/// ~~~ {.cpp}; 862/// MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 863/// ~~~; 864/// Of course, dynamic_cast<> can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:29241,avoid,avoid,29241,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['avoid'],['avoid']
Safety,"obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:11111,timeout,timeout,11111,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,6,['timeout'],['timeout']
Safety,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMemberInspector.html:2302,avoid,avoid,2302,root/html528/TMemberInspector.html,https://root.cern,https://root.cern/root/html528/TMemberInspector.html,1,['avoid'],['avoid']
Safety,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMemberInspector.html:2302,avoid,avoid,2302,root/html530/TMemberInspector.html,https://root.cern,https://root.cern/root/html530/TMemberInspector.html,1,['avoid'],['avoid']
Safety,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMemberInspector.html:2302,avoid,avoid,2302,root/html532/TMemberInspector.html,https://root.cern,https://root.cern/root/html532/TMemberInspector.html,2,['avoid'],['avoid']
Safety,"object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. void * ReadObjectAny(const TClass* expectedClass); To read an object (non deriving from TObject) from the file. If expectedClass is not null, we checked that that actual class of; the object stored is suitable to be stored in a pointer pointing; to an object of class 'expectedClass'. We also adjust the value; of the returned address so that it is suitable to be cast (C-Style); a a pointer pointing to an object of class 'expectedClass'. So for example if the class Bottom inherits from Top and the object; stored is of type Bottom you can safely do:. TClass *TopClass = TClass::GetClass(""Top"");; Top *ptr = (Top*) key->ReadObjectAny( TopClass );; if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:15024,safe,safely,15024,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,10,['safe'],['safely']
Safety,"object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←. RooProofDriverSelector. TProofDraw; ←. TProofDrawEntryList. TProofDrawEventList. TProofDrawGraph. TProofDrawHist. TProofDrawListOfGraphs. TProofDrawListOfPolyMarkers3D. TProofDrawPolyMarker3D. TProofDrawProfile.  [more...]. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). Bool_t ProcessCut(Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelector.html:10241,abort,abort,10241,root/html602/TSelector.html,https://root.cern,https://root.cern/root/html602/TSelector.html,4,['abort'],['abort']
Safety,"object. The same prior is used; for all the TEfficiency objects. Example:; If you use cuts to select electrons which can originate from two different; processes, you can determine the selection efficiency for each process. The; overall selection efficiency is then the combined efficiency. The weights to be used in the; combination should be the probability that an; electron comes from the corresponding process. VI. Further operations; VI.1 Information about the internal histograms; The methods GetPassedHistogram and GetTotalHistogram; return a constant pointer to the internal histograms. They can be used to; obtain information about the internal histograms (e.g. the binning, number of passed / total events in a bin, mean values...).; One can obtain a clone of the internal histograms by calling GetCopyPassedHisto or GetCopyTotalHisto.; The returned histograms are completely independent from the current; TEfficiency object. By default, they are not attached to a directory to; avoid the duplication of data and the user is responsible for deleting them. Example:; //open a root file which contains a TEfficiency object; TFile* pFile = new TFile(""myfile.root"",""update"");; //get TEfficiency object with name ""my_eff""; TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");; //get clone of total histogram; TH1* clone = pEff->GetCopyTotalHisto();; //change clone...; //save changes of clone directly; clone->Write();; //or append it to the current directoy and write the file; //clone->SetDirectory(gDirectory);; //pFile->Wrtie();; //delete histogram object; delete clone;; clone = 0;. It is also possible to set the internal total or passed histogram by using the; methods SetPassedHistogram or; SetTotalHistogram.; In order to ensure the validity of the TEfficiency object, the consistency of the; new histogram and the stored histogram is checked. It sometimes might be; impossible to change the histograms in a consistent way. Therefore one can force; the replacement by passing the opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEfficiency.html:17436,avoid,avoid,17436,root/html602/TEfficiency.html,https://root.cern,https://root.cern/root/html602/TEfficiency.html,4,['avoid'],['avoid']
Safety,"ocation of ROOT and non-PCH-able glibc headers.; Fix parsing of definition for forward declared enums ROOT-7419; Pass CXXFLAGS to the PCH generator, to ensure platform consistency.; Work around linker assert when building with GCC on OS X (PR #68). PyROOT. Fix lookup of templated classes in namespace with arguments that have ‘std::’ in their name ROOT-7448; Use GetTrueTypeName() instead of GetFullTypeName(), as the latter loses namespaces; Strip down number of libraries linked to libPyROOT in order to reduce to the minimum the time needed to import the ROOT module. TFormula, TF1. Allow possibility to automatically normalize itself. If the function TF1::SetNormalized(true) is called, when evaluated, the function will return its value divided by its integral computed in the function range.; Added helper classes TF1NormSum, TF1Convolution.; Fix a bug in calling TF1::Update when changing the parameter values. Fix also the TF1Convolution.; Fix the caching of the parameters in TF1NormSum to avoid recomputing integrals for same parameter values.; Remove unwanted printout from Streamer method. RooFit. Fix for contour computations in RooMinimizer[ROOT-7290]. Dictionary Generation. Uniform style of warnings, use standard ROOT logging facilities rather than cout/cerr.; Do not add as autoparse keys stl classes, stl (nested) containers templated with plain old data or integers. Tree. TTreeReaderArray now supports vector<builtin-type>. Graphics. Fix file corruption in TTeXDump::DrawPolyMarker.; Make sure the line width used to draw #sqrt is always >=1. Release 6.04/04; Build System. Fix generation of PCH with CXX flags with spaces ROOT-7478; Implemented option ‘geocad’ with CMake making use of the OpenCASCADE software package.; Fix option ‘rpath’ for CMake and ensure that works for MacOSX 10.11. Core. Fix the location of include files in ROOTINCDIR/include instead of ROOTINCDIR ROOT-7537. Interpreter. Fix redirection ROOT-7053; Take the language and target options from the PCH ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:28086,avoid,avoid,28086,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['avoid'],['avoid']
Safety,"ocation, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:1955,abort,abort,1955,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,1,['abort'],['abort']
Safety,"ocation, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSelector(const TSelector&); TSelector&operator=(const TSelector&). Data Members; public:. enum EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:9080,Abort,Abort,9080,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,2,['Abort'],['Abort']
Safety,"ocket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUDPSocket.html:12917,timeout,timeout,12917,root/html534/TUDPSocket.html,https://root.cern,https://root.cern/root/html534/TUDPSocket.html,6,['timeout'],['timeout']
Safety,"ocks,; 1470/// number of free blocks.; 1471 ; 1472int TSystem::GetFsInfo(const char *, Long_t *, Long_t *, Long_t *, Long_t *); 1473{; 1474 AbstractMethod(""GetFsInfo"");; 1475 return 1;; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Return a user configured or systemwide directory to create; 1480/// temporary files in.; 1481 ; 1482const char *TSystem::TempDirectory() const; 1483{; 1484 AbstractMethod(""TempDirectory"");; 1485 return nullptr;; 1486}; 1487 ; 1488////////////////////////////////////////////////////////////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:47122,safe,safely,47122,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,2,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"ocumentation; TGeoPolygon(); Dummy constructor. TGeoPolygon(Int_t nvert); Default constructor. ~TGeoPolygon(); Destructor. Double_t Area() const; Computes area of the polygon in [length^2]. Bool_t Contains(Double_t* point) const; Check if a point given by X = point[0], Y = point[1] is inside the polygon. void ConvexCheck(); Check polygon convexity. void FinishPolygon(); Decompose polygon in a convex outscribed part and a list of daughter; polygons that have to be substracted to get the actual one. Bool_t IsRightSided(Double_t* point, Int_t ind1, Int_t ind2) const; Check if POINT is right-sided with respect to the segment defined by IND1 and IND2. Bool_t IsSegConvex(Int_t i1, Int_t i2 = -1) const; Check if a segment [0..fNvert-1] belongs to the outscribed convex pgon. Bool_t IsIllegalCheck() const; Check for illegal crossings between non-consecutive segments. void OutscribedConvex(); Compute indices for the outscribed convex polygon. Double_t Safety(Double_t* point, Int_t& isegment) const; Compute minimum distance from POINT to any segment. Returns segment index. void SetNextIndex(Int_t index = -1); Sets the next polygone index. If index<0 sets all indices consecutive; in increasing order. void SetXY(Double_t* x, Double_t* y); Set X/Y array pointer for the polygon and daughters. TGeoPolygon(); constructors. Int_t GetNvert() const; {return fNvert;}. Double_t * GetX(); {return fX;}. Double_t * GetY(); {return fY;}. Bool_t IsClockwise() const; {return !TObject::TestBit(kGeoACW);}. Bool_t IsConvex() const; {return TObject::TestBit(kGeoConvex);}. Bool_t IsFinished() const; {return TObject::TestBit(kGeoFinishPolygon);}. void SetConvex(Bool_t flag = kTRUE); {TObject::SetBit(kGeoConvex,flag);}. » Author: Mihaela Gheata 05/01/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TGeoPolygon.h 27466 2009-02-17 12:53:37Z brun $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPolygon.html:8614,Safe,Safety,8614,root/html532/TGeoPolygon.html,https://root.cern,https://root.cern/root/html532/TGeoPolygon.html,1,['Safe'],['Safety']
Safety,"od(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBoolNode.html:2422,safe,safe,2422,root/html534/TGeoBoolNode.html,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html,6,['safe'],['safe']
Safety,"od, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual Bool_tPaintComposite(Option_t* option = """") const; virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:14378,safe,safe,14378,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,2,['safe'],['safe']
Safety,"od; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodLikelihood.html:2570,recover,recovered,2570,root/html528/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html,8,['recover'],['recovered']
Safety,"od; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; ; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodLikelihood.html:2570,recover,recovered,2570,root/html534/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodLikelihood.html,2,['recover'],['recovered']
Safety,"odel parameters; params = model.getParameters({x}); ; # Save snapshot of prefit parameters; initParams = params.snapshot(); ; # Do fit to data, obtain error estimates on parameters; data = model.generate({x}, 1000); model.fitTo(data, PrintLevel=-1); ; # Print LateX table of parameters of pdf; # --------------------------------------------------------------------------; ; # Print parameter list in LaTeX for (one column with names, column with; # values); params.printLatex(); ; # Print parameter list in LaTeX for (names values|names values); params.printLatex(Columns=2); ; # Print two parameter lists side by side (name values initvalues); params.printLatex(Sibling=initParams); ; # Print two parameter lists side by side (name values initvalues|name; # values initvalues); params.printLatex(Sibling=initParams, Columns=2); ; # Write LaTex table to file; params.printLatex(Sibling=initParams, OutputFile=""rf407_latextables.tex""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.5\pm 0.2$\\; $\verb+a1+ $ & $ 0.3\pm 0.1$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.46\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.79\pm 0.05$",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf407__latextables_8py.html:3059,safe,safe,3059,doc/master/rf407__latextables_8py.html,https://root.cern,https://root.cern/doc/master/rf407__latextables_8py.html,1,['safe'],['safe']
Safety,"of TH1/2/3 into this RooDataHist. ; The category indexCat labels the sources in the constructed RooDataHist. The stl map provides the mapping between the indexCat state labels and the import source ; Definition at line 497 of file RooDataHist.cxx. ◆ initialize(). void RooDataHist::initialize ; (; const char * ; binningName = nullptr, . bool ; fillTree = true . ). protected . Initialization procedure: allocate weights array, calculate multipliers needed for N-space to 1-dim array jump table, and fill the internal tree with all bin center coordinates. ; Definition at line 783 of file RooDataHist.cxx. ◆ initializeAsymErrArrays(). void RooDataHist::initializeAsymErrArrays ; (; ); const. private . Definition at line 1551 of file RooDataHist.cxx. ◆ interpolateDim(). double RooDataHist::interpolateDim ; (; int ; iDim, . double ; xval, . size_t ; centralIdx, . int ; intOrder, . bool ; correctForBinSize, . bool ; cdfBoundaries . ). protected . Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim' at current value 'xval'. ; Parameters. [in]iDimIndex of the histogram dimension along which to interpolate. ; [in]xvalValue of histogram variable at dimension iDim for which we want to interpolate the histogram weight. ; [in]centralIdxIndex of the bin that the point at which we interpolate the histogram weight falls into (can be obtained with RooDataHist::calcTreeIndex). ; [in]intOrderInterpolation order, i.e. how many neighbouring bins are used for the interpolation. ; [in]correctForBinSizeEnable the inverse bin volume correction factor. ; [in]cdfBoundariesEnable the special boundary condition for a cdf: underflow bins are assumed to have weight zero and overflow bins have weight one. Otherwise, the histogram is mirrored at the boundaries for the interpolation. . Definition at line 1638 of file RooDataHist.cxx. ◆ interpolateLinear(). void RooDataHist::interpolateLinear ; (; double * ; output, . std::span< const double > ; xVals, . bool ; correctForBinSize, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:63028,safe,safe,63028,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['safe'],['safe']
Safety,"of file TGeoParaboloid.h. ◆ InspectShape(). void TGeoParaboloid::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoParaboloid::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoParaboloid.h. ◆ IsCylType(). Bool_t TGeoParaboloid::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 66 of file TGeoParaboloid.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoParaboloid::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoParaboloid & TGeoParaboloid::operator= ; (; const TGeoParaboloid & ; ). privatedelete . ◆ Safety(). Double_t TGeoParaboloid::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoParaboloid::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoParaboloid::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoParaboloid::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetParaboloidDimensions(). void TGeoParaboloid::SetParaboloidDimensions ; (; Double_t ; rlo, . Double_t ; rhi, . Double_t ; dz . ). ◆ SetPoints() [1/2]. void TGeoParaboloid::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoParaboloid::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetSegsAndPols(). void TGeoParaboloid::SetSegsAndPols ; (; TBuffer3D & ; buff); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Sizeof3D(). void TGeoPara",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:28592,safe,safe,28592,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['safe'],['safe']
Safety,"of file TGeoPcon.h. ◆ IsCylType(). Bool_t TGeoPcon::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 91 of file TGeoPcon.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoPcon::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ operator=(). TGeoPcon & TGeoPcon::operator= ; (; const TGeoPcon & ; ). protecteddelete . ◆ Phi1(). Double_t & TGeoPcon::Phi1 ; (; ). inline . Definition at line 93 of file TGeoPcon.h. ◆ Rmax(). Double_t & TGeoPcon::Rmax ; (; Int_t ; ipl). inline . Definition at line 96 of file TGeoPcon.h. ◆ Rmin(). Double_t & TGeoPcon::Rmin ; (; Int_t ; ipl). inline . Definition at line 95 of file TGeoPcon.h. ◆ Safety(). Double_t TGeoPcon::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ Safety_v(). void TGeoPcon::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SafetyToSegment(). Double_t TGeoPcon::SafetyToSegment ; (; const Double_t * ; point, . Int_t ; ipl, . Bool_t ; in = kTRUE, . Double_t ; safmin = TGeoShape::Big() . ); const. ◆ SavePrimitive(). void TGeoPcon::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetDimensions(). void TGeoPcon::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetPoints() [1/2]. void TGeoPcon::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ SetPoints() [2/2]. void TGeoPcon::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoPgon. ◆ Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPcon.html:31740,safe,safe,31740,doc/master/classTGeoPcon.html,https://root.cern,https://root.cern/doc/master/classTGeoPcon.html,1,['safe'],['safe']
Safety,"of file TGeoXtru.h. ◆ GetZ() [2/2]. Double_t TGeoXtru::GetZ ; (; Int_t ; ipl); const. ◆ InspectShape(). void TGeoXtru::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoXtru::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 121 of file TGeoXtru.h. ◆ IsPointInsidePlane(). Bool_t TGeoXtru::IsPointInsidePlane ; (; const Double_t * ; point, . Double_t * ; vert, . Double_t * ; norm . ); const. protected . ◆ MakeBuffer3D(). TBuffer3D * TGeoXtru::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ operator=(). TGeoXtru & TGeoXtru::operator= ; (; const TGeoXtru & ; ). protecteddelete . ◆ Safety(). Double_t TGeoXtru::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoXtru::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SafetyToSector(). Double_t TGeoXtru::SafetyToSector ; (; const Double_t * ; point, . Int_t ; iz, . Double_t ; safmin, . Bool_t ; in . ). protected . ◆ SavePrimitive(). void TGeoXtru::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetCurrentVertices(). void TGeoXtru::SetCurrentVertices ; (; Double_t ; x0, . Double_t ; y0, . Double_t ; scale . ). ◆ SetCurrentZ(). void TGeoXtru::SetCurrentZ ; (; Double_t ; z, . Int_t ; iz . ). ◆ SetDimensions(). void TGeoXtru::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetIz(). void TGeoXtru::SetIz ; (; Int_t ; iz). protected . ◆ SetPoints() [1/2]. void TGeoXtru::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoXtru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:30217,safe,safe,30217,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['safe'],['safe']
Safety,"of file TUnixSystem.cxx. ◆ UnixRecv(). int TUnixSystem::UnixRecv ; (; int ; sock, . void * ; buffer, . int ; length, . int ; flag . ). staticprotected . Receive exactly length bytes into buffer. ; Returns number of bytes received. Returns -1 in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4508 of file TUnixSystem.cxx. ◆ UnixResetSignal(). void TUnixSystem::UnixResetSignal ; (; ESignals ; sig). staticprotected . Restore old signal handler for specified signal. ; Definition at line 3821 of file TUnixSystem.cxx. ◆ UnixResetSignals(). void TUnixSystem::UnixResetSignals ; (; ). staticprotected . Restore old signal handlers. ; Definition at line 3836 of file TUnixSystem.cxx. ◆ UnixSelect(). int TUnixSystem::UnixSelect ; (; Int_t ; nfds, . TFdSet * ; readready, . TFdSet * ; writeready, . Long_t ; timeout . ). staticprotected . Wait for events on the file descriptors specified in the readready and writeready masks or for timeout (in milliseconds) to occur. ; Returns the number of ready descriptors, or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR the errno has been reset and the method can be called again. ; Definition at line 3901 of file TUnixSystem.cxx. ◆ UnixSend(). int TUnixSystem::UnixSend ; (; int ; sock, . const void * ; buffer, . int ; length, . int ; flag . ). staticprotected . Send exactly length bytes from buffer. ; Returns -1 in case of error, otherwise number of sent bytes. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 4558 of file TUnixSystem.cxx. ◆ UnixSetitimer(). int TUnixSystem::UnixSetitimer ; (; Long_t ; ms). staticprotected . Set interval timer to time-out in ms milliseconds. ; Definition at line 3875 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:74809,timeout,timeout,74809,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety,"of last bin (not included in last bin) . Definition at line 697 of file TH1.cxx. ◆ TH1() [4/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . const Float_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type float. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type float and size nbins+1 . Definition at line 719 of file TH1.cxx. ◆ TH1() [5/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . const Double_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbins+1 . Definition at line 741 of file TH1.cxx. ◆ ~TH1(). TH1::~TH1 ; (; ). override . Histogram default destructor. ; Definition at line 643 of file TH1.cxx. Member Function Documentation. ◆ Add() [1/3]. Bool_t TH1::Add ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1 . ). virtual . Replace contents of this histogram by the addition of h1 and h2. ; this = c1*h1 + c2*h2 if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.; Note also that adding histogram with labels is not supported, histogram will be added merging them by bin number indep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:73632,avoid,avoid,73632,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['avoid'],['avoid']
Safety,"of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). char & operator[](Ssiz_t i). Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TString.h 39166 2011-05-12 09:37:06Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSubString.html:2560,detect,detecting,2560,root/html530/TSubString.html,https://root.cern,https://root.cern/root/html530/TSubString.html,1,['detect'],['detecting']
Safety,"of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). char & operator[](Ssiz_t i). Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TString.h 40340 2011-07-23 16:57:07Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSubString.html:2560,detect,detecting,2560,root/html532/TSubString.html,https://root.cern,https://root.cern/root/html532/TSubString.html,2,['detect'],['detecting']
Safety,"of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (that’s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a pointer to either thread specific data (TSD) or the main thread pointer. This mechanism works currently only for gPad, gDirectory, gFile and will be implemented soon for other global Objects as e.g. gVirtualX.; 23.2.4.4 Canceling a TThread; Canceling of a thread is a rather dangerous action. In TThread canceling is forbidden by default. The user can change this default by calling TThread::SetCancelOn(). There are two cancellation modes: deferred and asynchronous.; 23.2.4.5 Deferred; Set by TThread::SetCancelDeferred() (default): When the user knows safe places in their code where a thread can be canceled without risk for the rest of the system, they can define these points by invoking TThread::CancelPoint(). Then, if a thread is canceled, the cancellation is deferred up to the call of TThread::CancelPoint() and then the thread is canceled safely. There are some default cancel points for pthreads implementation, e.g. any call of the TCondition::Wait(), TCondition::TimedWait(), TThread::Join().; 23.2.4.6 Asynchronous; Set by TThread::SetCancelAsynchronous(): If the user is sure that their application is cancel safe, they could call:; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; To cancel a thread TThread* th call:; th->Kill();; To cancel by thread name:; TThread::Kill(name);; To cancel a thread by ID:; TThread::Kill(tid);; To cancel a thread and delete th when cancel finished:; th->Delete();; Deleting of the thread instance by the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1111699,safe,safe,1111699,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,"['risk', 'safe']","['risk', 'safe']"
Safety,"of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2096 of file TBufferFile.cxx. ◆ WriteFastArray() [6/15]. void TBufferFile::WriteFastArray ; (; const Long64_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n long longs into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2175 of file TBufferFile.cxx. ◆ WriteFastArray() [7/15]. void TBufferFile::WriteFastArray ; (; const Long_t * ; ll, . Long64_t ; n . ). overridevirtual . Write array of n longs into the I/O buffer with 8-byte width. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2129 of file TBufferFile.cxx. ◆ WriteFastArray() [8/15]. void TBufferFile::WriteFastArray ; (; const Short_t * ; h, . Long64_t ; n . ). overridevirtual . Write array of n shorts into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2063 of file TBufferFile.cxx. ◆ WriteFastArray() [9/15]. void TBufferFile::WriteFastArray ; (; const UChar_t * ; c, . Long64_t ; n . ). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 517 of file TBufferFile.h. ◆ WriteFastArray() [10/15]. void TBufferFile::WriteFastArray ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:83805,abort,aborts,83805,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf206_treevistoolsDefinition rf206_treevistools.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7ffd18ff9e50 RooAddPdf::model = 0.582695/1 [Auto,Clean] ; 0x7ffd18ff8f60/V- RooAddPdf::bkg = 0.16539/1 [Auto,Clean] ; 0x7ffd18ff65f8/V- RooChebychev::bkg1 = 0.8 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff7bd8/V- RooRealVar::a0 = 0.5; 0x7ffd18ff7fc0/V- RooRealVar::a1 = 0.2; 0x7ffd18ff8790/V- RooRealVar::bkg1frac = 0.2; 0x7ffd18ff6b28/V- RooExponential::bkg2 = 0.00673795 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff83a8/V- RooRealVar::alpha = -1; 0x7ffd18ff9a68/V- RooRealVar::bkgfrac = 0.5; 0x7ffd18ff5428/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7ffd18ff5b48/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0x7ffd18ff8b78/V- RooRealVar::mean = 5; 0x7ffd18ff7020/V- RooRealVar::sigma1 = 0.5; 0x7ffd18ff77f0/V- RooRealVar::sig1frac = 0.8; 0x7ffd18ff60a0/V- RooGaussian::sig2 = 1 [Auto,Dirty] ; 0x7ffd18ff9680/V- RooRealVar::x = 5; 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf206__treevistools_8C.html:4023,safe,safe,4023,doc/master/rf206__treevistools_8C.html,https://root.cern,https://root.cern/doc/master/rf206__treevistools_8C.html,1,['safe'],['safe']
Safety,"of the rotated axes:;   Double_t tx,ty,tz,px,py,pz;;   tx= a.ThetaX();;   ...;   pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object ; to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using ; SetXEulerAngles() or individually set with SetXPhi(), ; SetXTheta(), and SetXPsi(). These routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotation a,b;;   ...;   b = a.Inverse();  // b is inverse of a, a is unchanged;   b = a.Invert();   // invert a and set b = a. Compound Rotations; The operator * has been implemented in a way that follows the ; mathematical notation of a product of the two matrices which describe the ; two consecutive rotations. Therefore the second rotation should be placed ; first:;   r = r2 * r1;. Rotation of TVector3; The TRotation class provides an operator * which allows to express; a rotation of a TVector3 analog to the mathematical notation;   | x' |   |",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRotation.html:4191,recover,recover,4191,root/html528/TRotation.html,https://root.cern,https://root.cern/root/html528/TRotation.html,6,['recover'],['recover']
Safety,"of::Collect ; (; TMonitor * ; mon, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from the slave servers. ; Returns the number of messages received. Can be 0 if there are no active slaves. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. Collect also stops its execution from time to time to check for new workers in Dynamic Startup mode. ; Definition at line 2756 of file TProof.cxx. ◆ CollectInputFrom(). Int_t TProof::CollectInputFrom ; (; TSocket * ; s, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect and analyze available input from socket s. ; Returns 0 on success, -1 if any failure occurs. ; Definition at line 3060 of file TProof.cxx. ◆ CreateDrawFeedback(). TDrawFeedback * TProof::CreateDrawFeedback ; (; ). Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Definition at line 10094 of file TProof.cxx. ◆ CreateMerger(). Bool_t TProof::CreateMerger ; (; TSlave * ; sl, . Int_t ; port . ). private . Create a new merger. ; Definition at line 4454 of file TProof.cxx. ◆ CreateSlave(). TSlave * TProof::CreateSlave ; (; const char * ; url, . const char * ; ord, . Int_t ; perf, . const char * ; image, . const char * ; workdir . ). protected . Create a new TSlave of type TSlave::kSlave. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this function to create slaves. ; Definition at line 1853 of file TProof.cxx. ◆ CreateSubmaster(). TSlave * TProof::CreateSubmaster ; (; const char * ; url, . const char * ; ord, . const char * ; image, . const char * ; msd, . Int_t ; nwk = 1 . ). protected . Create a new TSlave of type TSlave::kMaster. ; Note: creation of TSlave is private with TProof as a friend. Derived classes must use this function to create slaves. ; Definition at line 18",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:79334,avoid,avoids,79334,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['avoid'],['avoids']
Safety,"ofProgressStatus*, TList**); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFailedPackets(TList* list); virtual voidSetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidSetProgressStatus(TProofProgressStatus* st); voidSetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPacketizer.html:5711,abort,abort,5711,root/html528/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html528/TVirtualPacketizer.html,1,['abort'],['abort']
Safety,"off; 1323/**; 1324\class ROOT::VecOps::RVec; 1325\brief A ""std::vector""-like collection of values implementing handy operation to analyse them; 1326\tparam T The type of the contained objects; 1327 ; 1328A RVec is a container designed to make analysis of values' collections fast and easy.; 1329Its storage is contiguous in memory and its interface is designed such to resemble to the one; 1330of the stl vector. In addition the interface features methods and; 1331[external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; 1332of the data in the RVec.; 1333 ; 1334\note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; 1335are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; 1336- RVecB (`bool`); 1337- RVecC (`char`); 1338- RVecD (`double`); 1339- RVecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; 1355\endhtmlonly; 1356 ; 1357## Table of Contents; 1358- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:46614,safe,safe,46614,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['safe'],['safe']
Safety,"ogram in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2331 of file TBufferFile.cxx. ◆ WriteFastArrayFloat16(). void TBufferFile::WriteFastArrayFloat16 ; (; const Float_t * ; f, . Long64_t ; n, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write array of n floats (as truncated float) into the I/O buffer. ; see comments about Float16_t encoding at TBufferFile::WriteFloat16 NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Definition at line 2265 of file TBufferFile.cxx. ◆ WriteFastArrayString(). void TBufferFile::WriteFastArrayString ; (; const Char_t * ; c, . Long64_t ; n . ). overridevirtual . Write array of n characters into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2033 of file TBufferFile.cxx. ◆ WriteFloat(). void TBufferFile::WriteFloat ; (; Float_t ; f). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 349 of file TBufferFile.h. ◆ WriteFloat16(). void TBufferFile::WriteFloat16 ; (; Float_t * ; f, . TStreamerElement * ; elem = nullptr . ). overridevirtual . Write a Float16_t to the buffer. ; The following cases are supported for streaming a Float16_t type depending on the range declaration in the comment field of the data member: . Case Example . A Float16_t fNormal; . B Float16_t fTemperature; //[0,100] . C Float16_t fCharge; //[-1,1,2] . D Float16_t fVertex[3]; //[-30,30,10] . E Float16_t fChi2; //[0,0,6] . F Int_t fNsp;; Float16_t* fPointValue; //[fNsp][0,3] . In case A fNormal is converted f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:88670,abort,aborts,88670,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"oid Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:9054,avoid,avoid,9054,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,5,['avoid'],['avoid']
Safety,oid* TGeoParallelWorld::fBoundingBoxes = nullptr. protected . stores bounding boxes serving a quick safety candidates (to be used with the VoxelGrid and SafetyVoxelInfo) ; Definition at line 54 of file TGeoParallelWorld.h. ◆ fBVH. void* TGeoParallelWorld::fBVH = nullptr. protected . array of physical nodes ; Definition at line 49 of file TGeoParallelWorld.h. ◆ fGeoManager. TGeoManager* TGeoParallelWorld::fGeoManager. protected . Definition at line 41 of file TGeoParallelWorld.h. ◆ fIsClosed. Bool_t TGeoParallelWorld::fIsClosed. protected . Definition at line 44 of file TGeoParallelWorld.h. ◆ fLastState. TGeoPhysicalNode* TGeoParallelWorld::fLastState. protected . helper volume ; Definition at line 46 of file TGeoParallelWorld.h. ◆ fPaths. TObjArray* TGeoParallelWorld::fPaths. protected . Definition at line 42 of file TGeoParallelWorld.h. ◆ fPhysical. TObjArray* TGeoParallelWorld::fPhysical. protected . Last PN touched. ; Definition at line 47 of file TGeoParallelWorld.h. ◆ fSafetyCandidateStore. std::vector<unsigned int> TGeoParallelWorld::fSafetyCandidateStore {}. protected . A regular 3D cache layer for fast point-based safety lookups. ; Definition at line 52 of file TGeoParallelWorld.h. ◆ fSafetyVoxelCache. TGeoVoxelGrid<SafetyVoxelInfo>* TGeoParallelWorld::fSafetyVoxelCache. protected . Initial value:=; nullptr. BVH helper structure for safety and navigation. ; Definition at line 50 of file TGeoParallelWorld.h. ◆ fUseOverlaps. Bool_t TGeoParallelWorld::fUseOverlaps. protected . Definition at line 43 of file TGeoParallelWorld.h. ◆ fVolume. TGeoVolume* TGeoParallelWorld::fVolume. protected . Closed flag. ; Definition at line 45 of file TGeoParallelWorld.h. Libraries for TGeoParallelWorld:. [legend]; The documentation for this class was generated from the following files:; geom/geom/inc/TGeoParallelWorld.h; geom/geom/src/TGeoParallelWorld.cxx. TGeoParallelWorld. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:07 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:29169,safe,safety,29169,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,2,['safe'],['safety']
Safety,"oid* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReady(TSocket* sock)SIGNAL ; virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TSocket* sock); virtual voidRemoveAll(); voidTObject::ResetBit(UInt_t f); voidResetInterrupt(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TSocket*Select(); TSocket*Select(Long_t timeout); Int_tSelect(TList* rdready, TList* wrready, Long_t timeout); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInterest(TSocket* sock, Int_t interest = kRead); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMonitor.html:7460,timeout,timeout,7460,root/html534/TMonitor.html,https://root.cern,https://root.cern/root/html534/TMonitor.html,4,['timeout'],['timeout']
Safety,"oid* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual Bool_tPaintComposite(Option_t* option = """") const; virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:14533,Safe,SafetySeg,14533,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,1,['Safe'],['SafetySeg']
Safety,"oid* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerMulti.html:5826,abort,abort,5826,root/html602/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html602/TPacketizerMulti.html,4,['abort'],['abort']
Safety,"oid*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TWebFile&operator=(const TWebFile&); virtual voidTFile::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFile::Print(Option_t* option = """") const; virtual voidTDirectoryFile::Purge(Short_t nkeep = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectoryFile::ReadAll(Option_t* option = """"); virtual Bool_tReadBuffer(char* buf, Int_t len); virtual Bool_tReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Bool_tTFile::ReadBufferAsync(Long64_t offs, Int_t len); virtual Bool_tReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); virtual voidTFile::ReadFree(); virtual Int_tTDirectoryFile::ReadKeys(Bool_t forceRead = kTRUE); virtual TProcessID*TFile::ReadProcessID(UShort_t pidf); virtual voidTFile::ReadStreamerInfo(); virtual Int_tTDirectoryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:10862,Recover,Recover,10862,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,2,['Recover'],['Recover']
Safety,"oidRedirectOutput(Bool_t on = kTRUE); virtual Int_tTProofPlayer::ReinitSelector(TQueryResult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerRemote.html:10774,abort,abort,10774,root/html530/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html530/TProofPlayerRemote.html,12,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"oidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVirtualProofPlayer(); TVirtualProofPlayer(const TVirtualProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualProofPlayer.html:10073,timeout,timeout,10073,root/html602/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualProofPlayer.html,2,['timeout'],['timeout']
Safety,"oidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayer(TProof* proof = 0); TProofPlayer(const TProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayer.html:10505,timeout,timeout,10505,root/html604/TProofPlayer.html,https://root.cern,https://root.cern/root/html604/TProofPlayer.html,2,['timeout'],['timeout']
Safety,"oidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:10606,timeout,timeout,10606,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,2,['timeout'],['timeout']
Safety,"oidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:10801,timeout,timeout,10801,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,1,['timeout'],['timeout']
Safety,"oidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleCheckFile(TMessage* mess); virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. voidExecLogon(); Int_tSendCanvases(); Int_tSetup(). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplicationServer.html:10999,abort,abort,10999,root/html528/TApplicationServer.html,https://root.cern,https://root.cern/root/html528/TApplicationServer.html,6,['abort'],['abort']
Safety,"oidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleCheckFile(TMessage* mess); virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. voidExecLogon(); Int_tSendCanvases(); Int_tSetup(). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDelete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:10908,abort,abort,10908,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,1,['abort'],['abort']
Safety,"oidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterTree&operator=(const TEventIterTree&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterTree.html:4626,abort,abort,4626,root/html530/TEventIterTree.html,https://root.cern,https://root.cern/root/html530/TEventIterTree.html,3,['abort'],['abort']
Safety,"oidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterUnit&operator=(const TEventIterUnit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterUnit.html:4610,abort,abort,4610,root/html530/TEventIterUnit.html,https://root.cern,https://root.cern/root/html530/TEventIterUnit.html,3,['abort'],['abort']
Safety,"oiding memory fragmentation and memory growth and improving the performance by orders of magnitude. Every time the memory of the TClonesArray has to be reused, the Clear() method is used. To provide its benefits, each TClonesArray must be allocated once per process and disposed of (deleted) only when not needed any more.; So a job should see only one deletion for each TClonesArray, which should be Clear()ed during the job several times. Deleting a TClonesArray is a double waste. Not only you do not avoid memory fragmentation, but you worsen it because the TClonesArray itself is a rather heavy structure, and there is quite some code in the destructor, so you have more memory fragmentation and slower code. NOTE 2; When investigating misuse of TClonesArray, please make sure of the following:. Use Clear() or Clear(""C"") instead of Delete(). This will improve program execution time.; TClonesArray object classes containing pointers allocate memory. To avoid causing memory leaks, special Clear(""C"") must be used for clearing TClonesArray. When option ""C"" is specified, ROOT automatically executes the Clear() method (by default it is empty contained in TObject). This method must be overridden in the relevant TClonesArray object class, implementing the reset procedure for pointer objects.; If the objects are added using the placement new then the Clear must deallocate the memory.; If the objects are added using TClonesArray::ConstructedAt then the heap-based memory can stay allocated and reused as the constructor is not called for already constructed/added object.; To reduce memory fragmentation, please make sure that the TClonesArrays are not destroyed and created on every event. They must only be constructed/destructed at the beginning/end of the run. . Definition at line 29 of file TClonesArray.h. Public Types; enum  EStatusBits { kBypassStreamer = (1ULL << ( 12 )); , kForgetBits = (1ULL << ( 15 )); };  Saved copies of pointers to objects. More...;  ;  Public Types inherited",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:4166,avoid,avoid,4166,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['avoid'],['avoid']
Safety,"oid DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistToParaboloid (const Double_t *point, const Double_t *dir, Bool_t in) const;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Double_t GetDz () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; Double_t GetRhi () const;  ; Double_t GetRlo () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetParaboloidDimensions (Double_t rlo, Double_t rhi, Double_t dz);  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:2873,safe,safe,2873,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,1,['safe'],['safe']
Safety,"oid ParameterGradient (double x, const double *p, double *grad) const;  Evaluate the derivatives of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ; virtual std::string ParameterName (unsigned int i) const;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ;  Public Member Functions inherited from ROOT::Math::IGradientFunctionOneDim; double Derivative (const double *x) const;  Compatibility method with multi-dimensional interface for partial derivative. ;  ; double Derivative (double x) const;  Return the derivative of the function at a point x Use the private method DoDerivative. ;  ; void FdF (const double *x, double &f, double *df) const;  Compatibility method with multi-dimensional interface for Gradient and function evaluation. ;  ; void Gradient (const double *x, double *g) const;  Compatibility method with multi-dimensional interface for Gradient. ;  ; bool HasGradient () const override;  . Private Member Functions; double DoDerivative (double x) const override;  Function to evaluate the derivative with respect each coordinate. To be implemented by the derived class. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html:5637,avoid,avoid,5637,doc/master/classROOT_1_1Math_1_1Polynomial.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Polynomial.html,1,['avoid'],['avoid']
Safety,"oid ProcessOptions ();  process user options reference cut value to distinguish signal-like from background-like events ;  ; Double_t TransformLikelihoodOutput (Double_t ps, Double_t pb) const;  returns transformed or non-transformed output ;  . Private Attributes; Int_t fAverageEvtPerBin;  average events per bin; used to calculate fNbins ;  ; Int_t * fAverageEvtPerBinVarB;  average events per bin; used to calculate fNbins ;  ; Int_t * fAverageEvtPerBinVarS;  average events per bin; used to calculate fNbins ;  ; TString fBorderMethodString;  the method to take care about ""border"" effects (string) ;  ; PDF * fDefaultPDFLik;  pdf that contains default definitions ;  ; Int_t fDropVariable;  for ranking test ;  ; Double_t fEpsilon;  minimum number of likelihood (to avoid zero) ;  ; std::vector< TH1 * > * fHistBgd;  background PDFs (histograms) ;  ; std::vector< TH1 * > * fHistBgd_smooth;  background PDFs (smoothed histograms) ;  ; std::vector< TH1 * > * fHistSig;  signal PDFs (histograms) ;  ; std::vector< TH1 * > * fHistSig_smooth;  signal PDFs (smoothed histograms) ;  ; TString * fInterpolateString;  which interpolation method used for reference histograms (individual for each variable) ;  ; Float_t fKDEfineFactor;  fine tuning factor for Adaptive KDE ;  ; TString fKDEiterString;  Number of iterations (string) ;  ; TString fKDEtypeString;  Kernel type to use for KDE (string) ;  ; Int_t fNsmooth;  number of smooth passes ;  ; Int_t * fNsmoothVarB;  number of smooth passes ;  ; Int_t * fNsmoothVarS;  number of smooth passes ;  ; std::vector< PDF * > * fPDFBgd;  list of PDFs (background) ;  ; std::vector< PDF * > * fPDFSig;  list of PDFs (signal) ;  ; Bool_t fTransformLikelihoodOutput;  likelihood output is sigmoid-transformed ;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html:29582,avoid,avoid,29582,doc/master/classTMVA_1_1MethodLikelihood.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html,1,['avoid'],['avoid']
Safety,"oint) const override;  Tests if point is inside the shape. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; void CreateThreadData (Int_t nthreads) override;  Needed just for cleanup. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute closest distance from point px,py to each corner. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to outside of this composite shape. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from outside point to this composite shape. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Divide all range of iaxis in range/step cells. ;  ; TGeoBoolNode * GetBoolNode () const;  ; void GetBoundingCylinder (Double_t *) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  Returns numbers of vertices, segments and polygons composing the shape mesh. ;  ; Int_t GetNmeshVertices () const override;  Return number of vertices of the mesh representation. ;  ; Bool_t GetPointsOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:11883,safe,safe,11883,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['safe'],['safe']
Safety,"oints, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCtub.html:3777,safe,safe,3777,root/html534/TGeoCtub.html,https://root.cern,https://root.cern/root/html534/TGeoCtub.html,6,['safe'],['safe']
Safety,"ol, Int_t npoints, Option_t *option);  Draw random points in the bounding box of a volume. ;  ; void RandomRays (Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol=nullptr, Bool_t check_norm=kFALSE);  Randomly shoot nrays from point (startx,starty,startz) and plot intersections with surfaces for current top node. ;  ; TGeoNode * SamplePoints (Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path);  shoot npoints randomly in a box of 1E-5 around current point. ;  ; void SetNmeshPoints (Int_t npoints=1000);  Set number of points to be generated on the shape outline when checking for overlaps. ;  ; void SetSelectedNode (TGeoNode *node);  ; void ShapeDistances (TGeoShape *shape, Int_t nsamples, Option_t *option);  Test TGeoShape::DistFromInside/Outside. ;  ; void ShapeNormal (TGeoShape *shape, Int_t nsamples, Option_t *option);  Check of validity of the normal for a given shape. ;  ; void ShapeSafety (TGeoShape *shape, Int_t nsamples, Option_t *option);  Check of validity of safe distance for a given shape. ;  ; Double_t * ShootRay (Double_t *start, Double_t dirx, Double_t diry, Double_t dirz, Double_t *array, Int_t &nelem, Int_t &dim, Double_t *enpoint=nullptr) const;  Shoot one ray from start point with direction (dirx,diry,dirz). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Test (Int_t npoints, Option_t *option);  Check time of finding ""Where am I"" for n points. ;  ; void TestOverlaps (const char *path);  Geometry overlap checker based on sampling. ;  ; Bool_t TestVoxels (TGeoVolume *vol, Int_t npoints=1000000);  Returns optimal voxelization type for volume vol. ;  ; Double_t Weight (Double_t precision=0.01, Option_t *option=""v"");  Estimate weight of top level volume with a precision SIGMA(W)/W better than PRECISION. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoChecker.html:6075,safe,safe,6075,doc/master/classTGeoChecker.html,https://root.cern,https://root.cern/doc/master/classTGeoChecker.html,1,['safe'],['safe']
Safety,"olNode.; Definition at line 118 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoUnion::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this union. ; Implements TGeoBoolNode.; Definition at line 778 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoUnion::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 128 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoUnion::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 432 of file TGeoBoolNode.cxx. ◆ Paint(). void TGeoUnion::Paint ; (; Option_t * ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 440 of file TGeoBoolNode.cxx. ◆ Safety(). Double_t TGeoUnion::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 822 of file TGeoBoolNode.cxx. ◆ SavePrimitive(). void TGeoUnion::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 846 of file TGeoBoolNode.cxx. ◆ Sizeof3D(). void TGeoUnion::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 865 of file TGeoBoolNode.cxx. ◆ Streamer(). void TGeoUnion::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. ◆ StreamerNVirtual(). void TGeoUnion::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 128 of file TGeoBoolNode.h. Libraries for TGeoUnion:. [legend]; The documentation for this class was generated from the following files:; geom/geom/inc/TGeoB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoUnion.html:18180,safe,safety,18180,doc/master/classTGeoUnion.html,https://root.cern,https://root.cern/doc/master/classTGeoUnion.html,1,['safe'],['safety']
Safety,"olNode.cxx. ◆ DeclFileName(). static const char * TGeoIntersection::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 166 of file TGeoBoolNode.h. ◆ DistanceToPrimitive(). Int_t TGeoIntersection::DistanceToPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute minimum distance to shape vertices. ; Implements TGeoBoolNode.; Definition at line 1464 of file TGeoBoolNode.cxx. ◆ DistFromInside(). Double_t TGeoIntersection::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point inside to the shape boundary. ; Implements TGeoBoolNode.; Definition at line 1472 of file TGeoBoolNode.cxx. ◆ DistFromOutside(). Double_t TGeoIntersection::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = 0, . Double_t * ; safe = nullptr . ); const. overridevirtual . Compute distance from a given point outside to the shape. ; Implements TGeoBoolNode.; Definition at line 1505 of file TGeoBoolNode.cxx. ◆ GetBooleanOperator(). EGeoBoolType TGeoIntersection::GetBooleanOperator ; (; ); const. inlineoverridevirtual . Implements TGeoBoolNode.; Definition at line 156 of file TGeoBoolNode.h. ◆ GetNpoints(). Int_t TGeoIntersection::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this intersection. ; Implements TGeoBoolNode.; Definition at line 1599 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoIntersection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 166 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoIntersection::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 1230 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:17126,safe,safe,17126,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['safe'],['safe']
Safety,"ol_t isowner = kTRUE); Initialize the CallFunc objects when selector is interpreted. int Version() const; Invoke the Version function via the interpreter. void Init(TTree* ); Invoke the Init function via the interpreter. void Begin(TTree* tree); Invoke the Begin function via the interpreter. void SlaveBegin(TTree* ); Invoke the SlaveBegin function via the interpreter if available. Bool_t Notify(); Invoke the Notify function via the interpreter. Bool_t ProcessCut(Long64_t entry); Invoke the ProcessCut function via the interpreter. void ProcessFill(Long64_t entry); Invoke the ProcessFill function via the interpreter. Bool_t Process(Long64_t entry); Invoke the ProcessCut function via the interpreter. void SetOption(const char* option); Set the selector option. void SetObject(TObject* obj); Set the current object. void SetInputList(TList* input); Set the selector list of input objects. TList * GetOutputList() const; Return the list of output object. void SlaveTerminate(); Invoke the SlaveTerminate function via the interpreter if available. void Terminate(); Invoke the Terminate function via the interpreter. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Invoke the GetAbort function via the interpreter. TSelector::EAbort GetAbort() const; Invoke the GetAbort function via the interpreter. void ResetAbort(); Invoke the GetAbort function via the interpreter. Long64_t GetStatus() const; Invoke the GetStatus function via the interpreter. TClass * GetInterpretedClass() const; Retrieve the TClass object for the interpreted class. TSelector * GetInterpretedSelector() const; { return fIntSelector; }. » Author: Rene Brun 05/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TSelectorCint.h 38871 2011-04-15 11:35:38Z pcanal $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSelectorCint.html:8852,Abort,Abort,8852,root/html532/TSelectorCint.html,https://root.cern,https://root.cern/root/html532/TSelectorCint.html,1,['Abort'],['Abort']
Safety,"ol_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:16726,abort,abort,16726,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,1,['abort'],['abort']
Safety,"ol_thas_more! indicates that potentially there are more items can be found; Int_tlvl! current level of hierarchy; UInt_tmask! defines operation kind; Int_tnum_childs! number of childs; Int_tnum_fields! number of fields; TRootSnifferScanRec*parent! pointer on parent record; const char*searchpath! current path searched; TStringstarted_node! name of node stared; TRootSnifferStore*store! object to store results. Class Charts. Inheritance Chart:. TRootSnifferScanRec. Function documentation; TRootSnifferScanRec(); constructor. ~TRootSnifferScanRec(); destructor. void SetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); record field for current element. void BeforeNextChild(); indicates that new child for current element will be started. void MakeItemName(const char* objname, TString& itemname); constructs item name from object name; if special symbols like '/', '#', ':', '&', '?' are used in object name; they will be replaced with '_'.; To avoid item name duplication, additional id number can be appended. void CreateNode(const char* _node_name); creates new node with specified name; if special symbols like ""[]&<>"" are used, node name; will be replaced by default name like ""extra_item_N"" and; original node name will be recorded as ""_original_name"" field; Optionally, object name can be recorded as ""_realname"" field. void CloseNode(); close started node. void SetRootClass(TClass* cl); set root class name as node kind; in addition, path to master item (streamer info) specified; Such master item required to correctly unstream data on JavaScript. Bool_t Done() const; returns true if scanning is done; Can happen when searched element is found. Bool_t IsReadyForResult() const; Checks if result will be accepted.; Used to verify if sniffer should read object from the file. Bool_t SetResult(void* obj, TClass* cl, TDataMember* member = 0, Int_t chlds = -1); set results of scanning. Int_t Depth() const; returns current depth of scanned hierarchy. Int_t ExtraFolder",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSnifferScanRec.html:2458,avoid,avoid,2458,root/html602/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html602/TRootSnifferScanRec.html,2,['avoid'],['avoid']
Safety,"oldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOwnThread! true when specialized thread allocated for processing requestsDefinition THttpServer.h:40; THttpServer::SetSniffervoid SetSniffer(TRootSniffer *sniff)Set TRootSniffer to the server.Definition THttpServer.cxx:267; THttpServer::IsFileRequestedBool_t IsFileRequested(const char *uri, TString &res) constCheck if file is requested, thread safe.Definition THttpServer.cxx:612; THttpServer::SetReadOnlyvoid SetReadOnly(Bool_t readonly=kTRUE)Set read-only mode for the server (default on)Definition THttpServer.cxx:296; THttpServer::GetItemFieldconst char * GetItemField(const char *fullname, const char *name)Get item field from sniffer.Definition THttpServer.cxx:1471; THttpServer::GetCorsconst char * GetCors() constReturns specified CORS domain.Definition THttpServer.h:115; THttpServer::fThrdstd::thread fThrd! own threadDefinition THttpServer.h:41; THttpServer::StopServerThreadvoid StopServerThread()Stop server thread.Definition THttpServer.cxx:547; THttpServer::ProcessRequestsInt_t ProcessRequests()Process submitted requests, must be called from appropriate thread.Definition THttpServer.cxx:708; THttpServer::ExecuteWSBool_t ExecuteWS(std::shared_ptr< THttpCallArg > &arg, Bool_t external_thrd=kFALSE, Bool_t wait_process=kFALSE)Execute WS request.Definition THttpSer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:58971,safe,safe,58971,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,2,['safe'],['safe']
Safety,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30687,avoid,avoid,30687,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['avoid'],['avoid']
Safety,"olution::SetExtraRange(Double_t percentage); 439{; 440 if (percentage<0) return;; 441 double range = fXmax - fXmin;; 442 fXmin -= percentage * range;; 443 fXmax += percentage * range;; 444 fFlagGraph = false; // to indicate we need to re-do the convolution; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Set the actual range used for the convolution.; 449/// In case a or b are -inf or +inf and FFT convolution is used, then the; 450/// range of the first function will be used and extended by the default extra range fraction.; 451 ; 452void TF1Convolution::SetRange(Double_t a, Double_t b); 453{; 454 if (a >= b) {; 455 Warning(""SetRange"", ""Invalid range: %f >= %f"", a, b);; 456 return;; 457 }; 458 ; 459 fXmin = a;; 460 fXmax = b;; 461 if (fFlagFFT && ( a==-TMath::Infinity() || b==TMath::Infinity() ) ); 462 {; 463 Warning(""TF1Convolution::SetRange()"",""In FFT mode, range can not be infinite. Infinity has been replaced by range of first function plus a bufferzone to avoid spillover."");; 464 if (a ==-TMath::Infinity()) fXmin = fFunction1 -> GetXmin();; 465 if ( b== TMath::Infinity()) fXmax = fFunction1 -> GetXmax();; 466 // add a spill over of 10% in this case; 467 SetExtraRange(fgExtraRangeFraction);; 468 }; 469 fFlagGraph = false; // to indicate we need to re-do the convolution; 470}; 471 ; 472////////////////////////////////////////////////////////////////////////////////; 473/// Set the default extra range fraction used when doing a FFT convolution.; 474/// By default the value is 0.1 (10%).; 475/// The function return the previous default defined value.; 476 ; 477Double_t TF1Convolution::SetDefaultExtraRange(Double_t fraction); 478{; 479 Double_t prevValue = fgExtraRangeFraction;; 480 fgExtraRangeFraction = fraction;; 481 return prevValue;; 482}; 483 ; 484////////////////////////////////////////////////////////////////////////////////; 485/// Get the range used for the convolution.; 486 ; 487void TF1Convolution::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1Convolution_8cxx_source.html:17327,avoid,avoid,17327,doc/master/TF1Convolution_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html,1,['avoid'],['avoid']
Safety,"om inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t* option = """") const; Paint this composite shape into the current 3D viewer; Returns bool flag indicating if the caller should continue to; paint child objects. void RegisterYourself(); Register the shape and all components to TGeoManager class. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; create points for a composite shape. void SetPoints(Float_t* points) const; create points for a composite shape. void Sizeof3D() const; compute size of this 3D object. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:20622,Safe,Safety,20622,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,3,['Safe'],['Safety']
Safety,"om the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  vectorizedFit.C use it for fitting an histogram ;  ► fitsio;  FITS_tutorial1.C ;  FITS_tutorial2.C ;  FITS_tutorial3.C ;  FITS_tutorial4.C ;  FITS_tutorial5.C ;  FITS_tutorial6.C ;  FITS_tutorial7.C ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geo2stp.CExports a geometry in step format ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:111145,detect,detector,111145,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['detect'],['detector']
Safety,"omLumi; stringfObsName; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactoryFast(); {}. ~HistoToWorkspaceFactoryFast(). HistoToWorkspaceFactoryFast(string , string , vector<string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1F* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1F* nominal, vector<TH1F*> lowHist, vector<TH1F*> highHist, vector<string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<string,pair<double,double> > systMap, vector<string>& likelihoodTermNames, vector<string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<string>& syst_x_expectedPrefixNames, vector<string>& normByNames); for ith bin calculate totN_i = lumi * sum_j expected_j * syst_j. void AddPoissonTerms(RooWorkspace* proto, string prefix, string obsPrefix,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:8784,predict,predictions,8784,root/html530/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,1,['predict'],['predictions']
Safety,"omVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHype&operator=(const TGeoHype&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; Double_tRadiusHypeSq(Double_t z, Bool_t inner) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); Double_tSafetyToHype(Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoHype.html:9534,Safe,SafetyS,9534,root/html532/TGeoHype.html,https://root.cern,https://root.cern/root/html532/TGeoHype.html,1,['Safe'],['SafetyS']
Safety,"omVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPlaneVertices(Double_t zpl, Double_t* vertices) const; virtual voidSetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoArb8.html:9507,Safe,SafetySeg,9507,root/html602/TGeoArb8.html,https://root.cern,https://root.cern/root/html602/TGeoArb8.html,2,['Safe'],['SafetySeg']
Safety,"omVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); voidSetCurrentZ(Double_t z, Int_t iz); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoXtru.html:10163,Safe,SafetySeg,10163,root/html602/TGeoXtru.html,https://root.cern,https://root.cern/root/html602/TGeoXtru.html,2,['Safe'],['SafetySeg']
Safety,"ombinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoChecker.html:15566,safe,safety,15566,root/html602/TGeoChecker.html,https://root.cern,https://root.cern/root/html602/TGeoChecker.html,4,['safe'],['safety']
Safety,"omments for function SetCompressionSettings.Definition TFile.cxx:2319; TFile::GetCacheWriteTFileCacheWrite * GetCacheWrite() constReturn a pointer to the current write cache.Definition TFile.cxx:1279; TFile::SetFileReadCallsstatic void SetFileReadCalls(Int_t readcalls=0)Definition TFile.cxx:4614; TFile::fgCacheFileDirstatic TString fgCacheFileDirDirectory where to locally stage files.Definition TFile.h:124; TFile::SysReadvirtual Int_t SysRead(Int_t fd, void *buf, Int_t len)Interface to system read. All arguments like in POSIX read().Definition TFile.cxx:4506; TFile::fVersionInt_t fVersionFile format version.Definition TFile.h:83; TFile::Printvoid Print(Option_t *option="""") const overridePrint all objects in the file.Definition TFile.cxx:1706; TFile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::Copyvoid Copy(TObject &) const overrideCopy this to obj.Definition TFile.h:209; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::GetArchiveOffsetLong64_t GetArchiveOffset() constDefinition TFile.h:221; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:32509,timeout,timeout,32509,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['timeout'],['timeout']
Safety,"ompare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:3038,safe,safe,3038,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,6,['safe'],['safe']
Safety,"ompiled OK; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& b); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace=0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last changed: Mon Dec 7 13:49:51 2009 » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooWorkspace__CodeRepo.html:7489,avoid,avoid,7489,root/html526/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html526/RooWorkspace__CodeRepo.html,3,"['abort', 'avoid', 'recover']","['abort', 'avoid', 'recover']"
Safety,"ompiledOK(). bool RooWorkspace::CodeRepo::compiledOK ; (; ); const. inline . Definition at line 182 of file RooWorkspace.h. ◆ DeclFileName(). static const char * RooWorkspace::CodeRepo::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 217 of file RooWorkspace.h. ◆ IsA(). TClass * RooWorkspace::CodeRepo::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 217 of file RooWorkspace.h. ◆ listOfClassNames(). std::string RooWorkspace::CodeRepo::listOfClassNames ; (; ); const. Return STL string with last of class names contained in the code repository. ; Definition at line 2571 of file RooWorkspace.cxx. ◆ Streamer(). void RooWorkspace::CodeRepo::Streamer ; (; TBuffer & ; R__b). overridevirtual . Custom streamer for the workspace. ; Stream contents of workspace and code repository. When reading, read code repository first and compile missing classes before proceeding with streaming of workspace contents to avoid errors. ; Reimplemented from TObject.; Definition at line 2352 of file RooWorkspace.cxx. ◆ StreamerNVirtual(). void RooWorkspace::CodeRepo::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 217 of file RooWorkspace.h. Member Data Documentation. ◆ _c2fmap. std::map<TString,ClassRelInfo> RooWorkspace::CodeRepo::_c2fmap. protected . Definition at line 212 of file RooWorkspace.h. ◆ _compiledOK. bool RooWorkspace::CodeRepo::_compiledOK. protected . Definition at line 215 of file RooWorkspace.h. ◆ _ehmap. std::map<TString,ExtraHeader> RooWorkspace::CodeRepo::_ehmap. protected . Definition at line 214 of file RooWorkspace.h. ◆ _fmap. std::map<TString,ClassFiles> RooWorkspace::CodeRepo::_fmap. protected . Definition at line 213 of file RooWorkspace.h. ◆ _wspace. RooWorkspace* RooWorkspace::CodeRepo::_wspace. protected . Definition at line 211 of file RooWorkspace.h. Libraries for RooWorkspa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html:14158,avoid,avoid,14158,doc/master/classRooWorkspace_1_1CodeRepo.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html,1,['avoid'],['avoid']
Safety,"ompressionSetting::EAlgorithm algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: More...;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). More...;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). More...;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). More...;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. More...;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. More...;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. More...;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:7461,safe,safe,7461,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,3,['safe'],['safe']
Safety,"ompute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set half-space parameters as stored in an array. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoHalfSpace.h 21425 2007-12-17 15:59:27Z brun $ »",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoHalfSpace.html:12666,Safe,Safety,12666,root/html532/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html532/TGeoHalfSpace.html,1,['Safe'],['Safety']
Safety,"omputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Computes normal vector in POINT to the composite shape. ;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions. ;  ; Bool_t Contains (const Double_t *point) const override;  Tests if point is inside the shape. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; void CreateThreadData (Int_t nthreads) override;  Needed just for cleanup. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute closest distance from point px,py to each corner. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to outside of this composite shape. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from outside point to this composite shape. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Divide all range of iaxis in range/step",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:11407,safe,safe,11407,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['safe'],['safe']
Safety,"on ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; ROOT::TSchemaRule::ReadFuncPtr_tfReadFunc!; ROOT::TSchemaRule::ReadRawFuncPtr_tfReadRawFunc!; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Streamer(TBuffer& ); Avoid streaming the synthetic/artificial streamer elements. ROOT::TSchemaRule::ReadFuncPtr_t GetReadFunc(); Return the read function if any. ROOT::TSchemaRule::ReadRawFuncPtr_t GetReadRawFunc(); Return the raw read function if any. TStreamerElement& operator=(const TStreamerArtificial& ). TStreamerArtificial(const TStreamerArtificial& ). TStreamerArtificial(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); TStreamerArtificial() : fReadFunc(0),fReadRawFunc(0) {}. {}. void SetReadFunc(ROOT::TSchemaRule::ReadFuncPtr_t val); { fReadFunc = val; }. void SetReadRawFunc(ROOT::TSchemaRule::ReadRawFuncPtr_t val); { fReadRawFunc = val; }. » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: e0eac11e63ad37390c9467c97c5c6849c4ab7d39 $ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStreamerArtificial.html:11194,Avoid,Avoid,11194,root/html604/TStreamerArtificial.html,https://root.cern,https://root.cern/root/html604/TStreamerArtificial.html,1,['Avoid'],['Avoid']
Safety,"on = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCompositeShape.html:8233,safe,safe,8233,root/html534/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html,6,['safe'],['safe']
Safety,"on RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf502_wspacewriteDefinition rf502_wspacewrite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf502__wspacewrite_8C.html:4111,safe,safe,4111,doc/master/rf502__wspacewrite_8C.html,https://root.cern,https://root.cern/doc/master/rf502__wspacewrite_8C.html,1,['safe'],['safe']
Safety,"on RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf304_uncorrprodDefinition rf304_uncorrprod.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigmay' with range [-inf, inf] of the RooGaussian 'gaussy' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on x integrates over variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on y integrates over variables (x); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf304_uncorrprod.C. tutorialsroofitrf304_uncorrprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf304__uncorrprod_8C.html:4335,safe,safe,4335,doc/master/rf304__uncorrprod_8C.html,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8C.html,2,['safe'],['safe']
Safety,"on TDataType.h:32; kVoid_t@ kVoid_tDefinition TDataType.h:35; kIsPointer@ kIsPointerDefinition TDictionary.h:78; kIsClass@ kIsClassDefinition TDictionary.h:65; kIsEnum@ kIsEnumDefinition TDictionary.h:68; kIsFundamental@ kIsFundamentalDefinition TDictionary.h:70; kIsStruct@ kIsStructDefinition TDictionary.h:66; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; propOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:63828,abort,abort,63828,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['abort'],['abort']
Safety,"on \( x \):. \[; A x = b \\; clo \le C x \le cup \\; xlo \le x \le xup; \]. where A and C are arbitrary matrices and the rest are vectors; Not all these constraints have to be defined . Our example will only use \( xlo \), \( A \) and \( b \) Still, this could be handled by a general non-linear minimizer like Minuit by introducing so-called ""slack"" variables . However, quadp is tailored to objective functions not more complex than being quadratic . This allows usage of solving techniques which are even stable for problems involving for instance 500 variables, 100 inequality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Efficient Frontier"". To quantify better the risk we are willing to take, we define a utility function \( U(x) \). It describes as a function of our total assets \( x \), our ""satisfaction"" . A common choice is \( 1-exp(-k*x) \) (the reason for the exponent will be clear later) . The parameter \( k \) is the risk-aversion factor . For small values of \( k \) the satisfaction is small for small values of \( x \); by increasing \( x \) the satisfaction can still be increased significantly . For large values of \( k \), \( U(x) \) increases rapidly to 1, there is no increase in satisfaction for additional dollars earned .; In summary :; small \( k \) ==> risk-loving investor; large \( k \) ==> risk-averse investor. Suppose we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:2070,risk,risks,2070,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['risk'],['risks']
Safety,"on at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:70808,risk,risk,70808,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['risk'],['risk']
Safety,"on axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:16367,safe,safe,16367,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,6,['safe'],['safe']
Safety,"on is also called comitting or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the ommited name of the parent branches.; In case of ambiguity, returns the first match. TLeaf* FindLeaf(const char* name); FIXME: Describe this function. Int_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:83739,recover,recoverable,83739,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['recover'],['recoverable']
Safety,"on is slower when embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes. Creating and Positioning Volumes; Making Volumes; As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined.; Volumes have to be named by users at creation time. Every different name may represent a unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user's task to provide different names for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases: when a parametric shape is used or when a division operation is applied. Each volume in the geometry stores a unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.; Example of Volume Creation; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);; ; // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);; ; // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);; ; // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:25099,avoid,avoid,25099,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['avoid'],['avoid']
Safety,"on of this class ; Definition at line 85 of file TMonitor.h. ◆ DeActivate(). void TMonitor::DeActivate ; (; TSocket * ; sock). virtual . De-activate a socket. ; Definition at line 284 of file TMonitor.cxx. ◆ DeActivateAll(). void TMonitor::DeActivateAll ; (; ). virtual . De-activate all activated sockets. ; Definition at line 302 of file TMonitor.cxx. ◆ DeclFileName(). static const char * TMonitor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMonitor.h. ◆ GetActive(). Int_t TMonitor::GetActive ; (; Long_t ; timeout = -1); const. Return number of sockets in the active list. ; If timeout > 0, remove from the list those sockets which did not have any activity since timeout millisecs. If timeout = 0, then reset activity timestamp on all active sockets. This time out is typically used if GetActive() is used to see how many remotes still need to send something. If they pass the timeout they will be skipped and GetActive() will return 0 and the loop can be exited. ; Definition at line 438 of file TMonitor.cxx. ◆ GetDeActive(). Int_t TMonitor::GetDeActive ; (; ); const. Return number of sockets in the de-active list. ; Definition at line 473 of file TMonitor.cxx. ◆ GetListOfActives(). TList * TMonitor::GetListOfActives ; (; ); const. Returns a list with all active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 498 of file TMonitor.cxx. ◆ GetListOfDeActives(). TList * TMonitor::GetListOfDeActives ; (; ); const. Returns a list with all de-active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 515 of file TMonitor.cxx. ◆ GetSender(). void * TMonitor::GetSender ; (; ). inlineoverrideprivatevirtual . Reimplemented from TQObject.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:19323,timeout,timeout,19323,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['timeout'],['timeout']
Safety,"on string ;  ; bool CreateTable (const TString &table);  Create the database table corresponding to this TTree. ;  ; std::vector< Int_t > * GetColumnIndice (TBranch *branch);  Return a vector of columns index corresponding to the current SQL table and the branch given as argument Returns 0 if no columns indices is found Otherwise returns a pointer to a vector to be deleted by the caller. ;  ; void Init ();  Initialization routine. ;  ; void ResetQuery ();  Reset the internal query. ;  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:39974,detect,detection,39974,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['detect'],['detection']
Safety,"on(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCaching(Bool_t b) { fgUsePWSafetyCaching = b; }; 232 static Bool_t IsPWSafetyCaching() { return fgUsePWSafetyCaching; }; 233 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:10532,safe,safeties,10532,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safeties']
Safety,"on(const char* rv); static voidTSlave::SetTXSlaveHook(TSlave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidFlushSocket(); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char* grp, Int_t priority); virtual voidSetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout). private:. static Int_tGetProofdProtocol(TSocket* s); voidInit(const char* host, Int_t stype). Data Members; public:. enum TSlave::ESlaveType { kMaster; kSlave; };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSlave.html:6553,abort,abort,6553,root/html528/TXSlave.html,https://root.cern,https://root.cern/root/html528/TXSlave.html,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"on. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.0861399 cHl3=-9.50561 cHq3=0.0801661; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:9413,recover,recover,9413,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"on. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC’s is to define and use only one dummy tracking medium as in the example (or a NULL pointer).; 18.2.4 User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; 18.3 Shapes; Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base TGeoShape class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods:. Computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;; Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes as a result of Boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (combined composites). This allows the creation of a quite large number of different shape topologies and combinati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:897117,safe,safe,897117,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['safe'],['safe']
Safety,"on. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFractionFitter.html:18131,predict,prediction,18131,root/html534/TFractionFitter.html,https://root.cern,https://root.cern/root/html534/TFractionFitter.html,2,['predict'],['prediction']
Safety,"on. ◆ EAbort. enum TSelector::EAbort. EnumeratorkContinue ; kAbortProcess ; kAbortFile . Definition at line 34 of file TSelector.h. Constructor & Destructor Documentation. ◆ TSelector() [1/2]. TSelector::TSelector ; (; const TSelector & ; ). private . ◆ TSelector() [2/2]. TSelector::TSelector ; (; ). Default selector ctor. ; Definition at line 89 of file TSelector.cxx. ◆ ~TSelector(). TSelector::~TSelector ; (; ). override . Selector destructor. ; Definition at line 102 of file TSelector.cxx. Member Function Documentation. ◆ Abort(). void TSelector::Abort ; (; const char * ; why, . EAbort ; what = kAbortProcess . ). virtual . Abort processing. ; If what = kAbortProcess, the Process() loop will be aborted. If what = kAbortFile, the current file in a chain will be aborted and the processing will continue with the next file, if there is no next file then Process() will be aborted. Abort() can also be called from Begin(), SlaveBegin(), Init() and Notify(). After abort the SlaveTerminate() and Terminate() are always called. The abort flag can be checked in these methods using GetAbort(). ; Definition at line 116 of file TSelector.cxx. ◆ Begin(). virtual void TSelector::Begin ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TProofDraw, h1analysisTreeReader, TProofDrawHist, TProofDrawProfile, TProofDrawProfile2D, TSelHist, TSelectorDraw, TSelectorEntries, and h1analysis.; Definition at line 54 of file TSelector.h. ◆ Class(). static TClass * TSelector::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSelector::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSelector::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 79 of file TSelector.h. ◆ DeclFileName(). static const char * TSelector::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:15773,abort,abort,15773,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['abort'],['abort']
Safety,"on::snapshot(Bool_t deepCopy = kTRUE) const; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooArgList::sort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServerPropagate shape dirty flags?; Bool_t_defValueServerPropagate value dirty flags?; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooListProxy.html:10262,safe,safeDeleteList,10262,root/html526/RooListProxy.html,https://root.cern,https://root.cern/root/html526/RooListProxy.html,2,['safe'],['safeDeleteList']
Safety,"onArguments`); 1985 ; 1986 TString replacementFormula = f->GetExpFormula();; 1987 ; 1988 // analyze expression string; 1989 // std::cout << ""formula to replace for "" << f->GetName() << "" is "" << replacementFormula <<; 1990 // std::endl;; 1991 PreProcessFormula(replacementFormula);; 1992 // we need to define different parameters if we use the unnamed default parameters ([0]); 1993 // I need to replace all the terms in the functor for backward compatibility of the case; 1994 // f1(""[0]*x"") f2(""[0]*x"") f1+f2 - it is weird but it is better to support; 1995 // std::cout << ""current number of parameter is "" << fNpar << std::endl;; 1996 int nparOffset = 0;; 1997 // if (fParams.find(""0"") != fParams.end() ) {; 1998 // do in any case if parameters are existing; 1999 std::vector<TString> newNames;; 2000 if (fNpar > 0) {; 2001 nparOffset = fNpar;; 2002 newNames.resize(f->GetNpar());; 2003 // start from higher number to avoid overlap; 2004 for (int jpar = f->GetNpar() - 1; jpar >= 0; --jpar) {; 2005 // parameters name have a ""p"" added in front; 2006 TString pj = TString(f->GetParName(jpar));; 2007 if (pj[0] == 'p' && TString(pj(1, pj.Length())).IsDigit()) {; 2008 TString oldName = TString::Format(""[%s]"", f->GetParName(jpar));; 2009 TString newName = TString::Format(""[p%d]"", nparOffset + jpar);; 2010 // std::cout << ""replace - parameter "" << f->GetParName(jpar) << "" with "" << newName <<; 2011 // std::endl;; 2012 replacementFormula.ReplaceAll(oldName, newName);; 2013 newNames[jpar] = newName;; 2014 } else; 2015 newNames[jpar] = f->GetParName(jpar);; 2016 }; 2017 // std::cout << ""after replacing params "" << replacementFormula << std::endl;; 2018 }; 2019 ExtractFunctors(replacementFormula);; 2020 // std::cout << ""after re-extracting functors "" << replacementFormula << std::endl;; 2021 ; 2022 // set parameter value from replacement formula; 2023 for (int jpar = 0; jpar < f->GetNpar(); ++jpar) {; 2024 if (nparOffset > 0) {; 2025 // parameter have an offset- so take this into account; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:75758,avoid,avoid,75758,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['avoid'],['avoid']
Safety,"on_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Process specified TDSet on PROOF. ;  ; void Progress (Long64_t total, Long64_t processed) override;  Progress signal. ;  ; void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  Progress signal. ;  ; void Progress (TProofProgressInfo *pi) override;  Progress signal. ;  ; void Progress (TSlave *, Long64_t total, Long64_t processed) override;  ; void Progress (TSlave *, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  ; void Progress (TSlave *, TProofProgressInfo *pi) override;  ; void RedirectOutput (Bool_t on=kTRUE);  Control output redirection to TProof::fLogFileW. ;  ; void SetInitTime () override;  Set init time. ;  ; void SetMerging (Bool_t on=kTRUE) override;  Switch on/off merge timer. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:4422,abort,abort,4422,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"on_t* option = """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerRemote(TProof* proof = 0); TProofPlayerRemote(const TProofPlayerRemote&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerRemote.html:11125,timeout,timeout,11125,root/html602/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html602/TProofPlayerRemote.html,2,['timeout'],['timeout']
Safety,"onadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__KDEKernel.html:2292,sanity check,sanity check,2292,root/html534/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html534/TMVA__KDEKernel.html,2,['sanity check'],['sanity check']
Safety,"ond fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3913,recover,recovery,3913,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['recover'],['recovery']
Safety,"onditional=({gaussx}, {x}),; ); ; # Marginalize m(x,y) to m(x); # ----------------------------------------------------; ; # modelx(x) = Int model(x,y) dy; modelx = model.createProjection({y}); ; # Use marginalized pdf as regular 1D pdf; # -----------------------------------------------; ; # Sample 1000 events from modelx; data = modelx.generateBinned({x}, 1000); ; # Fit modelx to toy data; modelx.fitTo(data, Verbose=True, PrintLevel=-1); ; # Plot modelx over data; frame = x.frame(40); data.plotOn(frame); modelx.plotOn(frame); ; # Make 2D histogram of model(x,y); hh = model.createHistogram(""x,y""); hh.SetLineColor(ROOT.kBlue); ; c = ROOT.TCanvas(""rf315_projectpdf"", ""rf315_projectpdf"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.SaveAs(""rf315_projectpdf.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_Int[y]_Norm[x,y]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_Int[y]_Norm[x,y]_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; [#1] INFO:NumericIntegration -- RooRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8py.html:2411,safe,safe,2411,doc/master/rf315__projectpdf_8py.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html,1,['safe'],['safe']
Safety,"ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). Option compress is used to specify the compression level:; compress = 0 objects written to this file will not be compressed.; compress = 1 minimal compression level but fast. compress = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map() shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs ref",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:25861,detect,detect,25861,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['detect'],['detect']
Safety,"onfigure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ; WebGui.HttpPort: 8088; or specify range of http ports, which can be used: WebGui.HttpPortMin: 8800; WebGui.HttpPortMax: 9800; By default range [8800..9800] is used; One also can bind HTTP server socket to loopback address, In that case only connection from localhost will be available: WebGui.HttpLoopback: yes; Or one could specify hostname which should be used for binding of server socket WebGui.HttpBind: hostname | ipaddress; To use secured protocol, following parameter should be specified WebGui.UseHttps: yes; WebGui.ServerCert: sertificate_filename.pem; Alternatively, one can specify unix socket to handle requests: WebGui.UnixSocket: /path/to/unix/socket; WebGui.UnixSocketMode: 0700; Typically one used unix sockets together with server mode like root --web=server:/tmp/root.socket and then redirect it via ssh tunnel (e.g. using rootssh) to client node; All incoming requests processed in THttpServer in timer handler with 10 ms timeout. One may decrease value to improve latency or increase value to minimize CPU load WebGui.HttpTimer: 10; To processing incoming http requests and websockets, THttpServer allocate 10 threads One have to increase this number if more simultaneous connections are expected: WebGui.HttpThrds: 10; One also can configure usage of special thread of processing of http server requests WebGui.HttpThrd: no; Extra threads can be used to send data to different clients via websocket (default no) WebGui.SenderThrds: no; If required, one could change websocket timeouts (default is 10000 ms) WebGui.HttpWSTmout: 10000; By default, THttpServer created in restricted mode which only allows websocket handlers and processes only very few other related http requests. For security reasons such mode should be always enabled. Only if it is really necessary to process all other kinds of HTTP requests, one could specify no for following parameter (default yes):",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:8431,timeout,timeout,8431,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,2,['timeout'],['timeout']
Safety,"onflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accesstype, const TCollection *collection,; 86 const char *function);; 87 ; 88 public:; 89 TErrorLock() : fWriteCurrent(), fWriteCurrentRecurse(0), fReadCurrentRecurse(0); 90 {; 91 std::atomic_flag_clear(&fSpinLockFlag);; 92 }; 93 ; 94 class WriteGuard {; 95 TErrorLock *fLock;; 96 ; 97 public:; 98 WriteGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 99 {; 100 fLock->Lock(collection, function);; 101 }; 102 ~WriteGuard() { fLock->Unlock(); }; 103 };; 104 ; 105 class ReadGuard {; 106 TErrorLock *fLock;; 107 ; 108 public:; 109 ReadGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 110 {; 111 fLock->ReadLock(collection, function);; 112 }; 113 ~ReadGuard() { fLock->ReadUnlock(); }; 114 };; 115 };; 116 ; 117 mutable TErrorLock fLock; //! Special 'lock' to detect multiple access to a collection.; 118 ; 119#define R__COLLECTION_WRITE_GUARD() TCollection::TErrorLock::WriteGuard wg(fLock, this, __PRETTY_FUNCTION__); 120#define R__COLLECTION_R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:3763,detect,detect,3763,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['detect'],['detect']
Safety,"ong64_t GetZipBytes (Option_t *option="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entries in this branch. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchObject.html:8556,avoid,avoid,8556,doc/master/classTBranchObject.html,https://root.cern,https://root.cern/doc/master/classTBranchObject.html,1,['avoid'],['avoid']
Safety,"onitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from socket s.; Returns 0 on success, -1 if any failure occurs. Int_t HandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:42474,timeout,timeout,42474,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,12,['timeout'],['timeout']
Safety,"onitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection.; Collect also stops its execution from time to time to check for new; workers in Dynamic Startup mode. Int_t PollForNewWorkers(); Asks the PROOF Serv for new workers in Dynamic Startup mode and activates; them. Returns the number of new workers found, or <0 on errors. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from so",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:46330,timeout,timeout,46330,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,18,['timeout'],['timeout']
Safety,"onitor::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMonitor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMonitor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TMonitor.h. ◆ DeActivate(). void TMonitor::DeActivate ; (; TSocket * ; sock). virtual . De-activate a socket. ; Definition at line 284 of file TMonitor.cxx. ◆ DeActivateAll(). void TMonitor::DeActivateAll ; (; ). virtual . De-activate all activated sockets. ; Definition at line 302 of file TMonitor.cxx. ◆ DeclFileName(). static const char * TMonitor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMonitor.h. ◆ GetActive(). Int_t TMonitor::GetActive ; (; Long_t ; timeout = -1); const. Return number of sockets in the active list. ; If timeout > 0, remove from the list those sockets which did not have any activity since timeout millisecs. If timeout = 0, then reset activity timestamp on all active sockets. This time out is typically used if GetActive() is used to see how many remotes still need to send something. If they pass the timeout they will be skipped and GetActive() will return 0 and the loop can be exited. ; Definition at line 438 of file TMonitor.cxx. ◆ GetDeActive(). Int_t TMonitor::GetDeActive ; (; ); const. Return number of sockets in the de-active list. ; Definition at line 473 of file TMonitor.cxx. ◆ GetListOfActives(). TList * TMonitor::GetListOfActives ; (; ); const. Returns a list with all active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 498 of file TMonitor.cxx. ◆ GetListOfDeActives(). TList * TMonitor::GetListOfDeActives ; (; ); const. Returns a list with all de-active sockets. ; This list must be deleted by the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:19023,timeout,timeout,19023,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,2,['timeout'],['timeout']
Safety,"only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:7964,avoid,avoid,7964,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['avoid'],['avoid']
Safety,"onnect a session. Use opt= ""S"" or ""s"" to; shutdown remote session.; Default is opt = """". void Close(Option_t* opt = """"); Close connection. Available options are (case insensitive); 'P' force closing of the underlying physical connection; 'S' shutdown remote session, is any; A session ID can be given using #...# signature, e.g. ""#1#"".; Default is opt = """". UnsolRespProcResult ProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); We are here if an unsolicited response comes from a logical conn; The response comes in the form of an XrdClientMessage *, that must NOT be; destroyed after processing. It is destroyed by the first sender.; Remember that we are in a separate thread, since unsolicited; responses are asynchronous by nature. void PostMsg(Int_t type, const char* msg = 0); Post a message of type 'type' into the read messages queue.; If 'msg' is defined it is also added as TString.; This is used, for example, with kPROOF_FATAL to force the main thread; to mark this socket as bad, avoiding race condition when a worker; dies while in processing state. Bool_t IsServProofd(); Return kTRUE if the remote server is a 'proofd'. Int_t GetInterrupt(Bool_t& forward); Get latest interrupt level and reset it; if the interrupt has to be; propagated to lower stages forward will be kTRUE after the call. Int_t Flush(); Flush the asynchronous queue.; Typically called when a kHardInterrupt is received.; Returns number of bytes in flushed buffers. Bool_t Create(Bool_t attach = kFALSE); This method sends a request for creation of (or attachment to) a remote; server application. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); Send a raw buffer of specified length.; Use opt = kDontBlock to ask xproofd to push the message into the proofsrv.; (by default is appended to a queue waiting for a request from proofsrv).; Returns the number of bytes sent or -1 in case of error. Bool_t Ping(const char* ord = 0); Ping functionality: contact the serve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:15569,avoid,avoiding,15569,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,4,['avoid'],['avoiding']
Safety,"onnection after failure. Int_t GetLowSocket() const; Auxilliary. { return (fConn ? fConn->GetLowSocket() : -1); }. Int_t GetClientID() const; { return -1; }. Int_t GetClientIDSize() const; { return 1; }. Int_t GetLogConnID() const; { return (fConn ? fConn->GetLogConnID() : -1); }. Int_t GetOpenError() const; { return (fConn ? fConn->GetOpenError() : -1); }. Int_t GetServType() const; { return (fConn ? fConn->GetServType() : -1); }. Int_t GetSessionID() const; { return (fConn ? fConn->GetSessionID() : -1); }. Int_t GetXrdProofdVersion() const; { return fXrdProofdVersion; }. Bool_t IsValid() const; { return (fConn ? (fConn->IsValid()) : kFALSE); }. void RemoveClientID(); { }. void SetClientID(Int_t ); { }. void SetSendOpt(ESendRecvOptions o); { fSendOpt = o; }. Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:20068,timeout,timeout,20068,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,2,['timeout'],['timeout']
Safety,"onnection after failure. Int_t GetLowSocket() const; Auxilliary. { return (fConn ? fConn->GetLowSocket() : -1); }. Int_t GetClientID() const; { return -1; }. Int_t GetClientIDSize() const; { return 1; }. Int_t GetLogConnID() const; { return (fConn ? fConn->GetLogConnID() : -1); }. Int_t GetOpenError() const; { return (fConn ? fConn->GetOpenError() : -1); }. Int_t GetServType() const; { return (fConn ? fConn->GetServType() : -1); }. Int_t GetSessionID() const; { return (fConn ? fConn->GetSessionID() : -1); }. Int_t GetXrdProofdVersion() const; { return fXrdProofdVersion; }. Bool_t IsValid() const; { return (fConn ? (fConn->IsValid()) : kFALSE); }. void RemoveClientID(); { }. void SetClientID(Int_t ); { }. void SetSendOpt(ESendRecvOptions o); { fSendOpt = o; }. Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXSocket.html:19986,timeout,timeout,19986,root/html604/TXSocket.html,https://root.cern,https://root.cern/root/html604/TXSocket.html,2,['timeout'],['timeout']
Safety,"ons steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 1280 training events and 320 validation events; : Training Model Summary; custom objects for loading model : {'optimizer': <class 'torch.optim.adam.Adam'>, 'criterion': BCELoss(), 'train_func': <function fit at 0x7fe43c5d1b80>, 'predict_func': <function predict at 0x7fe43c5d1ca0>}; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 16, 16, 1) 0 ; ; conv2d (Conv2D) (None, 16, 16, 10) 100 ; ; batch_normalization (Batch (None, 16, 16, 10) 40 ; Normalization) ; ; conv2d_1 (Conv2D) (None, 16, 16, 10) 910 ; ; max_pooling2d (MaxPooling2 (None, 15, 15, 10) 0 ; D) ; ; flatten (Flatten) (None, 2250) 0 ; ; dense (Dense) (None, 256) 576256 ; ; dense_1 (Dense) (None, 2) 514 ; ; =================================================================; Total params: 577820 (2.20 MB); Trainable params: 577800 (2.20 MB); Non-trainable params: 20 (80.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/10; ; 1/13 [=>............................] - ETA: 10s - loss: 0.9275 - accuracy: 0.4600␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 4/13 [========>.....................] - ETA: 0s - loss: 2.4547 - accuracy: 0.4675 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 7/13 [===============>..",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:16897,predict,predict,16897,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['predict'],['predict']
Safety,"ons; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus() & 8) != 0) {; 644 iparNewMin = i;; 645 }; 646 if (ret); 647 fResult->SetMinosError(index, elow, eup);; 648 ok |= ret;; 649 }; 650 ; 651 iparMax = iparNewMin;; 652 iter++; // to avoid infinite looping; 653 }; 654 while( iparNewMin > 0 && iter < 10);; 655 if (!ok) {; 656 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minos error calculation failed for all the selected parameters"");; 657 }; 658 ; 659 // update obj function in case it was an external one; 660 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 661 fResult->fObjFunc = fObjFunction;; 662 ; 663 // re-give a minimizer instance in case it has been changed; 664 // but maintain previous valid status. Do not set result to false if minos failed; 665 ok &= fResult->Update(fMinimizer, fConfig, fResult->IsValid());; 666 ; 667 return ok;; 668}; 669 ; 670 ; 671 ; 672// traits for distinguishing fit methods functions from generic objective functions; 673template<class Func>; 674struct ObjFuncTrait {; 675 static unsigned int NCalls(const Func & ) { return 0; }; 676 static int Type(const Func & ) { return -1; }; 677 static bool IsGrad() { return false; }; 678};; 679template<>; 680",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:25121,avoid,avoid,25121,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['avoid'],['avoid']
Safety,"onsider few examples. We will designate non-overlapping nodes as ONLY and the others MANY as in GEANT3, where this concept was introduced:. The part of a MANY node B extruding its container A will never be “seen” during navigation, as if B was in fact the result of the intersection of A and B.; If we have two nodes A (ONLY) and B (MANY) inside the same container, all points in the overlapping region of A and B will be designated as belonging to A.; If A an B in the above case were both MANY, points in the overlapping part will be designated to the one defined first. Both nodes must have the same medium.; The slices of a divided MANY will be as well MANY. One needs to know that navigation inside geometry parts MANY nodes is much slower. Any overlapping part can be defined based on composite shapes - might be in some cases a better way out.; 18.4.2.7 Replicating Volumes; What can we do if our chamber contains two identical wires instead of one? What if then we would need 1000 chambers in our detector? Should we create 2000 wires and 1000 chamber volumes? No, we will just need to replicate the ones that we have already created.; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let’s guess what it has to do. The most simple algorithm will just loop over all ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:949650,detect,detector,949650,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['detect'],['detector']
Safety,"onst Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ DistToHype(). Int_t TGeoHype::DistToHype ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t * ; s, . Bool_t ; inner, . Bool_t ; in . ); const. ◆ Divide(). TGeoVolume * TGeoHype::Divide ; (; TGeoVolume * ; voldiv, . const char * ; divname, . Int_t ; iaxis, . Int_t ; ndiv, . Double_t ; start, . Double_t ; step . ). overridevirtual . Reimplemented from TGeoBBox. ◆ GetAxisRange(). Double_t TGeoHype::GetAxisRange ; (; Int_t ; iaxis, . Double_t & ; xlo, . Double_t & ; xhi . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBoundingCylinder(). void TGeoHype::GetBoundingCylinder ; (; Double_t * ; param); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetBuffer3D(). const TBuffer3D & TGeoHype::GetBuffer3D ; (; Int_t ; reqSections, . Bool_t ; localFrame . ); const. overridevirtual . Stub implementation to avoid forcing implementation at this stage. ; Reimplemented from TGeoBBox. ◆ GetByteCount(). Int_t TGeoHype::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 67 of file TGeoHype.h. ◆ GetMakeRuntimeShape(). TGeoShape * TGeoHype::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetMeshNumbers(). void TGeoHype::GetMeshNumbers ; (; Int_t & ; nvert, . Int_t & ; nsegs, . Int_t & ; npols . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetNmeshVertices(). Int_t TGeoHype::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPointsOnSegments(). Bool_t TGeoHype::GetPointsOnSegments ; (; Int_t ; , . Double_t * ;  . ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 68 of file TGeoHype.h. ◆ GetStIn(). Double_t TGeoHype::GetStIn ; (; ); const. inline . Definition at line 72 of file TGeoHype.h. ◆ GetStOut(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:31129,avoid,avoid,31129,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['avoid'],['avoid']
Safety,"onst RooAbsAnaConvPdf &other, const char *name=nullptr);  ;  ~RooAbsAnaConvPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral defined by given code, which is returned by getAnalyticalIntegralWN() ;  ; virtual bool changeModel (const RooResolutionModel &newModel);  Change the current resolution model to newModel. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBDecay.html:5414,unsafe,unsafe,5414,doc/master/classRooBDecay.html,https://root.cern,https://root.cern/doc/master/classRooBDecay.html,1,['unsafe'],['unsafe']
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:73169,sanity check,sanity check,73169,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,124,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:66621,sanity check,sanity check,66621,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,4,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:68641,sanity check,sanity check,68641,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:61112,sanity check,sanity check,61112,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,14,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:73661,sanity check,sanity check,73661,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst RooArgProxy &c, const RooArgProxy &d) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:69048,sanity check,sanity check,69048,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,6,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"onst TSemaphore& s); TSemaphore(const TSemaphore& s). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance Chart:. TObject. ←; TSemaphore. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSemaphore.html:6148,timeout,timeout,6148,root/html604/TSemaphore.html,https://root.cern,https://root.cern/root/html604/TSemaphore.html,2,['timeout'],['timeout']
Safety,"onst TSemaphore& s); TSemaphore(const TSemaphore& s). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance Chart:. TObject. ←; TSemaphore. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSemaphore.html:6148,timeout,timeout,6148,root/html602/TSemaphore.html,https://root.cern,https://root.cern/root/html602/TSemaphore.html,2,['timeout'],['timeout']
Safety,"onst char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::atomic< TApplication * > fApplication;  Pointer to current application. ;  ; Bool_t fBatch;  True if session without graphics. ;  ; TList * fBrowsables;  List of browsables. ;  ; TSeqCollection * fBrowsers;  List of browsers. ;  ; Int_t fBuiltDate;  Date of ROOT built. ;  ; Int_t fBuiltTime;  Time of ROOT built. ;  ; TSeqCollection * fCanvases;  List of canvases. ;  ; TCollection * fClasses;  List of classes definition. ;  ; TCollection * fClassGenerators;  List of user defined class generators;. ;  ; TSeqCollection * fCleanups;  List of recursiveRemove collections. ;  ; TSeqCollection * fClipboard;  List of clipboard objects. ;  ; TSeqCollection * fClosedObjects;  List of closed objects from the list of files and sockets, so we can delete them if neededCl. ;  ; TSeqCollection * fColors;  List of colors. ;  ; TString fConfigFeatures;  ROOT ./configure detected build features. ;  ; TString fConfigOptions;  ROOT ./configure set build options. ;  ; TString fCutClassName;  Name of default CutG class in graphics editor. ;  ; TSeqCollection * fDataSets;  List of data sets (TDSet or TChain) ;  ; TString fDefCanvasName;  Name of default canvas. ;  ; Bool_t fEditHistograms;  True if histograms can be edited with the mouse. ;  ; Int_t fEditorMode;  Current Editor mode. ;  ; AListOfEnums_t fEnums;  List of enum types. ;  ; Bool_t fEscape;  True if ESC has been pressed. ;  ; Bool_t fExecutingMacro;  True while executing a TMacro. ;  ; TSeqCollection * fFiles;  List of files. ;  ; Bool_t fForceStyle;  Force setting of current style when reading objects. ;  ; Bool_t fFromPopUp;  True if command executed from a popup menu. ;  ; TListOfFunctionTemplates * fFuncTemplate;  List of global function templates. ;  ; TCollection * fFunctions;  List of analytic functions. ;  ; TSeqCollection * fGeometries;  List of geometries. ;  ; TString fGitBranch;  Git branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:34701,detect,detected,34701,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['detect'],['detected']
Safety,"onst char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = 2); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoMoreParallel(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:23291,timeout,timeout,23291,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['timeout'],['timeout']
Safety,"onst char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp | kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoMoreParallel(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:23164,timeout,timeout,23164,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['timeout'],['timeout']
Safety,"onst char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTorus.html:8487,Safe,SafetyPhi,8487,root/html602/TGeoTorus.html,https://root.cern,https://root.cern/root/html602/TGeoTorus.html,2,['Safe'],['SafetyPhi']
Safety,"onst char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); voidSetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); TGeoNode*Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTopToMaster(const Double_t* top, Double_t* master) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNavigator.html:8340,safe,safe,8340,root/html534/TGeoNavigator.html,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html,2,['safe'],['safe']
Safety,"onst char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPara.html:14245,safe,safe,14245,root/html534/TGeoPara.html,https://root.cern,https://root.cern/root/html534/TGeoPara.html,6,['safe'],['safe']
Safety,"onst char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t*, const Double_t*, Double_t*, Int_t); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t*, Bool_t*, Int_t) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; static Double_tDistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:8062,safe,safe,8062,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,6,['safe'],['safe']
Safety,"onst override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t Daxis (const Double_t *pt, const Double_t *dir, Double_t t) const;  ; Double_t DDaxis (const Double_t *pt, const Double_t *dir, Double_t t) const;  ; Double_t DDDaxis (const Double_t *pt, const Double_t *dir, Double_t t) const;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; Double_t GetDphi () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi1 () const;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; Double_t GetR () const;  ; Double_t GetRmax () const;  ; Double_t GetR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:1568,safe,safe,1568,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"onst. inline . Definition at line 213 of file TGeoTube.h. ◆ GetNmeshVertices(). Int_t TGeoCtub::GetNmeshVertices ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetPointsOnSegments(). Bool_t TGeoCtub::GetPointsOnSegments ; (; Int_t ; npoints, . Double_t * ; array . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ GetZcoord(). Double_t TGeoCtub::GetZcoord ; (; Double_t ; xc, . Double_t ; yc, . Double_t ; zc . ); const. ◆ InspectShape(). void TGeoCtub::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoCtub::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 226 of file TGeoTube.h. ◆ Safety(). Double_t TGeoCtub::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoCtub::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoCtub::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetCtubDimensions(). void TGeoCtub::SetCtubDimensions ; (; Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz, . Double_t ; phi1, . Double_t ; phi2, . Double_t ; lx, . Double_t ; ly, . Double_t ; lz, . Double_t ; tx, . Double_t ; ty, . Double_t ; tz . ). ◆ SetDimensions(). void TGeoCtub::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoCtub::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoCtub::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Streamer(). void TGeoCtub::Streamer ; (; TBuffer & ; R__b). o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:33721,safe,safe,33721,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['safe'],['safe']
Safety,"onst; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooArgList::sort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; Bool_t_defShapeServerPropagate shape dirty flags?; Bool_t_defValueServerPropagate value dirty flags?; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooListProxy.html:10521,safe,safeDeleteList,10521,root/html532/RooListProxy.html,https://root.cern,https://root.cern/root/html532/RooListProxy.html,2,['safe'],['safeDeleteList']
Safety,"onst; Bool_tRooAbsCollection::snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; voidRooArgList::sort(Bool_t reverse = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooArgList::writeToStream(ostream& os, Bool_t compact). protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); virtual voidRooAbsProxy::changeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServerPropagate shape dirty flags?; Bool_t_defValueServerPropagate value dirty flags?; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooListProxy.html:10459,safe,safeDeleteList,10459,root/html530/RooListProxy.html,https://root.cern,https://root.cern/root/html530/RooListProxy.html,1,['safe'],['safeDeleteList']
Safety,"onst; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:21111,Safe,Safety,21111,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,1,['Safe'],['Safety']
Safety,"onst; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 15:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoBBox.html:22865,Safe,Safety,22865,root/html604/TGeoBBox.html,https://root.cern,https://root.cern/root/html604/TGeoBBox.html,1,['Safe'],['Safety']
Safety,"onst; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBBox.html:22865,Safe,Safety,22865,root/html602/TGeoBBox.html,https://root.cern,https://root.cern/root/html602/TGeoBBox.html,1,['Safe'],['Safety']
Safety,"onst; create arb8 mesh points. void SetPoints(Float_t* points) const; create arb8 mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd1(); methods; constructors. Int_t GetByteCount() const; {return 52;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy() const; {return fDy;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd1.html:17067,safe,safe,17067,root/html534/TGeoTrd1.html,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"onst; create arb8 mesh points. void SetPoints(Float_t* points) const; create arb8 mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd1(); methods; constructors. Int_t GetByteCount() const; {return 52;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy() const; {return fDy;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTrd1.html:18821,safe,safe,18821,root/html604/TGeoTrd1.html,https://root.cern,https://root.cern/root/html604/TGeoTrd1.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"onst; create arb8 mesh points. void SetPoints(Float_t* points) const; create arb8 mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd1(); methods; constructors. Int_t GetByteCount() const; {return 52;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy() const; {return fDy;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTrd1.html:18821,safe,safe,18821,root/html602/TGeoTrd1.html,https://root.cern,https://root.cern/root/html602/TGeoTrd1.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"onst;  ; virtual ULongptr_t GetMethod () const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update (const TClass *oldClass, TClass *newClass);  function called",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerObjectAnyPointer.html:3209,detect,detected,3209,doc/master/classTStreamerObjectAnyPointer.html,https://root.cern,https://root.cern/doc/master/classTStreamerObjectAnyPointer.html,2,['detect'],['detected']
Safety,"onst;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:10992,safe,safely,10992,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,5,['safe'],['safely']
Safety,"onstDefinition MethodDL.h:278; TMVA::MethodDL::ParseBatchLayoutvoid ParseBatchLayout()Parse the input layout.Definition MethodDL.cxx:482; TMVA::MethodDL::ParseBatchNormLayervoid ParseBatchNormLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate reshape layer.Definition MethodDL.cxx:890; TMVA::MethodDL::ReadWeightsFromStreamvoid ReadWeightsFromStream(std::istream &)Definition MethodDL.cxx:2330; TMVA::MethodDL::ReadWeightsFromXMLvoid ReadWeightsFromXML(void *wghtnode)Definition MethodDL.cxx:2112; TMVA::MethodDL::fNumValidationStringTString fNumValidationStringThe string defining the number (or percentage) of training data used for validation.Definition MethodDL.h:199; TMVA::MethodDL::KeyValueVector_tstd::vector< std::map< TString, TString > > KeyValueVector_tDefinition MethodDL.h:93; TMVA::MethodDL::fOutputFunctionDNN::EOutputFunction fOutputFunctionThe output function for making the predictions.Definition MethodDL.h:189; TMVA::MethodDL::fWeightInitializationDNN::EInitialization fWeightInitializationThe initialization method.Definition MethodDL.h:188; TMVA::MethodDL::GetBatchDepthsize_t GetBatchDepth() constDefinition MethodDL.h:262; TMVA::MethodDL::ERecurrentLayerTypeERecurrentLayerTypeDefinition MethodDL.h:153; TMVA::MethodDL::kLayerLSTM@ kLayerLSTMDefinition MethodDL.h:153; TMVA::MethodDL::kLayerGRU@ kLayerGRUDefinition MethodDL.h:153; TMVA::MethodDL::kLayerRNN@ kLayerRNNDefinition MethodDL.h:153; TMVA::MethodDL::ParseRecurrentLayervoid ParseRecurrentLayer(ERecurrentLayerType type, DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate rnn layer.Definition MethodDL.cxx:931; TMVA::MethodDL::fTrainingSettingsstd::vector< TTrainingSettings > fTrainingSettingsThe vector defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:107948,predict,predictions,107948,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['predict'],['predictions']
Safety,"onstMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerRemote(TProof* proof = 0); TProofPlayerRemote(const TProofPlayerRemote&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerRemote.html:11175,abort,abort,11175,root/html604/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html604/TProofPlayerRemote.html,2,['abort'],['abort']
Safety,"onstMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); virtual voidSetMerging(Bool_t on = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerRemote.html:11270,abort,abort,11270,root/html534/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html534/TProofPlayerRemote.html,2,['abort'],['abort']
Safety,"onstMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLite(TProof* proof = 0); TProofPlayerLite(const TProofPlayerLite&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLite.html:11045,timeout,timeout,11045,root/html602/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLite.html,2,['timeout'],['timeout']
Safety,"onstMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSuperMaster.html:11455,timeout,timeout,11455,root/html602/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSuperMaster.html,2,['timeout'],['timeout']
Safety,"ontaining the point (original version based on TGeoVoxelFinder) ;  ; std::pair< double, double > GetBVHSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; std::pair< double, double > GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop version for comparison/debugging) ;  ; Double_t SafetyOrig (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (original version based on TGeoVoxelFinder) ;  ; void TestVoxelGrid ();  ; Double_t VoxelSafety (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching —> essentially an O(1) algorithm !) ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoParallelWorld.h>. Inheritance diagram for TGeoParallelWorld:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ AccelerationMode. enum class TGeoParallelWorld::AccelerationMode. strong . EnumeratorkVoxelFinder ; kBVH . Definition at line 28 of file TGeoParallelWorld.h. Constructor & Destructor Documentation. ◆ TGeoParallelWorld() [1/3]. TGeoParallelWorld::TGeoParallelWor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:16431,safe,safety,16431,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8C.html:4120,safe,safe,4120,doc/master/rf602__chi2fit_8C.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html,2,['safe'],['safe']
Safety,"ooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:15202,safe,safely,15202,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['safe'],['safely']
Safety,"ooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBreitWigner.html:10221,safe,safely,10221,doc/master/classRooBreitWigner.html,https://root.cern,https://root.cern/doc/master/classRooBreitWigner.html,49,['safe'],['safely']
Safety,"ooArgSet *normSet, const char *rangeName=nullptr) const override;  Return analytical integral defined by given code, which is returned by getAnalyticalIntegralWN() ;  ; virtual bool changeModel (const RooResolutionModel &newModel);  Change the current resolution model to newModel. ;  ; virtual RooFit::OwningPtr< RooArgSet > coefVars (Int_t coefIdx) const;  Return set of parameters with are used exclusively by the coefficient functions. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsRealLValue * convVar ();  Retrieve the convolution variable. ;  ; const RooAbsRealLValue * convVar () const;  Retrieve the convolution variable. ;  ; Int_t declareBasis (const char *expression, const RooArgList &params);  Declare a basis function for use in this physics model. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  This function forces RooRealIntegral to offer all integration dependents to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for internal integration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:5742,unsafe,unsafe,5742,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,4,['unsafe'],['unsafe']
Safety,"ooFit::Detail::CompileContext & ctx) const override;; 268 ; 269private:; 270 ; 271 std::unique_ptr<RooDataSet> generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype,; 272 double nEvents, bool verbose, bool randProtoOrder, bool resampleProto, bool skipInit=false,; 273 bool extended=false) const ;; 274 ; 275 // Implementation version; 276 virtual RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, bool showConstants=false,; 277 const char *label= """", double xmin=0.65,; 278 double xmax= 0.99,double ymax=0.95, const RooCmdArg* formatCmd=nullptr) ;; 279 ; 280 void logBatchComputationErrors(std::span<const double>& outputs, std::size_t begin) const;; 281 bool traceEvalPdf(double value) const;; 282 ; 283 /// Setter for the _normSet member, which should never be set directly.; 284 inline void setActiveNormSet(RooArgSet const* normSet) const {; 285 _normSet = normSet;; 286 // Also store the unique ID of the _normSet. This makes it possible to; 287 // detect if the pointer was invalidated.; 288 _normSetId = RooFit::getUniqueId(normSet);; 289 }; 290 ; 291protected:; 292 ; 293 virtual std::unique_ptr<RooAbsReal> createNLLImpl(RooAbsData& data, const RooLinkedList& cmdList);; 294 virtual std::unique_ptr<RooFitResult> fitToImpl(RooAbsData& data, const RooLinkedList& cmdList);; 295 ; 296 /// Checks if `normSet` is the currently active normalization set of this; 297 /// PDF, meaning is exactly the same object as the one the `_normSet` member; 298 /// points to (or both are `nullptr`).; 299 inline bool isActiveNormSet(RooArgSet const* normSet) const {; 300 return RooFit::getUniqueId(normSet).value() == _normSetId;; 301 }; 302 ; 303 double normalizeWithNaNPacking(double rawVal, double normVal) const;; 304 ; 305 RooPlot *plotOn(RooPlot *frame, PlotOpt o) const override;; 306 ; 307 friend class RooMCStudy ;; 308 ; 309 Int_t* randomizeProtoOrder(Int_t nProto,Int_t nGen,bool resample=false) const ;; 310 ; 311 // This also forces the definition of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:14187,detect,detect,14187,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['detect'],['detect']
Safety,"ooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4860,recover,recovery,4860,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recovery']
Safety,"ooVectorDataStore & ; vstore). overrideprotectedvirtual . Overload RooAbsReal::attachToTree to also attach branches for errors and/or asymmetric errors attribute StoreError and/or StoreAsymError are set. ; Reimplemented from RooAbsReal.; Definition at line 1069 of file RooRealVar.cxx. ◆ chopAt(). double RooRealVar::chopAt ; (; double ; what, . Int_t ; where . ); const. protected . Utility to calculate number of decimals to show based on magnitude of error. ; Definition at line 1055 of file RooRealVar.cxx. ◆ Class(). static TClass * RooRealVar::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooRealVar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooRealVar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 173 of file RooRealVar.h. ◆ cleanup(). void RooRealVar::cleanup ; (; ). static . Explicitly deletes the shared properties list on exit to avoid problems with the initialization order. ; Meant to be only used internally in RooFit by RooSentinel. ; Definition at line 75 of file RooRealVar.cxx. ◆ clone(). TObject * RooRealVar::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 48 of file RooRealVar.h. ◆ copyCache(). void RooRealVar::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache Warning: This function copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Reimplemented from RooAbsRealLValue.; Definition at line 1193 of file RooRealVar.cxx. ◆ copyCacheFast(). void RooRealVar::copyCacheFast ; (; const RooRealVar & ; other, . bool ; setValDirty = true . ). inline . Definition at line 131 of file RooRealVar.h. ◆ DeclFileName(). static const char * RooRealVar::DeclFileName ; (; ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:76499,avoid,avoid,76499,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['avoid'],['avoid']
Safety,"oof::EQueryMode mode); voidSetRealTimeLog(Bool_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); Int_tUploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:15934,abort,abort,15934,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['abort'],['abort']
Safety,"oof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoParallel(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:21378,timeout,timeout,21378,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,3,['timeout'],['timeout']
Safety,"oof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp|kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoParallel(Int_t nodes, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:21233,timeout,timeout,21233,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['timeout'],['timeout']
Safety,"oof::ShowDataSet(const char* dataset = """", const char* opt = ""filter:SsCc""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector&); voidTProof::ShowMissingFiles(TQueryResult* qr = 0); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual voidTProof::ShowStagingStatusDataSet(const char* dataset, const char* optStr = ""filter:SsCc""); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char*, TList*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSet(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadDataSetFromFile(const char*, const char*, const char* = 0, Int_t = 0, TList* = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:19268,timeout,timeout,19268,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,4,['timeout'],['timeout']
Safety,"oolNode.h. ◆ GetNpoints(). Int_t TGeoIntersection::GetNpoints ; (; ). overridevirtual . Returns number of vertices for the composite shape described by this intersection. ; Implements TGeoBoolNode.; Definition at line 1599 of file TGeoBoolNode.cxx. ◆ IsA(). TClass * TGeoIntersection::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBoolNode.; Definition at line 166 of file TGeoBoolNode.h. ◆ MakeClone(). TGeoBoolNode * TGeoIntersection::MakeClone ; (; ); const. overridevirtual . Make a clone of this. Pointers are preserved. ; Implements TGeoBoolNode.; Definition at line 1230 of file TGeoBoolNode.cxx. ◆ Paint(). void TGeoIntersection::Paint ; (; Option_t * ; option). overridevirtual . Paint method. ; Reimplemented from TGeoBoolNode.; Definition at line 1238 of file TGeoBoolNode.cxx. ◆ Safety(). Double_t TGeoIntersection::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Compute safety distance for a union node;. ; Implements TGeoBoolNode.; Definition at line 1641 of file TGeoBoolNode.cxx. ◆ SavePrimitive(). void TGeoIntersection::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBoolNode.; Definition at line 1665 of file TGeoBoolNode.cxx. ◆ Sizeof3D(). void TGeoIntersection::Sizeof3D ; (; ); const. overridevirtual . Register 3D size of this shape. ; Reimplemented from TGeoBoolNode.; Definition at line 1684 of file TGeoBoolNode.cxx. ◆ Streamer(). void TGeoIntersection::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBoolNode. ◆ StreamerNVirtual(). void TGeoIntersection::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 166 of file TGeoBoolNode.h. Libraries for TGeoIntersection:. [legend]; The documentation for this class was generated from the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoIntersection.html:18470,safe,safety,18470,doc/master/classTGeoIntersection.html,https://root.cern,https://root.cern/doc/master/classTGeoIntersection.html,1,['safe'],['safety']
Safety,"ool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:3362,safe,safe,3362,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,6,['safe'],['safe']
Safety,"ool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoParaboloid&operator=(const TGeoParaboloid&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParaboloidDi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoParaboloid.html:8725,safe,safe,8725,root/html602/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html602/TGeoParaboloid.html,4,['safe'],['safe']
Safety,"ool_t IsStepEntering () const;  ; Bool_t IsStepExiting () const;  ; void LocalToMaster (const Double_t *local, Double_t *master) const;  ; void LocalToMasterBomb (const Double_t *local, Double_t *master) const;  ; void LocalToMasterVect (const Double_t *local, Double_t *master) const;  ; void MasterToLocal (const Double_t *master, Double_t *local) const;  ; void MasterToLocalBomb (const Double_t *master, Double_t *local) const;  ; void MasterToLocalVect (const Double_t *master, Double_t *local) const;  ; void MasterToTop (const Double_t *master, Double_t *top) const;  Convert coordinates from master volume frame to top. ;  ; void PopDummy (Int_t ipop=9999);  ; Bool_t PopPath ();  ; Bool_t PopPath (Int_t index);  ; Bool_t PopPoint ();  ; Bool_t PopPoint (Int_t index);  ; Int_t PushPath (Int_t startlevel=0);  ; Int_t PushPoint (Int_t startlevel=0);  ; void ResetAll ();  Reset the navigator. ;  ; void ResetState ();  Reset current state flags. ;  ; Double_t Safety (Bool_t inside=kFALSE);  Compute safe distance from the current point. ;  ; TGeoNode * SearchNode (Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr);  Returns the deepest node containing fPoint, which must be set a priori. ;  ; void SetCheckingOverlaps (Bool_t flag=kTRUE);  ; void SetCldirChecked (Double_t *dir);  ; void SetCurrentDirection (const Double_t *dir);  ; void SetCurrentDirection (Double_t nx, Double_t ny, Double_t nz);  ; void SetCurrentPoint (const Double_t *point);  ; void SetCurrentPoint (Double_t x, Double_t y, Double_t z);  ; void SetLastPoint (Double_t x, Double_t y, Double_t z);  ; void SetLastSafetyForPoint (Double_t safe, const Double_t *point);  ; void SetLastSafetyForPoint (Double_t safe, Double_t x, Double_t y, Double_t z);  ; void SetOutside (Bool_t flag=kTRUE);  ; void SetStartSafe (Bool_t flag=kTRUE);  ; void SetStep (Double_t step);  ; TGeoNode * Step (Bool_t is_geom=kTRUE, Bool_t cross=kTRUE);  Make a rectiliniar step of length fStep from current point (fPoint) on current",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:8138,safe,safe,8138,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,"oord from vy; and the errors from vectors vex and vey.; The number of points in the graph is the minimum of number of points; in vx and vy. TGraphErrors(const TGraphErrors& gr); TGraphErrors copy constructor. TGraphErrors& operator=(const TGraphErrors& gr); TGraphErrors assignment operator. TGraphErrors(const TH1* h); TGraphErrors constructor importing its parameters from the TH1 object passed as argument. TGraphErrors(const char* filename, const char* format = ""%lg %lg %lg %lg"", Option_t* option = """"); GraphErrors constructor reading input from filename; filename is assumed to contain at least 3 columns of numbers; convention for format (default=""%lg %lg %lg %lg); format = ""%lg %lg"" read only 2 first columns into X,Y; format = ""%lg %lg %lg"" read only 3 first columns into X,Y and EY; format = ""%lg %lg %lg %lg"" read only 4 first columns into X,Y,EX,EY.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraphErrors(); TGraphErrors default destructor. void Apply(TF1* f); apply function to all the data points; y = f(x,y). The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphErrors.html:16768,avoid,avoid,16768,root/html532/TGraphErrors.html,https://root.cern,https://root.cern/root/html532/TGraphErrors.html,2,['avoid'],['avoid']
Safety,"oostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVector();; 583 } else {; 584 // TODO - should attempt to Throw with msg about; 585 // boostToCM computed for two 4-vectors with combined t=0; 586 return BetaVector(vecSum/eSum);; 587 }; 588 // TODO - should attempt to Throw with msg about; 589 // boostToCM computed for two 4-vectors with combined e=0; 590 }; 591 return BetaVector (vecSum * (-1./eSum));; 592 }; 593 ; 594 //beta and gamma; 595 ; 596 /**; 597 Return beta scalar value; 598 */; 599 Scalar Beta() const {; 600 if ( E() == 0 ) {; 601 if ( P2() == 0); 602 // to avoid Nan; 603 return 0;; 604 else {; 605 GenVector::Throw (""LorentzVector::Beta() - beta computed for LorentzVector with t = 0. Return an Infinite result"");; 606 return 1./E();; 607 }; 608 }; 609 if ( M2() <= 0 ) {; 610 GenVector::Throw (""LorentzVector::Beta() - beta computed for non-timelike LorentzVector . Result is physically meaningless"" );; 611 }; 612 return P() / E();; 613 }; 614 /**; 615 Return Gamma scalar value; 616 */; 617 Scalar Gamma() const {; 618 const Scalar v2 = P2();; 619 const Scalar t2 = E() * E();; 620 if (E() == 0) {; 621 if ( P2() == 0) {; 622 return 1;; 623 } else {; 624 GenVector::Throw (""LorentzVector::Gamma() - gamma computed for LorentzVector with t = 0. Return a zero result"");; 625 ; 626 }; 627 }; 628 if ( t2 < v2 ) {; 629 GenVector::Throw (""LorentzVector::Gamma() - gamma computed for a spacelike LorentzVector. Imaginary result"");; 630 return 0;; 631 }; 632 else if ( t2 == v2 ) {; 633 GenVector::Throw (""LorentzVector::Gamma() - gamm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:19232,avoid,avoid,19232,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['avoid'],['avoid']
Safety,"opPoint() [2/2]. Bool_t TGeoNavigator::PopPoint ; (; Int_t ; index). inline . Definition at line 272 of file TGeoNavigator.h. ◆ PushPath(). Int_t TGeoNavigator::PushPath ; (; Int_t ; startlevel = 0). inline . Definition at line 246 of file TGeoNavigator.h. ◆ PushPoint(). Int_t TGeoNavigator::PushPoint ; (; Int_t ; startlevel = 0). inline . Definition at line 263 of file TGeoNavigator.h. ◆ ResetAll(). void TGeoNavigator::ResetAll ; (; ). Reset the navigator. ; Definition at line 2708 of file TGeoNavigator.cxx. ◆ ResetState(). void TGeoNavigator::ResetState ; (; ). Reset current state flags. ; Definition at line 1643 of file TGeoNavigator.cxx. ◆ Safety(). Double_t TGeoNavigator::Safety ; (; Bool_t ; inside = kFALSE). Compute safe distance from the current point. ; This represent the distance from POINT to the closest boundary. ; Definition at line 1689 of file TGeoNavigator.cxx. ◆ SafetyOverlaps(). void TGeoNavigator::SafetyOverlaps ; (; ). protected . Compute safe distance from the current point within an overlapping node. ; Definition at line 1846 of file TGeoNavigator.cxx. ◆ SearchNode(). TGeoNode * TGeoNavigator::SearchNode ; (; Bool_t ; downwards = kFALSE, . const TGeoNode * ; skipnode = nullptr . ). Returns the deepest node containing fPoint, which must be set a priori. ; Check if parallel world navigation is enabled ; Definition at line 1924 of file TGeoNavigator.cxx. ◆ SetCheckingOverlaps(). void TGeoNavigator::SetCheckingOverlaps ; (; Bool_t ; flag = kTRUE). inline . Definition at line 147 of file TGeoNavigator.h. ◆ SetCldirChecked(). void TGeoNavigator::SetCldirChecked ; (; Double_t * ; dir). inline . Definition at line 193 of file TGeoNavigator.h. ◆ SetCurrentDirection() [1/2]. void TGeoNavigator::SetCurrentDirection ; (; const Double_t * ; dir). inline . Definition at line 185 of file TGeoNavigator.h. ◆ SetCurrentDirection() [2/2]. void TGeoNavigator::SetCurrentDirection ; (; Double_t ; nx, . Double_t ; ny, . Double_t ; nz . ). inline . Definition at line 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:41624,safe,safe,41624,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,"opagate with fStep=SNEXT (distance to boundary) and locate/return the next; 2734/// node.; 2735 ; 2736TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741////////////////////////////////////////////////////////////////////////////////; 2742/// Find distance to next boundary and store it in fStep. Returns node to which this; 2743/// boundary belongs. If PATH is specified, compute only distance to the node to which; 2744/// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; 2745/// than this value. STEPMAX represent the step to be made imposed by other reasons than; 2746/// geometry (usually physics processes). Therefore in this case this method provides the; 2747/// answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; 2748/// fStep with a big number.; 2749/// In case frombdr=kTRUE, the isotropic safety is set to zero.; 2750///; 2751/// Note : safety distance for the current point is computed ONLY in case STEPMAX is; 2752/// specified, otherwise users have to call explicitly TGeoManager::Safety() if; 2753/// they want this computed for the current point.; 2754 ; 2755TGeoNode *TGeoManager::FindNextBoundary(Double_t stepmax, const char *path, Bool_t frombdr); 2756{; 2757 // convert current point and direction to local reference; 2758 return GetCurrentNavigator()->FindNextBoundary(stepmax, path, frombdr);; 2759}; 2760 ; 2761////////////////////////////////////////////////////////////////////////////////; 2762/// Computes as fStep the distance to next daughter of the current volume.; 2763/// The point and direction must be converted in the coordinate system of the current volume.; 2764/// The proposed step limit is fStep.; 2765 ; 2766TGeoNode *TGeoManager::FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix); 2767{; 2768 return G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:98304,safe,safety,98304,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['safe'],['safety']
Safety,"opagateInGeom(Double_t*, Double_t*); voidScore(TGeoVolume*, Int_t, Double_t); Double_tTimingPerVolume(TGeoVolume*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TBuffer3D*fBuff1Buffer containing mesh vertices for first volume; TBuffer3D*fBuff2Buffer containing mesh vertices for second volume; Bool_t*fFlags! Array of flags per volume.; Bool_tfFullCheckFull overlap checking; TGeoManager*fGeoManagerpointer to geometry manager; Int_tfNchecks! Number of checks for current volume; Int_tfNmeshPoints! Number of points on mesh to be checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoChecker.html:9948,safe,safety,9948,root/html528/TGeoChecker.html,https://root.cern,https://root.cern/root/html528/TGeoChecker.html,4,['safe'],['safety']
Safety,"opagateInGeom(Double_t*, Double_t*); voidScore(TGeoVolume*, Int_t, Double_t); Double_tTimingPerVolume(TGeoVolume*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TBuffer3D*fBuff1Buffer containing mesh vertices for first volume; TBuffer3D*fBuff2Buffer containing mesh vertices for second volume; Bool_t*fFlags! Array of flags per volume.; Bool_tfFullCheckFull overlap checking; TGeoManager*fGeoManagerpointer to geometry manager; Int_tfNchecks! Number of checks for current volume; Int_tfNmeshPoints! Number of points on mesh to be checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char* msg = """"); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void Check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoChecker.html:10406,safe,safety,10406,root/html534/TGeoChecker.html,https://root.cern,https://root.cern/root/html534/TGeoChecker.html,2,['safe'],['safety']
Safety,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:31155,recover,recover,31155,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,5,['recover'],"['recover', 'recovered']"
Safety,"open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 240 of file TSQLFile.h. ◆ ReOpen(). Int_t TSQLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 719 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [1/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const char * ; clname, . Int_t ; version . ). protected . Search in database tables for specified class and return TSQLClassInfo object. ; Definition at line 1800 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [2/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const TClass * ; cl). protected . Search in database tables for specified class an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:85709,recover,recovered,85709,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Safety,"open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ◆ ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 372 of file TXMLFile.cxx. ◆ ResetErrno(). void TXMLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errno. ; Reimplemented from TFile.; Definition at line 64 of file TXMLFile.h. ◆ SaveToFile(). void TXMLFile::SaveToFile ; (; ). protected . Saves xml structures to the file xml elements are kept in list of TKeyXML objects When saving, all this elements are linked to root xml node At the end StreamerInfo structures are added After x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67760,recover,recovered,67760,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recovered']
Safety,"operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented from TTree.; Definition at line 91 of file TChain.h. ◆ FindBranch(). TBranch * TChain::FindBranch ; (; const char * ; name). overridevirtual . See TTree::GetReadEntry(). ; Reimplemented from TTree.; Reimplemented in TProofChain.; Definition at line 83",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:70875,recover,recoverable,70875,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['recover'],['recoverable']
Safety,"operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented from TTree.; Definition at line 91 of file TChain.h. ◆ FindBranch(). TBranch * TChain::FindBranch ; (; const char * ; name). overridevirtual . See TTree::GetReadEntry(). ; Reimplemented from TTree.; Reimplemented in TProofChain.; Definition at line 85",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:71284,recover,recoverable,71284,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['recover'],['recoverable']
Safety,"operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented in TChain, TNtuple, TNtupleD, and TTreeSQL.; Definition at line 4603 of file TTree.cxx. ◆ FindBranch(). TBranch * TTree::FindBranch ; (; const char * ; branchname). virtual . Return the branch that correspond to the path 'branchname', which can includ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:140104,recover,recoverable,140104,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['recover'],['recoverable']
Safety,"operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&Rmax(Int_t ipl); Double_t&Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPcon.html:8802,Safe,SafetySeg,8802,root/html602/TGeoPcon.html,https://root.cern,https://root.cern/root/html602/TGeoPcon.html,2,['Safe'],['SafetySeg']
Safety,"operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerAdaptive.html:6468,abort,abort,6468,root/html602/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html602/TPacketizerAdaptive.html,4,['abort'],['abort']
Safety,"operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPSocket.html:6173,timeout,timeout,6173,root/html530/TPSocket.html,https://root.cern,https://root.cern/root/html530/TPSocket.html,9,['timeout'],['timeout']
Safety,"operties; 69 TObjArray *fVisVolumes; // list of visible volumes; 70 Bool_t fIsEditable; // flag that geometry is editable; 71 ; 72 void DefineColors() const;; 73 void LocalToMasterVect(const Double_t *local, Double_t *master) const;; 74 ; 75protected:; 76 void ClearVisibleVolumes();; 77 ; 78public:; 79 TGeoPainter(TGeoManager *manager);; 80 ~TGeoPainter() override;; 81 ; 82 void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) override;; 83 TVirtualGeoTrack *AddTrack(Int_t id, Int_t pdgcode, TObject *part) override;; 84 void AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset = kFALSE) override;; 85 void BombTranslation(const Double_t *tr, Double_t *bombtr) override;; 86 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.) override;; 87 void CheckBoundaryReference(Int_t icheck = -1) override;; 88 void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000,; 89 const Double_t *vertex = nullptr) override;; 90 void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const override;; 91 void CheckEdit();; 92 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.) override;; 93 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) override;; 94 void CheckOverlaps(const TGeoVolume *vol, Double_t ovlp = 0.1, Option_t *option = """") const override;; 95 Int_t CountNodes(TGeoVolume *vol, Int_t level) const;; 96 Int_t CountVisibleNodes() override;; 97 void DefaultAngles() override;; 98 void DefaultColors() override;; 99 Int_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) override;; 100 void Draw(Option_t *option = """") override;; 101 void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option = """") override;; 102 void DrawOverlap(void *ovlp, Option_t *option = """") override;; 103 void DrawCurrentPoint(Int_t color) override;; 104 void DrawOnly(Option_t *option = """") override;; 105 void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8h_source.html:4029,safe,safety,4029,doc/master/TGeoPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html,1,['safe'],['safety']
Safety,"operty() [2/2]. Double_t TGeoMaterial::GetConstProperty ; (; Int_t ; i, . Bool_t * ; error = nullptr . ); const. Definition at line 405 of file TGeoMaterial.cxx. ◆ GetConstPropertyRef() [1/2]. const char * TGeoMaterial::GetConstPropertyRef ; (; const char * ; property); const. Definition at line 384 of file TGeoMaterial.cxx. ◆ GetConstPropertyRef() [2/2]. const char * TGeoMaterial::GetConstPropertyRef ; (; Int_t ; i); const. inline . Definition at line 90 of file TGeoMaterial.h. ◆ GetDefaultColor(). Int_t TGeoMaterial::GetDefaultColor ; (; ); const. virtual . Get some default color related to this material. ; Definition at line 614 of file TGeoMaterial.cxx. ◆ GetDensity(). virtual Double_t TGeoMaterial::GetDensity ; (; ); const. inlinevirtual . Definition at line 102 of file TGeoMaterial.h. ◆ GetElement() [1/2]. TGeoElement * TGeoMaterial::GetElement ; (; ); const. Get a pointer to the element this material is made of. ; This second call is to avoid warnings to not call a virtual method from the constructor ; Definition at line 625 of file TGeoMaterial.cxx. ◆ GetElement() [2/2]. TGeoElement * TGeoMaterial::GetElement ; (; Int_t ; i); const. virtual . Get a pointer to the element this material is made of. ; Reimplemented in TGeoMixture.; Definition at line 636 of file TGeoMaterial.cxx. ◆ GetElementProp(). void TGeoMaterial::GetElementProp ; (; Double_t & ; a, . Double_t & ; z, . Double_t & ; w, . Int_t ; i = 0 . ). virtual . Single interface to get element properties. ; Reimplemented in TGeoMixture.; Definition at line 647 of file TGeoMaterial.cxx. ◆ GetFWExtension(). TGeoExtension * TGeoMaterial::GetFWExtension ; (; ); const. inline . Definition at line 119 of file TGeoMaterial.h. ◆ GetIndex(). Int_t TGeoMaterial::GetIndex ; (; ). Retrieve material index in the list of materials. ; Definition at line 657 of file TGeoMaterial.cxx. ◆ GetIntLen(). virtual Double_t TGeoMaterial::GetIntLen ; (; ); const. inlinevirtual . Definition at line 110 of file TGeoMaterial.h. ◆ Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoMaterial.html:27301,avoid,avoid,27301,doc/master/classTGeoMaterial.html,https://root.cern,https://root.cern/doc/master/classTGeoMaterial.html,1,['avoid'],['avoid']
Safety,"options ""FB"" and ""BB"" suppress the ""Front Box"" and ""Back Box"" around the plot.; {; auto c2 = new TCanvas(""c2"",""c2"",600,400);; auto f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; }; TF3A 3-Dim function with parameters.Definition TF3.h:28. Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated functions of an histogram h without calling TH1::Fit simply doing: h->GetListOfFunctions()->Add(f1);; or h->GetListOfFunctions()->Add(f1,someoption);; To retrieve a function by name from this list, do: TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);; or TF1 *f1 = h->GetFunction(name);; Associated functions are automatically painted when an histogram is drawn. To avoid the painting of the associated functions the option HIST should be added to the list of the options used to paint the histogram. Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D graphics library. The plotting options start with GL keyword. In addition, in order to inform canvases that OpenGL should be used to render 3D representations, the following option should be set: gStyle->SetCanvasPreferGL(true);; General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. Option Description . ""GLLEGO"" Draw a lego plot. It works also for TH2Poly. . ""GLLEGO2"" Bins with color levels. . ""GLLEGO3"" Cylindrical bars. . Lego painter in cartesian supports logarithmic scales for X, Y, Z. In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. Option Description . ""GLSURF"" Draw a surface. . ""GLSURF1"" Surface with color levels . ""GLSURF2"" The same as ""GLSURF1"" but without p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:123187,avoid,avoid,123187,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['avoid'],['avoid']
Safety,"or ""silence"" option in configuration option string ; Definition at line 691 of file Tools.cxx. ◆ CheckForVerboseOption(). Bool_t TMVA::Tools::CheckForVerboseOption ; (; const TString & ; cs); const. check if verbosity ""V"" set in option ; Definition at line 708 of file Tools.cxx. ◆ CheckSplines(). Bool_t TMVA::Tools::CheckSplines ; (; const TH1 * ; theHist, . const TSpline * ; theSpline . ). check quality of splining by comparing splines and histograms in each bin ; Definition at line 479 of file Tools.cxx. ◆ Color(). const TString & TMVA::Tools::Color ; (; const TString & ; c). human readable color strings ; Definition at line 828 of file Tools.cxx. ◆ ComputeStat(). void TMVA::Tools::ComputeStat ; (; const std::vector< TMVA::Event * > & ; events, . std::vector< Float_t > * ; valVec, . Double_t & ; meanS, . Double_t & ; meanB, . Double_t & ; rmsS, . Double_t & ; rmsB, . Double_t & ; xmin, . Double_t & ; xmax, . Int_t ; signalClass, . Bool_t ; norm = kFALSE . ). sanity check ; Definition at line 202 of file Tools.cxx. ◆ ComputeVariance(). Double_t TMVA::Tools::ComputeVariance ; (; Double_t ; sumx2, . Double_t ; sumx, . Int_t ; nx . ). inline . compute variance from given sums ; Definition at line 358 of file Tools.h. ◆ ContainsRegularExpression(). Bool_t TMVA::Tools::ContainsRegularExpression ; (; const TString & ; s). check if regular expression helper function to search for ""$!%^&()'<>?= "" in a string ; Definition at line 784 of file Tools.cxx. ◆ DestroyInstance(). void TMVA::Tools::DestroyInstance ; (; ). static . Definition at line 82 of file Tools.cxx. ◆ FormattedOutput() [1/3]. void TMVA::Tools::FormattedOutput ; (; const std::vector< Double_t > & ; values, . const std::vector< TString > & ; V, . const TString ; titleVars, . const TString ; titleValues, . MsgLogger & ; logger, . TString ; format = ""%+1.3f"" . ). formatted output of simple table ; Definition at line 887 of file Tools.cxx. ◆ FormattedOutput() [2/3]. void TMVA::Tools::FormattedOutput ; (; const TMatr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Tools.html:13516,sanity check,sanity check,13516,doc/master/classTMVA_1_1Tools.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Tools.html,1,['sanity check'],['sanity check']
Safety,"or class code unload/reload and schema evolution. ; Definition at line 2209 of file TBranchElement.cxx. ◆ IsA(). TClass * TBranchElement::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TBranch.; Definition at line 255 of file TBranchElement.h. ◆ IsBranchFolder(). bool TBranchElement::IsBranchFolder ; (; ); const. inline . Definition at line 211 of file TBranchElement.h. ◆ IsFolder(). bool TBranchElement::IsFolder ; (; ); const. overridevirtual . Return true if more than one leaf, false otherwise. ; Reimplemented from TBranch.; Definition at line 3758 of file TBranchElement.cxx. ◆ IsMissingCollection(). bool TBranchElement::IsMissingCollection ; (; ); const. protected . Detect a collection written using a zero pointer in old versions of root. ; In versions of ROOT older than 4.00/03, if a collection (TClonesArray or STL container) was split but the pointer to the collection was zeroed out, nothing was saved. Hence there is no easy way to detect the case. In newer versions, a zero is written so that a 'missing' collection appears to be an empty collection. ; Definition at line 3776 of file TBranchElement.cxx. ◆ IsObjectOwner(). virtual bool TBranchElement::IsObjectOwner ; (; ); const. inlinevirtual . Definition at line 213 of file TBranchElement.h. ◆ Notify(). bool TBranchElement::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 214 of file TBranchElement.h. ◆ operator=(). TBra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:59362,detect,detect,59362,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['detect'],['detect']
Safety,"or each bin.; 178/// This is an array of type double and size nbinsx+1; 179/// \param[in] nbinsy number of bins; 180/// \param[in] ybins array of low-edges for each bin.; 181/// This is an array of type double and size nbinsy+1; 182 ; 183TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 184 ,Int_t nbinsy,const Double_t *ybins); 185 :TH1(name,title,nbinsx,xbins); 186{; 187 fDimension = 2;; 188 fScalefactor = 1;; 189 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 190 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 191 if (ybins) fYaxis.Set(nbinsy,ybins);; 192 else fYaxis.Set(nbinsy,0,1);; 193 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 194}; 195 ; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198/// Constructor for variable bin size (along X and Y axis) 2-D histograms using input; 199/// arrays of type float.; 200///; 201/// \param[in] name name of histogram (avoid blanks); 202/// \param[in] title histogram title.; 203/// If title is of the form `stringt;stringx;stringy;stringz`; 204/// the histogram title is set to `stringt`,; 205/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 206/// \param[in] nbinsx number of bins; 207/// \param[in] xbins array of low-edges for each bin.; 208/// This is an array of type float and size nbinsx+1; 209/// \param[in] nbinsy number of bins; 210/// \param[in] ybins array of low-edges for each bin.; 211/// This is an array of type float and size nbinsy+1; 212 ; 213TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 214 ,Int_t nbinsy,const Float_t *ybins); 215 :TH1(name,title,nbinsx,xbins); 216{; 217 fDimension = 2;; 218 fScalefactor = 1;; 219 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 220 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 221 if (ybins) fYaxis.Set(nbinsy,ybins);; 222 else fYaxis.Set(nbinsy,0,1);; 223 fNcells = fNcells*(n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:9058,avoid,avoid,9058,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"or indexing must be present in mainTree.; 1240// Return true if the trees can be friends, false otherwise.; 1241bool CheckReshuffling(TTree &mainTree, TTree &friendTree); 1242{; 1243 const auto isMainReshuffled = mainTree.TestBit(TTree::kEntriesReshuffled);; 1244 const auto isFriendReshuffled = friendTree.TestBit(TTree::kEntriesReshuffled);; 1245 const auto friendHasValidIndex = [&] {; 1246 auto idx = friendTree.GetTreeIndex();; 1247 return idx ? idx->IsValidFor(&mainTree) : false;; 1248 }();; 1249 ; 1250 if ((isMainReshuffled || isFriendReshuffled) && !friendHasValidIndex) {; 1251 const auto reshuffledTreeName = isMainReshuffled ? mainTree.GetName() : friendTree.GetName();; 1252 const auto msg =; 1253 ""Tree '%s' has the kEntriesReshuffled bit set and cannot have friends nor can be added as a friend unless the ""; 1254 ""main tree has a TTreeIndex on the friend tree '%s'. You can also unset the bit manually if you know what you ""; 1255 ""are doing; note that you risk associating wrong TTree entries of the friend with those of the main TTree!"";; 1256 Error(""AddFriend"", msg, reshuffledTreeName, friendTree.GetName());; 1257 return false;; 1258 }; 1259 return true;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:44741,risk,risk,44741,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['risk'],['risk']
Safety,"or memcpy if they are equal.; 466 if (I != E); 467 memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));; 468 }; 469 ; 470 /// Double the size of the allocated memory, guaranteeing space for at; 471 /// least one more element or MinSize if specified.; 472 void grow(size_t MinSize = 0); 473 {; 474 this->grow_pod(MinSize, sizeof(T));; 475 }; 476 ; 477public:; 478 using iterator = typename SuperClass::iterator;; 479 using const_iterator = typename SuperClass::const_iterator;; 480 using reference = typename SuperClass::reference;; 481 using size_type = typename SuperClass::size_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLineSize = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RVec_8hxx_source.html:18126,avoid,avoid,18126,doc/v632/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RVec_8hxx_source.html,1,['avoid'],['avoid']
Safety,"or memcpy if they are equal.; 466 if (I != E); 467 memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));; 468 }; 469 ; 470 /// Double the size of the allocated memory, guaranteeing space for at; 471 /// least one more element or MinSize if specified.; 472 void grow(size_t MinSize = 0); 473 {; 474 this->grow_pod(MinSize, sizeof(T));; 475 }; 476 ; 477public:; 478 using iterator = typename SuperClass::iterator;; 479 using const_iterator = typename SuperClass::const_iterator;; 480 using reference = typename SuperClass::reference;; 481 using size_type = typename SuperClass::size_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T));; 488 this->set_size(this->size() + 1);; 489 }; 490 ; 491 void pop_back() { this->set_size(this->size() - 1); }; 492};; 493 ; 494/// Storage for the SmallVector elements. This is specialized for the N=0 case; 495/// to avoid allocating unnecessary storage.; 496template <typename T, unsigned N>; 497struct SmallVectorStorage {; 498 alignas(T) char InlineElts[N * sizeof(T)]{};; 499};; 500 ; 501/// We need the storage to be properly aligned even for small-size of 0 so that; 502/// the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is; 503/// well-defined.; 504template <typename T>; 505struct alignas(T) SmallVectorStorage<T, 0> {; 506};; 507 ; 508/// The size of the inline storage of an RVec.; 509/// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); 510/// unless the size of the buffer with 8 elements would be over a certain maximum size.; 511template <typename T>; 512struct RVecInlineStorageSize {; 513private:; 514#ifdef R__HAS_HARDWARE_INTERFERENCE_SIZE; 515 static constexpr std::size_t cacheLineSize = std::hardware_destructive_interference_size;; 516#else; 517 // safe bet: assume the typical 64 bytes; 518 static constexpr std::size_t cacheLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:18127,avoid,avoid,18127,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,1,['avoid'],['avoid']
Safety,"or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:3335,avoid,avoided,3335,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['avoid'],['avoided']
Safety,"or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuit.html:3335,avoid,avoided,3335,root/html602/TMinuit.html,https://root.cern,https://root.cern/root/html602/TMinuit.html,4,['avoid'],['avoided']
Safety,"or only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TSlave ();  Default constructor used by derived classes. ;  ; virtual void FlushSocket ();  ; void Init (TSocket *s, Int_t stype);  Init a PROOF slave object using the connection opened via s. ;  ; virtual void Interrupt (Int_t type);  Send interrupt OOB byte to master or slave servers. ;  ; virtual Int_t Ping ();  Ping the remote master or slave servers. ;  ; virtual TObjString * SendCoordinator (Int_t kind, const char *msg=0, Int_t int2=0);  Send message to intermediate coordinator. ;  ; virtual Int_t SendGroupPriority (const char *, Int_t);  ; virtual void SetAlias (const char *alias);  Set an alias for this session. ;  ; void SetSocket (TSocket *s);  ; virtual void SetStatus (Int_t st);  ; virtual void StopProcess (Bool_t abort, Int_t timeout);  Sent stop/abort request to PROOF server. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TString fArchComp;  ; Long64_t fBytesRead;  ; Float_t fCpuTime;  ; TString fGroup;  ; TString fImage;  ; TFileHandler * fInput;  ; TString fMsd;  ; TString fName;  ; TString fOrdinal;  ; Int_t fParallel;  ; Int_t fPerfIdx;  ; Int_t fPort;  ; TProof * fProof;  ; TString fProofWorkDir;  ; Int_t fProtocol;  ; Float_t fRealTime;  ; TString fROOTVers;  ; TString fSessionTag;  ; ESlaveType fSlaveType;  ; TSocket * fSocket;  ; Int_t fStatus;  ; TString fUser;  ; TString fWorkDir;  . Private Member Functions;  TSlave (const char *host, const char *ord, Int_t perf, const char *image, TProof *proof, Int_t stype, const char *workdir, const char *msd, Int_t=1);  Create a PROOF s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSlave.html:12101,abort,abort,12101,doc/master/classTSlave.html,https://root.cern,https://root.cern/doc/master/classTSlave.html,3,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"or the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool_t Exec(const char* sql); Execute SQL command which does not produce any result sets.; Returns kTRUE if successful. Int_t SelectDataBase(const char* dbname); Select a database. Returns 0 if successful, non-zero otherwise. TSQLResult * GetDataBases(const char* wild = 0); List all available databases. Wild is for wildcarding ""t%"" list all; databases starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TSQLResult * GetTables(const char* dbname, const char* wild = 0); List all tables in the specified database. Wild is for wildcarding; ""t%"" list a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMySQLServer.html:9932,timeout,timeout,9932,root/html528/TMySQLServer.html,https://root.cern,https://root.cern/root/html528/TMySQLServer.html,10,['timeout'],['timeout']
Safety,"or the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13/** \class TGeoVolume; 14\ingroup Shapes_classes; 15 ; 16TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes; 17 ; 18 Volumes are the basic objects used in building the geometrical hierarchy.; 19They represent unpositioned objects but store all information about the; 20placement of the other volumes they may contain. Therefore a volume can; 21be replicated several times in the geometry. In order to create a volume, one; 22has to put together a shape and a medium which are already defined. Volumes; 23have to be named by users at creation time. Every different name may represent a; 24an unique volume object, but may also represent more general a family (class); 25of volume objects having the same shape type and medium, but possibly; 26different shape parameters. It is the user's task to provide different names; 27for different volume families in order to avoid ambiguities at tracking time.; 28A generic family rather than a single volume is created only in two cases :; 29when a generic shape is provided to the volume constructor or when a division; 30operation is applied. Each volume in the geometry stores an unique; 31ID corresponding to its family. In order to ease-up their creation, the manager; 32class is providing an API that allows making a shape and a volume in a single step.; 33 ; 34 Volumes are objects that can be visualized, therefore having visibility,; 35colour, line and fill attributes that can be defined or modified any time after; 36the volume creation. It is advisable however to define these properties just; 37after the first creation of a volume namespace, since in case of volume families; 38any new member created by the modeler inherits these properties.; 39 ; 40 In order to provide navigation features, volumes have to be able to find; 41the proper container of any point defined in the loc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:1574,avoid,avoid,1574,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['avoid'],['avoid']
Safety,"or.h""; 45#include ""Math/AdaptiveIntegratorMultiDim.h""; 46#include ""Math/RichardsonDerivator.h""; 47#include ""Math/Functor.h""; 48#include ""Math/Minimizer.h""; 49#include ""Math/MinimizerOptions.h""; 50#include ""Math/Factory.h""; 51#include ""Math/ChebyshevPol.h""; 52#include ""Fit/FitResult.h""; 53// for I/O backward compatibility; 54#include ""v5/TF1Data.h""; 55 ; 56#include ""AnalyticalIntegrals.h""; 57 ; 58std::atomic<Bool_t> TF1::fgAbsValue(kFALSE);; 59Bool_t TF1::fgRejectPoint = kFALSE;; 60std::atomic<Bool_t> TF1::fgAddToGlobList(kTRUE);; 61static Double_t gErrorTF1 = 0;; 62 ; 63using TF1Updater_t = void (*)(Int_t nobjects, TObject **from, TObject **to);; 64bool R__SetClonesArrayTF1Updater(TF1Updater_t func);; 65 ; 66 ; 67namespace {; 68struct TF1v5Convert : public TF1 {; 69public:; 70 void Convert(ROOT::v5::TF1Data &from); 71 {; 72 // convert old TF1 to new one; 73 fNpar = from.GetNpar();; 74 fNdim = from.GetNdim();; 75 if (from.fType == 0) {; 76 // formula functions; 77 // if ndim is not 1 set xmin max to zero to avoid error in ctor; 78 double xmin = from.fXmin;; 79 double xmax = from.fXmax;; 80 if (fNdim > 1) {; 81 xmin = 0;; 82 xmax = 0;; 83 }; 84 TF1 fnew(from.GetName(), from.GetExpFormula(), xmin, xmax);; 85 if (fNdim > 1) {; 86 fnew.SetRange(from.fXmin, from.fXmax);; 87 }; 88 fnew.Copy(*this);; 89 // need to set parameter values; 90 if (from.GetParameters()); 91 fFormula->SetParameters(from.GetParameters());; 92 } else {; 93 // case of a function pointers; 94 fParams = std::make_unique<TF1Parameters>(fNpar);; 95 fName = from.GetName();; 96 fTitle = from.GetTitle();; 97 // need to set parameter values; 98 if (from.GetParameters()); 99 fParams->SetParameters(from.GetParameters());; 100 }; 101 // copy the other data members; 102 fNpx = from.fNpx;; 103 fType = (EFType)from.fType;; 104 fNpfits = from.fNpfits;; 105 fNDF = from.fNDF;; 106 fChisquare = from.fChisquare;; 107 fMaximum = from.fMaximum;; 108 fMinimum = from.fMinimum;; 109 fXmin = from.fXmin;; 110 fXmax = from.fXm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:2570,avoid,avoid,2570,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['avoid'],['avoid']
Safety,"or::SetCldirChecked ; (; Double_t * ; dir). inline . Definition at line 193 of file TGeoNavigator.h. ◆ SetCurrentDirection() [1/2]. void TGeoNavigator::SetCurrentDirection ; (; const Double_t * ; dir). inline . Definition at line 185 of file TGeoNavigator.h. ◆ SetCurrentDirection() [2/2]. void TGeoNavigator::SetCurrentDirection ; (; Double_t ; nx, . Double_t ; ny, . Double_t ; nz . ). inline . Definition at line 186 of file TGeoNavigator.h. ◆ SetCurrentPoint() [1/2]. void TGeoNavigator::SetCurrentPoint ; (; const Double_t * ; point). inline . Definition at line 172 of file TGeoNavigator.h. ◆ SetCurrentPoint() [2/2]. void TGeoNavigator::SetCurrentPoint ; (; Double_t ; x, . Double_t ; y, . Double_t ; z . ). inline . Definition at line 173 of file TGeoNavigator.h. ◆ SetLastPoint(). void TGeoNavigator::SetLastPoint ; (; Double_t ; x, . Double_t ; y, . Double_t ; z . ). inline . Definition at line 179 of file TGeoNavigator.h. ◆ SetLastSafetyForPoint() [1/2]. void TGeoNavigator::SetLastSafetyForPoint ; (; Double_t ; safe, . const Double_t * ; point . ). inline . Definition at line 194 of file TGeoNavigator.h. ◆ SetLastSafetyForPoint() [2/2]. void TGeoNavigator::SetLastSafetyForPoint ; (; Double_t ; safe, . Double_t ; x, . Double_t ; y, . Double_t ; z . ). inline . Definition at line 199 of file TGeoNavigator.h. ◆ SetOutside(). void TGeoNavigator::SetOutside ; (; Bool_t ; flag = kTRUE). inline . Definition at line 148 of file TGeoNavigator.h. ◆ SetPWSafetyCaching(). static void TGeoNavigator::SetPWSafetyCaching ; (; Bool_t ; b). inlinestatic . Definition at line 231 of file TGeoNavigator.h. ◆ SetStartSafe(). void TGeoNavigator::SetStartSafe ; (; Bool_t ; flag = kTRUE). inline . Definition at line 136 of file TGeoNavigator.h. ◆ SetStep(). void TGeoNavigator::SetStep ; (; Double_t ; step). inline . Definition at line 137 of file TGeoNavigator.h. ◆ Step(). TGeoNode * TGeoNavigator::Step ; (; Bool_t ; is_geom = kTRUE, . Bool_t ; cross = kTRUE . ). Make a rectiliniar step of le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:43261,safe,safe,43261,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safe']
Safety,"or::fOutputlist of objects created during processing; Long64_tTSelector::fStatusselector status. private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupPySelf(); Install the python side identity of the TPySelector. PyObject* CallSelf(const char* method, PyObject* pyobject = 0); Forward <method> to python. TPySelector(TTree* = 0, PyObject* self = 0); Construct a TSelector derived with <self> as the underlying, which is; generally 0 to start out with in the current PROOF framework. ~TPySelector(); Destructor. Only deref if still holding on to Py_None (circular otherwise). Int_t Version() const; Return version number of this selector. First forward; if not overridden, then; yield an obvious ""undefined"" number,. Int_t GetEntry(Long64_t entry, Int_t getall = 0); Boilerplate get entry; same as for generated code; not forwarded. void Init(TTree* tree); Initialize with the current tree to be used; not forwarded (may be called; multiple times, and is called from Begin() and SlaveBegin() ). Bool_t Notify(); Forward call to derived Notify() if available. void Begin(TTree* tree = 0); First function called, and used to setup the python self; forward call. void SlaveBegin(TTree* tree); First function called on worker node, needs to make sure python self is setup,; then store the tree to be used, initialize client, and forward call. Bool_t Process(Long64_t entry); Actual processing; call is forwarded to python self. void SlaveTerminate(); End of client; call is forwarded to python self. void Terminate(); End of job; call is forwarded to python self. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); If no 'why' given, read from python error. » Last changed: Thu Nov 3 20:22:01 2011 » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPySelector.html:9714,Abort,Abort,9714,root/html532/TPySelector.html,https://root.cern,https://root.cern/root/html532/TPySelector.html,1,['Abort'],['Abort']
Safety,"or<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const Double32_t* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html:7362,avoid,avoid,7362,root/html534/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html,8,['avoid'],['avoid']
Safety,"or>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-06-30 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_float_2_.html:6744,avoid,avoid,6744,root/html602/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_float_2_.html,12,['avoid'],['avoid']
Safety,"or>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html:6692,avoid,avoid,6692,root/html534/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html,12,['avoid'],['avoid']
Safety,"or>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:6744,avoid,avoid,6744,root/html604/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html,12,['avoid'],['avoid']
Safety,"order { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id: KDEKernel.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__KDEKernel.html:2273,sanity check,sanity check,2273,root/html528/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html528/TMVA__KDEKernel.html,1,['sanity check'],['sanity check']
Safety,"ore it does not contain any; 24constraints related to physics. However, the package defines a number of; 25hooks for tracking, such as media, materials, magnetic field or track state flags,; 26in order to allow interfacing to tracking MC's. The final goal is to be; 27able to use the same geometry for several purposes, such as tracking,; 28reconstruction or visualization, taking advantage of the ROOT features; 29related to bookkeeping, I/O, histogramming, browsing and GUI's.; 30 ; 31 The geometrical modeler is the most important component of the package and; 32it provides answers to the basic questions like ""Where am I ?"" or ""How far; 33from the next boundary ?"", but also to more complex ones like ""How far from; 34the closest surface ?"" or ""Which is the next crossing along a helix ?"".; 35 ; 36 The architecture of the modeler is a combination between a GEANT-like; 37containment scheme and a normal CSG binary tree at the level of shapes. An; 38important common feature of all detector geometry descriptions is the; 39mother-daughter concept. This is the most natural approach when tracking; 40is concerned and imposes a set of constraints to the way geometry is defined.; 41Constructive solid geometry composition is used only in order to create more; 42complex shapes from an existing set of primitives through boolean operations.; 43This feature is not implemented yet but in future full definition of boolean; 44expressions will be supported.; 45 ; 46 Practically every geometry defined in GEANT style can be mapped by the modeler.; 47The basic components used for building the logical hierarchy of the geometry; 48are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; 49defined geometrical objects having a given shape and medium and possibly; 50containing a list of nodes. Nodes represent just positioned instances of volumes; 51inside a container volume and they are not directly defined by user. They are; 52automatically created as a result of adding one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:2088,detect,detector,2088,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['detect'],['detector']
Safety,"orflow.keras.layers import Input, Dense; ; model = Sequential(); model.add(Dense(64, activation=""relu"", input_dim=7)); model.add(Dense(64, activation=""relu"")); model.add(Dense(64, activation=""relu"")); model.add(Dense(64, activation=""relu"")); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(""model_higgs.h5""); model.summary(); ; if not os.path.exists(""model_higgs.h5""):; raise FileNotFoundError(""Error creating Keras model file - skip using Keras""); else:; # book PyKeras method only if Keras model could be created; ROOT.Info(""TMVA_Higgs_Classification"", ""Booking Deep Learning keras model""); factory.BookMethod(; loader,; TMVA.Types.kPyKeras,; ""PyKeras"",; H=True,; V=False,; VarTransform=None,; FilenameModel=""model_higgs.h5"",; FilenameTrainedModel=""trained_model_higgs.h5"",; NumEpochs=20,; BatchSize=100,; ); # GpuOptions=""allow_growth=True"",; # ) # needed for RTX NVidia card and to avoid TF allocates all GPU memory; ; ; ## Train Methods; ; # Here we train all the previously booked methods.; ; factory.TrainAllMethods(); ## Test all methods; ; # Now we test and evaluate all methods using the test data set; factory.TestAllMethods(); ; factory.EvaluateAllMethods(); ; # after we get the ROC curve and we display; ; c1 = factory.GetROCCurve(loader); c1.Draw(); # at the end we close the output file which contains the evaluation result of all methods and it can be used by TMVAGUI; # to display additional plots; ; outputFile.Close(); TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:67647,avoid,avoid,67647,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['avoid'],['avoid']
Safety,"orkNoStats Don't draw stats box. . kUserContour User specified contour levels. . kLogX X-axis in log scale. . kIsZoomed Bit set when zooming on Y axis. . kNoTitle Don't draw the histogram title. . kIsAverage Bin contents are average (used by Add) . kIsNotW Histogram is forced to be not weighted even when the histogram is filled with weighted. . kAutoBinPTwo different than 1. ; Use Power(2)-based algorithm for autobinning . kIsHighlight bit set if histo is highlight . Definition at line 164 of file TH1.h. Constructor & Destructor Documentation. ◆ TH1() [1/5]. TH1::TH1 ; (; const TH1 & ; ). privatedelete . ◆ TH1() [2/5]. TH1::TH1 ; (; ). protected . Histogram default constructor. ; Definition at line 615 of file TH1.cxx. ◆ TH1() [3/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . Double_t ; xlow, . Double_t ; xup . ). protected . Constructor for fix bin size histograms. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz, the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xlowlow edge of first bin ; [in]xupupper edge of last bin (not included in last bin) . Definition at line 697 of file TH1.cxx. ◆ TH1() [4/5]. TH1::TH1 ; (; const char * ; name, . const char * ; title, . Int_t ; nbins, . const Float_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type float. ; Creates the main histogram structure.; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type float and size nbins+1 . Definition at line 719 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:72359,avoid,avoid,72359,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['avoid'],['avoid']
Safety,"orm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistToSphere (const Double_t *point, const Double_t *dir, Double_t rsph, Bool_t check=kTRUE, Bool_t firstcross=kTRUE) const;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Int_t GetNumberOfDivisions () const;  ; Int_t GetNz () const;  ; Double_t GetPhi1 () const;  ; Double_t GetPhi2 () const;  ; Bool_t GetPo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoSphere.html:1407,safe,safe,1407,doc/master/classTGeoSphere.html,https://root.cern,https://root.cern/doc/master/classTGeoSphere.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"ormaly not necessary to make changes to the generated; code, but the routine can be extended by the user if needed.; Init() will be called many times when running on PROOF; (once per file to be processed). Bool_t Notify(); This function is called at the first entry of a new tree in a chain. Bool_t Process(Long64_t entry); The Process() function is called for each entry in the tree (or possibly; keyed object in the case of PROOF) to be processed. The entry argument; specifies which entry in the currently loaded tree is to be processed.; It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry(); to read either all or the required parts of the data. When processing; keyed objects with PROOF, the object is already loaded and is available; via the fObject pointer. This function should contain the ""body"" of the analysis. It can contain; simple or elaborate selection criteria, run algorithms on the data; of the event and typically fill histograms. The processing can be stopped by calling Abort(). Use fStatus to set the return value of TTree::Process(). The return value is currently not used. void SetSelection(const char* selection); set the selection expression. void SlaveTerminate(); The SlaveTerminate() function is called after all entries or objects; have been processed. When running with PROOF SlaveTerminate() is called; on each slave server. void Terminate(); The Terminate() function is the last function to be called during; a query. It always runs on the client, it can be used to present; the results graphically or save the results to file. TSelectorEntries(TTree* tree = 0, const char* selection = 0). Int_t Version() const; { return 2; }. Long64_t GetSelectedRows() const; { return fSelectedRows; }. void SetOption(const char* option); { fOption = option; }. void SetObject(TObject* obj); { fObject = obj; }. TList * GetOutputList() const; { return fOutput; }. » Author: Philippe Canal 09/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademaker",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelectorEntries.html:9509,Abort,Abort,9509,root/html602/TSelectorEntries.html,https://root.cern,https://root.cern/root/html602/TSelectorEntries.html,2,['Abort'],['Abort']
Safety,"ormation ;  CTLockFileA scoped lock based on files ;  CTLockGuard;  CTLockPathPath locking class allowing shared and exclusive locks ;  CTLockPathGuard;  ►CTLorentzRotationDescribes Lorentz transformations including Lorentz boosts and rotations (see TRotation) ;  CTLorentzRotationRow;  CTLorentzVectorTLorentzVector is a general four-vector class, which can be used either for the description of position and time (x,y,z,t) or momentum and energy (px,py,pz,E) ;  CTMacOSXSystem;  CTMacroClass supporting a collection of lines with C++ code ;  CTMakeProject;  CTMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries) ;  CTMapFileThis class implements a shared memory region mapped to a file ;  CTMapIterIterator of map ;  CTMapRecKeep track of an object in the mapped file ;  CTMarkerManages Markers ;  CTMarker3DBoxA special 3-D marker designed for event display ;  CTMaterialManages a detector material ;  CTMathTextTo draw TeX Mathematical Formula ;  CTMatrixDEigenTMatrixDEigen ;  CTMatrixDSymEigenTMatrixDSymEigen ;  CTMatrixTTMatrixT ;  CTMatrixTBaseLinear Algebra Package ;  CTMatrixTColumn;  CTMatrixTColumn_const;  CTMatrixTDiag;  CTMatrixTDiag_const;  CTMatrixTFlat;  CTMatrixTFlat_const;  CTMatrixTLazyTemplates of Lazy Matrix classes ;  CTMatrixTRow;  CTMatrixTRow_const;  CTMatrixTSparseTMatrixTSparse ;  CTMatrixTSparseDiag;  CTMatrixTSparseDiag_const;  CTMatrixTSparseRow;  CTMatrixTSparseRow_const;  CTMatrixTSub;  CTMatrixTSub_const;  CTMatrixTSymTMatrixTSym ;  CTMatrixTSymLazy;  CTMCImpMutexAutoLockRealization of TMCTemplateAutoLock with TMCMutex ;  CTMCParticleThis class serves as a data storage for description of one particle ;  CTMCTemplateAutoLockTemplate classe which provides a mechanism to create a mutex and locks/unlocks it ;  CTMCVerboseClass for printing a detailed information from MC application ;  CTMD5This code implements the MD5 message-digest algorithm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:177523,detect,detector,177523,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,4,['detect'],['detector']
Safety,"ormation ;  CTLockFileA scoped lock based on files ;  CTLockGuard;  CTLockPathPath locking class allowing shared and exclusive locks ;  CTLockPathGuard;  ►CTLorentzRotationDescribes Lorentz transformations including Lorentz boosts and rotations (see TRotation) ;  CTLorentzRotationRow;  CTLorentzVectorTLorentzVector is a general four-vector class, which can be used either for the description of position and time (x,y,z,t) or momentum and energy (px,py,pz,E) ;  CTMacOSXSystem;  CTMacroClass supporting a collection of lines with C++ code ;  CTMakeProject;  CTMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries) ;  CTMapFileThis class implements a shared memory region mapped to a file ;  CTMapIterIterator of map ;  CTMapRecKeep track of an object in the mapped file ;  CTMarkerManages Markers ;  CTMarker3DBoxA special 3-D marker designed for event display ;  CTMaterialManages a detector material ;  CTMathTextTo draw TeX Mathematical Formula ;  CTMatrixDEigenTMatrixDEigen ;  CTMatrixDSymEigenTMatrixDSymEigen ;  CTMatrixTTMatrixT ;  CTMatrixTBaseLinear Algebra Package ;  CTMatrixTColumn;  CTMatrixTColumn_const;  CTMatrixTDiag;  CTMatrixTDiag_const;  CTMatrixTFlat;  CTMatrixTFlat_const;  CTMatrixTLazyTemplates of Lazy Matrix classes ;  CTMatrixTRow;  CTMatrixTRow_const;  CTMatrixTSparseTMatrixTSparse ;  CTMatrixTSparseDiag;  CTMatrixTSparseDiag_const;  CTMatrixTSparseRow;  CTMatrixTSparseRow_const;  CTMatrixTSub;  CTMatrixTSub_const;  CTMatrixTSymTMatrixTSym ;  CTMatrixTSymLazy;  CTMCParticleThis class serves as a data storage for description of one particle ;  CTMCVerboseClass for printing a detailed information from MC application ;  CTMD5This code implements the MD5 message-digest algorithm ;  CTMehrotraSolver;  CTMemberInspectorAbstract base class for accessing the data-members of a class ;  CTMemberStreamer;  ►CTMemFileA TMemFile is like a normal TFile except th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:168998,detect,detector,168998,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['detect'],['detector']
Safety,"ors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:2857,avoid,avoid,2857,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['avoid'],['avoid']
Safety,"orted) ;  ; Bool_t fIsSorted;  Flags if the bin edges are sorted densitywise (or by bin endges in case of 1-dim ) ;  ; Bool_t fIsSortedAsc;  Flags if the bin edges are sorted densitywise (or by bin-edge for 1D) in ascending order. ;  ; UInt_t fNBins;  The number of bins. ;  . Friends; struct CompareAsc;  ! Predicate for ascending sort ;  ; struct CompareDesc;  ! Predicate for descending sort ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TKDTreeBinning.h>. Inheritance diagram for TKDTreeBinning:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkAdjustBinEdges adjust bin edges to avoid overlapping with data . Definition at line 66 of file TKDTreeBinning.h. Constructor & Destructor Documentation. ◆ TKDTreeBinning() [1/4]. TKDTreeBinning::TKDTreeBinning ; (; TKDTreeBinning & ; bins). private . Disallowed copy constructor. . ◆ TKDTreeBinning() [2/4]. TKDTreeBinning::TKDTreeBinning ; (; ). Default constructor (for I/O) ; Definition at line 112 of file TKDTreeBinning.cxx. ◆ TKDTreeBinning() [3/4]. TKDTreeBinning::TKDTreeBinning ; (; UInt_t ; dataSize, . UInt_t ; dataDim, . Double_t * ; data, . UInt_t ; nBins = 100, . bool ; adjustBinEdges = false . ). Class's constructor taking the size of the data points, dimension, a data array and the number of bins (default = 100). ; It is recommended to have the number of bins as an exact divider of the data size. The data array must be organized with a stride=1 for the points and = N (the dataSize) for the dimension.; Thus data[] = x1,x2,x3,......xN, y1,y2,y3......yN, z1,z2,...........zN,....; Note that the passed dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTreeBinning.html:16666,avoid,avoid,16666,doc/master/classTKDTreeBinning.html,https://root.cern,https://root.cern/doc/master/classTKDTreeBinning.html,1,['avoid'],['avoid']
Safety,"ory(const char *); 888{; 889 return nullptr;; 890}; 891 ; 892//////////////////////////////////////////////////////////////////////////////; 893/// Return the user's home directory.; 894 ; 895std::string TSystem::GetHomeDirectory(const char *) const; 896{; 897 return std::string();; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// Make a file system directory. Returns 0 in case of success and; 902/// -1 if the directory could not be created (either already exists or; 903/// illegal path name).; 904/// If 'recursive' is true, makes parent directories as needed.; 905 ; 906int TSystem::mkdir(const char *name, Bool_t recursive); 907{; 908 if (recursive) {; 909 TString safeName = name; // local copy in case 'name' is output from; 910 // TSystem::DirName as it uses static buffers; 911 TString dirname = GetDirName(safeName.Data());; 912 if (dirname.IsNull()) {; 913 // well we should not have to make the root of the file system!; 914 // (and this avoid infinite recursions!); 915 return -1;; 916 }; 917 if (AccessPathName(dirname.Data(), kFileExists)) {; 918 int res = mkdir(dirname.Data(), kTRUE);; 919 if (res) return res;; 920 }; 921 if (!AccessPathName(safeName.Data(), kFileExists)) {; 922 return -1;; 923 }; 924 }; 925 ; 926 return MakeDirectory(name);; 927}; 928 ; 929//---- Paths & Files -----------------------------------------------------------; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Base name of a file name. Base name of /user/root is root.; 933 ; 934const char *TSystem::BaseName(const char *name); 935{; 936 if (name) {; 937 if (name[0] == '/' && name[1] == '\0'); 938 return name;; 939 char *cp;; 940 if ((cp = (char *)strrchr(name, '/'))); 941 return ++cp;; 942 return name;; 943 }; 944 Error(""BaseName"", ""name = 0"");; 945 return nullptr;; 946}; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Return true if dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:27643,avoid,avoid,27643,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['avoid'],['avoid']
Safety,ory::UnregisterContext(TDirectory::TContext* ctxt). private:. TROOT&operator=(const TROOT&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fApplicationPointer to current application; Bool_tfBatchTrue if session without graphics; TList*fBrowsablesList of browsables; TSeqCollection*fBrowsersList of browsers; Int_tfBuiltDateDate of ROOT built; Int_tfBuiltTimeTime of ROOT built; TSeqCollection*fCanvasesList of canvases; TCollection*fClassGeneratorsList of user defined class generators;; TCollection*fClassesList of classes definition; TSeqCollection*fCleanupsList of recursiveRemove collections; TSeqCollection*fClipboardList of clipbard objects; TSeqCollection*fColorsList of colors; TStringfConfigFeaturesROOT ./configure detected build features; TStringfConfigOptionsROOT ./configure set build options; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrup,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:16544,detect,detected,16544,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['detect'],['detected']
Safety,"osest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volumes with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTube.html:14207,safe,safe,14207,root/html528/TGeoTube.html,https://root.cern,https://root.cern/root/html528/TGeoTube.html,12,['safe'],['safe']
Safety,"ostNegWeights. Bool_t TMVA::MethodBDT::fInverseBoostNegWeights. private . boost ev. with neg. weights with 1/boostweight rather than boostweight ; Definition at line 257 of file MethodBDT.h. ◆ fIsHighBkgCut. std::vector<Bool_t> TMVA::MethodBDT::fIsHighBkgCut. private . Definition at line 292 of file MethodBDT.h. ◆ fIsHighSigCut. std::vector<Bool_t> TMVA::MethodBDT::fIsHighSigCut. private . Definition at line 291 of file MethodBDT.h. ◆ fIsLowBkgCut. std::vector<Bool_t> TMVA::MethodBDT::fIsLowBkgCut. private . Definition at line 290 of file MethodBDT.h. ◆ fIsLowSigCut. std::vector<Bool_t> TMVA::MethodBDT::fIsLowSigCut. private . Definition at line 289 of file MethodBDT.h. ◆ fITree. Int_t TMVA::MethodBDT::fITree. private . ntuple var: ith tree ; Definition at line 265 of file MethodBDT.h. ◆ fLossFunctionEventInfo. std::map< const TMVA::Event*, LossFunctionEventInfo> TMVA::MethodBDT::fLossFunctionEventInfo. private . map event to true value, predicted value, and weight used by different loss functions for BDT regression ; Definition at line 224 of file MethodBDT.h. ◆ fLowBkgCut. std::vector<Double_t> TMVA::MethodBDT::fLowBkgCut. private . Definition at line 285 of file MethodBDT.h. ◆ fLowSigCut. std::vector<Double_t> TMVA::MethodBDT::fLowSigCut. private . Definition at line 284 of file MethodBDT.h. ◆ fMaxDepth. UInt_t TMVA::MethodBDT::fMaxDepth. private . max depth ; Definition at line 242 of file MethodBDT.h. ◆ fMinLinCorrForFisher. Double_t TMVA::MethodBDT::fMinLinCorrForFisher. private . the minimum linear correlation between two variables demanded for use in fisher criterium in node splitting ; Definition at line 237 of file MethodBDT.h. ◆ fMinNodeEvents. Int_t TMVA::MethodBDT::fMinNodeEvents. private . min number of events in node ; Definition at line 231 of file MethodBDT.h. ◆ fMinNodeSize. Float_t TMVA::MethodBDT::fMinNodeSize. private . min percentage of training events in node ; Definition at line 232 of file MethodBDT.h. ◆ fMinNodeSizeS. TString TMVA::MethodBDT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:64840,predict,predicted,64840,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['predict'],['predicted']
Safety,"ot(""plot"");; TRFunctionImport lines(""lines"");; TRFunctionImport devnew(""dev.new"");; TRFunctionImport devoff(""dev.off"");; TRFunctionImport min(""min"");; TRFunctionImport max(""max"");; TRFunctionImport seq(""seq"");; TRFunctionImport predict(""predict"");; ; r<<""options(device='png')"";//enable plot in png file; ; ////////////////////////; //doing the procedure //; ////////////////////////; TRObject xdata = c(-2,-1.64,-1.33,-0.7,0,0.45,1.2,1.64,2.32,2.9);; TRObject ydata = c(0.699369,0.700462,0.695354,1.03905,1.97389,2.41143,1.91091,0.919576,-0.730975,-1.42001);; ; TRDataFrame data;; data[""xdata""]=xdata;; data[""ydata""]=ydata;; ; //fit = nls(ydata ~ p1*cos(p2*xdata) + p2*sin(p1*xdata), start=list(p1=1,p2=0.2)) <- R code; TRObject fit = nls(asformula(""ydata ~ p1*cos(p2*xdata) + p2*sin(p1*xdata)""),Label[""data""]=data, Label[""start""]=list(Label[""p1""]=1,Label[""p2""]=0.2));; print(summary(fit));; ; print(confint(fit));; ; devnew(""Fitting Regression"");; plot(xdata,ydata);; ; TRObject xgrid=seq(min(xdata),max(xdata),Label[""len""]=10);; lines(xgrid,predict(fit,xgrid),Label[""col""] = ""green"");; devoff();; }; c#define c(i)Definition RSha256.hxx:101; plotwinID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter plotDefinition TGWin32VirtualGLProxy.cxx:53; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRInterface.h; FunctionDouble_t(* Function)(Double_t)Definition Functor.C:4; ROOT::R::TRDataFrameThis is a class to create DataFrames from ROOT to R.Definition TRDataFrame.h:176; ROOT::R::TRFunctionImportThis is a class to pass functions from ROOT to R.Definition TRFunctionImport.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRFunctionImport.html:2207,predict,predict,2207,doc/master/classROOT_1_1R_1_1TRFunctionImport.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRFunctionImport.html,1,['predict'],['predict']
Safety,"otUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TEventIterTree&operator=(const TEventIterTree&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPreProcessEvent(Long64_t ent); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTEventIter::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIterTree.html:4800,abort,abort,4800,root/html534/TEventIterTree.html,https://root.cern,https://root.cern/root/html534/TEventIterTree.html,2,['abort'],['abort']
Safety,"ouble EvtPerSec() constCompute a running mean of events/s.Definition RDFHelpers.cxx:162; ROOT::RDF::Experimental::ProgressHelper::fProcessedEventsstd::atomic< std::size_t > fProcessedEventsDefinition RDFHelpers.hxx:333; ROOT::RDF::Experimental::ProgressHelper::ComputeCurrentFileIdxunsigned int ComputeCurrentFileIdx() constDefinition RDFHelpers.hxx:444; ROOT::RDF::Experimental::ProgressHelper::fLastPrintTimestd::chrono::time_point< std::chrono::system_clock > fLastPrintTimeDefinition RDFHelpers.hxx:330; ROOT::RDF::Experimental::ProgressHelper::fBeginTimestd::chrono::time_point< std::chrono::system_clock > fBeginTimeDefinition RDFHelpers.hxx:329; ROOT::RDF::Experimental::ProgressHelper::PrintStatsFinalvoid PrintStatsFinal(std::ostream &stream, std::chrono::seconds totalElapsedSeconds) constDefinition RDFHelpers.cxx:273; ROOT::RDF::Experimental::ProgressHelper::fPrintIntervalstd::chrono::seconds fPrintIntervalDefinition RDFHelpers.hxx:331; ROOT::RDF::Experimental::ProgressHelper::operator()void operator()(T &)Thread-safe callback for RDataFrame.Definition RDFHelpers.hxx:399; ROOT::RDF::Experimental::ProgressHelper::fBarWidthunsigned int fBarWidthDefinition RDFHelpers.hxx:343; ROOT::RDF::Experimental::ProgressHelper::fEventsPerSecondStatisticsIndexstd::size_t fEventsPerSecondStatisticsIndexDefinition RDFHelpers.hxx:341; ROOT::RDF::Experimental::ProgressHelper::ComputeNEventsSoFarstd::size_t ComputeNEventsSoFar() constDefinition RDFHelpers.hxx:435; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RResultPtrSmart pointer for the return type of actions.Definition RResultPtr.hxx:119; ROOT::RDF::RResultPtr::fLoopManagerRDFDetail::RLoopManager * fLoopManagerNon-owning pointer to the RLoopManager at the root of this computation graph.Definition RResultPtr.hxx:174; ROOT::RDF::RResultPtr::fActionPtrstd::shared_ptr< RDFInternal::RActionBase >",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:25646,safe,safe,25646,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['safe'],['safe']
Safety,"ouble eps = 9.9999999999999998E-13); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GaussLegendreIntegrator.html:5051,unsafe,unsafe,5051,root/html602/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GaussLegendreIntegrator.html,2,['unsafe'],['unsafe']
Safety,"ouble eps = 9.9999999999999998E-13); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__GaussLegendreIntegrator.html:5051,unsafe,unsafe,5051,root/html604/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__GaussLegendreIntegrator.html,2,['unsafe'],['unsafe']
Safety,"ouble_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; const char * GetAxisName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; Double_t GetDphi () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Double_t GetPhi1 () const;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; Double_t GetR () const;  ; Double_t GetRmax () const;  ; Double_t GetRmin () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void SetTorusDimensions (Double_t r, Double_t rmin, Double_t rmax, Double_t phi1, Double_t dphi);  ; void Sizeof3D () const override;  ; Int_t SolveCubic (Double_t a, Double_t b, Double_t c, Double_t *x) const;  ; Int_t SolveQuartic (Double_t a, Double_t b, Double_t c, Double_t d, Double_t *x) const;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTorus.html:3304,safe,safe,3304,doc/master/classTGeoTorus.html,https://root.cern,https://root.cern/doc/master/classTGeoTorus.html,1,['safe'],['safe']
Safety,"ouble_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set polycone dimensions starting from an array. void SetPoints(Double_t* points) const; create polycone mesh points. void SetPoints(Float_t* points) const; create polycone mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomer();; if (!painter) return;; Int_t n;. n = gGeoManager->GetNsegments()+1;. Int_t numPoints = fNz*2*n;; Int_t numSegs = 4*(fNz*n-1+(fDphi == 360));; Int_t numPolys = 2*(fNz*n-1+(fDphi == 360));; painter->AddSize3D(numPoints, numSegs, numPolys);. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPcon.html:15708,Safe,Safety,15708,root/html532/TGeoPcon.html,https://root.cern,https://root.cern/root/html532/TGeoPcon.html,1,['Safe'],['Safety']
Safety,"ouble_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoEltu.html:14440,safe,safe,14440,root/html534/TGeoEltu.html,https://root.cern,https://root.cern/root/html534/TGeoEltu.html,12,['safe'],['safe']
Safety,"ouble_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. void GetBoundingCylinder(Double_t* param) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrd2.html:12773,safe,safe,12773,root/html528/TGeoTrd2.html,https://root.cern,https://root.cern/root/html528/TGeoTrd2.html,8,['safe'],['safe']
Safety,"ouble_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly,; 183 Double_t lz, Double_t tx, Double_t ty, Double_t tz);; 184 TGeoCtub(const char *name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx,; 185 Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);; 186 TGeoCtub(Double_t *params);; 187 // destructor; 188 ~TGeoCtub() override;; 189 // methods; 190 Double_t Capacity() const override;; 191 void ComputeBBox() override;; 192 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 193 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 194 Bool_t Contains(const Double_t *point) const override;; 195 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 196 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 197 Double_t *safe = nullptr) const override;; 198 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 199 Double_t *step) const override;; 200 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 201 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 202 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 203 Double_t *step) const override;; 204 TGeoVolume *; 205 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 206 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 207 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 208 Int_t GetByteCount() const override { return 98; }; 209 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 210 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:10708,safe,safe,10708,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety,"ouble_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:17032,safe,safe,17032,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,6,['safe'],['safe']
Safety,"ouble_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTube.html:15417,safe,safe,15417,root/html534/TGeoTube.html,https://root.cern,https://root.cern/root/html534/TGeoTube.html,6,['safe'],['safe']
Safety,"ouble_t* vert, Double_t* norm) const; Returns normal vector to the planar quadrilateral defined by vector VERT.; The normal points outwards the xtru. void GetPlaneVertices(Int_t iz, Int_t ivert, Double_t* vert) const; Returns (x,y,z) of 3 vertices of the surface defined by Z sections (iz, iz+1); and polygon vertices (ivert, ivert+1). No range check. Bool_t IsPointInsidePlane(Double_t* point, Double_t* vert, Double_t* norm) const; Check if the quadrilateral defined by VERT contains a coplanar POINT. void InspectShape() const; Print actual Xtru parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSector(Double_t* point, Int_t iz, Double_t safmin, Bool_t in); Compute safety to sector iz, returning also the closest segment index. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetCurrentZ(Double_t z, Int_t iz); Recompute current section vertices for a given Z position within range of section iz. void SetCurrentVertices(Double_t x0, Double_t y0, Double_t scale); Set current vertex coordinates according X0, Y0 and SCALE. void SetDimensions(Double_t* param); param[0] = nz // number of z planes. param[1] = z1 // Z position of first plane; param[2] = x1 // X position of first plane; param[3] = y1 // Y position of first plane; param[4] = scale1 // scale factor for first plane. param[4*(nz-1]+1] = zn; param[4*(nz-1)+2] = xn; param[4*(nz-1)+3] = yn; param[4*(nz-1)+4] = scalen. void SetPoints(Double_t* points) const; create polycone mesh points. void SetPoints(Float_t* points) const; create p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoXtru.html:17408,Safe,Safety,17408,root/html532/TGeoXtru.html,https://root.cern,https://root.cern/root/html532/TGeoXtru.html,1,['Safe'],['Safety']
Safety,"ouble_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set half-space parameter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHalfSpace.html:11824,safe,safe,11824,root/html528/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html528/TGeoHalfSpace.html,4,['safe'],['safe']
Safety,"ouble_t ; xup, . Int_t ; nbinsy, . const Double_t * ; ybins . ). protected . Constructor for Double_t variable bin size (along Y axis) 2-D histograms. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins along the X axis ; [in]xlowlow edge of the X axis first bin ; [in]xupupper edge of the X axis last bin (not included in last bin) ; [in]nbinsynumber of bins ; [in]ybinsarray of low-edges for each bin. This is an array of type double and size nbinsy+1 . Definition at line 154 of file TH2.cxx. ◆ TH2() [5/7]. TH2::TH2 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Double_t * ; xbins, . Int_t ; nbinsy, . const Double_t * ; ybins . ). protected . Constructor for Double_t variable bin size 2-D histograms. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsxnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbinsx+1 ; [in]nbinsynumber of bins ; [in]ybinsarray of low-edges for each bin. This is an array of type double and size nbinsy+1 . Definition at line 183 of file TH2.cxx. ◆ TH2() [6/7]. TH2::TH2 ; (; const char * ; name, . const char * ; title, . Int_t ; nbinsx, . const Float_t * ; xbins, . Int_t ; nbinsy, . const Float_t * ; ybins . ). protected . Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:59971,avoid,avoid,59971,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['avoid'],['avoid']
Safety,"ould go... RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Back end function to plotting functionality. Plot RooDataHist on given; frame in mode specified by plot options 'o'. The main purpose of; this function is to match the specified binning on 'o' to the; internal binning of the plot observable in this RooDataHist. Double_t weight(const RooArgSet& bin, Int_t intOrder = 1, Bool_t correctForBinSize = kFALSE, Bool_t cdfBoundaries = kFALSE, Bool_t oneSafe = kFALSE); Return the weight at given coordinates with optional; interpolation. If intOrder is zero, the weight; for the bin enclosing the coordinates; contained in 'bin' is returned. For higher values,; the result is interpolated in the real dimensions; of the dataset. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return the error on current weight. Double_t interpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim'; at current value 'xval'. void add(const RooArgSet& row, Double_t weight, Double_t sumw2); Increment the weight of the bin enclosing the coordinates given; by 'row' by the specified amount. Add the sum of weights squared; for the bin by 'sumw2' rather than wgt^2. void set(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the specified amount. Associate errors; [wgtErrLo,wgtErrHi] with the event weight on this bin. void set(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); Increment the weight of the bin enclosing the coordinates; given by 'row' by the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataHist.html:28552,safe,safe,28552,root/html530/RooDataHist.html,https://root.cern,https://root.cern/root/html530/RooDataHist.html,3,['safe'],['safe']
Safety,"ound a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlave.html:10005,abort,abort,10005,root/html528/TSlave.html,https://root.cern,https://root.cern/root/html528/TSlave.html,18,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"ound.C;  csgdemo.CCombinatorial Solid Geometry example ;  event_demo.CThis example display geometry, tracks and hits in web browser ;  geom_cms.C;  points.CThis example display only points in web browser ;  projection_prescale.C;  show_extract.CHelper script for showing of extracted / simplified geometries ;  table.CThis example display table in web browser ;  tracks.CThis example display only points in web browser ;  ► fft;  FFT.C This tutorial illustrates the Fast Fourier Transforms interface in ROOT ;  ► fit;  combinedFit.C Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ConfidenceIntervals.C Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ErrorIntegral.C Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit ;  exampleFit3D.C example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ;  fit1.C Simple fitting example (1-d histogram with an interpreted function) ;  fit2.C Fitting a 2-D histogram This tutorial illustrates : ;  fit2a.C Fitting a 2-D histogram (a variant) This tutorial illustrates : ;  fit2d.C Example illustrating how to fit a 2-d histogram of type y=f(x) ;  fit2dHist.C ;  fitCircle.C Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ;  fitcont.C Example illustrating how to draw the n-sigma contour of a Minuit fit ;  fitConvolution.C Tutorial for convolution of two functions ;  fitEllipseTGraphDLSF.cxx;  fitEllipseTGraphRMM.cxx;  fitExclude.C Illustrates how to fit excluding points in a given range ;  fithist.C Example of fit where the model is histogram + function ;  fitLinear.C Example of fitting with a linear function, using TLinearFitter This example is for a TGraphErrors, but it can also be used when fitting a hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:107018,predict,predictor,107018,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['predict'],['predictor']
Safety,"oundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; TGeoManager::FindNextBoundaryAndStepTGeoNode * FindNextBoundaryAndStep(Double_t stepmax=TGeoShape::Big(), Bool_t compsafe=kFALSE)Compute distance to next boundary within STEPMAX.Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear step of length fStep from current point (fPoint) on current dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:86789,safe,safety,86789,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"oundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNorma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:51672,safe,safety,51672,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,10,['safe'],['safety']
Safety,"ount) ;  ; Double_t * fFractions;  Template fractions scaled to the ""data"" histogram statistics. ;  ; TH1 * fPlot;  Pointer to histogram containing summed template predictions. ;  ; ROOT::Fit::Fitter * fFractionFitter;  Pointer to Fitter class. ;  . Private Member Functions; void CheckConsistency ();  Function used internally to check the consistency between the various histograms. ;  ; void CheckParNo (Int_t parm) const;  Function for internal use, checking parameter validity An invalid parameter results in an error. ;  ; void ComputeChisquareLambda ();  Method used internally to compute the likelihood ratio chi2 See the function GetChisquare() for details. ;  ; void ComputeFCN (Double_t &f, const Double_t *par, Int_t flag);  Used internally to compute the likelihood value. ;  ; void FindPrediction (int bin, double &t_i, int &k_0, double &A_ki) const;  Function used internally to obtain the template prediction in the individual bins 'bin' <=> 'i' (paper) 'par' <=> 'j' (paper) ;  ; void GetRanges (Int_t &minX, Int_t &maxX, Int_t &minY, Int_t &maxY, Int_t &minZ, Int_t &maxZ) const;  Used internally to obtain the bin ranges according to the dimensionality of the histogram and the limits set by hand. ;  ; bool IsExcluded (Int_t bin) const;  Function for internal use, checking whether the given bin is excluded from the fit or not. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:19890,predict,prediction,19890,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['prediction']
Safety,"ources used by ROOT (files, network sockets,; 865/// shared memory segments, etc.).; 866 ; 867TROOT::~TROOT(); 868{; 869 using namespace ROOT::Internal;; 870 ; 871 if (gROOTLocal == this) {; 872 ; 873 // TMapFile must be closed before they are deleted, so run CloseFiles; 874 // (possibly a second time if the application has an explicit TApplication; 875 // object, but in that this is a no-op). TMapFile needs the slow close; 876 // so that the custome operator delete can properly find out whether the; 877 // memory being 'freed' is part of a memory mapped file or not.; 878 CloseFiles();; 879 ; 880 // If the interpreter has not yet been initialized, don't bother; 881 gGetROOT = &GetROOT1;; 882 ; 883 // Mark the object as invalid, so that we can veto some actions; 884 // (like autoloading) while we are in the destructor.; 885 SetBit(TObject::kInvalidObject);; 886 ; 887 // Turn-off the global mutex to avoid recreating mutexes that have; 888 // already been deleted during the destruction phase; 889 if (gGlobalMutex) {; 890 TVirtualMutex *m = gGlobalMutex;; 891 gGlobalMutex = nullptr;; 892 delete m;; 893 }; 894 ; 895 // Return when error occurred in TCling, i.e. when setup file(s) are; 896 // out of date; 897 if (!fVersionInt) return;; 898 ; 899 // ATTENTION!!! Order is important!; 900 ; 901 SafeDelete(fBrowsables);; 902 ; 903 // FIXME: Causes rootcling to deadlock, debug and uncomment; 904 // SafeDelete(fRootFolder);; 905 ; 906#ifdef R__COMPLETE_MEM_TERMINATION; 907 fSpecials->Delete(); SafeDelete(fSpecials); // delete special objects : PostScript, Minuit, Html; 908#endif; 909 ; 910 fClosedObjects->Delete(""slow""); // and closed files; 911 fFiles->Delete(""slow""); // and files; 912 SafeDelete(fFiles);; 913 fSecContexts->Delete(""slow""); SafeDelete(fSecContexts); // and security contexts; 914 fSockets->Delete(); SafeDelete(fSockets); // and sockets; 915 fMappedFiles->Delete(""slow""); // and mapped files; 916 TSeqCollection *tl = fMappedFiles; fMappedFiles = nullptr; delete tl;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:35367,avoid,avoid,35367,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['avoid'],['avoid']
Safety,"ouse to click on the contour of the histogram hpx. When the mouse is clicked, the bin number and its contents are printed. Example2 of use of exec1.C; Root > TFile f(""hsimple.root""); Root > hpxpy.Draw(); Root > c1.AddExec(""ex2"","".x exec2.C""); When moving the mouse in the canvas, a second canvas shows the projection along X of the bin corresponding to the Y position of the mouse. The resulting histogram is fitted with a gaussian. A ""dynamic"" line shows the current bin position in Y. This more elaborated example can be used as a starting point to develop more powerful interactive applications exploiting the C++ interpreter as a development engine. ; Implements TVirtualPad.; Definition at line 498 of file TPad.cxx. ◆ AddFirst(). void TPad::AddFirst ; (; TObject * ; obj, . Option_t * ; opt = """", . Bool_t ; modified = kTRUE . ). overridevirtual . Add an object as first in list of primitives with speicified draw option When. ; modified set to kTRUE (default) pad will be marked as modifiedLet avoid usage of gPad when drawing object(s) in canvas or in subpads. ; Implements TVirtualPad.; Definition at line 439 of file TPad.cxx. ◆ AutoExec(). void TPad::AutoExec ; (; ). virtual . Execute the list of Execs when a pad event occurs. ; Definition at line 508 of file TPad.cxx. ◆ Browse(). void TPad::Browse ; (; TBrowser * ; b). overridevirtual . Browse pad. ; Reimplemented from TObject.; Definition at line 523 of file TPad.cxx. ◆ BuildLegend(). TLegend * TPad::BuildLegend ; (; Double_t ; x1 = 0.3, . Double_t ; y1 = 0.21, . Double_t ; x2 = 0.3, . Double_t ; y2 = 0.21, . const char * ; title = """", . Option_t * ; option = """" . ). overridevirtual . Build a legend from the graphical objects in the pad. ; A simple method to build automatically a TLegend from the primitives in a TPad.; Only those deriving from TAttLine, TAttMarker and TAttFill are added, excluding TPave and TFrame derived classes.; ReturnsThe built TLegend; Parameters. [in]x1,y1,x2,y2The TLegend coordinates ; [in]titleTh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:57992,avoid,avoid,57992,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['avoid'],['avoid']
Safety,"out a dictionary, by creating the branches for builtin types (int, float, double) and arrays explicitly. ; See tree2a.C for the same example using a class with dictionary instead of a C-struct.; In this example, we are mapping a C struct to one of the Geant3 common blocks /gctrak/. In the real life, this common will be filled by Geant3 at each step and only the Tree Fill function should be called. The example emulates the Geant3 step routines.; to run the example, do: .x tree2.C to execute with the Cling interpreter; .x tree2.C++ to execute with native compiler; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TH2.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TMath.h""; ; const Int_t MAXMEC = 30;; ; typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ; ; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; //magnetic field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];; Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];; vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; ; void tree2w(); {; //create a Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2_8C.html:1222,safe,safety,1222,doc/master/tree2_8C.html,https://root.cern,https://root.cern/doc/master/tree2_8C.html,1,['safe'],['safety']
Safety,"out parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of the expected distance to the minimum \(\mbox{EDM}\) is largely fantasy, so it would not even know if it did converge.; 6.2 Floating point precision; M figures out at execution time the machine precision [api:epsmac], and assumes that \(\mbox{FCN}\) provides about the same precision. That means not just the length of the numbers used and returned by \(\mbox{FCN}\), but the actual mathematical accuracy of the calculations. Section [install:epsmac] describes what to do if this is not the case.; 6.3 Parameter limits; Putting limits (absolute bounds) on the allowed values for a given parameter, causes M to make a non-linear transformation of its own internal parameter values to obtain the (external) parameter values passed to \(\mbox{FCN}\). To understand the adverse effect of limits, see [intro:limits].; Basically, the use of limits should be avoided unless needed to keep the parameter inside a desired range.; If parameter limits are needed, in spite of the effects described in Chapter One, then the user should be aware of the following techniques to alleviate problems caused by limits.; 6.3.1 Getting the Right Minimum with Limits; If \(\mbox{MIGRAD}\) converges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented M from finding the right minimum. On the other hand, if one or more parameters is near its limit at the minimum, this may be because the true minimum is indeed at a limit, or it may be because the minimizer has become “blocked” at a limit. This may normally happen only if the parameter is so close to a limit (internal value at an odd multiple of \(\pm \frac{ \pi}{ 2}\) that M prints a warning to this effect when it prints the parameter values.; The minimizer can become blocked at a limit, because at a limit the derivative seen by the minimizer \(\partial F / ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:68699,avoid,avoided,68699,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['avoid'],['avoided']
Safety,"ove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives); virtual voidSetMakeSharedLib(const char* directives)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSystem.html:10925,timeout,timeout,10925,root/html530/TSystem.html,https://root.cern,https://root.cern/root/html530/TSystem.html,3,['timeout'],['timeout']
Safety,"over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Fri Dec 11 12:20:07 2009 » Last generated: 2009-12-11 12:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenContext.html:9952,unsafe,unsafe,9952,root/html526/RooGenContext.html,https://root.cern,https://root.cern/root/html526/RooGenContext.html,1,['unsafe'],['unsafe']
Safety,"over uniform observables; RooArgSet_uniformVars; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Thu Sep 23 19:59:50 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenContext.html:10001,unsafe,unsafe,10001,root/html528/RooGenContext.html,https://root.cern,https://root.cern/root/html528/RooGenContext.html,1,['unsafe'],['unsafe']
Safety,"overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate nod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1001903,safe,safety,1001903,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['safe'],['safety']
Safety,"override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; void CreateThreadData (Int_t nthreads) override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNedges () const;  ; Int_t GetNmeshVertices () const override;  ; Int_t GetNsegments () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; ThreadData_t & GetThreadData () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; TBuffer3D *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPgon.html:1410,safe,safe,1410,doc/master/classTGeoPgon.html,https://root.cern,https://root.cern/doc/master/classTGeoPgon.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"override;  Compute bounding box of the scaled shape. ;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Compute normal to closest surface from POINT. ;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  Compute the normal for an array o points so that norm.dot.dir is positive Input: Arrays of point coordinates and directions + vector size Output: Array of normal directions. ;  ; Bool_t Contains (const Double_t *point) const override;  Test if point is inside the scaled shape. ;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  Check the inside status for each of the points in the array. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  compute closest distance from point px,py to each vertex. Should not be called. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from inside point to surface of the scaled shape. ;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  Compute distance from outside point to surface of the scaled shape. ;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  Compute distance from array of input points having directions specified by dirs. Store output in dists. ;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  Cannot divide assemblies. ;  ; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:1834,safe,safe,1834,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['safe'],['safe']
Safety,overridevirtual . ReturnsTClass describing current object ; Reimplemented from TGMainFrame.; Definition at line 658 of file TRecorder.h. ◆ Replay(). void TGRecorder::Replay ; (; ). Handles push of fReplay button according to the current recorder state. ; Definition at line 1977 of file TRecorder.cxx. ◆ SetDefault(). void TGRecorder::SetDefault ; (; ). private . Sets GUI to the default inactive state. ; Definition at line 1833 of file TRecorder.cxx. ◆ StartStop(). void TGRecorder::StartStop ; (; ). Handles push of the fStartStop button according to the current recorder state. ; Definition at line 1913 of file TRecorder.cxx. ◆ Streamer(). void TGRecorder::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGMainFrame. ◆ StreamerNVirtual(). void TGRecorder::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 658 of file TRecorder.h. ◆ Update(). void TGRecorder::Update ; (; ). Called when fTimer timeouts (every 0.025 second) Updates GUI of recorder. ; Definition at line 1851 of file TRecorder.cxx. Member Data Documentation. ◆ fCursorCheckBox. TGCheckButton* TGRecorder::fCursorCheckBox. private . Definition at line 640 of file TRecorder.h. ◆ fElapsed. time_t TGRecorder::fElapsed. private . Definition at line 643 of file TRecorder.h. ◆ fFilteredIds. Window_t TGRecorder::fFilteredIds[fgWidgetsCount]. private . Definition at line 646 of file TRecorder.h. ◆ fgWidgetsCount. const Int_t TGRecorder::fgWidgetsCount = 12. staticprivate . Definition at line 645 of file TRecorder.h. ◆ fRecorder. TRecorder* TGRecorder::fRecorder. private . Definition at line 633 of file TRecorder.h. ◆ fReplay. TGPictureButton* TGRecorder::fReplay. private . Definition at line 636 of file TRecorder.h. ◆ fStart. time_t TGRecorder::fStart. private . Definition at line 643 of file TRecorder.h. ◆ fStartStop. TGPictureButton* TGRecorder::fStartStop. private . Definition at line 635 of file TRecorder.h. ◆ fStatu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGRecorder.html:37837,timeout,timeouts,37837,doc/master/classTGRecorder.html,https://root.cern,https://root.cern/doc/master/classTGRecorder.html,1,['timeout'],['timeouts']
Safety,"oviding pointers to components. ;  ;  ~TGeoUnion () override;  Destructor — deletion of components handled by TGeoManager class. ;  ; void ComputeBBox (Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin) override;  Compute bounding box corresponding to a union of two shapes. ;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. ;  ; Bool_t Contains (const Double_t *point) const override;  Find if a union of two shapes contains a given point. ;  ; Int_t DistanceToPrimitive (Int_t px, Int_t py) override;  Compute minimum distance to shape vertices. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Computes distance from a given point inside the shape to its boundary. ;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=0, Double_t *safe=nullptr) const override;  Compute distance from a given outside point to the shape. ;  ; EGeoBoolType GetBooleanOperator () const override;  ; Int_t GetNpoints () override;  Returns number of vertices for the composite shape described by this union. ;  ; TClass * IsA () const override;  ; TGeoBoolNode * MakeClone () const override;  Make a clone of this. Pointers are preserved. ;  ; void Paint (Option_t *option) override;  Paint method. ;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  Compute safety distance for a union node;. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Sizeof3D () const override;  Register 3D size of this shape. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBoolNode;  TGeoBo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoUnion.html:1565,safe,safe,1565,doc/master/classTGeoUnion.html,https://root.cern,https://root.cern/doc/master/classTGeoUnion.html,1,['safe'],['safe']
Safety,"ow edge of the X axis first bin; 149/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 150/// \param[in] nbinsy number of bins; 151/// \param[in] ybins array of low-edges for each bin.; 152/// This is an array of type double and size nbinsy+1; 153 ; 154TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 155 ,Int_t nbinsy,const Double_t *ybins); 156 :TH1(name,title,nbinsx,xlow,xup); 157{; 158 fDimension = 2;; 159 fScalefactor = 1;; 160 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 161 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 162 if (ybins) fYaxis.Set(nbinsy,ybins);; 163 else fYaxis.Set(nbinsy,0,1);; 164 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 165}; 166 ; 167 ; 168////////////////////////////////////////////////////////////////////////////////; 169/// Constructor for Double_t variable bin size 2-D histograms.; 170///; 171/// \param[in] name name of histogram (avoid blanks); 172/// \param[in] title histogram title.; 173/// If title is of the form `stringt;stringx;stringy;stringz`; 174/// the histogram title is set to `stringt`,; 175/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 176/// \param[in] nbinsx number of bins; 177/// \param[in] xbins array of low-edges for each bin.; 178/// This is an array of type double and size nbinsx+1; 179/// \param[in] nbinsy number of bins; 180/// \param[in] ybins array of low-edges for each bin.; 181/// This is an array of type double and size nbinsy+1; 182 ; 183TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 184 ,Int_t nbinsy,const Double_t *ybins); 185 :TH1(name,title,nbinsx,xbins); 186{; 187 fDimension = 2;; 188 fScalefactor = 1;; 189 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 190 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 191 if (ybins) fYaxis.Set(nbinsy,ybins);; 192 else fYaxis.Set(nbinsy,0,1);; 193 fNcells = fNcell",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:7727,avoid,avoid,7727,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ow/overflows if considered in the option; 2004 // if specified in the option (by default they considered); 2005 Double_t totcont = 0;; 2006 ; 2007 Int_t out1min = out1->GetFirst();; 2008 Int_t out1max = out1->GetLast();; 2009 // GetFirst(), GetLast() can return (0,0) when the range bit is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinError(ix, TMath::Sqrt(err2) );; 2046 // sum all ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:79971,avoid,avoid,79971,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['avoid'],['avoid']
Safety,"owing citation ; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201] ; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Functionality; The TUnfoldBinning objects are connected by a tree-like structure. The structure does not hold any data, but is only responsible for arranging the analysis bins in the proper order. Each node of the tree is responsible for a group of bins. That group may consist of . several unconnected bins, each with a dedicated name. . bins organized in a multidimensional distribution, defined by a set of axes. The axes are defined by a number of bins N and by (N+1) bin borders. In addition to the N bins inside there may be an underflow and an overflow bin . Each bin has a ""global"" bin number, which can be found using the GetGlobalBinNumber() methods. The global bin number 0 is reserved and corresponds to the case where no bin is found in the TUnfoldBinning tree.; Use in the analysis; Booking histograms: . Define binning schemes on detector level and on truth level. This can be done using the XML language, use the class TUnfoldBinningXML to read the binning scheme. The TUnfoldBinning objects can be written to a root file, preferentially together with the corresponding histograms. . For Monte Carlo, book histograms for the response matrix (detector vs truth level) using the method CreateHistogramOfMigrations() . For data and background, book histograms using the ""detector level"" binning scheme and the method CreateHistogram() . (if required) for the data covarianve matrix, book a histogram using the ""detector level"" binning scheme and the method CreateErrorMatrixHistogram() . For truth histograms, book histograms using the ""truth level"" binning scheme and the method CreateHistogram() . The histograms which are booked have all analysis bins arranged on one axis (global bin number). TUnfoldBinning provides methods to locate the global bin number: . Use the method FindNode() to locate a group of bins (e.g. signal, contro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinning.html:1729,detect,detector,1729,doc/master/classTUnfoldBinning.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinning.html,1,['detect'],['detector']
Safety,"ownership of the objects in the list. Stack painting; By default, histograms are shown stacked:; the first histogram is painted; then the sum of the first and second histograms is painted, and so on. The axis ranges are computed automatically along the X and Y axes to display the complete histogram collection.; Warning: Histogram bins with negative content may produce wrong plots. Stack's drawing options; The specific stack's drawing options are:. NOSTACK If option ""nostack"" is specified, histograms are all painted in the same pad as if the option ""same"" had been specified.; NOSTACKB If the option ""nostackb"" is specified histograms are all painted on the same pad next to each other as bar plots.; PADS if option ""pads"" is specified, the current pad/canvas is subdivided into a number of pads equal to the number of histograms and each histogram is painted into a separate pad.; NOCLEAR By default the background of the histograms is erased before drawing the histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a THStack on top of another plot. If the patterns used to draw the histograms in the stack are transparent, then the plot behind will be visible. See the THistPainter class for the list of valid histograms' painting options.; Example;; {; auto hs = new THStack(""hs"","""");; auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);; auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);; auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);; auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; TText T; T.SetTextFont(42); T.SetTextAlign(21);; cs->Divide(2,2);; cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHStack.html:1661,avoid,avoids,1661,doc/master/classTHStack.html,https://root.cern,https://root.cern/doc/master/classTHStack.html,1,['avoid'],['avoids']
Safety,"ows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:33351,safe,safe,33351,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['safe'],['safe']
Safety,"ox () override;  ; void ComputeNormal (const Double_t *point, const Double_t *dir, Double_t *norm) override;  ; void ComputeNormal_v (const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;  ; Bool_t Contains (const Double_t *point) const override;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistToParaboloid (const Double_t *point, const Double_t *dir, Bool_t in) const;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Double_t GetDz () const;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; Double_t GetRhi () const;  ; Double_t GetRlo () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParaboloid.html:1290,safe,safe,1290,doc/master/classTGeoParaboloid.html,https://root.cern,https://root.cern/doc/master/classTGeoParaboloid.html,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"ox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ DistFromInside_v(). virtual void TGeoShape::DistFromInside_v ; (; const Double_t * ; , . const Double_t * ; , . Double_t * ; , . Int_t ; , . Double_t * ;  . ); const. inlinevirtual . Reimplemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru.; Definition at line 105 of file TGeoShape.h. ◆ DistFromOutside(). virtual Double_t TGeoShape::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. pure virtual . Implemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ DistFromOutside_v(). virtual void TGeoShape::DistFromOutside_v ; (; const Double_t * ; , . const Double_t * ; , . Double_t * ; , . Int_t ; , . Double_t * ;  . ); const. inlinevirtual . Reimplemented in TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru.; Definition at line 108 of file TGeoShape.h. ◆ DistToPhiMin(). Double_t TGeoShape::DistToPhiMin ; (; const Double_t * ; point, . const Double_t * ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:33504,safe,safe,33504,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety,"oxy *proxy); 1463{; 1464 new (*begin_arena) TGenCollectionProxy__SlowIterator(proxy);; 1465 *(UInt_t*)*end_arena = proxy->Size();; 1466}; 1467 ; 1468////////////////////////////////////////////////////////////////////////////////; 1469 ; 1470void *TGenCollectionProxy__SlowNext(void *iter, const void *end); 1471{; 1472 TGenCollectionProxy__SlowIterator *iterator = (TGenCollectionProxy__SlowIterator*)iter;; 1473 if (iterator->fIndex != *(UInt_t*)end) {; 1474 void *result = iterator->fProxy->At(iterator->fIndex);; 1475 ++(iterator->fIndex);; 1476 return result;; 1477 } else {; 1478 return 0;; 1479 }; 1480}; 1481 ; 1482////////////////////////////////////////////////////////////////////////////////; 1483 ; 1484void * TGenCollectionProxy__SlowCopyIterator(void *dest, const void *source); 1485{; 1486 *(TGenCollectionProxy__SlowIterator*)dest = *(TGenCollectionProxy__SlowIterator*)source;; 1487 return dest;; 1488}; 1489 ; 1490////////////////////////////////////////////////////////////////////////////////; 1491/// Nothing to do; 1492 ; 1493void TGenCollectionProxy__SlowDeleteSingleIterators(void *); 1494{; 1495}; 1496 ; 1497////////////////////////////////////////////////////////////////////////////////; 1498/// Nothing to do; 1499 ; 1500void TGenCollectionProxy__SlowDeleteTwoIterators(void *, void *); 1501{; 1502}; 1503 ; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// We can safely assume that the std::vector layout does not really depend on; 1507/// the content!; 1508 ; 1509void TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy*); 1510{; 1511 std::vector<char> *vec = (std::vector<char>*)obj;; 1512 if (vec->empty()) {; 1513 *begin_arena = 0;; 1514 *end_arena = 0;; 1515 return;; 1516 }; 1517 *begin_arena = &(*vec->begin());; 1518#ifdef R__VISUAL_CPLUSPLUS; 1519 *end_arena = &(*(vec->end()-1)) + 1; // On windows we can not dererence the end iterator at all.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:48407,safe,safely,48407,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['safe'],['safely']
Safety,"p); TXSocket&operator=(const TXSocket&); virtual voidTObject::Paint(Option_t* option = """"); Bool_tPing(const char* ord = 0); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual UnsolRespProcResultProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); voidRemoteTouch(); virtual voidRemoveClientID(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0, Long64_t l64 = 0, Int_t int3 = 0, const char* opt = 0); Int_tSendInterrupt(Int_t type); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock); voidSendUrgent(Int_t type, Int_t int1, Int_t int2); voidSetAWait(Bool_t w = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetClientID(Int_t); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:6278,timeout,timeout,6278,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,4,['timeout'],['timeout']
Safety,"p); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHype&operator=(const TGeoHype&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; Double_tRadiusHypeSq(Double_t z, Bool_t inner) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:10342,Safe,SafetyS,10342,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,1,['Safe'],['SafetyS']
Safety,"p. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); set trd1 params in one step :. void SetVertex(Double_t* vertex) const; set vertex of a corner according to visibility flags. void SetPoints(Double_t* points) const; create arb8 mesh points. void SetPoints(Float_t* points) const; create arb8 mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd1.html:15364,Safe,Safety,15364,root/html534/TGeoTrd1.html,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html,3,['Safe'],['Safety']
Safety,"pLinSolverDens. TQpLinSolverSparse. Function documentation; TQpLinSolverBase(); Default constructor. TQpLinSolverBase(TQpProbBase* factory, TQpDataBase* data); Constructor. TQpLinSolverBase(const TQpLinSolverBase& another); Copy constructor. void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& vars1, TVectorD& vars2, TVectorD& vars3, TVectorD& vars); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. TQpLinSolverBase & operator=(const TQpLinSolverBase& source); Assignment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpLinSolverBase.html:8253,recover,recovers,8253,root/html602/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html602/TQpLinSolverBase.html,4,['recover'],['recovers']
Safety,"pSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop version for comparison/debugging) ;  ; Double_t SafetyOrig (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (original version based on TGeoVoxelFinder) ;  ; void TestVoxelGrid ();  ; Double_t VoxelSafety (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching —> essentially an O(1) algorithm !) ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoParallelWorld.h>. Inheritance diagram for TGeoParallelWorld:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ AccelerationMode. enum class TGeoParallelWorld::AccelerationMode. strong . EnumeratorkVoxelFinder ; kBVH . Definition at line 28 of file TGeoParallelWorld.h. Constructor & Destructor Documentation. ◆ TGeoParallelWorld() [1/3]. TGeoParallelWorld::TGeoParallelWorld ; (; const TGeoParallelWorld & ; ). protecteddelete . switch between different algorithm implementations . ◆ TGeoParallelWorld() [2/3]. TGeoParallelWorld::TGeoParallelWorld ; (; ). inline . Definition at line 62 of file TGeoParallelWorld.h. ◆ TGeoParallelWorld() [3/3]. TGeoParallelWorld::TGeoParallelWorld ; (; const char * ; name,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:16766,safe,safety,16766,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"pThrd{false}; ///<! use special thread for THttpServer; 52 bool fUseSenderThreads{false}; ///<! use extra threads for sending data from RWebWindow to clients; 53 float fLaunchTmout{30.}; ///<! timeout in seconds to start browser process, default 30s; 54 bool fExternalProcessEvents{false}; ///<! indicate that there are external process events engine; 55 std::unique_ptr<TExec> fAssgnExec; ///<! special exec to assign thread id via ProcessEvents; 56 WebWindowShowCallback_t fShowCallback; ///<! function called for each RWebWindow::Show call; 57 WebWindowDeleteCallback_t fDeleteCallback; ///<! function called when RWebWindow is destroyed; 58 ; 59 /// Returns true if http server use special thread for requests processing (default off); 60 bool IsUseHttpThread() const { return fUseHttpThrd; }; 61 ; 62 /// Returns true if extra threads to send data via websockets will be used (default off); 63 bool IsUseSenderThreads() const { return fUseSenderThreads; }; 64 ; 65 /// Returns timeout for launching new browser process; 66 float GetLaunchTmout() const { return fLaunchTmout; }; 67 ; 68 void Unregister(RWebWindow &win);; 69 ; 70 /// Show window in specified location, see Show() method for more details; 71 unsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args);; 72 ; 73 int WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed = false, double tm = -1);; 74 ; 75 std::string GetUrl(RWebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 76 ; 77 bool CreateServer(bool with_http = false);; 78 ; 79 bool InformListener(const std::string &msg);; 80 ; 81 static std::string GenerateKey(int keylen = 32);; 82 ; 83public:; 84 RWebWindowsManager();; 85 ; 86 ~RWebWindowsManager();; 87 ; 88 /// Returns THttpServer instance; 89 THttpServer *GetServer() const { return fServer.get(); }; 90 ; 91 /// Returns http address of the server, empty string when not available; 92 std::string GetServerAddr() const { return fAddr; }; 93 ; 94 /// Assign show callback whic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:2286,timeout,timeout,2286,doc/master/RWebWindowsManager_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html,2,['timeout'],['timeout']
Safety,"par[0]*TMath::Power(x-0.13957, 0.25); + par[1] / 2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; return res;; }; ; ; void h1analysis::Begin(TTree * /*tree*/); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; // This is needed when re-processing the object; Reset();; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""Begin"", ""starting h1analysis with process option: %s"", option.Data());; ; //process cases with entry list; if (fChain) fChain->SetEntryList(nullptr);; delete gDirectory->GetList()->FindObject(""elist"");; ; // case when one creates/fills the entry list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEntryList(""elist"", ""H1 selection from Cut"");; // Add to the input list for processing in PROOF, if needed; if (fInput) {; fInput->Add(new TNamed(""fillList"",""""));; // We send a clone to avoid double deletes when importing the result; fInput->Add(elist);; // This is needed to avoid warnings from output-to-members mapping; elist = nullptr;; }; Info(""Begin"", ""creating an entry-list"");; }; // case when one uses the entry list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; if (fInput) {; // In PROOF option ""useList"" is processed in SlaveBegin and we do not need; // to do anything here; } else {; TFile f(""elist.root"");; elist = (TEntryList*)f.Get(""elist"");; if (elist) elist->SetDirectory(nullptr); //otherwise the file destructor will delete elist; }; }; }; ; ; void h1analysis::SlaveBegin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialisation for the entry list; ; //initialize the Tree branch addresses; Init(tree);; ; //print the option specified in the Process function.; TString option = GetOption();; Info(""SlaveBegin"",; ""starting h1analysis with process opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysis_8C.html:7229,avoid,avoid,7229,doc/master/h1analysis_8C.html,https://root.cern,https://root.cern/doc/master/h1analysis_8C.html,2,['avoid'],['avoid']
Safety,"parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:26277,safe,safe,26277,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['safe'],['safe']
Safety,"parameters; data = model.generate({x}, 1000); model.fitTo(data, PrintLevel=-1); ; # Print LateX table of parameters of pdf; # --------------------------------------------------------------------------; ; # Print parameter list in LaTeX for (one column with names, column with; # values); params.printLatex(); ; # Print parameter list in LaTeX for (names values|names values); params.printLatex(Columns=2); ; # Print two parameter lists side by side (name values initvalues); params.printLatex(Sibling=initParams); ; # Print two parameter lists side by side (name values initvalues|name; # values initvalues); params.printLatex(Sibling=initParams, Columns=2); ; # Write LaTex table to file; params.printLatex(Sibling=initParams, OutputFile=""rf407_latextables.tex""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.5\pm 0.2$\\; $\verb+a1+ $ & $ 0.3\pm 0.1$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.46\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.79\pm 0.05$\\; $\verb+sigma1+ $ & $ 0.5$\\; $\verb+sigma2+ $ & $ 1$\\; \end{tabular}; \begin{tabular}{lc|lc}; $\verb+a0+ $ & $ 0.5\pm 0.2$ & $\verb+mean+ $ & $ 5$\\; $\verb+a1+ $ &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf407__latextables_8py.html:3226,safe,safe,3226,doc/master/rf407__latextables_8py.html,https://root.cern,https://root.cern/doc/master/rf407__latextables_8py.html,1,['safe'],['safe']
Safety,"parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t Wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__RuleFitAPI.html:3474,abort,aborts,3474,root/html528/TMVA__RuleFitAPI.html,https://root.cern,https://root.cern/root/html528/TMVA__RuleFitAPI.html,10,['abort'],['aborts']
Safety,"params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); set dimensions of a cut tube. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCtub.html:15033,safe,safe,15033,root/html528/TGeoCtub.html,https://root.cern,https://root.cern/root/html528/TGeoCtub.html,4,['safe'],['safe']
Safety,"parse_range_header (const char *header, int64_t *a, int64_t *b);  ; static int prepare_cgi_environment (struct mg_connection *conn, const char *prog, struct cgi_environment *env, unsigned char cgi_config_idx);  ; static int print_dav_dir_entry (struct de *de, void *data);  ; static int print_dir_entry (struct de *de);  ; static int print_props (struct mg_connection *conn, const char *uri, const char *name, struct mg_file_stat *filep);  ; static void process_new_connection (struct mg_connection *conn);  ; static void produce_socket (struct mg_context *ctx, const struct socket *sp);  ; static int pull_all (FILE *fp, struct mg_connection *conn, char *buf, int len);  ; static int pull_inner (FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout);  ; static int push_all (struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len);  ; static int push_inner (struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len, double timeout);  ; static int put_dir (struct mg_connection *conn, const char *path);  ; static void put_file (struct mg_connection *conn, const char *path);  ; static int read_auth_file (struct mg_file *filep, struct read_auth_file_struct *workdata, int depth);  ; static int read_message (FILE *fp, struct mg_connection *conn, char *buf, int bufsiz, int *nread);  ; static void redirect_to_https_port (struct mg_connection *conn, int port);  ; static int refresh_trust (struct mg_connection *conn);  ; static void release_handler_ref (struct mg_connection *conn, struct mg_handler_info *handler_info);  ; static void remove_bad_file (const struct mg_connection *conn, const char *path);  ; static int remove_directory (struct mg_connection *conn, const char *dir);  ; static void remove_dot_segments (char *inout);  ; static void reset_per_request_attributes (struct mg_connection *conn);  ; static int scan_directory (struct mg_connection *conn, const char *dir, void *data, int(*cb)(struct de *, void *)); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:27308,timeout,timeout,27308,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['timeout'],['timeout']
Safety,"pa}}\]. . \( \gamma = 0.5772156649\dots\) is Euler's constant.; The parameters are:; 0: Norm: Normalization constant; 1: x0: Location parameter; 2: xi: Width parameter; 3: kappa: Parameter \(\kappa\) of the Vavilov distribution; 4: beta2: Parameter \(\beta^2\) of the Vavilov distribution. Benno List, June 2010 ; Definition at line 72 of file VavilovAccurateCdf.h. Public Member Functions;  VavilovAccurateCdf ();  Default constructor. ;  ;  VavilovAccurateCdf (const double *p);  Constructor with parameter values. ;  ;  ~VavilovAccurateCdf () override;  Destructor. ;  ; IBaseFunctionOneDim * Clone () const override;  Return a clone of the object. ;  ; double DoEval (double x) const override;  Evaluate the function. ;  ; double DoEvalPar (double x, const double *p) const override;  Evaluate the function, using parameters p. ;  ; unsigned int NPar () const override;  Return the number of Parameters. ;  ; std::string ParameterName (unsigned int i) const override;  Return the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default name (""Par_0, Par_1, ..."") ;  ; const double * Parameters () const override;  Access the parameter values. ;  ; void SetParameters (const double *p) override;  Set the parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  . Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovAccurateCdf.html:1870,avoid,avoid,1870,doc/master/classROOT_1_1Math_1_1VavilovAccurateCdf.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1VavilovAccurateCdf.html,1,['avoid'],['avoid']
Safety,"pdateClassInfoWithDecl(const NamedDecl* ND); 6682{; 6683 const TagDecl *td = dyn_cast<TagDecl>(ND);; 6684 const NamespaceDecl *ns = dyn_cast<NamespaceDecl>(ND);; 6685 const NamedDecl *canon = nullptr;; 6686 ; 6687 std::string name;; 6688 TagDecl* tdDef = nullptr;; 6689 if (td) {; 6690 canon = tdDef = td->getDefinition();; 6691 // Let's pass the decl to the TClass only if it has a definition.; 6692 if (!tdDef) return;; 6693 ; 6694 if (!tdDef->isCompleteDefinition() || llvm::isa<clang::FunctionDecl>(tdDef->getDeclContext())) {; 6695 // Ignore incomplete definition.; 6696 // Ignore declaration within a function.; 6697 return;; 6698 }; 6699 ; 6700 auto declName = tdDef->getNameAsString();; 6701 // Check if we have registered the unqualified name into the list; 6702 // of TClass that are in kNoInfo, kEmulated or kFwdDeclaredState.; 6703 // Since this is used as heureutistic to avoid spurrious calls to GetNormalizedName; 6704 // the unqualified name is sufficient (and the fully qualified name might be; 6705 // 'wrong' if there is difference in spelling in the template paramters (for example); 6706 if (!TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(declName.c_str())){; 6707 // fprintf (stderr,""WARNING: Impossible to find a TClassEntry in kNoInfo or kEmulated the decl of which would be called %s. Skip w/o building the normalized name.\n"",declName.c_str() );; 6708 return;; 6709 }; 6710 ; 6711 clang::QualType type(tdDef->getTypeForDecl(), 0);; 6712 ROOT::TMetaUtils::GetNormalizedName(name, type, *fInterpreter, *fNormalizedCtxt);; 6713 } else if (ns) {; 6714 canon = ns->getCanonicalDecl();; 6715 name = ND->getQualifiedNameAsString();; 6716 } else {; 6717 name = ND->getQualifiedNameAsString();; 6718 }; 6719 ; 6720 // Supposedly we are being called while something is being; 6721 // loaded ... let's now tell the autoloader to do the work; 6722 // yet another time.; 6723 SuspendAutoLoadingRAII autoLoadOff(this);; 6724 // FIXME: There can be more than one TClass for a single decl.; 6725 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:261171,avoid,avoid,261171,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avoid'],['avoid']
Safety,"pe.; Definition at line 85 of file TGeoBBox.h. ◆ MakeBuffer3D(). TBuffer3D * TGeoBBox::MakeBuffer3D ; (; ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoCone, TGeoConeSeg, TGeoHype, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoSphere, TGeoTessellated, TGeoTorus, TGeoTube, TGeoTubeSeg, TGeoXtru, and TGeoVGShape. ◆ operator=(). TGeoBBox & TGeoBBox::operator= ; (; const TGeoBBox & ; ). protecteddelete . ◆ Safety(). Double_t TGeoBBox::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Implements TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, TGeoXtru, and TGeoVGShape. ◆ Safety_v(). void TGeoBBox::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoShape.; Reimplemented in TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru. ◆ SavePrimitive(). void TGeoBBox::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TObject.; Reimplemented in TGeoTessellated, TGeoTrap, TGeoGtra, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfSpace, TGeoHype, TGeoPara, TGeoParaboloid, TGeoPcon, TGeoPgon, TGeoScaledShape, TGeoShapeAssembly, TGeoSphere, TGeoTorus, TGeoTrd1, TGeoTrd2, TGeoTube, TGeoTubeSeg, TGeoCtub, and TGeoXtru. ◆ SetBoxDimensions(). void TGeoBBox::SetBoxDimensions ; (; Double_t ; dx, . Double_t ; dy, . Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:36389,safe,safe,36389,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['safe'],['safe']
Safety,"pe::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; const Double_t * GetNhigh () const;  ; const Double_t * GetNlow () const;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; Double_t GetZcoord (Double_t xc, Double_t yc, Double_t zc) const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetCtubDimensions (Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoTubeSeg;  TGeoTubeSeg ();  ;  TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCtub.html:2864,safe,safe,2864,doc/master/classTGeoCtub.html,https://root.cern,https://root.cern/doc/master/classTGeoCtub.html,1,['safe'],['safe']
Safety,"pedef ROOT::Math::IParametricFunctionMultiDimTempl<ROOT::Double_v> IModelFunction_v;; 86 typedef ROOT::Math::IParamMultiGradFunctionTempl<ROOT::Double_v> IGradModelFunction_v;; 87#else; 88 typedef ROOT::Math::IParamMultiFunction IModelFunction_v;; 89 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction_v;; 90#endif; 91 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction;; 92 typedef ROOT::Math::IParamFunction IModel1DFunction;; 93 typedef ROOT::Math::IParamGradFunction IGradModel1DFunction;; 94 ; 95 typedef ROOT::Math::IMultiGenFunction BaseFunc;; 96 typedef ROOT::Math::IMultiGradFunction BaseGradFunc;; 97 ; 98 ; 99 /**; 100 Default constructor; 101 */; 102 Fitter () {}; 103 ; 104 /**; 105 Constructor from a result; 106 */; 107 Fitter (const std::shared_ptr<FitResult> & result);; 108 ; 109 ; 110 /**; 111 Destructor.; 112 Make it virtual in case users derive from Fitter class to extend it by adding new methods.; 113 This is needed to avoid a warning seen when doing from Python; 114 (see ROOT issue [#12391](https://github.com/root-project/root/issues/12391) ).; 115 Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes.; 116 */; 117 virtual ~Fitter () {}; 118 ; 119 /**; 120 Copy constructor (disabled, class is not copyable); 121 */; 122 Fitter(const Fitter &) = delete;; 123 ; 124 /**; 125 Assignment operator (disabled, class is not copyable); 126 */; 127 Fitter & operator = (const Fitter &) = delete;; 128 ; 129 ; 130public:; 131 ; 132 /**; 133 fit a data set using any generic model function; 134 If data set is binned a least square fit is performed; 135 If data set is unbinned a maximum likelihood fit (not extended) is done; 136 Pre-requisite on the function:; 137 it must implement the 1D or multidimensional parametric function interface.; 138 Note that both the input data and the function object are copied by the Fitter.; 139 */; 140 template <class Data, class Function,; 141 class cond = typename std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:3722,avoid,avoid,3722,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['avoid'],['avoid']
Safety,"pen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  FITS_tutorial7.COpen a FITS file that contains a catalog of astronomical objects and dump some of its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ;  RadioNuclides.CMacro that demonstrates usa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:107534,detect,detector,107534,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['detect'],['detector']
Safety,"pen in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !fFree) fFree = new TList;; 2069 ; 2070 TKey *key;; 2071 Int_t nrecov = 0;; 2072 nwheader = 1024;; 2073 Int_t nread = nwheader;; 2074 ; 207",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:73028,recover,recovered,73028,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Safety,"per must explicitly lock access to objects shared between threads. No other thread can write to a locked object unless it is unlocked. The developer needs to lock local objects. The spirit, if not the letter of this definition, requires the user of the library only to be familiar with the semantic content of the objects in use. Locking access to objects that are being shared due to extra-semantic details of implementation (for example, copy-on-write) should remain the responsibility of the library.; All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within the library. The preferred way of providing this protection is to use mutex locks. The library also locks an object before writing to it. The developer is not required to explicitly lock or unlock a class object (static, global or local) to perform a single operation on the object. Note that even multithread safe level II hardly relieves the user of the library from the burden of locking. A thread suffers from deadlock if it is blocked waiting for a condition that will never occur. Typically, this occurs when one thread needs to access a resource that is already locked by another thread, and that other thread is trying to access a resource that has already been locked by the first thread. In this situation, neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remote computer clusters or multi-core computers. The main design goals for the PROOF system are:; Transparency : there should be as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1124266,safe,safe,1124266,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['safe'],['safe']
Safety,"perateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidSetProxy(const char* url); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:12384,timeout,timeout,12384,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,1,['timeout'],['timeout']
Safety,"perateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:14143,timeout,timeout,14143,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,2,['timeout'],['timeout']
Safety,"perator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-18 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFriendLeafIter.html:2307,Safe,SafeDelete,2307,root/html604/TTreeFriendLeafIter.html,https://root.cern,https://root.cern/root/html604/TTreeFriendLeafIter.html,2,['Safe'],['SafeDelete']
Safety,"perimental::RResult< ROOT::Experimental::Internal::RPage > ROOT::Experimental::Internal::RPageSource::UnsealPage ; (; const RSealedPage & ; sealedPage, . const RColumnElementBase & ; element, . DescriptorId_t ; physicalColumnId, . RPageAllocator & ; pageAlloc . ). static . Helper for unstreaming a page. ; This is commonly used in derived, concrete page sources. The implementation currently always makes a memory copy, even if the sealed page is uncompressed and in the final memory layout. The optimization of directly mapping pages is left to the concrete page source implementations. ; Definition at line 487 of file RPageStorage.cxx. ◆ UnzipCluster(). void ROOT::Experimental::Internal::RPageSource::UnzipCluster ; (; RCluster * ; cluster). Parallel decompression and unpacking of the pages in the given cluster. ; The unzipped pages are supposed to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set if implicit multi-threading is turned on. ; Definition at line 224 of file RPageStorage.cxx. ◆ UnzipClusterImpl(). void ROOT::Experimental::Internal::RPageSource::UnzipClusterImpl ; (; RCluster * ; cluster). protectedvirtual . Definition at line 230 of file RPageStorage.cxx. Member Data Documentation. ◆ fActivePhysicalColumns. RActivePhysicalColumns ROOT::Experimental::Internal::RPageSource::fActivePhysicalColumns. protected . The active columns are implicitly defined by the model fields or views. ; Definition at line 658 of file RPageStorage.hxx. ◆ fCounters. std::unique_ptr<RCounters> ROOT::Experimental::Internal::RPageSource::fCounters. protected . Definition at line 654 of file RPageStorage.hxx. ◆ fDescriptor. RNTupleDescriptor ROOT::Experimental::Internal::RPageSource::fDescriptor. private . Definition at line 603 of file RPageSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:20425,safe,safely,20425,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['safe'],['safely']
Safety,"ph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, TDatabasePDG, TGenerator, TParticleClassPDG, TApplicationRemote, TProof, TProofChain, RooPlot, TBranch, TVirtualBranchBrowsable, TCollectionPropertyBrowsable, TBranchClones, TBranchElement, TBranchObject, TBranchSTL, TLeaf, TNtuple, TNtupleD, TTreePerfStats, ROOT::Experimental::XRooFit::xRooNode, and TQueryResult.; Definition at line 198 of file TObject.cxx. ◆ CheckedHash(). ULong_t TObject::CheckedHash ; (; ). inline . Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; The intent is for this routine to be called instead of directly calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; (*) The setup is consistent when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 324 of file TObject.h. ◆ Class(). static TClass * TObject::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TObject::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TObject::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 243 of file TObject.h. ◆ ClassName(). const char * TObject::ClassName ; (; ); const. virtual . Returns name of class to which the object belongs. ; Definition at line 207 of file TObject.cxx. ◆ Clear(). virtual void TObject::Clear ; (; Option_t * ; = """"). inlinevirtual . Reimplemented in TMVA::ResultsClassification, TMVA::ResultsMulticlass, TMVA::ResultsRegression, TMVA::ResultsClassification, TMVA::ResultsMulticlass, TMVA::ResultsRegression, TMrbSubevent_Caen, TNotifyLinkBase, TRefTable, ROOT::TSchemaRule, TGTextEdit, TGTextView, TGView, TGHtml, TStreamerInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:21904,safe,safe,21904,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['safe'],['safe']
Safety,"ph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, TDatabasePDG, TGenerator, TParticleClassPDG, TApplicationRemote, TProof, TProofChain, RooPlot, TBranch, TVirtualBranchBrowsable, TCollectionPropertyBrowsable, TBranchClones, TBranchElement, TBranchObject, TBranchSTL, TLeaf, TNtuple, TNtupleD, TTreePerfStats, ROOT::Experimental::XRooFit::xRooNode, and TQueryResult.; Definition at line 204 of file TObject.cxx. ◆ CheckedHash(). ULong_t TObject::CheckedHash ; (; ). inline . Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; The intent is for this routine to be called instead of directly calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; (*) The setup is consistent when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 324 of file TObject.h. ◆ Class(). static TClass * TObject::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TObject::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TObject::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 243 of file TObject.h. ◆ ClassName(). const char * TObject::ClassName ; (; ); const. virtual . Returns name of class to which the object belongs. ; Definition at line 213 of file TObject.cxx. ◆ Clear(). virtual void TObject::Clear ; (; Option_t * ; = """"). inlinevirtual . Reimplemented in TMVA::ResultsClassification, TMVA::ResultsMulticlass, TMVA::ResultsRegression, TMVA::ResultsClassification, TMVA::ResultsMulticlass, TMVA::ResultsRegression, TMrbSubevent_Caen, TNotifyLinkBase, TRefTable, ROOT::TSchemaRule, TGTextEdit, TGTextView, TGView, TGHtml, TStreamerInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:21905,safe,safe,21905,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['safe'],['safe']
Safety,"physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes:. ROOT::Math::DisplacementVector2D and ROOT::Math::DisplacementVector3D template classes describing 2 and 3 component direction and magnitude vectors, not rooted at any particular point;; ROOT::Math::Positio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719745,avoid,avoided,719745,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avoid'],['avoided']
Safety,"pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 204",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72265,recover,recovered,72265,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,"['recover', 'safe']","['recovered', 'safely']"
Safety,"piled OK; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& b); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last changed: Mon Jul 4 15:24:50 2011 » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooWorkspace__CodeRepo.html:7544,avoid,avoid,7544,root/html530/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html530/RooWorkspace__CodeRepo.html,3,"['abort', 'avoid', 'recover']","['abort', 'avoid', 'recover']"
Safety,"piled OK; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& b); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last changed: Thu Nov 3 20:10:09 2011 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooWorkspace__CodeRepo.html:7544,avoid,avoid,7544,root/html532/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html532/RooWorkspace__CodeRepo.html,6,"['abort', 'avoid', 'recover']","['abort', 'avoid', 'recover']"
Safety,"piled OK; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& b); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last changed: Wed Dec 8 11:39:40 2010 » Last generated: 2010-12-08 11:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooWorkspace__CodeRepo.html:7475,avoid,avoid,7475,root/html528/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html528/RooWorkspace__CodeRepo.html,3,"['abort', 'avoid', 'recover']","['abort', 'avoid', 'recover']"
Safety,"piled) (NA):(NA) 0 public: static const char *Class_Name();; (compiled) (NA):(NA) 0 public: static Version_t Class_Version();; (compiled) (NA):(NA) 0 public: static void Dictionary();; (compiled) (NA):(NA) 0 public: virtual class TClass *IsA() const;; (compiled) (NA):(NA) 0 public: virtual void ShowMembers(class TMemberInspector &insp) const;; (compiled) (NA):(NA) 0 public: virtual void Streamer(class TBuffer &);; (compiled) (NA):(NA) 0 public: void StreamerNVirtual(class TBuffer &ClassDef_StreamerNVirtual_b);; (compiled) (NA):(NA) 0 public: static const char *DeclFileName();; (compiled) (NA):(NA) 0 public: static int ImplFileLine();; (compiled) (NA):(NA) 0 public: static const char *ImplFileName();; (compiled) (NA):(NA) 0 public: static int DeclFileLine();; root [] .> test.log; root [] l.Dump();; root [] .>; root [] ?; Here we see:. Use .class as quick help and reference; Unix like I/O redirection using .> out.txt and unredirection with .>; Use ? to get help on all ‘‘raw’’ interpreter commands; Use @ to abort a multi-line command. Now let us execute a multi-line command:; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; Here we note:. A multi-line command starts with a { and ends with a }.; Inside continuation, every line has to be correctly terminated with a ; (like in ""real’’ C++).; All objects are created in global scope.; There is no way to back up; you are better off writing a script.; Use .q to exit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of stateme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:262240,abort,abort,262240,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['abort'],['abort']
Safety,"ping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):; 1. TGeoShape *clip1, *clip2, ...; One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom example looks clipped with a tube. Ray-tracing example with box-clipping. 18.8 Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1013261,detect,detector,1013261,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['detect'],['detector']
Safety,"ping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Double_tDistToParaboloid(Double_t* point, Double_t* dir) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoParaboloid.html:2313,safe,safe,2313,root/html528/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html528/TGeoParaboloid.html,1,['safe'],['safe']
Safety,"ping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoSphere.html:2099,safe,safe,2099,root/html528/TGeoSphere.html,https://root.cern,https://root.cern/root/html528/TGeoSphere.html,1,['safe'],['safe']
Safety,"ping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:7791,safe,safe,7791,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,3,['safe'],['safe']
Safety,"pl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:55783,safe,safe,55783,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['safe'],['safe']
Safety,"plementations that are designed to work with trivially copyable T's. More...;  ; class  SmallVectorTemplateCommon;  This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD. More...;  . Typedefs; template<typename T > ; using RVec = ROOT::VecOps::RVec< T >;  . Functions; constexpr bool All (const bool *vals, std::size_t size);  ; template<typename... T> ; std::size_t GetVectorsSize (const std::string &id, const RVec< T > &... vs);  ; template<typename Tuple_t , std::size_t... Is> ; auto MapFromTuple (Tuple_t &&t, std::index_sequence< Is... >) -> decltype(MapImpl(std::get< std::tuple_size< Tuple_t >::value - 1 >(t), std::get< Is >(t)...));  ; template<typename F , typename... RVecs> ; auto MapImpl (F &&f, RVecs &&... vs) -> RVec< decltype(f(vs[0]...))>;  ; uint64_t NextPowerOf2 (uint64_t A);  Return the next power of two (in 64-bits) that is strictly greater than A. ;  ; template<typename T > ; void ResetView (RVec< T > &v, T *addr, std::size_t sz);  An unsafe function to reset the buffer for which this RVec is acting as a view. ;  ; template<typename ForwardIt > ; void UninitializedValueConstruct (ForwardIt first, ForwardIt last);  ; template<typename T , bool TriviallyCopyable> ;  void (off) SmallVectorTemplateBase< T;  . Typedef Documentation. ◆ RVec. template<typename T > . using ROOT::Internal::VecOps::RVec = typedef ROOT::VecOps::RVec<T>. Definition at line 69 of file RVec.hxx. Function Documentation. ◆ All(). constexpr bool ROOT::Internal::VecOps::All ; (; const bool * ; vals, . std::size_t ; size . ). constexpr . Definition at line 79 of file RVec.hxx. ◆ GetVectorsSize(). template<typename... T> . std::size_t ROOT::Internal::VecOps::GetVectorsSize ; (; const std::string & ; id, . const RVec< T > &... ; vs . ). Definition at line 88 of file RVec.hxx. ◆ MapFromTuple(). template<typename Tuple_t , std::size_t... Is> . auto ROOT::Internal::VecOps::MapFromTuple ; (; Tuple_t && ; t, . std::index_sequence< Is... > ;  . ); -> d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1VecOps.html:2177,unsafe,unsafe,2177,doc/master/namespaceROOT_1_1Internal_1_1VecOps.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1VecOps.html,1,['unsafe'],['unsafe']
Safety,"plemented in TBufferSQL.; Definition at line 419 of file TBufferFile.h. ◆ ReadULong64(). void TBufferFile::ReadULong64 ; (; ULong64_t & ; l). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 432 of file TBufferFile.h. ◆ ReadUShort(). void TBufferFile::ReadUShort ; (; UShort_t & ; s). inlineoverridevirtual . Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 393 of file TBufferFile.h. ◆ ReadVersion(). Version_t TBufferFile::ReadVersion ; (; UInt_t * ; start = nullptr, . UInt_t * ; bcnt = nullptr, . const TClass * ; cl = nullptr . ). overridevirtual . Read class version from I/O buffer. ; Implements TBuffer.; Definition at line 2930 of file TBufferFile.cxx. ◆ ReadVersionForMemberWise(). Version_t TBufferFile::ReadVersionForMemberWise ; (; const TClass * ; cl = nullptr). overridevirtual . Read class version from I/O buffer. ; To be used when streaming out member-wise streamed collection where we do not care (not save) about the byte count and can safely ignore missing streamerInfo (since they usually indicate empty collections). ; Implements TBuffer.; Definition at line 3079 of file TBufferFile.cxx. ◆ ReadVersionNoCheckSum(). Version_t TBufferFile::ReadVersionNoCheckSum ; (; UInt_t * ; start = nullptr, . UInt_t * ; bcnt = nullptr . ). overridevirtual . Read class version from I/O buffer, when the caller knows for sure that there is no checksum written/involved. ; Implements TBuffer.; Definition at line 3036 of file TBufferFile.cxx. ◆ ReadWithFactor() [1/2]. void TBufferFile::ReadWithFactor ; (; Double_t * ; ptr, . Double_t ; factor, . Double_t ; minvalue . ). overridevirtual . Read a Double32_t from the buffer when the factor and minimum value have been specified see comments about Double32_t encoding at TBufferFile::WriteDouble32(). ; Implements TBuffer.; Definition at line 524 of file TBufferFile.cxx. ◆ ReadWithFactor() [2/2]. void TBufferFile::ReadWithFactor ; (; Float_t * ; ptr, . Double_t ; factor, . D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:69412,safe,safely,69412,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['safe'],['safely']
Safety,"plexType : short. strong . EnumeratorkNone ; kDouble ; kFloat ; kInt ; kLong . Definition at line 111 of file TClassEdit.h. ◆ EModType. enum TClassEdit::EModType. EnumeratorkNone ; kDropTrailStar ; kDropDefaultAlloc ; kDropAlloc ; kInnerClass ; kInnedMostClass ; kDropStlDefault ; kDropComparator ; kDropAllDefault ; kLong64 ; kDropStd ; kKeepOuterConst ; kResolveTypedef ; kDropPredicate ; kDropHash . Definition at line 75 of file TClassEdit.h. ◆ ESTLType. enum TClassEdit::ESTLType. EnumeratorkNotSTL ; kVector ; kList ; kForwardlist ; kDeque ; kMap ; kMultiMap ; kSet ; kMultiSet ; kUnorderedSet ; kUnorderedMultiSet ; kUnorderedMap ; kUnorderedMultiMap ; kBitSet ; kEnd . Definition at line 93 of file TClassEdit.h. Function Documentation. ◆ CleanType(). string TClassEdit::CleanType ; (; const char * ; typeDesc, . int ; mode = 0, . const char ** ; tail = nullptr . ). Cleanup type description, redundant blanks removed and redundant tail ignored return *tail = pointer to last used character if (mode==0) keep keywords if (mode==1) remove keywords outside the template params if (mode>=2) remove the keywords everywhere. ; if (tail!=0) cut before the trailing *; The keywords currently are: ""const"" , ""volatile"" removed; CleanType("" A<B, C< D, E> > *,F,G>"") returns ""A<B,C<D,E> >*"" ; Definition at line 1232 of file TClassEdit.cxx. ◆ DemangleName(). char * TClassEdit::DemangleName ; (; const char * ; mangled_name, . int & ; errorCode . ). inline . Definition at line 208 of file TClassEdit.h. ◆ DemangleTypeIdName(). char * TClassEdit::DemangleTypeIdName ; (; const std::type_info & ; ti, . int & ; errorCode . ). Demangle in a portable way the type id name. ; IMPORTANT: The caller is responsible for freeing the returned const char* ; Definition at line 2148 of file TClassEdit.cxx. ◆ GetComplexType(). TClassEdit::EComplexType TClassEdit::GetComplexType ; (; const char * ; clName). Definition at line 137 of file TClassEdit.cxx. ◆ GetLong64_Name() [1/2]. string TClassEdit::GetLong64_Name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTClassEdit.html:7017,redund,redundant,7017,doc/master/namespaceTClassEdit.html,https://root.cern,https://root.cern/doc/master/namespaceTClassEdit.html,2,['redund'],['redundant']
Safety,"plitlevel); 1604{; 1605 if (!ptrClass) {; 1606 Error(""Branch"", ""The pointer specified for %s is not of a class known to ROOT"", branchname);; 1607 return nullptr;; 1608 }; 1609 TClass* actualClass = nullptr;; 1610 void** addr = (void**) addobj;; 1611 if (addr && *addr) {; 1612 actualClass = ptrClass->GetActualClass(*addr);; 1613 if (!actualClass) {; 1614 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1615 branchname, ptrClass->GetName());; 1616 actualClass = ptrClass;; 1617 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1618 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1619 return nullptr;; 1620 }; 1621 } else {; 1622 actualClass = ptrClass;; 1623 }; 1624 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1625 Error(""Branch"", writeStlWithoutProxyMsg,; 1626 actualClass->GetName(), branchname, actualClass->GetName());; 1627 return nullptr;; 1628 }; 1629 return Branch(branchname, actualClass->GetName(), (void*) addobj, bufsize, splitlevel);; 1630}; 1631 ; 1632////////////////////////////////////////////////////////////////////////////////; 1633/// Same as TTree::Branch but automatic detection of the class name.; 1634/// \see TTree::Branch for other details.; 1635 ; 1636TBranch* TTree::BranchImpRef(const char* branchname, const char *classname, TClass* ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); 1637{; 1638 TClass* claim = TClass::GetClass(classname);; 1639 if (!ptrClass) {; 1640 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1641 Error(""Branch"", writeStlWithoutProxyMsg,; 1642 claim->GetName(), branch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:61926,detect,detection,61926,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['detect'],['detection']
Safety,"plotOn(extmodel) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_extmodel_modelData_LEFT,fit_nll_extmodel_modelData_RIGHT'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(extmodel) only plotting range 'fit_nll_extmodel_modelData_RIGHT'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(extmodel) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_extmodel_modelData_LEFT,fit_nll_extmodel_modelData_RIGHT'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(extmodel) only plotting range 'fit_nll_extmodel_modelData_RIGHT'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(extmodel) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_extmodel_modelData_LEFT,fit_nll_extmodel_modelData_RIGHT'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(extmodel) only plotting range 'fit_nll_extmodel_modelData_RIGHT'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(extmodel) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_extmodel_modelData_LEFT,fit_nll_extmodel_modelData_RIGHT'; [#0] WARNING:InputArguments -- The parameter 'width' with range [-inf, inf] of the RooGaussian 'sig' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_modelsum_modelData_LEFT' created with bounds [10,20]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_modelsum_modelData_RIGHT' created with bounds [60,100]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelsum) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelsum_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html:21136,safe,safe,21136,doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8C.html,2,['safe'],['safe']
Safety,"points; i++) fY[i] /= integ;; 409 }; 410 ; 411 f->TAttLine::Copy(*this);; 412 f->TAttFill::Copy(*this);; 413 f->TAttMarker::Copy(*this);; 414 ; 415 SetName(f->GetName());; 416 SetTitle(f->GetTitle());; 417}; 418 ; 419////////////////////////////////////////////////////////////////////////////////; 420/// Graph constructor reading input from filename.; 421///; 422/// `filename` is assumed to contain at least two columns of numbers.; 423/// The string format is by default `""%lg %lg""`.; 424/// This is a standard c formatting for `scanf()`.; 425/// For example, set format to `""%lg,%lg""` for a comma-separated file.; 426///; 427/// If columns of numbers should be skipped, a `""%*lg""` or `""%*s""` for each column; 428/// can be added, e.g. `""%lg %*lg %lg""` would read x-values from the first and; 429/// y-values from the third column.; 430///; 431/// For files separated by a specific delimiter different from ' ' and '\\t' (e.g.; 432/// ';' in csv files) you can avoid using `%*s` to bypass this delimiter by explicitly; 433/// specify the `option` argument,; 434/// e.g. option=`"" \\t,;""` for columns of figures separated by any of these characters; 435/// (' ', '\\t', ',', ';'); 436/// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; 437/// Note in that case, the instantiation is about two times slower.; 438 ; 439TGraph::TGraph(const char *filename, const char *format, Option_t *option); 440 : TNamed(""Graph"", filename), TAttFill(0, 1000); 441{; 442 Double_t x, y;; 443 TString fname = filename;; 444 gSystem->ExpandPathName(fname);; 445 ; 446 std::ifstream infile(fname.Data());; 447 if (!infile.good()) {; 448 MakeZombie();; 449 Error(""TGraph"", ""Cannot open file: %s, TGraph is Zombie"", filename);; 450 fNpoints = 0;; 451 return;; 452 } else {; 453 fNpoints = 100; //initial number of points; 454 }; 455 if (!CtorAllocate()) return;; 456 std::string line;; 457 Int_t np = 0;; 458 ; 459 // No delimiters specified (standard constructor).; 460 if (strcmp(option, """") == 0) {; 46",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:13758,avoid,avoid,13758,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['avoid'],['avoid']
Safety,"pollres = 0 means timeout */; 6322 nread = 0;; 6323 }; 6324#endif; 6325 ; 6326 } else {; 6327 struct mg_pollfd pfd[1];; 6328 int pollres;; 6329 ; 6330 pfd[0].fd = conn->client.sock;; 6331 pfd[0].events = POLLIN;; 6332 pollres = mg_poll(pfd,; 6333 1,; 6334 (int)(timeout * 1000.0),; 6335 &(conn->phys_ctx->stop_flag));; 6336 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6337 return -2;; 6338 }; 6339 if (pollres > 0) {; 6340 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6341 err = (nread < 0) ? ERRNO : 0;; 6342 if (nread <= 0) {; 6343 /* shutdown of the socket at client side */; 6344 return -2;; 6345 }; 6346 } else if (pollres < 0) {; 6347 /* error callint poll */; 6348 return -2;; 6349 } else {; 6350 /* pollres = 0 means timeout */; 6351 nread = 0;; 6352 }; 6353 }; 6354 ; 6355 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6356 return -2;; 6357 }; 6358 ; 6359 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:184834,timeout,timeout,184834,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"pollres = 0 means timeout */; 6323 nread = 0;; 6324 }; 6325#endif; 6326 ; 6327 } else {; 6328 struct mg_pollfd pfd[1];; 6329 int pollres;; 6330 ; 6331 pfd[0].fd = conn->client.sock;; 6332 pfd[0].events = POLLIN;; 6333 pollres = mg_poll(pfd,; 6334 1,; 6335 (int)(timeout * 1000.0),; 6336 &(conn->phys_ctx->stop_flag));; 6337 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6338 return -2;; 6339 }; 6340 if (pollres > 0) {; 6341 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6342 err = (nread < 0) ? ERRNO : 0;; 6343 if (nread <= 0) {; 6344 /* shutdown of the socket at client side */; 6345 return -2;; 6346 }; 6347 } else if (pollres < 0) {; 6348 /* error callint poll */; 6349 return -2;; 6350 } else {; 6351 /* pollres = 0 means timeout */; 6352 nread = 0;; 6353 }; 6354 }; 6355 ; 6356 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6357 return -2;; 6358 }; 6359 ; 6360 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:184866,timeout,timeout,184866,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['timeout'],['timeout']
Safety,"ponent"", -0.1337, -10.0, -0.1); expo = ROOT.RooExponential(""expo"", ""A falling exponential function"", x, tau); ; # Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30); x.setRange(""left"", 1, 10); x.setRange(""right"", 20, 30); ; # Generate toy data, and cut out the blinded region.; data = expo.generate(x, 1000); blindedData = data.reduce(CutRange=""left,right""); ; # Kick tau a bit, and run an unbinned fit where the blinded data are missing.; # ----------------------------------------------------------------------------------------------------------; # The fit should be done only in the unblinded regions, otherwise it would try; # to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.0); expo.fitTo(blindedData, Range=""left,right"", PrintLevel=-1); ; # Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would be; # automatically taken as the NormRange() for plotting. We want to avoid this,; # because the point of this tutorial is to show what can go wrong when the; # NormRange() is not specified.; expo.removeStringAttribute(""fitrange""); ; ; # Here we will plot the results; canvas = ROOT.TCanvas(""canvas"", ""canvas"", 800, 600); canvas.Divide(2, 1); ; ; # Wrong:; # ----------------------------------------------------------------------------------------------------------; # Plotting each slice on its own normalises the PDF over its plotting range. For the full curve, that means; # that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; # comes out too low, and doesn't match up with the slices in the side bands, which are normalised to ""their"" data.; ; print(""Now plotting with unique normalisation for each slice.\n""); canvas.cd(1); plotFrame = x.frame(Title=""Wrong: Each slice normalised over its plotting range""); ; # Plot only the blinded data, and then plot the PDF over the full range as well as both sidebands; blindedData.plotOn(plotFrame); expo.plotOn(plotFrame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html:1860,avoid,avoid,1860,doc/master/rf212__plottingInRanges__blinding_8py.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html,1,['avoid'],['avoid']
Safety,"poses only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:13520,timeout,timeout,13520,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,4,['timeout'],['timeout']
Safety,"powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the tail of the exponential where; // there are not so many events. And we can't afford any precision loss for; // these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100); // It's not about binning effects anymore, so reset the number of bins.; ; RooRealVar mu{""mu"", ""mu"", 3.0, 0.1, 5.1};; RooRealVar sigma{""sigma"", ""sigma"", 0.5, 0.01, 5.0};; RooGaussian gauss{""gauss"", ""gauss"", x, mu, sigma};; ; RooRealVar nsig{""nsig"", ""nsig"", 10000, 0, 1e9};; RooRealVar nbkg{""nbkg"", ""nbkg"", 10000000, 0, 1e9};; RooRealVar frac{""frac"", ""frac"", nsig.getVal() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:6304,predict,predicted,6304,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['predict'],['predicted']
Safety,"practical applications of MVAs correlations are present. ; Linear correlations, measured from the training sample, can be taken into account in a straightforward manner through the square-root of the covariance matrix. The square-root of a matrix \( C \) is the matrix \( C′ \) that multiplied with itself yields \( C \): \( C \)= \( C′C′ \). We compute the square-root matrix (SQM) by means of diagonalising ( \( D \)) the covariance matrix:. \[; D = S^TCS \Rightarrow C' = S \sqrt{DS^T}; \]. and the linear transformation of the linearly correlated into the uncorrelated variables space is then given by multiplying the measured variable tuple by the inverse of the SQM. Note that these transformations are performed for both signal and background separately, since the correlation pattern is not the same in the two samples.; The above diagonalisation is complete for linearly correlated, Gaussian distributed variables only. In real-world examples this is not often the case, so that only little additional information may be recovered by the diagonalisation procedure. In these cases, non-linear methods must be applied. ; Definition at line 61 of file MethodLikelihood.h. Public Member Functions;  MethodLikelihood (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption="""");  standard constructor ;  ;  MethodLikelihood (DataSetInfo &theData, const TString &theWeightFile);  construct likelihood references from file ;  ; virtual ~MethodLikelihood ();  destructor ;  ; void AddWeightsXMLTo (void *parent) const;  write weights to XML ;  ; const Ranking * CreateRanking ();  computes ranking of input variables ;  ; Double_t GetMvaValue (Double_t *err=nullptr, Double_t *errUpper=nullptr);  returns the likelihood estimator for signal fill a new Likelihood branch into the testTree ;  ; virtual Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets);  FDA can handle classification with 2 classes. ;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html:2890,recover,recovered,2890,doc/master/classTMVA_1_1MethodLikelihood.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodLikelihood.html,1,['recover'],['recovered']
Safety,"press is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:27504,detect,detected,27504,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,3,"['Recover', 'detect']","['Recovery', 'detected']"
Safety,"press is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:26821,detect,detected,26821,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,4,"['Recover', 'detect']","['Recovery', 'detected']"
Safety,"preter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimer.html:13560,timeout,timeout,13560,root/html528/TTimer.html,https://root.cern,https://root.cern/root/html528/TTimer.html,8,['timeout'],['timeout']
Safety,"procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by TTree::Fill when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by TTree::Fill every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.; Note that calling TTree::AutoSave too frequently (or similarly calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:75536,recover,recovered,75536,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['recover'],['recovered']
Safety,"process a command line.; 2411///; 2412/// If the command is executed and the error is 0, then the return value; 2413/// is the int value corresponding to the result of the executed command; 2414/// (float and double return values will be truncated).; 2415///; 2416 ; 2417// Method for handling the interpreter exceptions.; 2418// the MetaProcessor is passing in as argument to teh function, because; 2419// cling::Interpreter::CompilationResult is a nested class and it cannot be; 2420// forward declared, thus this method cannot be a static member function; 2421// of TCling.; 2422 ; 2423static int HandleInterpreterException(cling::MetaProcessor* metaProcessor,; 2424 const char* input_line,; 2425 cling::Interpreter::CompilationResult& compRes,; 2426 cling::Value* result); 2427{; 2428 try {; 2429 return metaProcessor->process(input_line, compRes, result);; 2430 }; 2431 catch (cling::InterpreterException& ex); 2432 {; 2433 Error(""HandleInterpreterException"", ""%s\n%s"", ex.what(), ""Execution of your code was aborted."");; 2434 ex.diagnose();; 2435 compRes = cling::Interpreter::kFailure;; 2436 }; 2437 return 0;; 2438}; 2439 ; 2440////////////////////////////////////////////////////////////////////////////////; 2441 ; 2442bool TCling::DiagnoseIfInterpreterException(const std::exception &e) const; 2443{; 2444 if (auto ie = dynamic_cast<const cling::InterpreterException*>(&e)) {; 2445 ie->diagnose();; 2446 return true;; 2447 }; 2448 return false;; 2449}; 2450 ; 2451////////////////////////////////////////////////////////////////////////////////; 2452 ; 2453Longptr_t TCling::ProcessLine(const char* line, EErrorCode* error/*=0*/); 2454{; 2455 // Copy the passed line, it comes from a static buffer in TApplication; 2456 // which can be reentered through the Cling evaluation routines,; 2457 // which would overwrite the static buffer and we would forget what we; 2458 // were doing.; 2459 //; 2460 TString sLine(line);; 2461 if (strstr(line,fantomline)) {; 2462 // End-Of-Line action; 2463",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:94381,abort,aborted,94381,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['abort'],['aborted']
Safety,"progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 40088 2011-06-30 15:10:06Z bellen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionQueryFrame.html:21863,abort,aborted,21863,root/html532/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html532/TSessionQueryFrame.html,2,['abort'],['aborted']
Safety,"provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:114260,avoid,avoid,114260,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"provided; 3080 // by a user provided TClassGenerator. We have no way of knowing whether; 3081 // those do (or even can) behave the same way as the ROOT dictionary and; 3082 // have the 'dictionary is now available for use' step informs the existing; 3083 // TClass that their dictionary is now available.; 3084 ; 3085 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3086 load = kTRUE;; 3087 }; 3088 ; 3089 if (TClassEdit::IsArtificial(name)) {; 3090 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3091 // from an already normalized name for the purpose of supporting schema evolution.; 3092 // There is no dictionary or interpreter information about this kind of class, the only; 3093 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3094 // auto-loading or auto-parsing based on the scope of the name.; 3095 return cl;; 3096 }; 3097 ; 3098 // To avoid spurious auto parsing, let's check if the name as-is is; 3099 // known in the TClassTable.; 3100 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3101 if (dict) {; 3102 // The name is normalized, so the result of the first search is; 3103 // authoritative.; 3104 if (!cl && !load) return nullptr;; 3105 ; 3106 TClass *loadedcl = (dict)();; 3107 if (loadedcl) {; 3108 loadedcl->PostLoadCheck();; 3109 return loadedcl;; 3110 }; 3111 ; 3112 // We should really not fall through to here, but if we do, let's just; 3113 // continue as before ...; 3114 }; 3115 ; 3116 std::string normalizedName;; 3117 Bool_t checkTable = kFALSE;; 3118 ; 3119 if (!cl) {; 3120 {; 3121 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3122 TClassEdit::GetNormalizedName(normalizedName, name);; 3123 }; 3124 // Try the normalized name.; 3125 if (normalizedName != name) {; 3126 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3127 ; 3128 if (cl) {; 3129 if (cl->IsLoaded() || cl->TestBit(kUnloa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:117011,avoid,avoid,117011,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avoid'],['avoid']
Safety,"psMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); Double_tDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Double_tDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Double_tDDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:2607,safe,safe,2607,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,6,['safe'],['safe']
Safety,"pshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; StorageType storageType;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from RooDirItem; TDirectory * _dir {nullptr};  ! Associated directory ;  . Private Member Functions; void _adjustBinning (RooRealVar &theirVar, const TAxis &axis, RooRealVar *ourVar, Int_t *offset);  Helper doing the actual work of adjustBinning(). ;  ; VarInfo const & getVarInfo ();  Return reference to VarInfo struct with cached histogram variable information that is frequently used for histogram weights retrieval. ;  ; void initializeAsymErrArrays () const;  ; void interpolateLinear (double *output, std::span< const double > xVals, bool correctForBinSize, bool cdfBoundaries);  A vectorized version of interpolateDim for boundary safe linear interpolation of one dimensional histograms. ;  ; void interpolateQuadratic (double *output, std::span< const double > xVals, bool correctForBinSize, bool cdfBoundaries);  A vectorized version of interpolateDim for boundary safe quadratic interpolation of one dimensional histograms. ;  ; void registerWeightArraysToDataStore () const;  Hand over pointers to our weight arrays to the data store implementation. ;  ; double weightInterpolated (const RooArgSet &bin, int intOrder, bool correctForBinSize, bool cdfBoundaries);  Return the weight at given coordinates with interpolation. ;  . Static Private Member Functions; static std::unique_ptr< RooAbsDataStore > makeDefaultDataStore (RooStringView name, RooStringView title, RooArgSet const &vars);  . Private Attributes; std::vector< double > _interpolationBuffer;  ! Buffer to contain values used for weight interpolation ;  ; VarInfo _varInfo;  ! ;  . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:40650,safe,safe,40650,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['safe'],['safe']
Safety,"pt = o; }. void SetSessionID(Int_t id). Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); { return TSocket::Send(mess, kind); }. Int_t SendRaw(const void* buf, Int_t len, ESendRecvOptions opt = kDontBlock). Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. Int_t Recv(char* mess, Int_t max, Int_t& kind); { return TSocket::Recv(mess, max, kind); }. Int_t RecvRaw(void* buf, Int_t len, ESendRecvOptions opt = kDefault); Interrupts. Int_t GetInterrupt(Bool_t& forward). void SendUrgent(Int_t type, Int_t int1, Int_t int2); Urgent message. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t Flush(); Flush the asynchronous queue. Bool_t Ping(const char* ord = 0); Ping the counterpart. void RemoteTouch(); Request remote touch of the admin file associated with this connection. void CtrlC(); Propagate a Ctrl-C. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. Int_t Reconnect(); Try reconnection after error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSocket.html:15547,timeout,timeout,15547,root/html534/TXSocket.html,https://root.cern,https://root.cern/root/html534/TXSocket.html,2,['timeout'],['timeout']
Safety,"ptRootMapFileName,; 5116 rootmapLibName,; 5117 classesDefsList,; 5118 classesNamesForRootmap,; 5119 nsNames,; 5120 typedefsRootmapLines,; 5121 enumNames,; 5122 varNames,; 5123 headersClassesMap,; 5124 headersToIgnore);; 5125 ; 5126 if (0 != rootclingRetCode) return 1;; 5127 }; 5128 ; 5129 if (genreflex::verbose); 5130 tmpCatalog.dump();; 5131 ; 5132 // Manually call end of translation unit because we never call the; 5133 // appropriate deconstructors in the interpreter. This writes out the C++; 5134 // module file that we currently generate.; 5135 {; 5136 cling::Interpreter::PushTransactionRAII RAII(&interp);; 5137 CI->getSema().getASTConsumer().HandleTranslationUnit(CI->getSema().getASTContext());; 5138 }; 5139 ; 5140 // Add the warnings; 5141 rootclingRetCode += ROOT::TMetaUtils::GetNumberOfErrors();; 5142 ; 5143 // make sure the file is closed before committing; 5144 fileout.close();; 5145 ; 5146 // Before returning, rename the files if no errors occurred; 5147 // otherwise clean them to avoid remnants (see ROOT-10015); 5148 if(rootclingRetCode == 0) {; 5149 rootclingRetCode += tmpCatalog.commit();; 5150 } else {; 5151 tmpCatalog.clean();; 5152 }; 5153 ; 5154 return rootclingRetCode;; 5155 ; 5156}; 5157 ; 5158namespace genreflex {; 5159 ; 5160////////////////////////////////////////////////////////////////////////////////; 5161/// Loop on arguments: stop at the first which starts with -; 5162 ; 5163 unsigned int checkHeadersNames(std::vector<std::string> &headersNames); 5164 {; 5165 unsigned int numberOfHeaders = 0;; 5166 for (std::vector<std::string>::iterator it = headersNames.begin();; 5167 it != headersNames.end(); ++it) {; 5168 const std::string headername(*it);; 5169 if (ROOT::TMetaUtils::IsHeaderName(headername)) {; 5170 numberOfHeaders++;; 5171 } else {; 5172 ROOT::TMetaUtils::Warning(nullptr,; 5173 ""*** genreflex: %s is not a valid header name (.h and .hpp extensions expected)!\n"",; 5174 headername.c_str());; 5175 }; 5176 }; 5177 return numberOfHeaders;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:208809,avoid,avoid,208809,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['avoid'],['avoid']
Safety,"ption = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the automatic delete bit. This bit is used by TBranchObject::ReadBasket to decide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBranch.html:25983,avoid,avoid,25983,root/html530/TBranch.html,https://root.cern,https://root.cern/root/html530/TBranch.html,1,['avoid'],['avoid']
Safety,"ption = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the automatic delete bit. This bit is used by TBranchObject::ReadBasket to decide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionLevel(Int_t level = 1); *-*-*-*-*-*-*-*Set the branch/subbranches compression level; *-* ============================================. void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranch.html:23604,avoid,avoid,23604,root/html528/TBranch.html,https://root.cern,https://root.cern/root/html528/TBranch.html,1,['avoid'],['avoid']
Safety,"ption = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the automatic delete bit. This bit is used by TBranchObject::ReadBasket to decide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionLevel(Int_t level = 1); *-*-*-*-*-*-*-*Set the branch/subbranches compression level; *-* ============================================. void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranch.html:22603,avoid,avoid,22603,root/html526/TBranch.html,https://root.cern,https://root.cern/root/html526/TBranch.html,1,['avoid'],['avoid']
Safety,"ption = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoIntersection.html:2557,safe,safe,2557,root/html532/TGeoIntersection.html,https://root.cern,https://root.cern/root/html532/TGeoIntersection.html,6,['safe'],['safe']
Safety,"ption = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSlave(TSocket* socket = 0); TProofPlayerSlave(TProofPlayerSlave&&); TProofPlayerSlave(const TProofPlayerSlave&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSlave.html:11374,timeout,timeout,11374,root/html602/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSlave.html,2,['timeout'],['timeout']
Safety,"ption =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entries in this branch. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where this branch writes/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchClones.html:8155,avoid,avoid,8155,doc/master/classTBranchClones.html,https://root.cern,https://root.cern/doc/master/classTBranchClones.html,1,['avoid'],['avoid']
Safety,"ption gnuinstall also sets RPATH in librries and executables in installation directory; Various fixes for MacOS X 10.11 ROOT-7680. Core. Fix thread safety of the creation of TMethodCall from a TFunction.; Fix dictionary generation of STL collection involving one of ROOT’s core classes when the user header contains only a forward declaration of the class [ROOT-7695]. Bugs. [ROOT-7680] - Can’t build v6-02-12 on MacOS X 10.11; [ROOT-7695] - Segmentation violation in rootcint; [ROOT-7709] - PyROOT not functional with system-default Python version on MacOS X 10.11; [ROOT-7715] - Building ROOT with CMake not in my PATH fails. Release 6.04/08; Build. Add –disable-search-usrlocal to configure/make to be able to avoid conflict with incompatible installation (e.g. homebrew).; Add /opt/X11 to configure/make search for include files and libraries.; Updates PCRE to 8.37 (current upstream version) which can detect PPC64LE machine.; Fail cmake configuration if the specified CMAKE_BUILD_TYPE is unknown; Fix RPATH for MacOSX (El Capitan) to avoid building with -Drpath=ON. The default uses rpath=@loader_path/../lib. Core. Add missing protection when creating new StreamerInfo.; Add accessor functions and functionality needed by CMS event display.; Do not delete resource when replaceing default TApplication. Interpreter. Prevent crash in expressions which contain use undefined identifier ROOT-7737; Disable unnecessary code during dictionary generation that triggered problem due to the lack of support for template parameter packs ROOT-7708; Add suport in the type and name normalization routine for template parameter packs ROOT-7708. IO. For backward compatibility with ROOT5, allow to define IO constructors with the signature MyClass::MyClass(void&) where void is a forward declared type.; In TBuffer shrink buffers when requested. Histograms. Fix interval calculation in Divide for the Poisson ratio case. Minuit. Make function pointer held by TMinuitMinimize thread local. Patches Release 6.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:32969,avoid,avoid,32969,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['avoid'],['avoid']
Safety,"ption="""") const;  Return total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branch too. ;  ; bool IsAutoDelete () const;  Return true if an existing object in a TBranchObject must be deleted. ;  ; virtual void KeepCircular (Long64_t maxEntries);  keep a maximum of fMaxEntries in memory ;  ; virtual Int_t LoadBaskets ();  Baskets associated to this branch are forced to be in memory. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entries in this branch. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where this branch writes/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:13342,avoid,avoid,13342,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['avoid'],['avoid']
Safety,"ption="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoGtra::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoGtra::TGeoGtraTGeoGtra(); TGeoGtra::TGeoGtraTGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoGtra::GetTwistAngleDouble_t GetTwistAngle() constDefinition TGeoArb8.h:171; TGeoGtra::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoGtra::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoGtra::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoGtra::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoGtra::~TGeoGtra~TGeoGtra() override; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoTrapDefinition TGeoArb8.h:96; TGeoTrap::~TGeoTrap~TGeoTrap() override; TGeoTrap::TGeoTrapTGeoTrap(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoTrap::fTl2Double_t fTl2Definition TGeoArb8.h:107; TGeoTrap::GetTl1Double_t GetTl1() constDefinition TGeoArb8.h:134; TGeoTrap::GetPhiDouble_t GetPhi() constDefinition TGeoArb8.h:131; TGeoTrap::fBl2Double_t fBl2Definition TGeoArb8.h:1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:16588,safe,safe,16588,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,2,['safe'],['safe']
Safety,"ption_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Int_t len);  Read a buffer from the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read a buffer from the file at the offset 'pos' in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read the nbuf blocks described in arrays pos and len. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:7944,recover,recover,7944,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,5,['recover'],['recover']
Safety,"ption_t* option = """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLite(TProof* proof = 0); TProofPlayerLite(const TProofPlayerLite&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLite.html:11023,abort,abort,11023,root/html602/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLite.html,2,['abort'],['abort']
Safety,"ption_t* option = """") constMENU ; virtual Int_tTProofPlayer::SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerSuperMaster(TProof* proof = 0); TProofPlayerSuperMaster(const TProofPlayerSuperMaster&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSuperMaster.html:11433,abort,abort,11433,root/html602/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSuperMaster.html,2,['abort'],['abort']
Safety,"ption_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_tfDetIdCustom detector id.; Int_tfEvaLabelLabel of primary particle, ancestor of label.; Int_tfLabelLabel of particle that produced the hit.; UShort_tfSubdetIdCustom sub-detector id.; TEveVectorfVHit position. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveMCTrack& operator=(const TEveHit& ); { *((TParticle*)this) = p; return *this; }. TEveHit(); Float_t charge; probably specific. {}. virtual ~TEveHit(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveHit.html:5092,detect,detector,5092,root/html534/TEveHit.html,https://root.cern,https://root.cern/root/html534/TEveHit.html,4,['detect'],['detector']
Safety,"ptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__KDEKernel.html:2489,sanity check,sanity check,2489,root/html604/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html604/TMVA__KDEKernel.html,2,['sanity check'],['sanity check']
Safety,"ptiveKDE; static TMVA::KDEKernel::EKernelTypekNone; static TMVA::KDEKernel::EKernelBorderkSampleMirror. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__KDEKernel.html:2481,sanity check,sanity check,2481,root/html602/TMVA__KDEKernel.html,https://root.cern,https://root.cern/root/html602/TMVA__KDEKernel.html,2,['sanity check'],['sanity check']
Safety,"ptr = 0); virtual voidTSystem::DoBeep(Int_t = -1, Int_t = -1) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const char*TSystem::ExpandFileName(const char* fname); virtual const char*FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); TSystem*TSystem::FindHelper(const char* path, void* dirptr = 0); TString&TSystem::GetLastErrorString(); const TString&TSystem::GetLastErrorString() const; virtual const char*GetLinkedLibraries(); voidTObject::MakeZombie(); static const char*TSystem::StripOffProto(const char* path, const char* proto); static intUnixFilestat(const char* path, FileStat_t& buf); static intUnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); static const char*UnixGetdirentry(void* dir); static const char*UnixHomedirectory(const char* user = 0); static voidUnixIgnoreSignal(ESignals sig, Bool_t ignore); static intUnixMakedir(const char* name); static Long64_tUnixNow(); static void*UnixOpendir(const char* name); static intUnixRecv(int sock, void* buf, int len, int flag); static voidUnixResetSignal(ESignals sig); static voidUnixResetSignals(); static intUnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); static intUnixSend(int sock, const void* buf, int len, int flag); static intUnixSetitimer(Long_t ms); static voidUnixSigAlarmInterruptsSyscalls(Bool_t set); static voidUnixSignal(ESignals sig, SigHandler_t h); static const char*UnixSigname(ESignals sig); static intUnixTcpConnect(const char* hostname, int port, int tcpwindowsize); static intUnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); static intUnixUdpConnect(const char* hostname, int port); static intUnixUdpService(int port, int backlog); static intUnixUnixConnect(int port); static intUnixUnixConnect(const char* path); static intUnixUnixService(int port, int backlog); static intUnixUnixService(const char* sockpath, int backlog); static intUnixWaitchild().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:15709,timeout,timeout,15709,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,4,['timeout'],['timeout']
Safety,"ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSelect(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* service); voidSetServType(Int_t st); virtual voidTNamed::SetTitle(const char* title = """")MENU ; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:5641,timeout,timeout,5641,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['timeout'],['timeout']
Safety,"ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerUnit(TList* slaves, Long64_t num, TList* input, TProofProgressStatus* st = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerUnit.html:5930,abort,abort,5930,root/html602/TPacketizerUnit.html,https://root.cern,https://root.cern/root/html602/TPacketizerUnit.html,4,['abort'],['abort']
Safety,"pute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221, ; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1. » Last changed: root/hist:$Id: TFractionFitter.h 38775 2011-04-08 08:27:27Z moneta $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:19659,predict,prediction,19659,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,1,['predict'],['prediction']
Safety,"pute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221, ; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1. » Last changed: root/hist:$Id: TFractionFitter.h 38775 2011-04-08 08:27:27Z moneta $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFractionFitter.html:19659,predict,prediction,19659,root/html532/TFractionFitter.html,https://root.cern,https://root.cern/root/html532/TFractionFitter.html,2,['predict'],['prediction']
Safety,"q += x*x; }, {""x""});; 1287std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1288~~~; 1289In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1290thread will execute the expression concurrently.; 1291The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1292this is probably too much head-scratch for such a simple operation.; 1293 ; 1294ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1295additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1296guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1297executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1298We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1299~~~{.cpp}; 1300// Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; 1301ROOT::EnableImplicitMT();; 1302const unsigned int nSlots = df.GetNSlots();; 1303std::vector<double> sumSqs(nSlots, 0.);; 1304std::vector<unsigned int> ns(nSlots, 0);; 1305 ; 1306df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; 1307double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; 1308unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; 1309std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1310~~~; 1311Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`.; 1312 ; 1313 ; 1314\anchor friends; 1315### Dataset joins with friend trees; 1316 ; 1317Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same col",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:75545,safe,safe,75545,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"q += x*x; }, {""x""});; 1327std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1328~~~; 1329In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1330thread will execute the expression concurrently.; 1331The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1332this is probably too much head-scratch for such a simple operation.; 1333 ; 1334ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1335additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1336guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1337executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1338We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1339~~~{.cpp}; 1340// Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; 1341ROOT::EnableImplicitMT();; 1342const unsigned int nSlots = df.GetNSlots();; 1343std::vector<double> sumSqs(nSlots, 0.);; 1344std::vector<unsigned int> ns(nSlots, 0);; 1345 ; 1346df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; 1347double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; 1348unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; 1349std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1350~~~; 1351Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`.; 1352 ; 1353 ; 1354\anchor friends; 1355### Dataset joins with friend trees; 1356 ; 1357Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same col",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:77225,safe,safe,77225,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safe']
Safety,"q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. void SetExitStatus(TVirtualProofPlayer::EExitStatus ). Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). void SetMerging(Bool_t on = kTRUE). Long64_t GetCacheSize(). Int_t GetLearnEntries(). void UpdateProgressInfo(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. void SetOutputFilePath(const char* fp). Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE). TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0). » Author: Fons Rademakers 15/03/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualProofPlayer.html:14776,abort,abort,14776,root/html534/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html534/TVirtualProofPlayer.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"quals yval.; 4049/// (Calculation is performed with Brent root finding algorithm); 4050 ; 4051double RooAbsReal::findRoot(RooRealVar& x, double xmin, double xmax, double yval); 4052{; 4053 double result(0) ;; 4054 RooBrentRootFinder(RooRealBinding(*this,x)).findRoot(result,xmin,xmax,yval) ;; 4055 return result ;; 4056}; 4057 ; 4058 ; 4059 ; 4060////////////////////////////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176097,predict,predicted,176097,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['predict'],['predicted']
Safety,"quence information including 'cached','repeat','write' or 'nodelete'. ;  ; virtual Int_t GetSize () const;  Returns size of this element in bytes. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual void Init (TVirtualStreamerInfo *obj=nullptr);  Initliaze the element. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void Streamer (TBuffer &) override;  Stream an object of class TStrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerArtificial.html:3182,detect,detected,3182,doc/master/classTStreamerArtificial.html,https://root.cern,https://root.cern/doc/master/classTStreamerArtificial.html,2,['detect'],['detected']
Safety,"r &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step will enter new volume; 67 Bool_t fIsStepExiting; //! flag that n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:2265,safe,safety,2265,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety,"r * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Int_t GetInflateFactor() const; { return fInflateFactor; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. » Author: Fons Rademakers 16/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofServ.h 39696 2011-06-13 21:35:34Z pcanal $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofServ.html:33301,timeout,timeout,33301,root/html532/TProofServ.html,https://root.cern,https://root.cern/root/html532/TProofServ.html,2,['timeout'],['timeout']
Safety,"r * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { return fGroupId; }. Int_t GetGroupSize() const; { return fGroupSize; }. Int_t GetLogLevel() const; { return fLogLevel; }. TSocket * GetSocket() const; { return fSocket; }. Float_t GetRealTime() const; { return fRealTime; }. Float_t GetCpuTime() const; { return fCpuTime; }. Int_t GetQuerySeqNum() const; { return fQuerySeqNum; }. Int_t GetTotSessions() const; { return fTotSessions; }. Int_t GetActSessions() const; { return fActSessions; }. Float_t GetEffSessions() const; { return fEffSessions; }. TList * GetEnabledPackages() const; { return fEnabledPackages; }. Int_t GetInflateFactor() const; { return fInflateFactor; }. Long64_t GetMsgSizeHWM() const; { return fMsgSizeHWM; }. const char * GetPrefix() const; { return fPrefix; }. TProofLockPath * GetCacheLock(); { return fCacheLock; }. EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE). void HandleTermination(); { Terminate(0); }. void Interrupt(); { fInterrupt = kTRUE; }. Bool_t IsEndMaster() const; { return fEndMaster; }. Bool_t IsMaster() const; { return fMasterServ; }. Bool_t IsTopMaster() const; { return fOrdinal == ""0""; }. void ReleaseWorker(const char* ); { }. void DisableTimeout(); Disable / Enable read timeout. { }. void EnableTimeout(); { }. void LogToMaster(Bool_t on = kTRUE); Log control. { fSendLogToMaster = on; }. » Author: Fons Rademakers 16/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofServ.h 39697 2011-06-13 21:43:43Z pcanal $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:33301,timeout,timeout,33301,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,1,['timeout'],['timeout']
Safety,"r *buf, size_t size, struct mg_file *filep);  ; static int mg_fopen (const struct mg_connection *conn, const char *path, int mode, struct mg_file *filep);  ; static __inline void mg_free (void *a);  ; const char * mg_get_builtin_mime_type (const char *path);  ; struct mg_context * mg_get_context (const struct mg_connection *conn);  ; int mg_get_context_info (const struct mg_context *ctx, char *buffer, int buflen);  ; int mg_get_cookie (const char *cookie_header, const char *var_name, char *dst, size_t dst_size);  ; static uint64_t mg_get_current_time_ns (void);  ; const char * mg_get_header (const struct mg_connection *conn, const char *name);  ; const char * mg_get_option (const struct mg_context *ctx, const char *name);  ; const struct mg_request_info * mg_get_request_info (const struct mg_connection *conn);  ; int mg_get_request_link (const struct mg_connection *conn, char *buf, size_t buflen);  ; int mg_get_response (struct mg_connection *conn, char *ebuf, size_t ebuf_len, int timeout);  ; const char * mg_get_response_code_text (const struct mg_connection *conn, int response_code);  ; const struct mg_response_info * mg_get_response_info (const struct mg_connection *conn);  ; int mg_get_server_ports (const struct mg_context *ctx, int size, struct mg_server_port *ports);  ; int mg_get_system_info (char *buffer, int buflen);  ; void * mg_get_thread_pointer (const struct mg_connection *conn);  ; void * mg_get_user_connection_data (const struct mg_connection *conn);  ; void * mg_get_user_context_data (const struct mg_connection *conn);  ; void * mg_get_user_data (const struct mg_context *ctx);  ; const struct mg_option * mg_get_valid_options (void);  ; int mg_get_var (const char *data, size_t data_len, const char *name, char *dst, size_t dst_len);  ; int mg_get_var2 (const char *data, size_t data_len, const char *name, char *dst, size_t dst_len, size_t occurrence);  ; static void mg_global_lock (void);  ; static void mg_global_unlock (void);  ; static int mg_inet_pto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c.html:18642,timeout,timeout,18642,doc/master/civetweb_8c.html,https://root.cern,https://root.cern/doc/master/civetweb_8c.html,1,['timeout'],['timeout']
Safety,"r *name,const char *shape,Int_t nmed);; TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a volume in GEANT3 style.Definition TGeoManager.cxx:1388. name: the name of the newly created volume;; shape:the type of the associated shape. This has to contain the case-insensitive first 4 letters of the corresponding class name (e.g. ""`tubs`"" will match **TGeoTubeSeg**, ""`bbox`"" will match **TGeoBBox**); nmed: the medium number. This will create a special volume that will not be directly used in the geometry, but whenever positioned will require a list of actual parameters for the current shape that will be created in this process. Such volumes having shape parameters known only when used have to be positioned only with **TGeoManager::Node() method (see ‘Creating and Positioning Volumes').**; Other case when shape parameterizations are quite useful is scaling geometry structures. Imagine that we would like to enlarge/shrink a detector structure on one or more axes. This happens quite often in real life and is handled by ""fitting mother"" parameters. This is accomplished by defining shapes with one or more invalid (negative) parameters. For instance, defining a box having dx=10., dy=10., and dz=-1 will not generate an error but will be interpreted in a different way: A special volume **TGeoVolumeMulti** will be created. Whenever positioned inside a mother volume, this will create a normal **TGeoVolume** object having as shape a box with dz fitting the corresponding dzof the mother shape. Generally, this type of parameterization is used when positioning volumes in containers having a matching shape, but it works also for most reasonable combinations. . Modules;  Tubes;  ;  Cones;  ;  Trapezoids;  . Classes; class  TGeoCompositeShape;  Composite shapes are Boolean combinations of two or more shape components. More...;  ; class  TGeoHalfSpace;  A half space is limited just by a plane, defined by a point and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:11831,detect,detector,11831,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['detect'],['detector']
Safety,"r * ; name). static . Static method to find a thread by name. ; Definition at line 479 of file TThread.cxx. ◆ GetThread() [2/2]. TThread * TThread::GetThread ; (; Long_t ; id). static . Static method to find a thread by id. ; Definition at line 463 of file TThread.cxx. ◆ GetTime(). Int_t TThread::GetTime ; (; ULong_t * ; absSec, . ULong_t * ; absNanoSec . ). static . Static method to get the current time. ; Returns the number of seconds. ; Definition at line 761 of file TThread.cxx. ◆ GetTls(). void ** TThread::GetTls ; (; Int_t ; k). staticprivate . Static method that initializes the TLS array of a thread and returns the reference to a given position in that array. ; Definition at line 907 of file TThread.cxx. ◆ Init(). void TThread::Init ; (; ). staticprivate . Initialize global state and variables once. ; Definition at line 319 of file TThread.cxx. ◆ Initialize(). void TThread::Initialize ; (; ). static . Initialize the Thread package. ; This initializes the TThread and ROOT global mutexes to make parts of ROOT thread safe/aware. This call is implicit in case a TThread is created. ; Definition at line 300 of file TThread.cxx. ◆ IsA(). TClass * TThread::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 180 of file TThread.h. ◆ IsInitialized(). Bool_t TThread::IsInitialized ; (; ). static . Return true, if the TThread objects have been initialize. ; If false, the process is (from ROOT's point of view) single threaded. ; Definition at line 309 of file TThread.cxx. ◆ Join() [1/2]. Long_t TThread::Join ; (; Long_t ; id, . void ** ; ret = nullptr . ). static . Static method to join a thread by id. ; Definition at line 534 of file TThread.cxx. ◆ Join() [2/2]. Long_t TThread::Join ; (; void ** ; ret = nullptr). Join this thread. ; Definition at line 510 of file TThread.cxx. ◆ Kill() [1/3]. Int_t TThread::Kill ; (; ). Kill this thread. ; Returns 0 on success, otherwise an error number will b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTThread.html:25273,safe,safe,25273,doc/master/classTThread.html,https://root.cern,https://root.cern/doc/master/classTThread.html,1,['safe'],['safe']
Safety,"r * ; selection). virtual . Return the number of entries matching the selection. ; Return -1 in case of errors.; If the selection uses any arrays or containers, we return the number of entries where at least one element match the selection. GetEntries is implemented using the selector class TSelectorEntries, which can be used directly (see code in TTreePlayer::GetEntries) for additional option. If SetEventList was used on the TTree or TChain, only that subset of entries will be considered. ; Reimplemented in TProofChain, TChain, and TTreeSQL.; Definition at line 5499 of file TTree.cxx. ◆ GetEntriesFast(). virtual Long64_t TTree::GetEntriesFast ; (; ); const. inlinevirtual . Return a number greater or equal to the total number of entries in the dataset. ; NoteIf you are interested in the total number of entries in a TChain, this function will give that number once the last file of the chain is opened. In general, using this instead of GetEntries will avoid opening all files in the chain which could be very costly for very large number of files stored at a remote location.; The logic depends on whether the dataset is a TTree or a TChain. In the first case, it simply returns the total number of entries in the tree. In the latter case, it depends on which point of the processing of the chain this function is called. During most of the chain processing, this function will return TTree::kMaxEntries. When the chain arrives at the last file, then the function will return the accumulated total number of entries in the whole chain. A notable use case where this function becomes quite useful is when writing the following for loop to traverse the entries in the dataset:; for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; // Do something with the event in the dataset; }; In the example above, independently on whether the dataset is a TTree or a TChain, the GetEntriesFast call will provide the correct stopping condition for the loop (i.e. the total number of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:149631,avoid,avoid,149631,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['avoid'],['avoid']
Safety,"r * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec timeout. ;  ; virtual void Stop ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Timeout ();  ; virtual void TurnOff ();  Remove timer from system timer list. ;  ; virtual void TurnOn ();  Add the timer to the system timer list. ;  ;  Public Member Functions inherited from TSysEvtHandler;  TSysEvtHandler ();  ; virtual ~TSysEvtHandler ();  ; void Activate ();  Activate a system event handler. ;  ; virtual void Activated ();  ; virtual void Added ();  ; void DeActivate ();  De-activate a system event handler. ;  ; virtual void DeActivated ();  ; Bool_t IsActive () const;  ; virtual void Notified ();  ; virtual void Removed ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBlinkTimer.html:2069,timeout,timeout,2069,doc/master/classTBlinkTimer.html,https://root.cern,https://root.cern/doc/master/classTBlinkTimer.html,19,['timeout'],['timeout']
Safety,"r * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec timeout. ;  ; virtual void Stop ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Timeout ();  ; virtual void TurnOff ();  Remove timer from system timer list. ;  ;  Public Member Functions inherited from TSysEvtHandler;  TSysEvtHandler ();  ; virtual ~TSysEvtHandler ();  ; void Activate ();  Activate a system event handler. ;  ; virtual void Activated ();  ; virtual void Added ();  ; void DeActivate ();  De-activate a system event handler. ;  ; virtual void DeActivated ();  ; Bool_t IsActive () const;  ; virtual void Notified ();  ; virtual void Removed ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSingleShotCleaner.html:2213,timeout,timeout,2213,doc/master/classTSingleShotCleaner.html,https://root.cern,https://root.cern/doc/master/classTSingleShotCleaner.html,1,['timeout'],['timeout']
Safety,"r * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec timeout. ;  ; virtual void Stop ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void TurnOff ();  Remove timer from system timer list. ;  ; virtual void TurnOn ();  Add the timer to the system timer list. ;  ;  Public Member Functions inherited from TSysEvtHandler;  TSysEvtHandler ();  ; virtual ~TSysEvtHandler ();  ; void Activate ();  Activate a system event handler. ;  ; virtual void Activated ();  ; virtual void Added ();  ; void DeActivate ();  De-activate a system event handler. ;  ; virtual void DeActivated ();  ; Bool_t IsActive () const;  ; virtual void Notified ();  ; virtual void Removed ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html:2163,timeout,timeout,2163,doc/v632/classROOT_1_1RBrowserTimer.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowserTimer.html,9,['timeout'],['timeout']
Safety,"r * GetCommand () const;  ; TObject * GetObject ();  ; TTime GetTime () const;  ; UInt_t GetTimerID ();  ; Bool_t HasTimedOut () const;  ; TClass * IsA () const override;  ; Bool_t IsAsync () const;  ; Bool_t IsInterruptingSyscalls () const;  ; Bool_t IsRunning ();  This function checks if the timer is running within gSystem (Has been started and did not finish yet). ;  ; Bool_t IsSync () const;  ; Bool_t Notify () override;  Notify when timer times out. ;  ; void Remove () override;  ; void Reset ();  Reset the timer. ;  ; void SetCommand (const char *command);  Set the interpreter command to be executed at time out. ;  ; void SetInterruptSyscalls (Bool_t set=kTRUE);  When the argument is true the a-synchronous timer (SIGALRM) signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void SetObject (TObject *object);  Set the object to be notified at time out. ;  ; void SetTime (Long_t milliSec);  ; void SetTimerID (UInt_t id=0);  ; virtual void Start (Long_t milliSec=-1, Bool_t singleShot=kFALSE);  Starts the timer with a milliSec timeout. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Timeout ();  ; virtual void TurnOff ();  Remove timer from system timer list. ;  ; virtual void TurnOn ();  Add the timer to the system timer list. ;  ;  Public Member Functions inherited from TSysEvtHandler;  TSysEvtHandler ();  ; virtual ~TSysEvtHandler ();  ; void Activate ();  Activate a system event handler. ;  ; virtual void Activated ();  ; virtual void Added ();  ; void DeActivate ();  De-activate a system event handler. ;  ; virtual void DeActivated ();  ; Bool_t IsActive () const;  ; virtual void Notified ();  ; virtual void Removed ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLRedrawTimer.html:2260,timeout,timeout,2260,doc/master/classTGLRedrawTimer.html,https://root.cern,https://root.cern/doc/master/classTGLRedrawTimer.html,1,['timeout'],['timeout']
Safety,"r = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:84140,safe,safe,84140,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['safe'],['safe']
Safety,"r Functions |; Protected Member Functions |; Static Protected Member Functions |; List of all members ; TUnfoldBinningXML Class Reference. ; XML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity. ; Binning schemes are used to map analysis bins on a single histogram axis and back. The analysis bins may include unconnected bins (e.g nuisances for background normalisation) or various multidimensional histograms (signal bins, differential background normalisation bins, etc). ; If you use this software, please consider the following citation ; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201] ; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Please consult the documentation of the class TUnfoldBinning about how to use binning schemes. This class provides methods to read and write binning schemes in the XML language. There is also a method which writes out a dtd file for validation. Example XML code; The example below encodes two binning schemes, detector and generator. The detecor scheme consists of a single, three-dimensional distribution (pt,eta,discriminator). The generator scheme consists of two two-dimensional distributions, signal and background. ; <?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>; <!DOCTYPE TUnfoldBinning SYSTEM ""tunfoldbinning.dtd"">; <TUnfoldBinning>; <BinningNode name=""detector"" firstbin=""1"" factor=""1"">; <BinningNode name=""detectordistribution"" firstbin=""1"" factor=""1"">; ; <Bin repeat=""3"" width=""0.5"" >; <Bin repeat=""3"" width=""1"" >; <Bin width=""2"" >; <Bin width=""3"" >; <Bin location=""overflow"">; ; <Bin repeat=""2"" width=""0.5"" >; <Bin width=""1"" >; <Bin repeat=""4"" width=""0.5"" >; <Bin width=""1"" >; <Bin repeat=""2"" width=""0.5"" >; ; <Bin width=""0.15"" >; <Bin repeat=""2"" width=""0.35"" >; <Bin width=""0.15"" >; </Axis>; </Axis>; </Axis>; </BinningNode>; </BinningNode>; <BinningNode name=""generator"" firstbin=""1"" factor=""1"">; <BinningNode name=""signal"" firstbin=""1"" factor=""1"">; ; <Bin location",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinningXML.html:1215,detect,detector,1215,doc/master/classTUnfoldBinningXML.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinningXML.html,1,['detect'],['detector']
Safety,"r GPU. ;  ; size_t fBatchDepth;  The depth of the batch used to train the deep net. ;  ; size_t fBatchHeight;  The height of the batch used to train the deep net. ;  ; TString fBatchLayoutString;  The string defining the layout of the batch. ;  ; size_t fBatchWidth;  The width of the batch used to train the deep net. ;  ; bool fBuildNet;  Flag to control whether to build fNet, the stored network used for the evaluation. ;  ; TString fErrorStrategy;  The string defining the error strategy for training. ;  ; TString fInputLayoutString;  The string defining the layout of the input. ;  ; std::vector< size_t > fInputShape;  Contains the batch size (no. ;  ; TString fLayoutString;  The string defining the layout of the deep net. ;  ; DNN::ELossFunction fLossFunction;  The loss function. ;  ; std::unique_ptr< DeepNetImpl_t > fNet;  ; TString fNumValidationString;  The string defining the number (or percentage) of training data used for validation. ;  ; DNN::EOutputFunction fOutputFunction;  The output function for making the predictions. ;  ; size_t fRandomSeed;  The random seed used to initialize the weights and shuffling batches (default is zero) ;  ; bool fResume;  ; KeyValueVector_t fSettings;  Map for the training strategy. ;  ; std::vector< TTrainingSettings > fTrainingSettings;  The vector defining each training strategy. ;  ; TString fTrainingStrategyString;  The string defining the training strategy. ;  ; DNN::EInitialization fWeightInitialization;  The initialization method. ;  ; TString fWeightInitializationString;  The string defining the weight initialization method. ;  ; TensorImpl_t fXInput;  ; HostBufferImpl_t fXInputBuffer;  ; std::unique_ptr< MatrixImpl_t > fYHat;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:32390,predict,predictions,32390,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['predict'],['predictions']
Safety,"r Python. ; In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available on their machines completely transparently.; Skip to the class reference or keep reading for the user guide.; In a nutshell: ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; Calculations are expressed in terms of a type-safe functional chain of actions and transformations, RDataFrame takes care of their execution. The implementation automatically puts in place several low level optimisations such as multi-thread parallelization and caching. For the impatient user; You can directly see RDataFrame in action in our tutorials, in C++ or Python. Table of Contents. Cheat sheet; Introduction; Crash course; Working with collections; Transformations: manipulating data; Actions: getting results; Distributed execution in Python; Performance tips and parallel execution; More features; Systematic variations; RDataFrame objects as function arguments and return values; Storing RDataFrame objects in collections; Executing callbacks every N events; Default column lists; Special helper columns: `rdfentry_` and `rdfslot_`; Just-in-time compilation: column type inference and explicit declaration of column types; User-defined custom actions; Dataset joins with friend trees; Reading data formats other than ROOT trees; Computation graphs (stor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:1366,safe,safe,1366,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['safe'],['safe']
Safety,"r SIGURG and SIGIO); 228 kAtMark, // are we at out-of-band mark (read only); 229 kBytesToRead // get number of bytes to read, FIONREAD (read only); 230};; 231 ; 232enum ESendRecvOptions {; 233 kDefault, // default option (= 0); 234 kOob, // send or receive out-of-band data; 235 kPeek, // peek at incoming message (receive only); 236 kDontBlock // send/recv as much data as possible without blocking; 237};; 238 ; 239typedef void (*Func_t)();; 240 ; 241R__EXTERN const char *gRootDir;; 242R__EXTERN const char *gProgName;; 243R__EXTERN const char *gProgPath;; 244R__EXTERN TVirtualMutex *gSystemMutex;; 245 ; 246 ; 247//////////////////////////////////////////////////////////////////////////; 248// //; 249// Asynchronous timer used for processing pending GUI and timer events //; 250// every delay ms. Call in a tight computing loop //; 251// TProcessEventTimer::ProcessEvent(). If the timer did timeout this //; 252// call will process the pending events and return kTRUE if the //; 253// TROOT::IsInterrupted() flag is set (can be done by hitting key in //; 254// canvas or selecting canvas menu item View/Interrupt. //; 255// //; 256//////////////////////////////////////////////////////////////////////////; 257class TProcessEventTimer : public TTimer {; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:9336,timeout,timeout,9336,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['timeout'],['timeout']
Safety,"r a constrained, coherent shape variation of affected samples ;  CHistoToWorkspaceFactory;  CHistoToWorkspaceFactoryFast;  CHistRefInternal class wrapping an histogram and managing its content ;  CLinInterpVarRooAbsReal that does piecewise-linear interpolations ;  CMeasurementThe RooStats::HistFactory::Measurement class can be used to construct a model by combining multiple RooStats::HistFactory::Channel objects ;  CNormFactorConfiguration for an un- constrained overall systematic to scale sample normalisations ;  COverallSysConfiguration for a constrained overall systematic to scale sample normalisations ;  CPreprocessFunction;  ►CRooBarlowBeestonLLClass RooBarlowBeestonLL implements the profile likelihood estimator for a given likelihood and set of parameters of interest ;  CBarlowCache;  CSample;  CShapeFactorUnconstrained bin-by-bin variation of affected histogram ;  CShapeSysConstrained bin-by-bin variation of affected histogram ;  CStatErrorStatistical error of Monte Carlo predictions ;  CStatErrorConfigConfiguration to automatically assign nuisance parameters for the statistical error of the Monte Carlo simulations ;  CAcceptanceRegion;  CAsymptoticCalculatorHypothesis Test Calculator based on the asymptotic formulae for the profile likelihood ratio ;  CBayesianCalculatorBayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation of a credible interval using a Bayesian method ;  CBernsteinCorrectionBernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial correction term ;  CCombinedCalculatorCombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals ;  CConfidenceBeltConfidenceBelt is a concrete implementation of the ConfInterval interface ;  CConfIntervalConfInterval is an interface class for a generic interval in the RooStats framework ;  CDebuggingSampler;  CDebuggingTestStat;  CDetailedOutputAggregatorThis class is designed to ai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:6438,predict,predictions,6438,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['predict'],['predictions']
Safety,"r a constrained, coherent shape variation of affected samples ;  CHistoToWorkspaceFactory;  CHistoToWorkspaceFactoryFast;  CHistRefInternal class wrapping an histogram and managing its content ;  CLinInterpVarRooAbsReal that does piecewise-linear interpolations ;  CMeasurementThe RooStats::HistFactory::Measurement class can be used to construct a model by combining multiple RooStats::HistFactory::Channel objects ;  CNormFactorConfiguration for an un- constrained overall systematic to scale sample normalisations ;  COverallSysConfiguration for a constrained overall systematic to scale sample normalisations ;  CPreprocessFunction;  ►CRooBarlowBeestonLLClass RooBarlowBeestonLL implements the profile likelihood estimator for a given likelihood and set of parameters of interest ;  CBarlowCache;  CSample;  CShapeFactorUnconstrained bin-by-bin variation of affected histogram ;  CShapeSysConstrained bin-by-bin variation of affected histogram ;  CStatErrorStatistical error of Monte Carlo predictions ;  CStatErrorConfigConfiguration to automatically assign nuisance parameters for the statistical error of the Monte Carlo simulations ;  NNumberCountingUtils;  CAcceptanceRegion;  CAsymptoticCalculatorHypothesis Test Calculator based on the asymptotic formulae for the profile likelihood ratio ;  CBayesianCalculatorBayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation of a credible interval using a Bayesian method ;  CBernsteinCorrectionBernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial correction term ;  CCombinedCalculatorCombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals ;  CConfidenceBeltConfidenceBelt is a concrete implementation of the ConfInterval interface ;  CConfIntervalConfInterval is an interface class for a generic interval in the RooStats framework ;  CDebuggingSampler;  CDebuggingTestStat;  CDetailedOutputAggregatorThis ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:9315,predict,predictions,9315,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['predict'],['predictions']
Safety,"r conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1028232,safe,safety,1028232,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['safe'],['safety']
Safety,"r delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoEltu&operator=(const TGeoEltu&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoEltu.html:9011,Safe,SafetyS,9011,root/html602/TGeoEltu.html,https://root.cern,https://root.cern/root/html602/TGeoEltu.html,2,['Safe'],['SafetyS']
Safety,"r delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPgon&operator=(const TGeoPgon&); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&TGeoPcon::Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&TGeoPcon::Rmax(Int_t ipl); Double_t&TGeoPcon::Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPgon.html:9101,Safe,SafetyPhi,9101,root/html602/TGeoPgon.html,https://root.cern,https://root.cern/root/html602/TGeoPgon.html,2,['Safe'],['SafetyPhi']
Safety,"r delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoArb8::SetPlaneVertices(Double_t zpl, Double_t* vertices) const; virtual voidTGeoArb8::SetPoints(Double_t* points) const; virtual voidTGeoArb8::SetPoints(Float_t* points) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtra.html:10709,Safe,SafetyToFace,10709,root/html534/TGeoGtra.html,https://root.cern,https://root.cern/root/html534/TGeoGtra.html,2,['Safe'],['SafetyToFace']
Safety,r interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summur,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:123704,safe,safe,123704,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,2,"['detect', 'safe']","['detector', 'safe']"
Safety,"r log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denomi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13003,recover,recover,13003,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"r object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ColumnsRooCmdArg Columns(Int_t ncol)Definition RooGlobalFunc.cxx:513; RooFit::SiblingRooCmdArg Sibling(const RooAbsCollection &sibling)Definition RooGlobalFunc.cxx:521; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf407_latextablesDefinition rf407_latextables.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; \begin{tabular}{lc}; $\verb+a0+ $ & $ 0.6\pm 0.2$\\; $\verb+a1+ $ & $ 0.2\pm 0.2$\\; $\verb+alpha+ $ & $ -1.00$\\; $\verb+bkgfrac+ $ & $ 0.45\pm 0.03$\\; $\verb+mean+ $ & $ 5$\\; $\verb+sig1frac+ $ & $ 0.71\pm 0.06",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf407__latextables_8C.html:4935,safe,safe,4935,doc/master/rf407__latextables_8C.html,https://root.cern,https://root.cern/doc/master/rf407__latextables_8C.html,1,['safe'],['safe']
Safety,"r of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; 4582/// This makes future reading faster as it guarantees that baskets belonging to nearby; 4583/// entries will be on the same disk region.; 4584/// When the first call to flush the baskets happen, we also take this opportunity; 4585/// to optimize the baskets buffers.; 4586/// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; 4587/// In this case we also write the Tree header. This makes the Tree recoverable up to this point; 4588/// in case the program writing the Tree crashes.; 4589/// The decisions to FlushBaskets and Auto Save can be made based either on the number; 4590/// of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; 4591/// written (fAutoFlush and fAutoSave positive).; 4592/// Note that the user can decide to call FlushBaskets and AutoSave in her event loop; 4593/// base on the number of events written instead of the number of bytes written.; 4594///; 4595/// \note Calling `TTree::FlushBaskets` too often increases the IO time.; 4596///; 4597/// \note Calling `TTree::AutoSave` too often increases the IO time and also the; 4598/// file size.; 4599///; 4600/// \note This method calls `TTree::ChangeFile` when the tree reaches a size; 4601/// greater than `TTree::fgMaxTreeSize`. This doesn't happen if the tree is; 4602/// attached to a `TMemFile` or derivate.; 4603 ; 4604Int_t TTree::Fill(); 4605{; 4606 Int_t nbytes = 0;; 4607 Int_t nwrite = 0;; 4608 Int_t nerror = 0;; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:186206,recover,recoverable,186206,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['recover'],['recoverable']
Safety,"r of events associated with the extentable input p.d.f; in the product. If there is no extendable term, return zero and issue and error. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return generator context optimized for generating events from product p.d.f.s. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Query internal generation capabilities of component p.d.f.s and aggregate capabilities; into master configuration passed to the generator context. void initGenerator(Int_t code); Forward one-time initialization call to component generation initialization; methods. void generateEvent(Int_t code); Generate a single event with configuration specified by 'code'; Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected) const; Return all parameter constraint p.d.f.s on parameters listed in constrainedParams; The observables set is required to distinguish unambiguously p.d.f in terms; of observables and parameters, which are not constraints, and p.d.fs in terms; of parameters only, which can serve as constraints p.d.f.s. RooArgSet* getConnectedParameters(const RooArgSet& observables) const; Return all parameter constraint p.d.f.s on parameters listed in constrainedParams; The observables set is required to distinguish unambiguously p.d.f in terms; of observables and parameters, which are not constraints, and p.d.fs in terms; of parameters only, which can serve as const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:55752,safe,safety,55752,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,8,['safe'],['safety']
Safety,"r of events associated with the extentable input p.d.f; in the product. If there is no extendable term, return zero and issue and error. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return generator context optimized for generating events from product p.d.f.s. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Query internal generation capabilities of component p.d.f.s and aggregate capabilities; into master configuration passed to the generator context. void initGenerator(Int_t code); Forward one-time initialization call to component generation initialization; methods. void generateEvent(Int_t code); Generate a single event with configuration specified by 'code'; Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected) const; Return all parameter constraint p.d.f.s on parameters listed in constrainedParams; The observables set is required to distinguish unambiguously p.d.f in terms; of observables and parameters, which are not constraints, and p.d.fs in terms; of parameters only, which can serve as constraints p.d.f.s. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t stripDisconnected) const. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:54089,safe,safety,54089,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,2,['safe'],['safety']
Safety,"r of events associated with the extentable input p.d.f; in the product. If there is no extendable term, return zero and issue and error. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return generator context optimized for generating events from product p.d.f.s. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Query internal generation capabilities of component p.d.f.s and aggregate capabilities; into master configuration passed to the generator context. void initGenerator(Int_t code); Forward one-time initialization call to component generation initialization; methods. void generateEvent(Int_t code); Generate a single event with configuration specified by 'code'; Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConstraints(const RooArgSet& observables, const RooArgSet& constrainedParams, Bool_t stripDisconnected) const; Return all parameter constraint p.d.f.s on parameters listed in constrainedParams; The observables set is required to distinguish unambiguously p.d.f in terms; of observables and parameters, which are not constraints, and p.d.fs in terms; of parameters only, which can serve as constraints p.d.f.s. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t stripDisconnected) const. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:52034,safe,safety,52034,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['safe'],['safety']
Safety,"r of nodes). void FillTree(TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(TMVA::DecisionTree::EventList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event& ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:10745,avoid,avoid,10745,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,4,['avoid'],['avoid']
Safety,"r parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t InsidePolygon(Double_t x, Double_t y, Double_t* pts); Finds if a point in XY plane is inside the polygon defines by PTS. void InspectShape() const; Prints shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. Double_t SafetyToFace(Double_t* point, Int_t iseg, Bool_t in) const; Estimate safety to lateral plane defined by segment iseg in range [0,3]; Might be negative: plane seen only from inside. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPlaneVertices(Double_t zpl, Double_t* vertices) const; Computes intersection points between plane at zpl and non-horizontal edges. void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = x0; param[2] = y0. void SetPoints(Double_t* points) const; Creates arb8 mesh points. void SetPoints(Float_t* points) const; Creates arb8 mesh points. void SetVertex(Int_t vnum, Double_t x, Double_t y); Set values for a given vertex. void Sizeof3D() const; Fill size of this 3-D object. void Streamer(TBuffer& b); Stream an object of class TGeoManager. Int_t GetByteCount() const; {return 100;}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoArb8.html:16186,Safe,Safety,16186,root/html532/TGeoArb8.html,https://root.cern,https://root.cern/root/html532/TGeoArb8.html,1,['Safe'],['Safety']
Safety,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:35392,recover,recovered,35392,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,10,['recover'],['recovered']
Safety,"r tau-paths ;  ; std::vector< Double_t > fGDTauVec;  the tau's ;  ; std::vector< Double_t > fGradVec;  gradient vector - dimension = number of rules in ensemble ;  ; std::vector< Double_t > fGradVecLin;  gradient vector - dimension = number of variables ;  ; std::vector< std::vector< Double_t > > fGradVecLinTst;  gradient vector, linear terms - one per tau ;  ; std::vector< std::vector< Double_t > > fGradVecTst;  gradient vector - one per tau ;  ; Double_t fNEveEffPath;  sum of weights for Path events ;  ; Double_t fNEveEffPerf;  idem for Perf events ;  ; UInt_t fNLinear;  number of linear terms ;  ; UInt_t fNRules;  number of rules ;  ; Double_t * fNTCoeff;  GD path: rule coefficients. ;  ; Double_t fNTCoefRad;  GD path: 'radius' of all rulecoeffs. ;  ; Double_t fNTErrorRate;  GD path: error rate (or performance) ;  ; Double_t * fNTLinCoeff;  GD path: linear coefficients. ;  ; Double_t fNTNuval;  GD path: value of nu. ;  ; Double_t fNTOffset;  GD path: model offset. ;  ; Double_t fNTRisk;  GD path: risk. ;  ; UInt_t fPathIdx1;  first event index for path search ;  ; UInt_t fPathIdx2;  last event index for path search ;  ; UInt_t fPerfIdx1;  first event index for performance evaluation ;  ; UInt_t fPerfIdx2;  last event index for performance evaluation ;  ; RuleEnsemble * fRuleEnsemble;  rule ensemble ;  ; RuleFit * fRuleFit;  rule fit ;  ; Double_t fsigave;  Sigma of current signal score function F(sig) ;  ; Double_t fsigrms;  Rms of F(sig) ;  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; MsgLogger * fLogger;  ! message logger ;  . #include <TMVA/RuleFitParams.h>; Member Typedef Documentation. ◆ EventItr. typedef std::vector<constTMVA::Event*>::const_iterator TMVA::RuleFitParams::EventItr. protected . Definition at line 130 of file RuleFitParams.h. Constructor & Destructor Documentation. ◆ RuleFitParams(). TMVA::RuleFitParams::RuleFitParams ; (; ). constructor ; Definition at line 64 of file RuleFitParams.cxx. ◆ ~RuleFitParams(). TMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:7486,risk,risk,7486,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['risk'],['risk']
Safety,"r the proper line wrapping (this is the one implemented in this change).; TLatex; Make sure the line width used to draw #sqrt is always >= 1.; When a global text alignment was set the TLatexcharacters #minus, #plus, #mp, #hbar, and #backslash were mis-aligned. The following macro demonstrate the problem:; {; gStyle->SetTextAlign(22);; TLatex t(.5,.5,""#minus100 #mp100 #plus100 #hbar #backslash"");; t.Draw();; }; The angle of a TLatex object was set to 0 if the GetYsize method was called.; TColor; New palette kViridis. It was presented at SciPy2015 by Stéfan van der Walt and Nathaniel Smith. It is now matplotlib’s current default color map. Viridis. TMultiGraph; Ignore empty graphs when computing the multi-graph range at painting time.; TASImage; A left click on a image produced a one pixel zoom.; TCreatePrimitives; The ending of a polyline creation is based on the closeness of the two last entered points. The previous algorithm was based on user coordinates. It is now based on pixel to avoid the problem reported here.; TCanvas; When the first canvas created by ROOT was in batch mode, it was note possible to come back in interactive mode for the next canvases. this problem was reported here.; Cocoa Backend; Sometimes the mouse cursor did not change back to the window manager arrow when exiting a TCanvas.; freetype library; Updates builtin_freetype to 2.6.1 (current upstream version), which can detect PPC64LE machine. This was compiled and tested on SLC6 + ICC + x86_64, F21 + GCC + ppc64le, MacOSX 10.11.1 + Xcode 7.1 and Windows (ROOT 5.34). $ROOTSYS/graf2d/freetype/src/README was removed, because no issues were noticed with ICC compiler and -Wall -pedantic -ansi flags. Additionally --with-png=no --with-bzip2=no flags are passed to freetype configuration script. Default values for these options are auto. freetype finds libpng and libbzip2 on the system and builds extra modules. Then attempting to link against freetype one would need to link -lpng -lbzip2 explicitly other",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:16813,avoid,avoid,16813,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['avoid'],['avoid']
Safety,"r to an existing shape; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true if the scaled shap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoScaledShape.html:12262,safe,safe,12262,root/html532/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html532/TGeoScaledShape.html,2,['safe'],['safe']
Safety,"r to an existing shape; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsReflected() const; Check if the scale transformat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoScaledShape.html:12037,safe,safe,12037,root/html528/TGeoScaledShape.html,https://root.cern,https://root.cern/root/html528/TGeoScaledShape.html,2,['safe'],['safe']
Safety,"r to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will delete; the sockets that are still being used by the monitor. TList * GetListOfDeActives() const; Returns a list with all de-active sockets. This list must be deleted; by the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:12632,timeout,timeout,12632,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,10,['timeout'],['timeout']
Safety,"r was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void ResetSignals(); Reset signals handlers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignr is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:21958,timeout,timeout,21958,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,2,['timeout'],['timeout']
Safety,"r words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; We will call overlaps only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1000016,detect,detected,1000016,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['detect'],['detected']
Safety,"r(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:4616,unsafe,unsafe,4616,root/html534/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html,2,['unsafe'],['unsafe']
Safety,"r) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf510_wsnamedsetsDefinition rf510_wsnamedsets.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8C.html:8879,safe,safe,8879,doc/master/rf510__wsnamedsets_8C.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html,1,['safe'],['safe']
Safety,"r* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTorus.html:8790,Safe,SafetyPhi,8790,root/html534/TGeoTorus.html,https://root.cern,https://root.cern/root/html534/TGeoTorus.html,1,['Safe'],['SafetyPhi']
Safety,"r* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidComputeTwist(); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoArb8.html:2686,safe,safe,2686,root/html532/TGeoArb8.html,https://root.cern,https://root.cern/root/html532/TGeoArb8.html,2,['safe'],['safe']
Safety,"r* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoEltu&operator=(const TGeoEltu&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoEltu.html:8422,Safe,SafetyS,8422,root/html532/TGeoEltu.html,https://root.cern,https://root.cern/root/html532/TGeoEltu.html,1,['Safe'],['SafetyS']
Safety,"r* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHalfSpace&operator=(const TGeoHalfSpace&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t*) const; virtual voidSetPoints(Float_t*) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHalfSpace.html:8343,Safe,SafetyPhi,8343,root/html602/TGeoHalfSpace.html,https://root.cern,https://root.cern/root/html602/TGeoHalfSpace.html,2,['Safe'],['SafetyPhi']
Safety,"r* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTube.html:2706,safe,safe,2706,root/html528/TGeoTube.html,https://root.cern,https://root.cern/root/html528/TGeoTube.html,4,['safe'],['safe']
Safety,"r* path, Option_t* opt = 0); Issue a stage request for file defined by 'path'. The string 'opt'; defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". void GetPrefix(const char* url, TString& pfx); Isolate prefix in url. void Print(Option_t* option = """") const; Print basic info about this stager. Int_t Locate(const char* path, TString& endpath); Get actual end-point url for a path; Returns 0 in case of success and 1 if any error occured. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. A noop prepare command is; issued beforehand to fill redirector's cache, then Locate() is issued on; each file. Results are saved back to the input collection: when a file is; found, the staged bit is set to on, and its endpoint URL is added, if; different from the redirector's URL. If a file is not found, the staged; bit is set to off.; If addDummyUrl is kTRUE, in case file is not staged or redirector is; identical to endpoint URL, a dummy URL is prepended, respectively:; ""noop://redir"" and ""noop://none"".; If the collection contains URLs with ""anchors"" (i.e., #fileName.root),; they are ignored by xrootd.; The Locate() command preserves anchors, but needs single paths to be full; URLs beginning with root://.; Returns < 0 in case of errors, and the number of files processed in case; of success. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager.; Avoids multiple instantiations of the potentially the same TXNetSystem. TXNetFileStager(const char* stager = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. » Author: A. Peters, G. Ganis 7/2/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFileStager.html:8818,Avoid,Avoids,8818,root/html602/TXNetFileStager.html,https://root.cern,https://root.cern/root/html602/TXNetFileStager.html,1,['Avoid'],['Avoids']
Safety,"r* path, Option_t* opt = 0); Issue a stage request for file defined by 'path'. The string 'opt'; defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". void GetPrefix(const char* url, TString& pfx); Isolate prefix in url. void Print(Option_t* option = """") const; Print basic info about this stager. Int_t Locate(const char* path, TString& endpath); Get actual end-point url for a path; Returns 0 in case of success and 1 if any error occured. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. A noop prepare command is; issued beforehand to fill redirector's cache, then Locate() is issued on; each file. Results are saved back to the input collection: when a file is; found, the staged bit is set to on, and its endpoint URL is added, if; different from the redirector's URL. If a file is not found, the staged; bit is set to off.; If addDummyUrl is kTRUE, in case file is not staged or redirector is; identical to endpoint URL, a dummy URL is prepended, respectively:; ""noop://redir"" and ""noop://none"".; If the collection contains URLs with ""anchors"" (i.e., #fileName.root),; they are ignored by xrootd.; The Locate() command preserves anchors, but needs single paths to be full; URLs beginning with root://.; Returns < 0 in case of errors, and the number of files processed in case; of success. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager.; Avoids multiple instantiations of the potentially the same TXNetSystem. TXNetFileStager(const char* stager = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. » Author: A. Peters, G. Ganis 7/2/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXNetFileStager.html:8771,Avoid,Avoids,8771,root/html604/TXNetFileStager.html,https://root.cern,https://root.cern/root/html604/TXNetFileStager.html,1,['Avoid'],['Avoids']
Safety,"r* rfile = 0, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TProof::ESlaves list = kAllUnique); Int_tBroadcastGroupPriority(const char* grp, Int_t priority, TList* workers); Int_tBroadcastObject(const TObject* obj, Int_t kind, TList* slaves); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT, TProof::ESlaves list = kActive); Int_tBroadcastRaw(const void* buffer, Int_t length, TList* slaves); Int_tBroadcastRaw(const void* buffer, Int_t length, TProof::ESlaves list = kActive); Int_tBuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT, TList* workers = 0); Int_tBuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Bool_tCheckFile(const char* file, TSlave* sl, Long_t modtime, Int_t cpopt = (kCp | kCpBin)); voidCleanGDirectory(TList* ol); voidClearDataProgress(Int_t r, Int_t t); Int_tCollect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; virtual voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:23219,timeout,timeout,23219,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,2,['timeout'],['timeout']
Safety,"r* sniffer = 0); virtual TClass*IsA() const; Bool_tIsReadOnly(Bool_t dflt = kTRUE); Bool_tIsReadyForResult() const; voidMakeItemName(const char* objname, TString& itemname); Bool_tScanOnlyFields() const; voidSetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); Bool_tSetFoundResult(void* obj, TClass* cl, TDataMember* member = 0); Bool_tSetResult(void* obj, TClass* cl, TDataMember* member = 0); voidSetRootClass(TClass* cl); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum { kScan; kExpand; kSearch; kCheckChilds; kOnlyFields; kActions; };. protected:. Bool_tfHasMore! indicates that potentially there are more items can be found; TStringfItemName! name of current item; TListfItemsNames! list of created items names, need to avoid duplication; Int_tfLevel! current level of hierarchy; UInt_tfMask! defines operation kind; Bool_tfNodeStarted! indicate if node was started; Int_tfNumChilds! number of childs; Int_tfNumFields! number of fields; TRootSnifferScanRec*fParent! pointer on parent record; Int_tfRestriction! restriction 0 - default, 1 - read-only, 2 - full access; const char*fSearchPath! current path searched; TRootSnifferStore*fStore! object to store results. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSnifferScanRec(). virtual ~TRootSnifferScanRec(). void CloseNode(). Bool_t CanSetFields() const; return true when fields could be set to the hierarchy item . Bool_t ScanOnlyFields() const. void CreateNode(const char* _node_name); Starts new node, must be closed at the end . void BeforeNextChild(). void SetField(const char* name, const char* value, Bool_t with_quotes = kTRUE); Set item field only when creating is specified . void SetRootClass(TClass* cl); Mark item with ROOT class and correspondent streamer info . Bool_t CanExpandItem(); Returns true when item can be expanded . Bool_t IsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootSnifferScanRec.html:1585,avoid,avoid,1585,root/html534/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html534/TRootSnifferScanRec.html,2,['avoid'],['avoid']
Safety,"r, Double_t *s, Bool_t inner, Bool_t in) const;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Bool_t GetPointsOnSegments (Int_t, Double_t *) const override;  ; Double_t GetStIn () const;  ; Double_t GetStOut () const;  ; Bool_t HasInner () const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t RadiusHypeSq (Double_t z, Bool_t inner) const;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; Double_t SafetyToHype (const Double_t *point, Bool_t inner, Bool_t in) const;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetHypeDimensions (Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz);  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHype.html:3120,safe,safe,3120,doc/master/classTGeoHype.html,https://root.cern,https://root.cern/doc/master/classTGeoHype.html,1,['safe'],['safe']
Safety,"r, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19926 }; 19927 ; 19928 /* Call script */; 19929 state = mg_lua_context_script_run(state,; 19930 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19931 ctx,; 19932 ebuf,; 19933 sizeof(ebuf));; 19934 if (!state) {; 19935 mg_cry_ctx_internal(ctx,; 19936 ""lua_background_script start error: %s"",; 19937 ebuf);; 19938 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19939 mg_snprintf(NULL,; 19940 NULL, /* No truncation check for error buffers */; 19941 error->text,; 19942 error->text_buffer_size,; 19943 ""Error in script %s: %s"",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 19949 free_context(ctx);; 19950 pthread_setspecific(sTlsKey, NULL);; 19951 return NULL;; 19952 }; 19953 ; 19954 /* state remains valid */; 19955 ctx->lua_background_state = (void *)state;; 19956 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19957 ; 19958 } else {; 19959 ctx->lua_background_state = 0;; 19960 }; 19961#endif; 19962 ; 19963 /* Step by step initialization of ctx - depending on build options */; 19964#if !defined(NO_FILESYSTEMS); 19965 if (!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error !=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:596694,abort,abort,596694,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"r, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error !=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:596727,abort,abort,596727,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['abort'],['abort']
Safety,"r, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoShapeAssembly&operator=(const TGeoShapeAssembly&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); voidRecomputeBoxLast(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShapeAssembly.html:8475,Safe,SafetySeg,8475,root/html534/TGeoShapeAssembly.html,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html,1,['Safe'],['SafetySeg']
Safety,"r, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCone&operator=(const TGeoCone&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCone.html:9608,Safe,SafetySeg,9608,root/html534/TGeoCone.html,https://root.cern,https://root.cern/root/html534/TGeoCone.html,3,['Safe'],['SafetySeg']
Safety,"r. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd1.html:14079,safe,safe,14079,root/html534/TGeoTrd1.html,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html,12,['safe'],['safe']
Safety,"r. TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nz. param[3] = z1; param[4] = Rmin1; param[5] = Rmax1. TGeoPcon(const TGeoPcon& ); copy constructor. TGeoPcon& operator=(const TGeoPcon& ); assignment operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPcon.html:14497,safe,safe,14497,root/html534/TGeoPcon.html,https://root.cern,https://root.cern/root/html534/TGeoPcon.html,6,['safe'],['safe']
Safety,"r. void PutLog(TQueryResult* qr); Display log of query pq into the log window frame. void ShowLog(const char* queryref); Display on screen the content of the temporary log file for query; in reference. void ShowLog(Int_t qry = -1); Display on screen the content of the temporary log file.; If qry == -2 show messages from the last (current) query.; If qry == -1 all the messages not yet displayed are shown (default).; If qry == 0, all the messages in the file are shown.; If qry > 0, only the messages related to query 'qry' are shown.; For qry != -1 the original file offset is restored at the end. void cd(Int_t id = -1); Set session with 'id' the default one. If 'id' is not found in the list,; the current session is set as default. void Detach(Option_t* opt = """"); Detach this instance to its proofserv.; If opt is 'S' or 's' the remote server is shutdown. void SetAlias(const char* alias = """"); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t UploadDataSet(const char* , TList* , const char* = 0, Int_t = 0, TList* = 0); *** This function is deprecated and will disappear in future versions ***; *** It is just a wrapper around TFile::Cp.; *** Please use TProofMgr::UploadFiles. Upload a set of files and save the list of files by name dataSetName.; The 'files' argument is a list of TFileInfo objects describing the files; as first url.; The mask 'opt' is a combination of EUploadOpt:; kAppend (0x1) if set true files will be appended to; the dataset existing by given name; kOverwriteDataSet (0x2) if dataset with given name exited it; would be overwritten; kNoOverwriteDataSet (0x4) do not overwirte if the dataset exists; kOverwriteAllFiles (0x8) overwrite all files that may exist; kOverwriteNoFiles (0x10) overwrite none; kAskUser (0x0) ask user before overwriteng dataset/files; The default value is kAskUser.; The user will be asked to confirm overwriting data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:87972,recover,recovered,87972,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['recover'],['recovered']
Safety,"r. void PutLog(TQueryResult* qr); Display log of query pq into the log window frame. void ShowLog(const char* queryref); Display on screen the content of the temporary log file for query; in reference. void ShowLog(Int_t qry = -1); Display on screen the content of the temporary log file.; If qry == -2 show messages from the last (current) query.; If qry == -1 all the messages not yet displayed are shown (default).; If qry == 0, all the messages in the file are shown.; If qry > 0, only the messages related to query 'qry' are shown.; For qry != -1 the original file offset is restored at the end. void cd(Int_t id = -1); Set session with 'id' the default one. If 'id' is not found in the list,; the current session is set as default. void Detach(Option_t* opt = """"); Detach this instance to its proofserv.; If opt is 'S' or 's' the remote server is shutdown. void SetAlias(const char* alias = """"); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Upload a set of files and save the list of files by name dataSetName.; The 'files' argument is a list of TFileInfo objects describing the files; as first url.; The mask 'opt' is a combination of EUploadOpt:; kAppend (0x1) if set true files will be appended to; the dataset existing by given name; kOverwriteDataSet (0x2) if dataset with given name exited it; would be overwritten; kNoOverwriteDataSet (0x4) do not overwirte if the dataset exists; kOverwriteAllFiles (0x8) overwrite all files that may exist; kOverwriteNoFiles (0x10) overwrite none; kAskUser (0x0) ask user before overwriteng dataset/files; The default value is kAskUser.; The user will be asked to confirm overwriting dataset or files unless; specified opt provides the answer!; If kOverwriteNoFiles is set, then a pointer to TList must be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:77187,recover,recovered,77187,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['recover'],['recovered']
Safety,"r3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, Double_t* point, Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at a given Z for a given ray inside a given sector; and fills coefficients:; Rproj = a + b*z. Double_t SafetyToSegment(Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set PGON dimensions starting from an array. void SetPoints(Double_t* points) const; create polygone mesh points. void SetPoints(Float_t* points) const; create polygone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n;. n = fNedges+1;. Int_t numPoints = fNz*2*n;; Int_t numSegs = 4*(fNz*n-1+(fDphi == 360));; Int_t numPolys = 2*(fNz*n-1+(fDphi == 360));; painter->AddSize3D(num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPgon.html:18503,Safe,Safety,18503,root/html532/TGeoPgon.html,https://root.cern,https://root.cern/root/html532/TGeoPgon.html,1,['Safe'],['Safety']
Safety,"r::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made. Making a geometrically contained step with boundary crossing (is_geom=kTRUE, cross=kTRUE) - This is the default method behavior. In this cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:988317,safe,safe,988317,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,9,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"r::GetCldirconst Double_t * GetCldir() constDefinition TGeoNavigator.h:165; TGeoNavigator::fTopNodeTGeoNode * fTopNodecurrent nodeDefinition TGeoNavigator.h:76; TGeoNavigator::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:236; TGeoNavigator::IsSafeStepBool_t IsSafeStep(Double_t proposed, Double_t &newsafety) constIn case a previous safety value was computed, check if the safety region is still safe for the curren...Definition TGeoNavigator.cxx:2609; TGeoNavigator::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoNavigator.cxx:1924; TGeoNavigator::fLastSafetyDouble_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaughterIndexInt_t fNextDaughterIndexnumber of overlapping nodes on current branchDefinition TGeoNavigator.h:57; TGeoNavigator::PopPathBool_t PopPath(Int_t index)Definition TGeoNavigator.h:255; TGeoNavigator::fIsNullStepBool_t fIsNullStepflag that a new point is in the same node as previousDefinition TGeoNavigator.h:71; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, const Double_t *point)Definition TGeoNavigator.h:194; TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:31635,safe,safety,31635,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety,"r::fIsStepEntering. private . flag that current track is about to leave current node ; Definition at line 66 of file TGeoNavigator.h. ◆ fIsStepExiting. Bool_t TGeoNavigator::fIsStepExiting. private . flag that next geometric step will enter new volume ; Definition at line 67 of file TGeoNavigator.h. ◆ fLastNode. TGeoNode* TGeoNavigator::fLastNode. private . top physical node ; Definition at line 77 of file TGeoNavigator.h. ◆ fLastPoint. Double_t TGeoNavigator::fLastPoint[3]. private . current direction ; Definition at line 51 of file TGeoNavigator.h. ◆ fLastPWSafety. Double_t TGeoNavigator::fLastPWSafety {-1}. private . last point for which parallel world safety was ""evaluated"" ; Definition at line 53 of file TGeoNavigator.h. ◆ fLastPWSaftyPnt. Double_t TGeoNavigator::fLastPWSaftyPnt[3]. private . last point for which safety was computed ; Definition at line 52 of file TGeoNavigator.h. ◆ fLastSafety. Double_t TGeoNavigator::fLastSafety. private . safety radius from current point ; Definition at line 45 of file TGeoNavigator.h. ◆ fLevel. Int_t TGeoNavigator::fLevel. private . thread id for this navigator ; Definition at line 55 of file TGeoNavigator.h. ◆ fNextDaughterIndex. Int_t TGeoNavigator::fNextDaughterIndex. private . number of overlapping nodes on current branch ; Definition at line 57 of file TGeoNavigator.h. ◆ fNextNode. TGeoNode* TGeoNavigator::fNextNode. private . last searched node ; Definition at line 78 of file TGeoNavigator.h. ◆ fNmany. Int_t TGeoNavigator::fNmany. private . current geometry level; ; Definition at line 56 of file TGeoNavigator.h. ◆ fNormal. Double_t TGeoNavigator::fNormal[3]. private . last computed safety radius ; Definition at line 46 of file TGeoNavigator.h. ◆ fOverlapClusters. Int_t* TGeoNavigator::fOverlapClusters. private . current recursive position in fOverlapClusters ; Definition at line 60 of file TGeoNavigator.h. ◆ fOverlapMark. Int_t TGeoNavigator::fOverlapMark. private . current size of fOverlapClusters ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:49165,safe,safety,49165,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safety']
Safety,"r; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.fData[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.fData[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. Ssiz_t Length() const; { return fNchars; }. char & operator[](Ssiz_t i); { return ((char*)(this+1))[i]; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TString.h 34285 2010-07-01 20:37:52Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSubString.html:2578,detect,detecting,2578,root/html528/TSubString.html,https://root.cern,https://root.cern/root/html528/TSubString.html,1,['detect'],['detecting']
Safety,"r=""r""); ; # Adjust frame maximum for visual clarity; frame1.SetMinimum(0); frame1.SetMaximum(3); ; # Construct profile likelihood in sigma_g2; # -------------------------------------------------------------------------------; ; # The profile likelihood estimator on nll for sigma_g2 will minimize nll; # w.r.t all floating parameters except sigma_g2 for each evaluation; pll_sigmag2 = nll.createProfile({sigma_g2}); ; # Plot the profile likelihood in sigma_g2; pll_sigmag2.plotOn(frame2, LineColor=""r""); ; # Adjust frame maximum for visual clarity; frame2.SetMinimum(0); frame2.SetMaximum(3); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf605_profilell"", ""rf605_profilell"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf605_profilell.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf605__profilell_8py.html:3020,safe,safe,3020,doc/master/rf605__profilell_8py.html,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html,1,['safe'],['safe']
Safety,"r>(this->end()));; 831 ; 832 // Copy the existing elements that get replaced.; 833 std::move_backward(I, OldEnd - NumToInsert, OldEnd);; 834 ; 835 std::fill_n(I, NumToInsert, Elt);; 836 return I;; 837 }; 838 ; 839 // Otherwise, we're inserting more elements than exist already, and we're; 840 // not inserting at the end.; 841 ; 842 // Move over the elements that we're about to overwrite.; 843 T *OldEnd = this->end();; 844 this->set_size(this->size() + NumToInsert);; 845 size_t NumOverwritten = OldEnd - I;; 846 this->uninitialized_move(I, OldEnd, this->end() - NumOverwritten);; 847 ; 848 // Replace the overwritten part.; 849 std::fill_n(I, NumOverwritten, Elt);; 850 ; 851 // Insert the non-overwritten middle part.; 852 std::uninitialized_fill_n(OldEnd, NumToInsert - NumOverwritten, Elt);; 853 return I;; 854 }; 855 ; 856 template <typename ItTy,; 857 typename = typename std::enable_if<std::is_convertible<; 858 typename std::iterator_traits<ItTy>::iterator_category, std::input_iterator_tag>::value>::type>; 859 iterator insert(iterator I, ItTy From, ItTy To); 860 {; 861 // Convert iterator to elt# to avoid invalidating iterator when we reserve(); 862 size_t InsertElt = I - this->begin();; 863 ; 864 if (I == this->end()) { // Important special case for empty vector.; 865 append(From, To);; 866 return this->begin() + InsertElt;; 867 }; 868 ; 869 if (I < this->begin() || I > this->end()) {; 870 throw std::runtime_error(""The iterator passed to `insert` is out of bounds."");; 871 }; 872 ; 873 size_t NumToInsert = std::distance(From, To);; 874 ; 875 // Ensure there is enough space.; 876 reserve(this->size() + NumToInsert);; 877 ; 878 // Uninvalidate the iterator.; 879 I = this->begin() + InsertElt;; 880 ; 881 // If there are more elements between the insertion point and the end of the; 882 // range than there are being inserted, we can use a simple approach to; 883 // insertion. Since we already reserved space, we know that this won't; 884 // reallocate the vector.; 885 if (size",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:30331,avoid,avoid,30331,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['avoid'],['avoid']
Safety,"rEntry; TGNumberEntryLayout Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:83633,safe,safe,83633,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['safe'],['safe']
Safety,"rGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnixSystem.html:30420,Abort,Abort,30420,root/html532/TUnixSystem.html,https://root.cern,https://root.cern/root/html532/TUnixSystem.html,2,['Abort'],['Abort']
Safety,"rJSON.cxx. ◆ SetTypeversionTag(). void TBufferJSON::SetTypeversionTag ; (; const char * ; tag = nullptr). Configures _typeversion tag in JSON One can specify name of the JSON tag like ""_typeversion"" or ""$tv"" which will be used to store class version Such tag can be used to correctly recover objects from JSON If empty string is provided (default), class version will not be stored. ; Definition at line 592 of file TBufferJSON.cxx. ◆ SkipObjectAny(). void TBufferJSON::SkipObjectAny ; (; ). finalvirtual . Skip any kind of object from buffer. ; Implements TBuffer.; Definition at line 2508 of file TBufferJSON.cxx. ◆ Stack(). TJSONStackObj * TBufferJSON::Stack ; (; ). inlineprotected . Definition at line 257 of file TBufferJSON.h. ◆ StoreObject(). TString TBufferJSON::StoreObject ; (; const void * ; obj, . const TClass * ; cl . ). Store provided object as JSON structure Allows to configure different TBufferJSON properties before converting object into JSON Actual object class must be specified here Method can be safely called once - after that TBufferJSON instance must be destroyed Code should look like: ; auto obj = new UserClass(); TBufferJSON buf; buf.SetCompact(TBufferJSON::kNoSpaces); // change any other settings in TBufferJSON auto json = buf.StoreObject(obj, TClass::GetClass<UserClass>()); ; Definition at line 700 of file TBufferJSON.cxx. ◆ Streamer(). void TBufferJSON::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TBufferIO. ◆ StreamerNVirtual(). void TBufferJSON::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 332 of file TBufferJSON.h. ◆ StreamObject() [1/4]. void TBufferText::StreamObject ; (; TObject * ; obj). overridevirtual . Implements TBuffer.; Definition at line 33 of file TBufferText.cxx. ◆ StreamObject() [2/4]. void TBufferText::StreamObject ; (; void * ; obj, . const char * ; className, . const TClass * ; onFileClass = nullptr . ). overridevirtual . s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:86832,safe,safely,86832,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['safe'],['safely']
Safety,"r_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& ); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TShape.html:8940,avoid,avoid,8940,root/html534/TShape.html,https://root.cern,https://root.cern/root/html534/TShape.html,2,['avoid'],['avoid']
Safety,"ractive) {; 1263 fInteractive->AddPoint(stepCount, trainingError, testError);; 1264 fIPyCurrentIter = 100.0 * minimizer.GetConvergenceCount(); 1265 / minimizer.GetConvergenceSteps ();; 1266 if (fExitFromTraining) break;; 1267 } else {; 1268 Log() << std::setw(10) << stepCount << "" | ""; 1269 << std::setw(12) << trainingError; 1270 << std::setw(12) << testError; 1271 << std::setw(12) << nFlops / seconds; 1272 << std::setw(12) << minimizer.GetConvergenceCount() << Endl;; 1273 if (converged) {; 1274 Log() << Endl;; 1275 }; 1276 }; 1277 }; 1278 }; 1279 ; 1280 ; 1281 for (size_t l = 0; l < net.GetDepth(); l++) {; 1282 auto & layer = fNet.GetLayer(l);; 1283 layer.GetWeights() = (TMatrixT<Scalar_t>) net.GetLayer(l).GetWeights();; 1284 layer.GetBiases() = (TMatrixT<Scalar_t>) net.GetLayer(l).GetBiases();; 1285 }; 1286 }; 1287 ; 1288#else // DNNCPU flag not set.; 1289 Log() << kFATAL << ""Multi-core CPU backend not enabled. Please make sure ""; 1290 ""you have a BLAS implementation and it was successfully ""; 1291 ""detected by CMake as well that the imt CMake flag is set."" << Endl;; 1292#endif // DNNCPU; 1293}; 1294 ; 1295////////////////////////////////////////////////////////////////////////////////; 1296 ; 1297Double_t TMVA::MethodDNN::GetMvaValue( Double_t* /*errLower*/, Double_t* /*errUpper*/ ); 1298{; 1299 size_t nVariables = GetEvent()->GetNVariables();; 1300 Matrix_t X(1, nVariables);; 1301 Matrix_t YHat(1, 1);; 1302 ; 1303 const std::vector<Float_t>& inputValues = GetEvent()->GetValues();; 1304 for (size_t i = 0; i < nVariables; i++) {; 1305 X(0,i) = inputValues[i];; 1306 }; 1307 ; 1308 fNet.Prediction(YHat, X, fOutputFunction);; 1309 return YHat(0,0);; 1310}; 1311 ; 1312////////////////////////////////////////////////////////////////////////////////; 1313 ; 1314const std::vector<Float_t> & TMVA::MethodDNN::GetRegressionValues(); 1315{; 1316 size_t nVariables = GetEvent()->GetNVariables();; 1317 Matrix_t X(1, nVariables);; 1318 ; 1319 const Event *ev = GetEvent();; 1320 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:46561,detect,detected,46561,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['detect'],['detected']
Safety,"rame (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed by the ROOT script TMhs3demo.C, or are linked against an executable: TMhs3run.cxx.; 23.3.1 Known Problems; Parts of the ROOT framework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.; Object instantiation: there is no implicit locking mechanism for memory allocation and global ROOT lists. The user has to explicitly protect their code when using them.; 23.4 The Signals of ROOT; The list of default signals handled by ROOT is:; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; The signals kSigFloatingException, kSigSegmentationViolation, kSigIllegalInstruction, and kSigBus cause the printing of the *** Break *** message and make a long jump back to the ROOT prompt. No other custom TSignalHandler can be added to these signals.; The kSigAlarm signal handles asynchronous timers. The kSigWindowChanged signal handles the resizing of the terminal window. The other signals have no other behavior then that to call any registered TSignalHandler::Notify().; Wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1117479,safe,safe,1117479,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['safe'],['safe']
Safety,"rame to top. ;  ; void PopDummy (Int_t ipop=9999);  ; Bool_t PopPath ();  ; Bool_t PopPath (Int_t index);  ; Bool_t PopPoint ();  ; Bool_t PopPoint (Int_t index);  ; Int_t PushPath (Int_t startlevel=0);  ; Int_t PushPoint (Int_t startlevel=0);  ; void ResetAll ();  Reset the navigator. ;  ; void ResetState ();  Reset current state flags. ;  ; Double_t Safety (Bool_t inside=kFALSE);  Compute safe distance from the current point. ;  ; TGeoNode * SearchNode (Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr);  Returns the deepest node containing fPoint, which must be set a priori. ;  ; void SetCheckingOverlaps (Bool_t flag=kTRUE);  ; void SetCldirChecked (Double_t *dir);  ; void SetCurrentDirection (const Double_t *dir);  ; void SetCurrentDirection (Double_t nx, Double_t ny, Double_t nz);  ; void SetCurrentPoint (const Double_t *point);  ; void SetCurrentPoint (Double_t x, Double_t y, Double_t z);  ; void SetLastPoint (Double_t x, Double_t y, Double_t z);  ; void SetLastSafetyForPoint (Double_t safe, const Double_t *point);  ; void SetLastSafetyForPoint (Double_t safe, Double_t x, Double_t y, Double_t z);  ; void SetOutside (Bool_t flag=kTRUE);  ; void SetStartSafe (Bool_t flag=kTRUE);  ; void SetStep (Double_t step);  ; TGeoNode * Step (Bool_t is_geom=kTRUE, Bool_t cross=kTRUE);  Make a rectiliniar step of length fStep from current point (fPoint) on current direction (fDirection). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TopToMaster (const Double_t *top, Double_t *master) const;  Convert coordinates from top volume frame to master. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:8759,safe,safe,8759,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,2,['safe'],['safe']
Safety,"rameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitter.html:16180,predict,predict,16180,root/html528/TFitter.html,https://root.cern,https://root.cern/root/html528/TFitter.html,10,['predict'],['predict']
Safety,"ranch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with only one branch). /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; TH2F *hpxpy = new TH2F(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile *hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //-----------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:5155,detect,detector,5155,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['detect'],['detector']
Safety,"rap::GetMakeRuntimeShape ; (; TGeoShape * ; mother, . TGeoMatrix * ; mat . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ GetPhi(). Double_t TGeoTrap::GetPhi ; (; ); const. inline . Definition at line 131 of file TGeoArb8.h. ◆ GetTheta(). Double_t TGeoTrap::GetTheta ; (; ); const. inline . Definition at line 130 of file TGeoArb8.h. ◆ GetTl1(). Double_t TGeoTrap::GetTl1 ; (; ); const. inline . Definition at line 134 of file TGeoArb8.h. ◆ GetTl2(). Double_t TGeoTrap::GetTl2 ; (; ); const. inline . Definition at line 138 of file TGeoArb8.h. ◆ IsA(). TClass * TGeoTrap::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoArb8.; Definition at line 146 of file TGeoArb8.h. ◆ Safety(). Double_t TGeoTrap::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ Safety_v(). void TGeoTrap::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoArb8. ◆ SavePrimitive(). void TGeoTrap::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoArb8. ◆ SetDimensions(). void TGeoTrap::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoArb8. ◆ Streamer(). void TGeoTrap::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoArb8. ◆ StreamerNVirtual(). void TGeoTrap::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 146 of file TGeoArb8.h. Member Data Documentation. ◆ fAlpha1. Double_t TGeoTrap::fAlpha1. protected . Definition at line 104 of file TGeoArb8.h. ◆ fAlpha2. Double_t TGeoTrap::fAlpha2. protected . Definition at line 108 of file TGeoArb8.h. ◆ fBl1. Double_t TGeoTrap::fBl1. protected . Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrap.html:29378,safe,safe,29378,doc/master/classTGeoTrap.html,https://root.cern,https://root.cern/doc/master/classTGeoTrap.html,1,['safe'],['safe']
Safety,"raphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::Raisevirtual void Raise()Definition TApplication.h:133; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::fSigHandlerTSignalHandler * fSigHandlerDefinition TApplication.h:70; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::Showvirtual void Show()Definition TApplication.h:129; TApplication::SetSignalHandlervoid SetSignalHandler(TSignalHandler *sh)Definition TApplication.h:92; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8h_source.html:19743,timeout,timeout,19743,doc/master/TApplication_8h_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html,1,['timeout'],['timeout']
Safety,"rated using a linear congruential random generator. The multipliers used are the same of the BSD rand() random generator. Its sequence is:; \(x_{n+1} = (ax_n + c) mod m\) with \(a =1103515245\), \(c = 12345\) and \(m =2^{31}\).; This type of generator uses a state of only a 32 bit integer and it has a very short period, 231,about 109, which can be exhausted in just few seconds. The quality of this generator is therefore BAD and it is strongly recommended to NOT use for any statistical study.; 13.4.2 TRandom1; This random number generator is based on the Ranlux engine, developed by M. Lüsher and implemented in Fortran by F. James. This engine has mathematically proven random proprieties and a long period of about 10171. Various luxury levels are provided (1,2,3,4) and can be specified by the user in the constructor. Higher the level, better random properties are obtained at a price of longer CPU time for generating a random number. The level 3 is the default, where any theoretical possible correlation has very small chance of being detected. This generator uses a state of 24 32-bits words. Its main disadvantage is that is much slower than the others (see timing table). For more information on the generator see the following article:. F. James, “RANLUX: A Fortran implementation of the high quality pseudo-random number generator of Lüscher”, Computer Physics Communication, 79 (1994) 111. 13.4.3 TRandom2; This generator is based on the maximally equi-distributed combined Tausworthe generator by L’Ecuyer. It uses only 3 32-bits words for the state and it has a period of about 1026. It is fast and given its small states, it is recommended for applications, which require a very small random number size. For more information on the generator see the following article:. P. L’Ecuyer, “Maximally Equi-distributed Combined Tausworthe Generators”, Mathematics of Computation, 65, 213 (1996), 203-213. 13.4.4 TRandom3; This is based on the Mersenne and Twister pseudo-random number g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:666505,detect,detected,666505,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['detect'],['detected']
Safety,"ration, if RooRealIntegral considers this to be unsafe (e.g. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create a generator context for this p.d.f. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise capability to perform (analytical) integrals internally. ;  ; virtual Int_t getCoefAnalyticalIntegral (Int_t coef, RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Default implementation of function advertising integration capabilities. ;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet &nset, const char *rangeName) const;  ; double getCoefNorm (Int_t coefIdx, const RooArgSet *nset=nullptr, const char *rangeName=nullptr) const;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Return true if it is safe to generate the convolution observable from the internal generator (this is the case if the chosen resolution model is the truth model) ;  ; void printMultiline (std::ostream &stream, Int_t contents, bool verbose=false, TString indent="""") const override;  Print info about this object to the specified stream. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components with cache-and-track. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDecay.html:6790,safe,safe,6790,doc/master/classRooDecay.html,https://root.cern,https://root.cern/doc/master/classRooDecay.html,1,['safe'],['safe']
Safety,"rator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*&); virtual Int_tRecv(Int_t&, Int_t&); virtual Int_tRecv(char*, Int_t); virtual Int_tRecv(char*, Int_t, Int_t&); virtual Int_tRecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage&); virtual Int_tSend(Int_t); virtual Int_tSend(Int_t, Int_t); virtual Int_tSend(const char*, Int_t = kMESS_STRING); virtual Int_tSendObject(const TObject*, Int_t = kMESS_OBJECT); virtual Int_tSendRaw(const void*, Int_t, ESendRecvOptions = kDefault); static voidSetAcceptOptions(UChar_t Opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecConte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TServerSocket.html:6039,timeout,timeout,6039,root/html530/TServerSocket.html,https://root.cern,https://root.cern/root/html530/TServerSocket.html,5,['timeout'],['timeout']
Safety,"rator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance Chart:. TIterator. ←; TTreeFriendLeafIter. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFriendLeafIter.html:2333,Safe,SafeDelete,2333,root/html602/TTreeFriendLeafIter.html,https://root.cern,https://root.cern/root/html602/TTreeFriendLeafIter.html,2,['Safe'],['SafeDelete']
Safety,"rator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.0861399 cHl3=-9.50561 cHq3=0.0801661; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.186765 cHl3=8.8591 cHq3=-0.971282; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.218731 cHl3=0.37397 cHq3=-2.08166; RooAbsPdf::wrap_pdf_over_wrap_pd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:10327,recover,recover,10327,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Safety,"ratorOptions.h. Public Member Functions;  BaseIntegratorOptions (const BaseIntegratorOptions &opt);  ; virtual ~BaseIntegratorOptions ();  protected constructor to avoid user creating this class ;  ; double AbsTolerance () const;  non-static methods for retrieving options ;  ; IOptions * ExtraOptions () const;  return extra options ;  ; virtual std::string Integrator () const =0;  name of 1D integrator ;  ; BaseIntegratorOptions & operator= (const BaseIntegratorOptions &opt);  assignment operators ;  ; double RelTolerance () const;  absolute tolerance ;  ; void SetAbsTolerance (double tol);  non-static methods for setting options ;  ; void SetExtraOptions (const IOptions &opt);  set extra options (in this case pointer is cloned) ;  ; void SetRelTolerance (double tol);  set the relative tolerance ;  ; void SetWKSize (unsigned int size);  set workspace size ;  ; unsigned int WKSize () const;  size of the workspace ;  . Protected Member Functions;  BaseIntegratorOptions ();  protected constructor to avoid user creating this class ;  ; void ClearExtra ();  . Protected Attributes; double fAbsTolerance;  absolute tolerance ;  ; ROOT::Math::IOptions * fExtraOptions;  ; int fIntegType;  Integrator type (value converted from enum) ;  ; unsigned int fNCalls;  (max) function calls ;  ; double fRelTolerance;  relative tolerance ;  ; unsigned int fWKSize;  workspace size ;  . #include <Math/IntegratorOptions.h>. Inheritance diagram for ROOT::Math::BaseIntegratorOptions:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ BaseIntegratorOptions() [1/2]. ROOT::Math::BaseIntegratorOptions::BaseIntegratorOptions ; (; ). protected . protected constructor to avoid user creating this class ; constructor (protected) to avoid user creating this class ; Definition at line 125 of file IntegratorOptions.cxx. ◆ BaseIntegratorOptions() [2/2]. ROOT::Math::BaseIntegratorOptions::BaseIntegratorOptions ; (; cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html:1612,avoid,avoid,1612,doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,1,['avoid'],['avoid']
Safety,"raw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each elemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:43384,detect,detection,43384,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,8,['detect'],['detection']
Safety,"raw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 everytime a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:41238,detect,detection,41238,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['detect'],['detection']
Safety,"rawn but its sons are drawn; VT1_1->SetVisibility(-4); //Node is not drawn. Its immediate sons are drawn; VT2_1->SetVisibility(-4);; MTL_1->SetVisibility(-4);; MTR_1->SetVisibility(-4);; TOFR1->SetVisibility(-4);; ; gBenchmark->Show(""na49"");; }; TBRIK.h; TBenchmark.h; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; TGeometry.h; TMaterial.h; TMixture.h; TNode.h; TRotMatrix.h; TTRAP.h; TTUBE.h; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TBRIKA box with faces perpendicular to the axes.Definition TBRIK.h:26; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TGeometryTGeometry description.Definition TGeometry.h:39; TMaterialManages a detector material.Definition TMaterial.h:28; TMixtureManages a detector mixture.Definition TMixture.h:27; TMixture::DefineElementvirtual void DefineElement(Int_t n, Float_t a, Float_t z, Float_t w)Define one mixture element.Definition TMixture.cxx:86; TNodeTNode description.Definition TNode.h:33; TNode::cdvirtual void cd(const char *path=nullptr)Change Current Reference node to this.Definition TNode.cxx:249; TNode::ImportShapeAttributesvirtual void ImportShapeAttributes()Copy shape attributes as node attributes.Definition TNode.cxx:409; TNode::SetVisibilityvirtual void SetVisibility(Int_t vis=1)Set visibility for this node and its sons.Definition TNode.cxx:758; TRotMatrixManages a detector rotation matrix.Definition TRotMatrix.h:28; TShape::SetVisibilityvirtual void SetVisibility(Int_t vis)Definition TShape.h:62; TTRAPA general trapezoid.Definition TTRAP.h:33; TTUBEA tube.Definition TTUBE.h:32; AuthorRene Brun ; Definition in file na49.C. tutorialsgeomna49.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/na49_8C.html:949142,detect,detector,949142,doc/master/na49_8C.html,https://root.cern,https://root.cern/doc/master/na49_8C.html,1,['detect'],['detector']
Safety,"ray of physical nodes; TStringTNamed::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolume! helper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(const char* path); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t* point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t* point, Double_t safmax = 1.E30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. void SetUseOverlaps(Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParallelWorld.html:7872,detect,detected,7872,root/html534/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html,2,['detect'],['detected']
Safety,"ray of physical nodes; TStringTNamed::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolume! helper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(const char* path); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t[3] point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t[3] point, Double_t safmax = 1.0E+30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. void SetUseOve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoParallelWorld.html:8345,detect,detected,8345,root/html604/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html604/TGeoParallelWorld.html,2,['detect'],['detected']
Safety,"rce. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. Backward compatible implementation of TVirtualFitter using the the class ROOT::Fit::Fitter.; This class is created after fitting an histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using; <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also provided.; Note that after a new calls to TH1::Fit (or similar) the class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. TBackCompFitter(); TBackCompFitter(const TBackCompFitter&); TBackCompFitter(auto_ptr<ROOT::Fit::Fitter> fitter, auto_ptr<ROOT::Fit::FitData> data); virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.683); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBackCompFitter.html:1163,avoid,avoid,1163,root/html526/TBackCompFitter.html,https://root.cern,https://root.cern/root/html526/TBackCompFitter.html,7,['avoid'],['avoid']
Safety,"rces (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:2743,detect,detector,2743,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,4,['detect'],['detector']
Safety,"rd fields have no; 111/// materialization on the primitive column layer.; 112enum ENTupleStructure : std::uint16_t { kInvalid, kLeaf, kCollection, kRecord, kVariant, kStreamer, kUnknown };; 113 ; 114/// Integer type long enough to hold the maximum number of entries in a column; 115using NTupleSize_t = std::uint64_t;; 116constexpr NTupleSize_t kInvalidNTupleIndex = std::uint64_t(-1);; 117/// Wrap the integer in a struct in order to avoid template specialization clash with std::uint64_t; 118struct RClusterSize {; 119 using ValueType = std::uint64_t;; 120 ; 121 RClusterSize() : fValue(0) {}; 122 explicit constexpr RClusterSize(ValueType value) : fValue(value) {}; 123 RClusterSize &operator=(const ValueType value); 124 {; 125 fValue = value;; 126 return *this;; 127 }; 128 RClusterSize &operator+=(const ValueType value); 129 {; 130 fValue += value;; 131 return *this;; 132 }; 133 RClusterSize operator++(int); 134 {; 135 auto result = *this;; 136 fValue++;; 137 return result;; 138 }; 139 operator ValueType() const { return fValue; }; 140 ; 141 ValueType fValue;; 142};; 143using ClusterSize_t = RClusterSize;; 144constexpr ClusterSize_t kInvalidClusterIndex(std::uint64_t(-1));; 145 ; 146constexpr int kUnknownCompressionSettings = -1;; 147 ; 148/// Holds the index and the tag of a kSwitch column; 149class RColumnSwitch {; 150private:; 151 ClusterSize_t fIndex;; 152 std::uint32_t fTag = 0;; 153 ; 154public:; 155 RColumnSwitch() = default;; 156 RColumnSwitch(ClusterSize_t index, std::uint32_t tag) : fIndex(index), fTag(tag) {}; 157 ClusterSize_t GetIndex() const { return fIndex; }; 158 std::uint32_t GetTag() const { return fTag; }; 159};; 160 ; 161/// Uniquely identifies a physical column within the scope of the current process, used to tag pages; 162using ColumnId_t = std::int64_t;; 163constexpr ColumnId_t kInvalidColumnId = -1;; 164 ; 165/// Distriniguishes elements of the same type within a descriptor, e.g. different fields; 166using DescriptorId_t = std::uint64_t;; 167conste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html:3975,avoid,avoid,3975,doc/master/RNTupleUtil_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html,1,['avoid'],['avoid']
Safety,"rd, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Create a PROOF slave object. Called via the TProof ctor. void Init(const char* host, Int_t stype); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. void ParseBuffer(); Parse fBuffer after a connection attempt. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSlave.html:9887,abort,abort,9887,root/html530/TXSlave.html,https://root.cern,https://root.cern/root/html530/TXSlave.html,15,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"re details. ; . How can I fix the problem leading to :Error: Can't call vector<...>::push_back . This usually indicates that some classes dictionary refer and/or use this particular instance of std::vector. To solve the problem, you will need to generate a dictionary for this particular instance. With ROOT v5.27/06 and above this can be done by executing:gInterpreter->GenerateDictionary(""vector<Track&gt"",""Track.h;vector"");. With older version of ROOT ; this can simply be done using ACLiC and a simple loader.C script:// File loader.C; #include ; #include ; #ifdef __MAKECINT__; #pragma link C++ class vector<Track>+;; #endifI am defining a vector for my custom type (for example Track) in a root macro but when I push_back a Track object in the vector, CINT complains. e.g.; vector testVector;; Track obj;; ...; testVector.push_back(obj);; gives:Error: Can't call vector::push_back(timeStamp) in current scope MyAnalysisMasterTreeMaker.C:358:; Possible candidates are...; (in vector); *** Interpreter error recovered ***. Although, if I use a vector or vector or vector push_back works fine.; ; . What is the difference between a TFolder and a TDirectory? . TFolder manages a hierrachy of objects in memory.; TDirectory is doing it for a file.; One can save the TFolder structure to a directory in a file.; ; . Ubuntu: No backtrace (stacktrace) when ROOT crashes . Enable /proc/sys/kernel/yama/ptrace_scope or edit /etc/sysctl.d/10-ptrace.conf. See this blog entry for details. ; . Can I integrate ROOT into my CMake build? . Absolutely. The CMake command find_package() will set all needed ROOT related variables, which can be used to compile and link one's own code. An example from the ROOT Event example (found in root/test) can be downloaded here. Just un-tar the attached file and run:. cd event/build; cmake ..; make. I use CMake to build my own code, and I would like to use ROOT in that code. Is there a way to wire ROOT into the CMake build files? Something like FindROOT.cmake? ; . Win",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:4199,recover,recovered,4199,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['recover'],['recovered']
Safety,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-06-30 14:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11617,avoid,avoid,11617,root/html602/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,26,['avoid'],['avoid']
Safety,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-06-30 14:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:11589,avoid,avoid,11589,root/html602/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,20,['avoid'],['avoid']
Safety,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:11366,avoid,avoid,11366,root/html534/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,30,['avoid'],['avoid']
Safety,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:11617,avoid,avoid,11617,root/html604/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,36,['avoid'],['avoid']
Safety,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:11589,avoid,avoid,11589,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,10,['avoid'],['avoid']
Safety,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:85; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TIOFeatures_8hxx_source.html:3347,safe,safety,3347,doc/v632/TIOFeatures_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/TIOFeatures_8hxx_source.html,1,['safe'],['safety']
Safety,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:90; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TIOFeatures_8hxx_source.html:3348,safe,safety,3348,doc/master/TIOFeatures_8hxx_source.html,https://root.cern,https://root.cern/doc/master/TIOFeatures_8hxx_source.html,1,['safe'],['safety']
Safety,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:37070,timeout,timeout,37070,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,16,['timeout'],['timeout']
Safety,"re) ;  ; void GetGeometry (Int_t wid, Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) override;  Returns position and size of window ""wid"". ;  ; void GetImageSize (Drawable_t id, UInt_t &width, UInt_t &height) override;  Returns the width and height of the image id. ;  ; Window_t GetInputFocus () override;  Returns the window id of the window having the input focus. ;  ; Color_t GetLineColor () const override;  Return the line color. ;  ; Style_t GetLineStyle () const override;  Return the line style. ;  ; Width_t GetLineWidth () const override;  Return the line width. ;  ; Color_t GetMarkerColor () const override;  Return the marker color. ;  ; Size_t GetMarkerSize () const override;  Return the marker size. ;  ; Style_t GetMarkerStyle () const override;  Return the marker style. ;  ; Handle_t GetNativeEvent () const override;  Returns the current native event handle. ;  ; Window_t GetParent (Window_t id) const override;  might be thread unsafe (?) ;  ; void GetPasteBuffer (Window_t id, Atom_t atom, TString &text, Int_t &nchar, Bool_t del) override;  Gets contents of the paste buffer ""atom"" into the string ""text"". ;  ; ULong_t GetPixel (Color_t cindex) override;  Returns pixel value associated to specified ROOT color number ""cindex"". ;  ; void GetPlanes (Int_t &nplanes) override;  Returns the maximum number of planes. ;  ; Window_t GetPrimarySelectionOwner () override;  Returns the window id of the current owner of the primary selection. ;  ; Int_t GetProperty (Window_t, Atom_t, Long_t, Long_t, Bool_t, Atom_t, Atom_t *, Int_t *, ULong_t *, ULong_t *, unsigned char **) override;  Returns the actual type of the property; the actual format of the property; the number of 8-bit, 16-bit, or 32-bit items transferred; the number of bytes remaining to be read in the property; and a pointer to the data actually returned. ;  ; void GetRegionBox (Region_t reg, Rectangle_t *rect) override;  Returns smallest enclosing rectangle. ;  ; void GetRGB (Int_t index, Float_t &r, Float_t &g, Fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:12243,unsafe,unsafe,12243,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['unsafe'],['unsafe']
Safety,"re; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(Double_t* point, Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoSphere.html:13837,safe,safe,13837,root/html528/TGeoSphere.html,https://root.cern,https://root.cern/root/html528/TGeoSphere.html,4,['safe'],['safe']
Safety,"reamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4643 version = fClassVersion;; 4644 }; 4645 ; 4646 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4647 ; 4648 if (!sinfo && (version != fClassVersion)) {; 4649 // When the requested version does not exist we return; 4650 // the TVirtualStreamerInfo for the currently loaded class version.; 4651 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4652 // Note: This is done for STL collections; 4653 // Note: fClassVersion could be -1 here (for an emulated class).; 4654 // This is also the code path take for unversioned classes.; 4655 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4656 }; 4657 ; 4658 if (!sinfo) {; 4659 // We just were not able to find a streamer info, we have to make a new one.; 4660 TMmallocDescTemp setreset;; 4661 sinfo = TVirtualStreamerInfo::Factory()->NewInfo(const_cast<TClass*>(this));; 4662 fStreamerInfo->AddAtAndExpand(sinfo, fClassVersion);; 4663 if (gDebug > 0) {; 4664 printf(""Creating StreamerInfo for class: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:176063,abort,abort,176063,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['abort'],['abort']
Safety,"reamerInfo being called from multiple thread; 4690 // on that same TClass object.; 4691 //; 4692 // Summary: need careful review but risk of problem is extremely low.; 4693 ; 4694 R__LOCKGUARD(gInterpreterMutex);; 4695 ; 4696 return GetStreamerInfoImpl(version, isTransient);; 4697};; 4698 ; 4699// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4700// This routine assumes the global lock has been taken.; 4701TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4702{; 4703 // Warning: version may be -1 for an emulated class, or -2 if the; 4704 // user requested the emulated streamerInfo for an abstract; 4705 // base class, even though we have a dictionary for it.; 4706 ; 4707 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4708 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4709 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4710 version = fClassVersion;; 4711 }; 4712 ; 4713 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4714 ; 4715 if (!sinfo && (version != fClassVersion)) {; 4716 // When the requested version does not exist we return; 4717 // the TVirtualStreamerInfo for the currently loaded class version.; 4718 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4719 // Note: This is done for STL collections; 4720 // Note: fClassVersion could be -1 here (for an emulated class).; 4721 // This is also the code path take for unversioned classes.; 4722 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4723 }; 4724 ; 4725 if (!sinfo) {; 4726 // We just were not able to find a streamer info, we have to make a new one.; 4727 TMmallocDescTemp setreset;; 4728 sinfo = TVirtualStreamerInfo::Factory()->NewInfo(const_cast<TClass*>(this));; 4729 fStreamerInfo->AddAtAndExpand(sinfo, fClassVersion);; 4730 if (gDebug > 0) {; 4731 printf(""Creating StreamerInfo for class: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:178814,abort,abort,178814,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['abort'],['abort']
Safety,"reamerInfo in the given slot.; 7318/// Update the slot accordingly.; 7319 ; 7320void TClass::RemoveStreamerInfo(Int_t slot); 7321{; 7322 if (fStreamerInfo->GetSize() >= slot) {; 7323 R__LOCKGUARD(gInterpreterMutex);; 7324 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->At(slot);; 7325 fStreamerInfo->RemoveAt(fClassVersion);; 7326 if (fLastReadInfo.load() == info); 7327 fLastReadInfo = nullptr;; 7328 if (fCurrentInfo.load() == info); 7329 fCurrentInfo = nullptr;; 7330 delete info;; 7331 if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {; 7332 fState = kForwardDeclared;; 7333 }; 7334 }; 7335}; 7336 ; 7337////////////////////////////////////////////////////////////////////////////////; 7338/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7339/// classes in the class hierarchy that overload TObject::Hash do call; 7340/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7341/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7342/// This routines is used for a small subset of the class for which we need; 7343/// the answer before gROOT is properly initialized.; 7344 ; 7345Bool_t ROOT::Internal::HasConsistentHashMember(const char *cname); 7346{; 7347 // Hand selection of correct classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365///////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:281708,safe,safe,281708,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"reamerInfo in the given slot.; 7385/// Update the slot accordingly.; 7386 ; 7387void TClass::RemoveStreamerInfo(Int_t slot); 7388{; 7389 if (fStreamerInfo->GetSize() >= slot) {; 7390 R__LOCKGUARD(gInterpreterMutex);; 7391 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->At(slot);; 7392 fStreamerInfo->RemoveAt(fClassVersion);; 7393 if (fLastReadInfo.load() == info); 7394 fLastReadInfo = nullptr;; 7395 if (fCurrentInfo.load() == info); 7396 fCurrentInfo = nullptr;; 7397 delete info;; 7398 if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {; 7399 fState = kForwardDeclared;; 7400 }; 7401 }; 7402}; 7403 ; 7404////////////////////////////////////////////////////////////////////////////////; 7405/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7406/// classes in the class hierarchy that overload TObject::Hash do call; 7407/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7408/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7409/// This routines is used for a small subset of the class for which we need; 7410/// the answer before gROOT is properly initialized.; 7411 ; 7412Bool_t ROOT::Internal::HasConsistentHashMember(const char *cname); 7413{; 7414 // Hand selection of correct classes, those classes should be; 7415 // cross-checked in testHashRecursiveRemove.cxx; 7416 static const char *handVerified[] = {; 7417 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7418 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7419 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7420 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7421 ""TQClass"", ""TGlobal"" };; 7422 ; 7423 if (cname && cname[0]) {; 7424 for (auto cursor : handVerified) {; 7425 if (strcmp(cname, cursor) == 0); 7426 return true;; 7427 }; 7428 }; 7429 return false;; 7430}; 7431 ; 7432///////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:284459,safe,safe,284459,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['safe'],['safe']
Safety,"reate a two-dimensional TEfficiency object with; 104- name = ""eff""; 105- title = ""my efficiency""; 106- axis titles: x, y and LaTeX-formatted epsilon as a label for Z axis; 107- 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge; 108 from the first bin) up to 10 (upper edge of last bin); 109- 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower; 110 edge from the first bin) up to 5 (upper edge of last bin); 111 ; 112 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);; 113 ; 114If you already have two histograms filled with the number of passed and total; 115events, you will use the constructor TEfficiency(const TH1& passed,const TH1& total); 116to construct the TEfficiency object. The histograms ""passed"" and ""total"" have; 117to fulfill the conditions mentioned in TEfficiency::CheckConsistency, otherwise the construction will fail.; 118As the histograms already exist, the new TEfficiency is by default **not** attached; 119to the current directory to avoid duplication of data. If you want to store the; 120new object anyway, you can either write it directly by calling TObject::Write or attach it to a directory using TEfficiency::SetDirectory.; 121This also applies to TEfficiency objects created by the copy constructor TEfficiency::TEfficiency(const TEfficiency& rEff).; 122 ; 123\anchor EFF02a; 124### Example 1; 125 ; 126~~~~~~~~~~~~~~~{.cpp}; 127TEfficiency* pEff = 0;; 128TFile* pFile = new TFile(""myfile.root"",""recreate"");; 129 ; 130//h_pass and h_total are valid and consistent histograms; 131if(TEfficiency::CheckConsistency(h_pass,h_total)); 132{; 133 pEff = new TEfficiency(h_pass,h_total);; 134 // this will write the TEfficiency object to ""myfile.root""; 135 // AND pEff will be attached to the current directory; 136 pEff->Write();; 137}; 138~~~~~~~~~~~~~~~; 139 ; 140\anchor EFF02b; 141### Example 2; 142 ; 143~~~~~~~~~~~~~~~{.cpp}; 144TEfficiency* pEff = 0;; 145TFile* pFile = new TFile(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:5400,avoid,avoid,5400,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['avoid'],['avoid']
Safety,"reate an application environment. ;  ; virtual ~TApplication ();  TApplication dtor. ;  ; virtual const char * ApplicationName () const;  ; Int_t Argc () const;  ; char ** Argv () const;  ; char * Argv (Int_t index) const;  Return specified argument. ;  ; void ClearInputFiles ();  Clear list containing macro files passed as program arguments. ;  ; EExitOnException ExitOnException (EExitOnException opt=kExit);  Set the exit on exception option. ;  ; virtual TApplicationImp * GetApplicationImp ();  ; TApplication * GetAppRemote () const;  ; const char * GetIdleCommand () const;  ; virtual void GetOptions (Int_t *argc, char **argv);  Get and handle command line options. ;  ; TString GetSetup ();  It gets the ROOT installation setup as TString. ;  ; TSignalHandler * GetSignalHandler () const;  ; virtual void HandleException (Int_t sig);  Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingException) trapped in TSystem. ;  ; virtual void HandleIdleTimer ();  Handle idle timeout. ;  ; virtual Bool_t HandleTermInput ();  ; virtual void Hide ();  ; virtual void Iconify ();  ; virtual void Init ();  ; void InitializeGraphics (Bool_t only_web=kFALSE);  Initialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:2867,timeout,timeout,2867,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['timeout'],['timeout']
Safety,"reateChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range named rangeName with integrand normalized over observables in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:79564,unsafe,unsafe,79564,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,1,['unsafe'],['unsafe']
Safety,"reated baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::fBasketBytesInt_t * fBasketBytes[fMaxBaskets] Length of baskets on fileDefinition TBranch.h:141; TBranch::fNextBasketEntryLong64_t fNextBasketEntry! Next entry that will requires us to go to the next basketDefinition TBranch.h:132; TBranch::IsAutoDeletebool IsAutoDelete() constReturn true if an existing object in a TBranc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:135240,avoid,avoid,135240,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['avoid'],['avoid']
Safety,"reated via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUDPSocket.html:13234,timeout,timeout,13234,root/html534/TUDPSocket.html,https://root.cern,https://root.cern/root/html534/TUDPSocket.html,6,['timeout'],['timeout']
Safety,"received bytes. Returns -1 in case of error. In case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 867 of file TUDPSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TUDPSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 898 of file TUDPSocket.cxx. ◆ Select(). Int_t TUDPSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 407 of file TUDPSocket.cxx. ◆ Send() [1/4]. Int_t TUDPSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Definition at line 464 of file TUDPSocket.cxx. ◆ Send() [2/4]. Int_t TUDPSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUDPSocket.html:29100,timeout,timeout,29100,doc/master/classTUDPSocket.html,https://root.cern,https://root.cern/doc/master/classTUDPSocket.html,1,['timeout'],['timeout']
Safety,"rectives). virtual . Directives has the same syntax as the argument of SetMakeSharedLib but is used to create an executable. ; This creation is used as a means to output a list of unresolved symbols, when loading a shared library has failed. The required variable is $ExeName rather than $SharedLib, e.g.: gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; TSystem::SetMakeExevirtual void SetMakeExe(const char *directives)Directives has the same syntax as the argument of SetMakeSharedLib but is used to create an executabl...Definition TSystem.cxx:4093. Definition at line 4093 of file TSystem.cxx. ◆ SetMakeSharedLib(). void TSystem::SetMakeSharedLib ; (; const char * ; directives). virtual . Directives should contain the description on how to compile and link a shared lib. ; This description can be any valid shell command, including the use of ';' to separate several instructions. However, shell specific construct should be avoided. In particular this description can contain environment variables, like $ROOTSYS (or ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; valueOption_t Option_t TPoint TPoint const char Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:88558,avoid,avoided,88558,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['avoid'],['avoided']
Safety,"rectory->WriteTObject(this); //nbytes will be 0 if Write failed (disk space exceeded); 1523 if (nbytes && key && strcmp(ClassName(), key->GetClassName()) == 0) {; 1524 key->Delete();; 1525 delete key;; 1526 }; 1527 }; 1528 // save StreamerInfo; 1529 TFile *file = fDirectory->GetFile();; 1530 if (file) file->WriteStreamerInfo();; 1531 ; 1532 if (opt.Contains(""saveself"")) {; 1533 fDirectory->SaveSelf();; 1534 //the following line is required in case GetUserInfo contains a user class; 1535 //for which the StreamerInfo must be written. One could probably be a bit faster (Rene); 1536 if (file) file->WriteHeader();; 1537 }; 1538 ; 1539 return nbytes;; 1540}; 1541 ; 1542namespace {; 1543 // This error message is repeated several times in the code. We write it once.; 1544 const char* writeStlWithoutProxyMsg = ""The class requested (%s) for the branch \""%s\""""; 1545 "" is an instance of an stl collection and does not have a compiled CollectionProxy.""; 1546 "" Please generate the dictionary for this collection (%s) to avoid to write corrupted data."";; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Same as TTree::Branch() with added check that addobj matches className.; 1551///; 1552/// \see TTree::Branch() for other details.; 1553///; 1554 ; 1555TBranch* TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); 1556{; 1557 TClass* claim = TClass::GetClass(classname);; 1558 if (!ptrClass) {; 1559 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1560 Error(""Branch"", writeStlWithoutProxyMsg,; 1561 claim->GetName(), branchname, claim->GetName());; 1562 return nullptr;; 1563 }; 1564 return Branch(branchname, classname, (void*) addobj, bufsize, splitlevel);; 1565 }; 1566 TClass* actualClass = nullptr;; 1567 void** addr = (void**) addobj;; 1568 if (addr) {; 1569 actualClass = ptrClass->GetA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:57450,avoid,avoid,57450,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"red singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix. In this case, the user will have to reduce the tolerance number by this factor. (For CPU time saving we decided not to make this an automatic procedure).; 14.6.2 Condition number; The numerical accuracy of the solution x in Ax = b can be accurately estimated by calculating the condition number k of matrix \(A\), which is defined as:; \(k = ||A||_{1}||A^{-1}||_{1}\) where \(||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)\); A good rule of thumb is that if the matrix condition number is 10n, the accuracy in x is 15 - n digits for double precision.; Hager devised an iterative method (W.W. Hager, Condition estimators, SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to determine \(||A^{-1}||_{1}\) without actually having to calculate \(A^{-1}\). It is used when calling Condition().; A code example below shows the usage of the condition number. The matrix \(A\) is a (10x10) Hilbert matrix tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:794338,detect,detect,794338,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['detect'],['detect']
Safety,"reference. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 56;}. TGeoConeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:21898,safe,safe,21898,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"reference. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 56;}. TGeoConeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoConeSeg.html:23650,safe,safe,23650,root/html604/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html604/TGeoConeSeg.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"reference. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 56;}. TGeoConeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoConeSeg.html:23650,safe,safe,23650,root/html602/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html602/TGeoConeSeg.html,5,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"reference. For instance, for a box having DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to exiting a shape from a given point INSIDE, along a given direction. The direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of IACT input parameter : :IACT = 0 => compute only safe distance and fill it at the location given by SAFESAFEIACT = 1 => a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned..IACT = 2 => compute both safe distance and distance to exiting, ignoring the proposed step..IACT > 2 => compute only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t</h4> safe) computes the distance to entering a shape from a given point OUTSIDE. Acts in the same way as B). Double_t Safety(const Double_t *point[3], Bool_t inside); compute maximum shift of a point in any direction that does not change its INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point have to be properly supplied.; Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside); returns director cosines of normal to the crossed shape surface from a given point towards a direction. One has to specify if the point is inside or outside shape. According to this, the normal will be outwards or inwards shape respectively. Normal components are statically stored by shape class, so it has to be copied after retrieval in a diffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoShape.html:5524,safe,safe,5524,doc/master/classTGeoShape.html,https://root.cern,https://root.cern/doc/master/classTGeoShape.html,1,['safe'],['safe']
Safety,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMD5.html:4708,safe,safely,4708,root/html528/TMD5.html,https://root.cern,https://root.cern/root/html528/TMD5.html,2,['safe'],['safely']
Safety,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMD5.html:4708,safe,safely,4708,root/html530/TMD5.html,https://root.cern,https://root.cern/root/html530/TMD5.html,2,['safe'],['safely']
Safety,"reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMD5.html:4708,safe,safely,4708,root/html532/TMD5.html,https://root.cern,https://root.cern/root/html532/TMD5.html,4,['safe'],['safely']
Safety,"rence< InvokeResult_t< F, T... > >::value &&!std::is_void< InvokeResult_t< F, T... > >::value >;  type definition used in templated functions for not allowing mapping functions that return references or void. ;  . #include <ROOT/TThreadExecutor.hxx>. Inheritance diagram for ROOT::TThreadExecutor:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TThreadExecutor() [1/2]. ROOT::TThreadExecutor::TThreadExecutor ; (; UInt_t ; nThreads = 0u). explicit . Class constructor. ; If the scheduler is active (e.g. because another TThreadExecutor is in flight, or ROOT::EnableImplicitMT() was called), work with the current pool of threads. If not, initialize the pool of threads, spawning nThreads. nThreads' default value, 0, initializes the pool with as many logical threads as are available in the system (see NLogicalCores in RTaskArenaWrapper.cxx).; At construction time, TThreadExecutor automatically enables ROOT's thread-safety locks as per calling ROOT::EnableThreadSafety(). ; Definition at line 149 of file TThreadExecutor.cxx. ◆ TThreadExecutor() [2/2]. ROOT::TThreadExecutor::TThreadExecutor ; (; const TThreadExecutor & ; ). delete . Member Function Documentation. ◆ Foreach() [1/5]. template<class F , class T > . void ROOT::TThreadExecutor::Foreach ; (; F ; func, . const std::vector< T > & ; args, . unsigned ; nChunks = 0 . ). Execute a function in parallel over the elements of a immutable vector, dividing the execution in nChunks. ; Parameters. funcFunction to be executed on the elements of the vector passed as second parameter. ; argsImmutable vector of elements passed as an argument to func. ; nChunksNumber of chunks to split the input data for processing. . Definition at line 231 of file TThreadExecutor.hxx. ◆ Foreach() [2/5]. template<class F , class INTEGER > . void ROOT::TThreadExecutor::Foreach ; (; F ; func, . ROOT::TSeq< INTEGER > ; args, . unsigned ; nChunks = 0 . ). Execute a fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:16178,safe,safety,16178,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,2,['safe'],['safety']
Safety,"renced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; ROOT::Fit::Fitter*fFractionFitterpointer to Fitter class; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:11876,predict,predictions,11876,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,8,['predict'],['predictions']
Safety,"rent iteration over this formula for this entry (i.e. varies from 0 to Length$).; Length$(formula ) : return the total number of element of the formula given as a parameter.; Sum$(formula ) : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with: Sum$(formula )/Length$(formula ); Min$(formula ) : return the minimum (within one TTree entry) of the value of the elements of the formula given as a parameter.; Max$(formula ) : return the maximum (within one TTree entry) of the value of the elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition) : return the minimum (maximum) (within one TTree entry) of the value of the elements of the formula given as a parameter if they match the condition. If no element matches the condition, the result is zero. To avoid the resulting peak at zero, use the pattern: tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match for the condition.; Alt$(primary,alternate) : return the value of ""primary"" if it is available for the current iteration otherwise return the value of ""alternate"". For example, with arr1[3] and arr2[2] tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0 Or with a variable size array arr3 tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1) As a comparison tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using Alt$ with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by TTree::Draw, TTree::Scan can be used: tree->Scan(""arr1:Alt$(arr2,0)"")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:125655,avoid,avoid,125655,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,4,['avoid'],['avoid']
Safety,rent node; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoHMatrix*fDivMatrix! current local matrix of the selected division cell; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNavigator.html:11815,safe,safety,11815,root/html602/TGeoNavigator.html,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html,16,['safe'],"['safe', 'safety']"
Safety,"rent value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:10812,safe,safely,10812,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,3,['safe'],['safely']
Safety,replayer interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury infor,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:114126,safe,safe,114126,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,"['detect', 'safe']","['detector', 'safe']"
Safety,"resentative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfAverageEvtPerBinaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarBaverage events per bin; used to calculate fNbins; Int_t*fAverageEvtPerBinVarSaverage events per bin; used to calculate fNbins; TStringfBorderMethodStringthe method to take care about ""border"" effects (string); TMVA::PDF*fDefaultPDFLikpdf that contains default definitions; Int_tfDropVariablefor ranking test; Double_tfEpsilonminimum number of likelihood (to avoid zero); vector<TH1*>*fHistBgdbackground PDFs (histograms); vector<TH1*>*fHistBgd_smoothbackground PDFs (smoothed histograms); vector<TH1*>*fHistSigsignal PDFs (histograms); vector<TH1*>*fHistSig_smoothsignal PDFs (smoothed histograms); TString*fInterpolateStringwhich interpolation method used for reference histograms (individual for each variable); Float_tfKDEfineFactorfine tuning factor for Adaptive KDE; TStringfKDEiterStringNumber of iterations (string); TStringfKDEtypeStringKernel type to use for KDE (string); Int_tfNsmoothnumber of smooth passes; Int_t*fNsmoothVarBnumber of smooth passes; Int_t*fNsmoothVarSnumber of smooth passes; vector<PDF*>*fPDFBgdlist of PDFs (background); vector<PDF*>*fPDFSiglist of PDFs (signal) ; Bool_tfTransformLikelihoodOutputlikelihood output is sigmoid-transformed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLikelihood(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodLikelihood(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodLikelihood.html:18231,avoid,avoid,18231,root/html528/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html,1,['avoid'],['avoid']
Safety,"resize (all others). The expected values are: . Implements TVirtualPad.; Definition at line 6350 of file TPad.cxx. ◆ StartEditing(). virtual void TPad::StartEditing ; (; ). inlinevirtual . Definition at line 417 of file TPad.h. ◆ Streamer(). void TPad::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TObject.; Reimplemented in TSlider.; Definition at line 6713 of file TPad.cxx. ◆ StreamerNVirtual(). void TPad::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 419 of file TPad.h. ◆ Update(). void TPad::Update ; (; ). overridevirtual . Update pad. ; Implements TVirtualPad.; Definition at line 2935 of file TPad.cxx. ◆ UpdateAsync(). void TPad::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2947 of file TPad.cxx. ◆ UseCurrentStyle(). void TPad::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in pad. ; Reimplemented from TObject.; Definition at line 6927 of file TPad.cxx. ◆ UtoAbsPixel(). Int_t TPad::UtoAbsPixel ; (; Double_t ; u); const. overridevirtual . Convert X NDC to absolute pixel. ; Implements TVirtualPad.; Definition at line 7459 of file TPad.cxx. ◆ UtoPixel(). Int_t TPad::UtoPixel ; (; Double_t ; u); const. overridevirtual . Convert X NDC to pixel. ; Implements TVirtualPad.; Definition at line 7433 of file TPad.cxx. ◆ VtoAbsPixel(). Int_t TPad::VtoAbsPixel ; (; Double_t ; v); const. overridevirtual . Convert Y NDC to absolute pixel. ; Implements TVirtualPad.; Definition at line 7467 of file TPad.cxx. ◆ VtoPixel(). Int_t TPad::VtoPixel ; (; Double_t ; v); const. overridevirtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:127593,avoid,avoid,127593,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['avoid'],['avoid']
Safety,"rest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:11629,timeout,timeout,11629,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,10,['timeout'],['timeout']
Safety,"restore previous behaviour.; 874 ; 875void TUnixSystem::ResetSignal(ESignals sig, Bool_t reset); 876{; 877 if (reset); 878 UnixResetSignal(sig);; 879 else; 880 UnixSignal(sig, SigHandler);; 881}; 882 ; 883////////////////////////////////////////////////////////////////////////////////; 884/// Reset signals handlers to previous behaviour.; 885 ; 886void TUnixSystem::ResetSignals(); 887{; 888 UnixResetSignals();; 889}; 890 ; 891////////////////////////////////////////////////////////////////////////////////; 892/// If ignore is true ignore the specified signal, else restore previous; 893/// behaviour.; 894 ; 895void TUnixSystem::IgnoreSignal(ESignals sig, Bool_t ignore); 896{; 897 UnixIgnoreSignal(sig, ignore);; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// When the argument is true the SIGALRM signal handler is set so that; 902/// interrupted syscalls will not be restarted by the kernel. This is; 903/// typically used in case one wants to put a timeout on an I/O operation.; 904/// By default interrupted syscalls will always be restarted (for all; 905/// signals). This can be controlled for each a-synchronous TTimer via; 906/// the method TTimer::SetInterruptSyscalls().; 907 ; 908void TUnixSystem::SigAlarmInterruptsSyscalls(Bool_t set); 909{; 910 UnixSigAlarmInterruptsSyscalls(set);; 911}; 912 ; 913////////////////////////////////////////////////////////////////////////////////; 914/// Return the bitmap of conditions that trigger a floating point exception.; 915 ; 916Int_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:27319,timeout,timeout,27319,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['timeout'],['timeout']
Safety,"resultPtr.GetValue() << std::endl;; 1270}; 1271~~~; 1272 ; 1273See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1274for a more complete example.; 1275 ; 1276#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1277 ; 1278Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1279executes the callable on the values of those columns for each event that passes all upstream selections.; 1280It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1281evaluates the root mean square of column ""x"":; 1282~~~{.cpp}; 1283// Single-thread evaluation of RMS of column ""x"" using Foreach; 1284double sumSq = 0.;; 1285unsigned int n = 0;; 1286df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1287std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1288~~~; 1289In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1290thread will execute the expression concurrently.; 1291The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1292this is probably too much head-scratch for such a simple operation.; 1293 ; 1294ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1295additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1296guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1297executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1298We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1299~~~{.cpp}; 1300// Thread-safe evaluation of RMS of column ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:74698,safe,safety,74698,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['safe'],['safety']
Safety,"resultPtr.GetValue() << std::endl;; 1310}; 1311~~~; 1312 ; 1313See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1314for a more complete example.; 1315 ; 1316#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1317 ; 1318Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1319executes the callable on the values of those columns for each event that passes all upstream selections.; 1320It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1321evaluates the root mean square of column ""x"":; 1322~~~{.cpp}; 1323// Single-thread evaluation of RMS of column ""x"" using Foreach; 1324double sumSq = 0.;; 1325unsigned int n = 0;; 1326df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1327std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1328~~~; 1329In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1330thread will execute the expression concurrently.; 1331The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1332this is probably too much head-scratch for such a simple operation.; 1333 ; 1334ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1335additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1336guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1337executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1338We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1339~~~{.cpp}; 1340// Thread-safe evaluation of RMS of column ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:76378,safe,safety,76378,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['safe'],['safety']
Safety,"return 0;; 1931 ; 1932 TString stem(fname);; 1933 // Remove extension if any, ignore files with extension not being .h*; 1934 Int_t where = stem.Last('.');; 1935 if (where != kNPOS) {; 1936 if (stem.EndsWith("".so"") || stem.EndsWith("".sl"") ||; 1937 stem.EndsWith("".dl"") || stem.EndsWith("".a"") ||; 1938 stem.EndsWith("".dll"", TString::kIgnoreCase)); 1939 return 0;; 1940 stem.Remove(where);; 1941 }; 1942 ; 1943 TString className = gSystem->BaseName(stem);; 1944 TClass* cla = R__GetClassIfKnown(className);; 1945 if (!cla) {; 1946 // Try again with modifications to the file name:; 1947 className = stem;; 1948 className.ReplaceAll(""/"", ""::"");; 1949 className.ReplaceAll(""\\"", ""::"");; 1950 if (className.Contains("":::"")) {; 1951 // ""C:\dir"" becomes ""C:::dir"".; 1952 // fname corresponds to whatever is stated after #include and; 1953 // a full path name usually means that it's not a regular #include; 1954 // but e.g. a "".L"", so we can assume that this is not a header of; 1955 // a class in a namespace (a global-namespace class would have been; 1956 // detected already before).; 1957 return 0;; 1958 }; 1959 cla = R__GetClassIfKnown(className);; 1960 }; 1961 ; 1962 if (!cla) {; 1963 return 0;; 1964 }; 1965 ; 1966 // cla is valid, check wether it's actually in the header of the same name:; 1967 if (cla->GetDeclFileLine() <= 0) return 0; // to a void an error with VisualC++; 1968 TString decfile = gSystem->BaseName(cla->GetDeclFileName());; 1969 if (decfile != gSystem->BaseName(fname)) {; 1970 return 0;; 1971 }; 1972 return 1;; 1973}; 1974 ; 1975////////////////////////////////////////////////////////////////////////////////; 1976/// Initialize operating system interface.; 1977 ; 1978void TROOT::InitSystem(); 1979{; 1980 if (gSystem == nullptr) {; 1981#if defined(R__UNIX); 1982#if defined(R__HAS_COCOA); 1983 gSystem = new TMacOSXSystem;; 1984#else; 1985 gSystem = new TUnixSystem;; 1986#endif; 1987#elif defined(R__WIN32); 1988 gSystem = new TWinNTSystem;; 1989#else; 1990 gSystem = new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:75339,detect,detected,75339,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['detect'],['detected']
Safety,"return 0;; 212 }; 213 ; 214 void HandleReferencedTObject(TBuffer &buf, void *addr, const TConfiguration *config) {; 215 TBitsConfiguration *conf = (TBitsConfiguration*)config;; 216 UShort_t pidf;; 217 buf >> pidf;; 218 pidf += buf.GetPidOffset();; 219 TProcessID *pid = buf.ReadProcessID(pidf);; 220 if (pid!=0) {; 221 TObject *obj = (TObject*)( ((char*)addr) + conf->fObjectOffset);; 222 UInt_t gpid = pid->GetUniqueID();; 223 UInt_t uid;; 224 if (gpid>=0xff) {; 225 uid = obj->GetUniqueID() | 0xff000000;; 226 } else {; 227 uid = ( obj->GetUniqueID() & 0xffffff) + (gpid<<24);; 228 }; 229 obj->SetUniqueID(uid);; 230 pid->PutObjectWithID(obj);; 231 }; 232 }; 233 ; 234 template <>; 235 INLINE_TEMPLATE_ARGS Int_t ReadBasicType<BitsMarker>(TBuffer &buf, void *addr, const TConfiguration *config); 236 {; 237 UInt_t *x = (UInt_t*)( ((char*)addr) + config->fOffset );; 238 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 239 // Idea: This code really belongs inside TBuffer[File]; 240 const UInt_t isonheap = *x & TObject::kIsOnHeap; // Record how this instance was actually allocated.; 241 buf >> *x;; 242 *x |= isonheap | TObject::kNotDeleted; // by definition de-serialized object are not yet deleted.; 243 ; 244 if ((*x & kIsReferenced) != 0) {; 245 HandleReferencedTObject(buf,addr,config);; 246 }; 247 return 0;; 248 }; 249 ; 250 template <typename T>; 251 INLINE_TEMPLATE_ARGS Int_t WriteBasicType(TBuffer &buf, void *addr, const TConfiguration *config); 252 {; 253 T *x = (T *)(((char *)addr) + config->fOffset);; 254 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 255 buf << *x;; 256 return 0;; 257 }; 258 ; 259 INLINE_TEMPLATE_ARGS Int_t WriteTextTNamed(TBuffer &buf, void *addr, const TConfiguration *config); 260 {; 261 void *x = (void *)(((char *)addr) + config->fOffset);; 262 // Idea: Implement buf.ReadBasic/Primitive to avoid the return value; 263 buf.StreamObject(x, TNamed::Class(), TNamed::Class());; 264 return 0;; 265 }; 266 ; 267 INLI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:8657,avoid,avoid,8657,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['avoid'],['avoid']
Safety,"return fDrawCameraCenter; }. void PickCameraCenter(); { fPushAction = kPushCamCenter; RefreshPadEditor(this); }. void PickAnnotate(); { fPushAction = kPushAnnotate; RefreshPadEditor(this); }. TGLCameraOverlay* GetCameraOverlay() const; { return fCameraOverlay; }. void SetCameraOverlay(TGLCameraOverlay* m); { fCameraOverlay = m; }. Bool_t GetStereo() const; Stereo. { return fStereo; }. Float_t GetStereoZeroParallax() const; { return fStereoZeroParallax; }. Float_t GetStereoEyeOffsetFac() const; { return fStereoEyeOffsetFac; }. Float_t GetStereoFrustumAsymFac() const; { return fStereoFrustumAsymFac; }. void SetStereoZeroParallax(Float_t f); { fStereoZeroParallax = f; }. void SetStereoEyeOffsetFac(Float_t f); { fStereoEyeOffsetFac = f; }. void SetStereoFrustumAsymFac(Float_t f); { fStereoFrustumAsymFac = f; }. EPushAction GetPushAction() const; Push / drag action. { return fPushAction; }. EDragAction GetDragAction() const; { return fDragAction; }. Float_t GetMaxSceneDrawTimeHQ() const; Draw and selection; Scene rendering timeouts. { return fMaxSceneDrawTimeHQ; }. Float_t GetMaxSceneDrawTimeLQ() const; { return fMaxSceneDrawTimeLQ; }. void SetMaxSceneDrawTimeHQ(Float_t t); { fMaxSceneDrawTimeHQ = t; }. void SetMaxSceneDrawTimeLQ(Float_t t); { fMaxSceneDrawTimeLQ = t; }. const char* GetPictureFileName() const; { return fPictureFileName.Data(); }. void SetPictureFileName(const TString& f); { fPictureFileName = f; }. Float_t GetFader() const; { return fFader; }. void SetFader(Float_t x); { fFader = x; }. Bool_t GetIgnoreSizesOnUpdate() const; { return fIgnoreSizesOnUpdate; }. void SetIgnoreSizesOnUpdate(Bool_t v); { fIgnoreSizesOnUpdate = v; }. Bool_t GetResetCamerasOnUpdate() const; { return fResetCamerasOnUpdate; }. void SetResetCamerasOnUpdate(Bool_t v); { fResetCamerasOnUpdate = v; }. void Activated(); { Emit(""Activated()""); }. void DoubleClicked(); { Emit(""DoubleClicked()""); }. TGEventHandler * GetEventHandler() const; { return fEventHandler; }. TGedEditor* GetGedEdito",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLViewer.html:41291,timeout,timeouts,41291,root/html604/TGLViewer.html,https://root.cern,https://root.cern/root/html604/TGLViewer.html,2,['timeout'],['timeouts']
Safety,"rgetDir = __null); construction from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Cuts can only handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. ~MethodCuts( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; Method <string> Minimisation method; available values are: MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method; available values are: EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_t GetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; retrieve cut values for given signal efficiency. void Train( void ); training method: here the cuts are optimised for the training sample. void TestClassification(); nothing to test. Double_t EstimatorFunction(Int_t ievt1, Int_t ievt2); for full event scan. Double_t EstimatorFunction(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA. Double_t ComputeEstimator(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA; there are two requirements:; 1) the sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCuts.html:24082,sanity check,sanity check,24082,root/html602/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCuts.html,4,['sanity check'],['sanity check']
Safety,"rgs() methods to advertise the algorithms they provide.; 1521 ; 1522Int_t RooAbsPdf::getGenerator(const RooArgSet &/*directVars*/, RooArgSet &/*generatedVars*/, bool /*staticInitOK*/) const; 1523{; 1524 return 0 ;; 1525}; 1526 ; 1527 ; 1528 ; 1529////////////////////////////////////////////////////////////////////////////////; 1530/// Interface for one-time initialization to setup the generator for the specified code.; 1531 ; 1532void RooAbsPdf::initGenerator(Int_t /*code*/); 1533{; 1534}; 1535 ; 1536 ; 1537 ; 1538////////////////////////////////////////////////////////////////////////////////; 1539/// Interface for generation of an event using the algorithm; 1540/// corresponding to the specified code. The meaning of each code is; 1541/// defined by the getGenerator() implementation. The default; 1542/// implementation does nothing.; 1543 ; 1544void RooAbsPdf::generateEvent(Int_t /*code*/); 1545{; 1546}; 1547 ; 1548 ; 1549 ; 1550////////////////////////////////////////////////////////////////////////////////; 1551/// Check if given observable can be safely generated using the; 1552/// pdfs internal generator mechanism (if that existsP). Observables; 1553/// on which a PDF depends via more than route are not safe; 1554/// for use with internal generators because they introduce; 1555/// correlations not known to the internal generator; 1556 ; 1557bool RooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; 1558{; 1559 // Arg must be direct server of self; 1560 if (!findServer(arg.GetName())) return false ;; 1561 ; 1562 // There must be no other dependency routes; 1563 for (const auto server : _serverList) {; 1564 if(server == &arg) continue;; 1565 if(server->dependsOn(arg)) {; 1566 return false ;; 1567 }; 1568 }; 1569 ; 1570 return true ;; 1571}; 1572 ; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Generate a new dataset containing the specified variables with events sampled from our distribution.; 1576/// \param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:75978,safe,safely,75978,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['safe'],['safely']
Safety,"ri, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMinuit.html:56138,safe,safely,56138,root/html604/TMinuit.html,https://root.cern,https://root.cern/root/html604/TMinuit.html,2,['safe'],['safely']
Safety,"riable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMinuitMinimizer.html:9316,avoid,avoid,9316,root/html530/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html530/TMinuitMinimizer.html,1,['avoid'],['avoid']
Safety,"riable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMinuitMinimizer.html:9364,avoid,avoid,9364,root/html532/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html,8,['avoid'],['avoid']
Safety,"riable is stored (i.e. one wants to be able to assign values to it): RooTemplateProxy<RooRealVar> Other template arguments are possible, as long as they derive from RooAbsArg. Increment the class version of the owning class.; Make sure that the right type is passed in the constructor of the proxy.; Always use proxy-> and *proxy to work with the stored object. No need to cast.; Only if necessary If errors about missing symbols connected to RooTemplateProxy appear at link time, a specific template instantiation for RooTemplateProxy is not yet in ROOT's dictionaries. These two lines should be added to the LinkDef.h of the project: #pragma link C++ class RooTemplateProxy<RooMultiCategory>+;; #pragma read sourceClass=""RooCategoryProxy"" targetClass=""RooTemplateProxy<RooMultiCategory>""; Replace RooMultiCategory by the proper type. If the proxy was holding a real-valued object, use sourceClass=""RooRealProxy"".; The first line adds the proxy class to the dictionary, the second line enables reading a legacy RooCategoryProxy from a file, and converting it to the new type-safe proxy. If no old proxies have to be read from files, this line can be omitted.; If the template instantiation that triggered the missing symbols seems to be a very common instantiation, request for it to be added to RooFit by creating a pull request for ROOT. If it is rather uncommon, it is sufficient to add it to the LinkDef.h of the local project only. . Definition at line 152 of file RooTemplateProxy.h. Public Member Functions;  RooTemplateProxy ();  ; template<typename Bool = bool, typename = std::enable_if_t<std::is_same<Bool,bool>::value>> ;  RooTemplateProxy (const char *theName, const char *desc, RooAbsArg *owner, Bool valueServer=true, bool shapeServer=false);  Constructor with owner. ;  ; TClass * IsA () const override;  ; const LValue_t * lvptr (const LValue_t *) const;  Return l-value pointer to contents. ;  ; const LValue_t * lvptr (const RooAbsArg *) const;  Return l-value pointer to contents.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTemplateProxy.html:5120,safe,safe,5120,doc/master/classRooTemplateProxy.html,https://root.cern,https://root.cern/doc/master/classRooTemplateProxy.html,1,['safe'],['safe']
Safety,"riable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf302_utilfuncsDefinition rf302_utilfuncs.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calcul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8C.html:5690,safe,safe,5690,doc/master/rf302__utilfuncs_8C.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8C.html,1,['safe'],['safe']
Safety,"rials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development ROOT 7. For the first time since 20 year (i.e. ever), the ROOT team plans to break backward compatibility for crucial interfaces - once.; This new major version of ROOT will make ROOT much simpler and safer to use: we want to increase clarity and usability.; If you are a physicist, please read on - this is about your ROOT.; The ROOT team will be releasing parts of ROOT 7 throughout the coming years.; Previews will gradually sneak into the ROOT sources, in the namespace ROOT::Experimental for those parts that are not yet cast in stone, and in the namespace ROOT for those that are.; We will use standard C++ types, standard interface behavior (e.g. with respect to ownership and thread safety), good documentation and tests: we are trying to be nice!; Feedback; The main point of the meeting and this page is to solicit your feedback. Most of it has been taken care of in the code already.; Building ROOT 7; Pre-requisites; Support for the c++14 standard is required. Usage of g++ >= 5 or clang >= 3.4 is recommended.; Relevant cmake variables; The CMAKE_CXX_STANDARD cmake variables must be set to at least 14.; Building from source would look similar to this:; $ mkdir root7_build; $ cd roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-7.html:2056,safe,safer,2056,d/root-7.html,https://root.cern,https://root.cern/d/root-7.html,1,['safe'],['safer']
Safety,"ribe the transformations defined as a composition between a rotation and a translation using the class ROOT::Math::Transform3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.; The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see ROOT::Math::VectorUtil). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. 13.12.1.7 Naming Convention; As part of ROOT, the GenVector package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:. Every class and function is in the R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:725088,Avoid,Avoiding,725088,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Avoid'],['Avoiding']
Safety,"ride;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; void DrawPolygon (Option_t *option="""");  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *, TGeoMatrix *) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; Int_t GetNvert () const;  ; Int_t GetNz () const;  ; Double_t GetScale (Int_t i) const;  ; ThreadData_t & GetThreadData () const;  ; Double_t GetX (Int_t i) const;  ; Double_t GetXOffset (Int_t i) const;  ; Double_t GetY (Int_t i) const;  ; Double_t GetYOffset (Int_t i) const;  ; Double_t * GetZ () const;  ; Double_t GetZ (Int_t ipl) const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetCurrentVertices (Double_t x0, Double_t y0, Double_t scale);  ; void SetCurrentZ (Double_t z, Int_t iz);  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buff) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoXtru.html:2953,safe,safe,2953,doc/master/classTGeoXtru.html,https://root.cern,https://root.cern/doc/master/classTGeoXtru.html,1,['safe'],['safe']
Safety,"ridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ Contains_v(). void TGeoCone::Contains_v ; (; const Double_t * ; points, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ DeclFileName(). static const char * TGeoCone::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 96 of file TGeoCone.h. ◆ DistancetoPrimitive(). Int_t TGeoCone::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ DistFromInside(). Double_t TGeoCone::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ DistFromInside_v(). void TGeoCone::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ DistFromInsideS(). static Double_t TGeoCone::DistFromInsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; dz, . Double_t ; rmin1, . Double_t ; rmax1, . Double_t ; rmin2, . Double_t ; rmax2 . ). static . ◆ DistFromOutside(). Double_t TGeoCone::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoConeSeg. ◆ DistFromOutside_v(). void TGeoCone::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCone.html:26485,safe,safe,26485,doc/master/classTGeoCone.html,https://root.cern,https://root.cern/doc/master/classTGeoCone.html,1,['safe'],['safe']
Safety,"ridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ Contains_v(). void TGeoTube::Contains_v ; (; const Double_t * ; points, . Bool_t * ; inside, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DeclFileName(). static const char * TGeoTube::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 91 of file TGeoTube.h. ◆ DistancetoPrimitive(). Int_t TGeoTube::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromInside(). Double_t TGeoTube::DistFromInside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromInside_v(). void TGeoTube::DistFromInside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsize, . Double_t * ; step . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromInsideS(). static Double_t TGeoTube::DistFromInsideS ; (; const Double_t * ; point, . const Double_t * ; dir, . Double_t ; rmin, . Double_t ; rmax, . Double_t ; dz . ). static . ◆ DistFromOutside(). Double_t TGeoTube::DistFromOutside ; (; const Double_t * ; point, . const Double_t * ; dir, . Int_t ; iact = 1, . Double_t ; step = TGeoShape::Big(), . Double_t * ; safe = nullptr . ); const. overridevirtual . Reimplemented from TGeoBBox.; Reimplemented in TGeoTubeSeg. ◆ DistFromOutside_v(). void TGeoTube::DistFromOutside_v ; (; const Double_t * ; points, . const Double_t * ; dirs, . Double_t * ; dists, . Int_t ; vecsiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTube.html:25815,safe,safe,25815,doc/master/classTGeoTube.html,https://root.cern,https://root.cern/doc/master/classTGeoTube.html,1,['safe'],['safe']
Safety,"ries. Function documentation; TDatime(); Create a TDatime and set it to the current time. TDatime(Int_t date, Int_t time); Create a TDatime and set it to the specified date and time.; See Set(Int_t, Int_t) about the date, time format. TDatime(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec); Create a TDatime and set it to the specified year, month,; day, time, hour, minute and second. See Set() about the format. TDatime(const char* sqlDateTime); Expects as input a string in SQL date/time compatible format, like:; yyyy-mm-dd hh:mm:ss. Int_t GetDayOfWeek() const; Returns day of week, with Monday being day 1 and Sunday day 7. const char * AsString() const; Return the date & time as a string (ctime() format).; Copy result because it points to a statically allocated string. const char * AsString(char* out) const; Return the date & time as a string (ctime() format).; Result is copied into out (and out is returned). Make sure; out can at least contain 26 characters. Thread safe. const char * AsSQLString() const; Return the date & time in SQL compatible string format, like:; 1997-01-15 20:16:28. The returned string buffer is static and; will be reused. UInt_t Convert(Bool_t toGMT = kFALSE) const; Convert fDatime from TDatime format to the standard time_t format.; If toGMT is true, the time offset of the current local time zone is; subtracted from the returned time_t. One use of such a non-standard time_t; value is to convert a TDatime object that contains local time to GMT,; as in this example:. TDatime now;; now.Set(now.Convert(kTRUE));. Caution: the time_t returned from Convert(kTRUE) is incompatible with; regular Unix time - it contains an artificial, locale-dependent offset. void Copy(TDatime& datime) const; Copy this to datime. void FillBuffer(char*& buffer); Encode Date/Time into buffer, used by I/O system. UInt_t Get() const; Return raw date/time as encoded by TDatime. Note, this value cannot; be used to e.g. calculate time differences, as it is a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDatime.html:3234,safe,safe,3234,root/html528/TDatime.html,https://root.cern,https://root.cern/root/html528/TDatime.html,10,['safe'],['safe']
Safety,"riestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TMap*fAssignedPackMap {worker,packetizer} of lat assignement; TVirtualPacketizer*fCurrentPacketizer being currently processed; TList*fPacketizersPacketizers to be processed; TIter*fPacketizersIterIterator on fPacketizers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerMulti(); Destructor. TDSetElement * GetNextPacket(TSlave* wrk, TMessage* r); Get next packet from the current packetizer.; If the current packetizer is done, move to next.; Retun null when all packetizers are done. TVirtualPacketizer * CreatePacketizer(TDSet* dset, TList* wrks, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Create a packetizer for dataset 'dset'; Return null on failure. TPacketizerMulti(). TPacketizerMulti(const TPacketizerMulti& ). void operator=(const TPacketizerMulti& ). Int_t GetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls). Float_t GetCurrentRate(Bool_t& all). void StopProcess(Bool_t abort). void MarkBad(TSlave* wrk, TProofProgressStatus* st, TList** missing); { if (fCurrent) fCurrent->MarkBad(wrk, st, missing); return; }. Int_t AddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing). Int_t GetActiveWorkers(); { if (fCurrent) return fCurrent->GetActiveWorkers(); return 0; }. » Author: G. Ganis Jan 2010 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Sep 23 20:19:01 2010 » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerMulti.html:10427,abort,abort,10427,root/html528/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html528/TPacketizerMulti.html,1,['abort'],['abort']
Safety,"rimary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:108945,detect,detector,108945,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['detect'],['detector']
Safety,"rimitive as a C++ statement(s) on output stream ""out"". ;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void Sizeof3D () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoBBox;  TGeoBBox ();  ;  TGeoBBox (const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  TGeoBBox (Double_t *param);  ;  TGeoBBox (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ;  ~TGeoBBox () override;  ; Bool_t CouldBeCrossed (const Double_t *point, const Double_t *dir) const override;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Computes distance from point (px,py) to the object. ;  ; const char * GetAxisName (Int_t iaxis) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void SetSegsAndPols (TBuffer3D &buffer) const override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPara.html:3964,avoid,avoid,3964,doc/master/classTGeoPara.html,https://root.cern,https://root.cern/doc/master/classTGeoPara.html,1,['avoid'],['avoid']
Safety,"rimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLocal(Bool_t client = kTRUE); TProofPlayerLocal(const TProofPlayerLocal&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLocal.html:11505,abort,abort,11505,root/html602/TProofPlayerLocal.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLocal.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"rint (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBtree.html:15914,safe,safe,15914,doc/master/classTBtree.html,https://root.cern,https://root.cern/doc/master/classTBtree.html,3,['safe'],['safe']
Safety,"rint (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:8304,safe,safe,8304,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['safe'],['safe']
Safety,"rint (Option_t *option="""") const override;  Print TBranch parameters. ;  ; void PrintCacheInfo () const;  Print the information we have about which basket is currently cached and whether they have been 'used'/'read' from the cache. ;  ; virtual void ReadBasket (TBuffer &b);  Loop on all leaves of this branch to read Basket buffer. ;  ; virtual void Refresh (TBranch *b);  Refresh this branch using new information in b This function is called by TTree::Refresh. ;  ; virtual void Reset (Option_t *option="""");  Reset a Branch. ;  ; virtual void ResetAddress ();  Reset the address of the branch. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Reset a Branch. ;  ; virtual void ResetReadEntry ();  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFirstEntry (Long64_t entry);  set the first entry nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookBranch.html:8231,avoid,avoid,8231,doc/master/classTHbookBranch.html,https://root.cern,https://root.cern/doc/master/classTHbookBranch.html,1,['avoid'],['avoid']
Safety,"riteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto holder = fWriteCurrent.load();; 167 if (holder != local) ConflictReport(holder, ""ReadLock with WriteLock taken"", collection, function);; 168 }; 169}; 170 ; 171void TCollection::TErrorLock::ReadUnlock(); 172{; 173 auto local = std::this_thread::get_id();; 174 {; 175 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 176 fReadSet.erase(local); // this is not thread safe ...; 177 }; 178 --fReadCurrentRecurse;; 179}; 180 ; 181#endif // R__CHECK_COLLECTION_MULTI_ACCESS; 182 ; 183////////////////////////////////////////////////////////////////////////////////; 184/// TNamed destructor.; 185 ; 186TCollection::~TCollection(); 187{; 188 // Required since we overload TObject::Hash.; 189 ROOT::CallRecursiveRemoveIfNeeded(*this);; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// Add all objects from collection col to this collection.; 194 ; 195void TCollection::AddAll(const TCollection *col); 196{; 197 TIter next(col);; 198 TObject *obj;; 199 ; 200 while ((obj = next())); 201 Add(obj);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Add all arguments to the collection. The list of objects must be; 206/// terminated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);; 207 ; 208void TCollection::AddVector(TObject *va_(obj1), ...); 209{; 210 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:6890,safe,safe,6890,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['safe'],['safe']
Safety,"riteFastArray() [12/15]. void TBufferJSON::WriteFastArray ; (; const ULong_t * ; l, . Long64_t ; n . ). finalvirtual . Write array of ULong_t to buffer. ; Implements TBuffer.; Definition at line 3392 of file TBufferJSON.cxx. ◆ WriteFastArray() [13/15]. void TBufferJSON::WriteFastArray ; (; const UShort_t * ; h, . Long64_t ; n . ). finalvirtual . Write array of UShort_t to buffer. ; Implements TBuffer.; Definition at line 3360 of file TBufferJSON.cxx. ◆ WriteFastArray() [14/15]. Int_t TBufferJSON::WriteFastArray ; (; void ** ; startp, . const TClass * ; cl, . Long64_t ; n = 1, . Bool_t ; isPreAlloc = kFALSE, . TMemberStreamer * ; s = nullptr . ). finalvirtual . Recall TBuffer function to avoid gcc warning message. ; Implements TBuffer.; Definition at line 3485 of file TBufferJSON.cxx. ◆ WriteFastArray() [15/15]. void TBufferJSON::WriteFastArray ; (; void * ; start, . const TClass * ; cl, . Long64_t ; n = 1, . TMemberStreamer * ; s = nullptr . ). finalvirtual . Recall TBuffer function to avoid gcc warning message. ; Implements TBuffer.; Definition at line 3432 of file TBufferJSON.cxx. ◆ WriteFastArrayString(). void TBufferJSON::WriteFastArrayString ; (; const Char_t * ; c, . Long64_t ; n . ). finalvirtual . Write array of Char_t to buffer. ; Implements TBuffer.; Definition at line 3336 of file TBufferJSON.cxx. ◆ WriteFloat(). void TBufferJSON::WriteFloat ; (; Float_t ; f). finalvirtual . Writes Float_t value to buffer. ; Implements TBuffer.; Definition at line 3828 of file TBufferJSON.cxx. ◆ WriteInt(). void TBufferJSON::WriteInt ; (; Int_t ; i). finalvirtual . Writes Int_t value to buffer. ; Implements TBuffer.; Definition at line 3774 of file TBufferJSON.cxx. ◆ WriteLong(). void TBufferJSON::WriteLong ; (; Long_t ; l). finalvirtual . Writes Long_t value to buffer. ; Implements TBuffer.; Definition at line 3792 of file TBufferJSON.cxx. ◆ WriteLong64(). void TBufferJSON::WriteLong64 ; (; Long64_t ; l). finalvirtual . Writes Long64_t value to buffer. ; Implements TBuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:96779,avoid,avoid,96779,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['avoid'],['avoid']
Safety,"rithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:27684,Recover,Recover,27684,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,1,['Recover'],['Recover']
Safety,"rithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:27422,Recover,Recover,27422,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,1,['Recover'],['Recover']
Safety,"ritten to the current file so far. Use TDirectoryFile::SetBufferSize to force a given buffer size.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by obj->GetName().; The option can be a combination of:; ""SingleKey""; ""Overwrite""; ""WriteDelete"" Using the ""Overwrite"" option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the ""WriteDelete"" option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. The ""SingleKey"" option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key. An object is read from this directory via TDirectoryFile::Get. The function returns the total number of bytes written to the directory. It returns 0 if the object cannot be written. WARNING: avoid special characters like '^','$','.' in the name as they are used by the regular expression parser (see TRegexp). ; Reimplemented from TDirectory.; Definition at line 1909 of file TDirectoryFile.cxx. Member Data Documentation. ◆ fBufferSize. Int_t TDirectoryFile::fBufferSize {0}. protected . Default buffer size to create new TKeys. ; Definition at line 41 of file TDirectoryFile.h. ◆ fDatimeC. TDatime TDirectoryFile::fDatimeC. protected . Date and time when directory is created. ; Definition at line 37 of file TDirectoryFile.h. ◆ fDatimeM. TDatime TDirectoryFile::fDatimeM. protected . Date and time of last modification. ; Definition at line 38 of file TDirectoryFile.h. ◆ fFile. TFile* TDirectoryFile::fFile {nullptr}. protected . Pointer to current file in memory. ; Definition at line 45 of file TDirectoryFile.h. ◆ fKeys. TList* TDirectoryFile::fKeys {nullptr}. protected . Pointer to keys list in memory. ; Definition at line 46 of file TDirectoryFile.h. ◆ fModified. Bool_t TDirectoryFile::fModifie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectoryFile.html:54832,avoid,avoid,54832,doc/master/classTDirectoryFile.html,https://root.cern,https://root.cern/doc/master/classTDirectoryFile.html,1,['avoid'],['avoid']
Safety,"rivate:. TSelector(const TSelector&); TSelector&operator=(const TSelector&). Data Members; public:. enum EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:9091,abort,aborted,9091,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,4,['abort'],['aborted']
Safety,"rix ("") + fDataSetInfo.GetClassInfo(cls)->GetName() + TString("")""));; 624 if (h != 0) {; 625 h->Write();; 626 delete h;; 627 }; 628 }; 629 } else {; 630 m = fDataSetInfo.CorrelationMatrix(""Signal"");; 631 h = fDataSetInfo.CreateCorrelationMatrixHist(m, ""CorrelationMatrixS"", ""Correlation Matrix (signal)"");; 632 if (h != 0) {; 633 h->Write();; 634 delete h;; 635 }; 636 ; 637 m = fDataSetInfo.CorrelationMatrix(""Background"");; 638 h = fDataSetInfo.CreateCorrelationMatrixHist(m, ""CorrelationMatrixB"", ""Correlation Matrix (background)"");; 639 if (h != 0) {; 640 h->Write();; 641 delete h;; 642 }; 643 ; 644 m = fDataSetInfo.CorrelationMatrix(""Regression"");; 645 h = fDataSetInfo.CreateCorrelationMatrixHist(m, ""CorrelationMatrix"", ""Correlation Matrix"");; 646 if (h != 0) {; 647 h->Write();; 648 delete h;; 649 }; 650 }; 651 ; 652 // some default transformations to evaluate; 653 // NOTE: all transformations are destroyed after this test; 654 TString processTrfs = ""I""; //""I;N;D;P;U;G,D;""; 655 ; 656 // plus some user defined transformations; 657 processTrfs = fTransformations;; 658 ; 659 // remove any trace of identity transform - if given (avoid to apply it twice); 660 std::vector<TMVA::TransformationHandler *> trfs;; 661 TransformationHandler *identityTrHandler = 0;; 662 ; 663 std::vector<TString> trfsDef = gTools().SplitString(processTrfs, ';');; 664 std::vector<TString>::iterator trfsDefIt = trfsDef.begin();; 665 for (; trfsDefIt != trfsDef.end(); ++trfsDefIt) {; 666 trfs.push_back(new TMVA::TransformationHandler(fDataSetInfo, ""Factory""));; 667 TString trfS = (*trfsDefIt);; 668 ; 669 // Log() << kINFO << Endl;; 670 Log() << kDEBUG << ""current transformation string: '"" << trfS.Data() << ""'"" << Endl;; 671 TMVA::CreateVariableTransforms(trfS, fDataSetInfo, *(trfs.back()), Log());; 672 ; 673 if (trfS.BeginsWith('I')); 674 identityTrHandler = trfs.back();; 675 }; 676 ; 677 const std::vector<Event *> &inputEvents = fDataSetInfo.GetDataSet()->GetEventCollection();; 678 ; 679 // apply a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:26421,avoid,avoid,26421,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['avoid'],['avoid']
Safety,"rlaps, checkcrossings, ntracks, vertex);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224/// Geometry checking method (see TGeoChecker).; 225 ; 226void TGeoPainter::CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; 227{; 228 fChecker->CheckGeometry(nrays, startx, starty, startz);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Check overlaps for the top volume of the geometry, within a limit OVLP.; 233 ; 234void TGeoPainter::CheckOverlaps(const TGeoVolume *vol, Double_t ovlp, Option_t *option) const; 235{; 236 fChecker->CheckOverlaps(vol, ovlp, option);; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Check current point in the geometry.; 241 ; 242void TGeoPainter::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 243{; 244 fChecker->CheckPoint(x, y, z, option, safety);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Test for shape navigation methods. Summary for test numbers:; 249/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 250/// directions randomly in cos(theta). Compute DistFromInside and move the; 251/// point with bigger distance. Compute DistFromOutside back from new point.; 252/// Plot d-(d1+d2); 253 ; 254void TGeoPainter::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 255{; 256 fChecker->CheckShape(shape, testNo, nsamples, option);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Clear the list of visible volumes; 261/// reset the kVisOnScreen bit for volumes previously in the list; 262 ; 263void TGeoPainter::ClearVisibleVolumes(); 264{; 265 if (!fVisVolumes); 266 return;; 267 TIter next(fVisVolumes);; 268 TGeoVolume *vol;; 269 while ((vol = (TGeoVolume *)n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:8083,safe,safety,8083,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,2,['safe'],['safety']
Safety,"rlo. 2: SetPoissonBkgGaussEff(x,y,em,sde,tau). Background: Poisson; Efficiency: Gaussian. when the background is simultaneously measured; from sidebands (or MC), and; the efficiency is modeled as Gaussian. 3: SetGaussBkgGaussEff(x,bm,em,sde,sdb). Background: Gaussian; Efficiency: Gaussian. when background and efficiency can both be; modeled as Gaussian. 4: SetPoissonBkgKnownEff(x,y,tau,e). Background: Poisson; Efficiency: Known. when the background is simultaneously measured; from sidebands (or MC). 5: SetGaussBkgKnownEff(x,bm,sdb,e). Background: Gaussian; Efficiency: Known. when background is Gaussian. 6: SetKnownBkgBinomEff(x,z,b,m). Background: Known; Efficiency: Binomial. when signal efficiency was determined from Monte Carlo. 7: SetKnownBkgGaussEff(x,em,sde,b). Background: Known; Efficiency: Gaussian. when background is known and efficiency Gaussian. Parameters and further explanation. For all models:. x = number of observed events in the experiment. Efficiency (e or em) is the detection probability for signal.; A low efficiency hence generally means weaker limits.; If the efficiency of an experiment (with analysis cuts) is; dealt with elsewhere, em or e can be set to one. For Poisson background measurements (sideband or MC):. y = number of observed events in background region; tau =; Either: the ratio between signal and background region; in case background is observed.; Or: the ratio between observed and simulated live-time; in case background is determined from MC. For Gaussian efficiency or background:. bm = estimate of the background; sdb = corresponding standard deviation. em = estimate of the efficiency; sde = corresponding standard deviation. If the efficiency scale of dealt with elsewhere,; set em to 1 and sde to the relative uncertainty. For Binomial signal efficiency:. m = number of MC events generated; z = number of MC events observed. For the case of known background expectation or known efficiency:. e = true efficiency (considered known); b = back",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRolke.html:2274,detect,detection,2274,root/html528/TRolke.html,https://root.cern,https://root.cern/root/html528/TRolke.html,10,['detect'],['detection']
Safety,"rm, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ GetVisibleCorner(). void TGeoTrd1::GetVisibleCorner ; (; const Double_t * ; point, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ InspectShape(). void TGeoTrd1::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoTrd1::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 78 of file TGeoTrd1.h. ◆ IsCylType(). Bool_t TGeoTrd1::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 68 of file TGeoTrd1.h. ◆ operator=(). TGeoTrd1 & TGeoTrd1::operator= ; (; const TGeoTrd1 & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTrd1::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoTrd1::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoTrd1::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoTrd1::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoTrd1::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoTrd1::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetVertex(). void TGeoTrd1::SetVertex ; (; Double_t * ; vertex); const. ◆ Sizeof3D(). void TGeoTrd1::Sizeof3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Streamer(). void TGeoTrd1::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBBox. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd1.html:27857,safe,safe,27857,doc/master/classTGeoTrd1.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd1.html,1,['safe'],['safe']
Safety,"rm, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ GetVisibleCorner(). void TGeoTrd2::GetVisibleCorner ; (; const Double_t * ; point, . Double_t * ; vertex, . Double_t * ; normals . ); const. ◆ InspectShape(). void TGeoTrd2::InspectShape ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ IsA(). TClass * TGeoTrd2::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGeoBBox.; Definition at line 80 of file TGeoTrd2.h. ◆ IsCylType(). Bool_t TGeoTrd2::IsCylType ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoBBox.; Definition at line 70 of file TGeoTrd2.h. ◆ operator=(). TGeoTrd2 & TGeoTrd2::operator= ; (; const TGeoTrd2 & ; ). protecteddelete . ◆ Safety(). Double_t TGeoTrd2::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Safety_v(). void TGeoTrd2::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SavePrimitive(). void TGeoTrd2::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox. ◆ SetDimensions(). void TGeoTrd2::SetDimensions ; (; Double_t * ; param). overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [1/2]. void TGeoTrd2::SetPoints ; (; Double_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetPoints() [2/2]. void TGeoTrd2::SetPoints ; (; Float_t * ; points); const. overridevirtual . Reimplemented from TGeoBBox. ◆ SetVertex(). void TGeoTrd2::SetVertex ; (; Double_t * ; vertex); const. ◆ Sizeof3D(). void TGeoTrd2::Sizeof3D ; (; ); const. overridevirtual . Reimplemented from TGeoBBox. ◆ Streamer(). void TGeoTrd2::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGeoBBox. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:28080,safe,safe,28080,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['safe'],['safe']
Safety,"rmal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z div",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:16627,safe,safe,16627,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,12,['safe'],['safe']
Safety,rmal. Double_t TGeoNavigator::fNormal[3]. private . last computed safety radius ; Definition at line 46 of file TGeoNavigator.h. ◆ fOverlapClusters. Int_t* TGeoNavigator::fOverlapClusters. private . current recursive position in fOverlapClusters ; Definition at line 60 of file TGeoNavigator.h. ◆ fOverlapMark. Int_t TGeoNavigator::fOverlapMark. private . current size of fOverlapClusters ; Definition at line 59 of file TGeoNavigator.h. ◆ fOverlapSize. Int_t TGeoNavigator::fOverlapSize. private . next daughter index after FindNextBoundary ; Definition at line 58 of file TGeoNavigator.h. ◆ fPath. TString TGeoNavigator::fPath. private . current local matrix of the selected division cell ; Definition at line 84 of file TGeoNavigator.h. ◆ fPoint. Double_t TGeoNavigator::fPoint[3]. private . unit vector to current checked shape ; Definition at line 49 of file TGeoNavigator.h. ◆ fSafety. Double_t TGeoNavigator::fSafety. private . step to be done from current point and direction ; Definition at line 44 of file TGeoNavigator.h. ◆ fSearchOverlaps. Bool_t TGeoNavigator::fSearchOverlaps. private . internal array for overlaps ; Definition at line 61 of file TGeoNavigator.h. ◆ fStartSafe. Bool_t TGeoNavigator::fStartSafe. private . flags the type of the current node ; Definition at line 63 of file TGeoNavigator.h. ◆ fStep. Double_t TGeoNavigator::fStep. private . Definition at line 43 of file TGeoNavigator.h. ◆ fThreadId. Int_t TGeoNavigator::fThreadId. private . last safety returned from parallel world (negative if invalid) ; Definition at line 54 of file TGeoNavigator.h. ◆ fTopNode. TGeoNode* TGeoNavigator::fTopNode. private . current node ; Definition at line 76 of file TGeoNavigator.h. Libraries for TGeoNavigator:. [legend]; The documentation for this class was generated from the following files:; geom/geom/inc/TGeoNavigator.h; geom/geom/src/TGeoNavigator.cxx. TGeoNavigator. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:06 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:51273,safe,safety,51273,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['safe'],['safety']
Safety,"rminate the application. ;  ;  Public Member Functions inherited from TApplication;  TApplication (const char *appClassName, Int_t *argc, char **argv, void *options=nullptr, Int_t numOptions=0);  Create an application environment. ;  ; virtual ~TApplication ();  TApplication dtor. ;  ; virtual const char * ApplicationName () const;  ; Int_t Argc () const;  ; char ** Argv () const;  ; char * Argv (Int_t index) const;  Return specified argument. ;  ; void ClearInputFiles ();  Clear list containing macro files passed as program arguments. ;  ; EExitOnException ExitOnException (EExitOnException opt=kExit);  Set the exit on exception option. ;  ; virtual TApplicationImp * GetApplicationImp ();  ; TApplication * GetAppRemote () const;  ; const char * GetIdleCommand () const;  ; virtual void GetOptions (Int_t *argc, char **argv);  Get and handle command line options. ;  ; TString GetSetup ();  It gets the ROOT installation setup as TString. ;  ; TSignalHandler * GetSignalHandler () const;  ; virtual void HandleIdleTimer ();  Handle idle timeout. ;  ; virtual void Hide ();  ; virtual void Iconify ();  ; virtual void Init ();  ; void InitializeGraphics (Bool_t only_web=kFALSE);  Initialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint.html:2731,timeout,timeout,2731,doc/master/classTRint.html,https://root.cern,https://root.cern/doc/master/classTRint.html,1,['timeout'],['timeout']
Safety,"rn azimuth and polar angles of the rotated axes:; Double_t tx,ty,tz,px,py,pz;; tx= a.ThetaX();; ...; pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using SetXEulerAngles() or individually set with SetXPhi(), SetXTheta(), and SetXPsi(). These routines set the Euler angles using the X-convention which is defined by a rotation about the Z-axis, about the new X-axis, and about the new Z-axis. This is the convention used in Landau and Lifshitz, Goldstein and other common physics texts. The Y-convention Euler angles can be set with SetYEulerAngles(), SetYPhi(), SetYTheta(), and SetYPsi(). The caveat is that Euler angles usually define the rotation of the new coordinate system with respect to the original system, however, the TRotation class specifies the rotation of the object in the original system (an active rotation). To recover the usual Euler rotations (ie. rotate the system not the object), you must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and SetZAxis() will create a rotation which rotates the requested axis of the object to be parallel to a vector. If used with one argument, the rotation about that axis is arbitrary. If used with two arguments, the second variable defines the XY, YZ, or ZX respectively. Inverse rotation; TRotation a,b;; ...; b = a.Inverse(); // b is inverse of a, a is unchanged; b = a.Invert(); // invert a and set b = a; b#define b(i)Definition RSha256.hxx:100; TRotation::InvertTRotation & Invert()Definition TRotation.h:275; TRotation::InverseTRotation Inverse() constDefinition TRotation.h:271. Compound Rotations; The operator * has been implemented in a way that follows the mathematical notation of a product of the two matrices which describe the two consecutive rotations. Therefore the second rotation should be placed first:; r = r2 * r1;. Rotation of TVect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRotation.html:4589,recover,recover,4589,doc/master/classTRotation.html,https://root.cern,https://root.cern/doc/master/classTRotation.html,1,['recover'],['recover']
Safety,"rn destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  TGeoTessellated (const TGeoTessellated &)=delete;  Temporary map used to deduplicate vertices. ;  ; TGeoTessellated & operator= (const TGeoTessellated &)=delete;  . Private Attributes; bool fClosedBody = false;  Shape fully defined. ;  ; bool fDefined = false;  ; std::vector< TGeoFacet > fFacets;  ; int fNfacets = 0;  ; int fNseg = 0;  ; int fNvert = 0;  ; std::vector< Vertex_t > fVertices;  ; std::multimap< long, int > fVerticesMap;  . Additional Inherited Members;  Public Attributes inherited from TGeoBBox; static Bool_t DO NOT USE !The overlap detection does not work for all cases;  ; static Bool_t DEPRECATED;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGeoBBox;  TGeoBBox (const TGeoBBox &)=delete;  ; void FillBuffer3D (TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const override;  Fill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections, frame etc. ;  ; TGeoBBox & operator= (const TGeoBBox &)=delete;  ;  Protected Member Functions inherited from TGeoShape; Int_t GetBasicColor () const;  Get the basic color (0-7). ;  ; void SetOnBoundary (Bool_t);  ; void TransformPoints (Double_t *points, UInt_t NbPoints) const;  Tranform a set of points (LocalToMaster) ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoBBox; Double_t fDX;  ; Double_t fDY;  ; Double_t fDZ;  ; Double_t fOrigin [3];  ;  Protected Attributes inherited from TGeoSha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTessellated.html:23015,detect,detection,23015,doc/master/classTGeoTessellated.html,https://root.cern,https://root.cern/doc/master/classTGeoTessellated.html,1,['detect'],['detection']
Safety,"rn l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 407 of file RooTemplateProxy.h. ◆ lvptr() [2/4]. template<class T > . const LValue_t * RooTemplateProxy< T >::lvptr ; (; const RooAbsArg * ; ); const. inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an LValue type, then; in a debug build, a dynamic_cast with an assertion is used.; in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies. Deprecated:This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. . Definition at line 415 of file RooTemplateProxy.h. ◆ lvptr() [3/4]. template<class T > . LValue_t * RooTemplateProxy< T >::lvptr ; (; LValue_t * ; ). inline . Return l-value pointer to contents. ; If the contents derive from RooAbsLValue or RooAbsCategoryLValue, the conversion is safe, and the function directly returns the pointer using a static_cast. If the template parameter of this proxy is not an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTemplateProxy.html:24369,safe,safe,24369,doc/master/classRooTemplateProxy.html,https://root.cern,https://root.cern/doc/master/classRooTemplateProxy.html,1,['safe'],['safe']
Safety,"rn pars[0] * x[0] * x[0] + x[1] * pars[0]; ; my_func = ROOT.TF1(""my_func"", func, -10, 10, npar=2, ndim=2); Second, after performing the initialisation with a Python functor, the TF1 instance can be evaluated using the Pythonized TF1::EvalPar function. The pythonization allows passing in 1D(single set of x variables) or 2D(a dataset) NumPy arrays.; The following example shows how we can create a TF1 instance with a Python function and evaluate it on a dataset:; import ROOT; import math; import numpy as np; ; def pyf_tf1_coulomb(x, p):; return p[1] * x[0] * x[1] / (p[0]**2) * math.exp(-p[2] / p[0]); ; rtf1_coulomb = ROOT.TF1(""my_func"", pyf_tf1_coulomb, -10, 10, ndims = 2, npars = 3); ; # x dataset: 5 pairs of particle charges; x = np.array([; [1.0, 10, 2.0],; [1.5, 10, 2.5],; [2.0, 10, 3.0],; [2.5, 10, 3.5],; [3.0, 10, 4.0]; ]); ; params = np.array([; [1.0], # Distance between charges r; [8.99e9], # Coulomb constant k (in N·m²/C²); [0.1] # Additional factor for modulation; ]); ; # Slice to avoid the dummy column of 10's; res = rtf1_coulomb.EvalPar(x[:, ::2], params). Definition at line 233 of file TF1.h. Classes; struct  TF1FunctorPointer;  ; struct  TF1FunctorPointerImpl;  . Public Types; enum class  EAddToList { kDefault; , kAdd; , kNo; };  Add to list behavior. More...;  ; enum  EStatusBits { kNotGlobal = (1ULL << ( 10 )); , kNotDraw = (1ULL << ( 9 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:9337,avoid,avoid,9337,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['avoid'],['avoid']
Safety,"rn the previous set of conditions. ; Reimplemented from TSystem.; Definition at line 999 of file TUnixSystem.cxx. ◆ SetProgname(). void TUnixSystem::SetProgname ; (; const char * ; name). overridevirtual . Set the application name (from command line, argv[0]) and copy it in gProgName. ; Copy the application pathname in gProgPath. If name is 0 let the system set the actual executable name and path (works on MacOS X and Linux). ; Reimplemented from TSystem.; Definition at line 641 of file TUnixSystem.cxx. ◆ SetSockOpt(). int TUnixSystem::SetSockOpt ; (; int ; sock, . int ; option, . int ; val . ). overridevirtual . Set socket option. ; Reimplemented from TSystem.; Definition at line 3437 of file TUnixSystem.cxx. ◆ SigAlarmInterruptsSyscalls(). void TUnixSystem::SigAlarmInterruptsSyscalls ; (; Bool_t ; set). overridevirtual . When the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be restarted by the kernel. ; This is typically used in case one wants to put a timeout on an I/O operation. By default interrupted syscalls will always be restarted (for all signals). This can be controlled for each a-synchronous TTimer via the method TTimer::SetInterruptSyscalls(). ; Reimplemented from TSystem.; Definition at line 908 of file TUnixSystem.cxx. ◆ Sleep(). void TUnixSystem::Sleep ; (; UInt_t ; milliSec). overridevirtual . Sleep milliSec milliseconds. ; Reimplemented from TSystem.; Definition at line 1184 of file TUnixSystem.cxx. ◆ StackTrace(). void TUnixSystem::StackTrace ; (; ). overridevirtual . Print a stack trace. ; Reimplemented from TSystem.; Definition at line 2281 of file TUnixSystem.cxx. ◆ Streamer(). void TUnixSystem::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TSystem. ◆ StreamerNVirtual(). void TUnixSystem::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 219 of file TUnixSystem.h. ◆ Symlink(). int TUnixSystem::Symlink ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:68752,timeout,timeout,68752,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['timeout'],['timeout']
Safety,"rnal class-to-file map and import the contents of the files, if they are not imported yet. ; Definition at line 1497 of file RooWorkspace.cxx. ◆ Class(). static TClass * RooWorkspace::CodeRepo::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooWorkspace::CodeRepo::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooWorkspace::CodeRepo::Class_Version ; (; ). inlinestaticconstexpr . Flag indicating that classes compiled OK. ; ReturnsVersion of this class ; Definition at line 217 of file RooWorkspace.h. ◆ compileClasses(). bool RooWorkspace::CodeRepo::compileClasses ; (; ). For all classes in the workspace for which no class definition is found in the ROOT class table extract source code stored in code repository into temporary directory set by setClassFileExportDir(), compile classes and link them with current ROOT session. ; If a compilation error occurs print instructions for user how to fix errors and recover workspace and abort import procedure. ; Definition at line 2684 of file RooWorkspace.cxx. ◆ compiledOK(). bool RooWorkspace::CodeRepo::compiledOK ; (; ); const. inline . Definition at line 182 of file RooWorkspace.h. ◆ DeclFileName(). static const char * RooWorkspace::CodeRepo::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 217 of file RooWorkspace.h. ◆ IsA(). TClass * RooWorkspace::CodeRepo::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 217 of file RooWorkspace.h. ◆ listOfClassNames(). std::string RooWorkspace::CodeRepo::listOfClassNames ; (; ); const. Return STL string with last of class names contained in the code repository. ; Definition at line 2571 of file RooWorkspace.cxx. ◆ Streamer(). void RooWorkspace::CodeRepo::Streamer ; (; TBuffer & ; R__b). overridevirtual . Custom streamer for the workspace. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html:12999,recover,recover,12999,doc/master/classRooWorkspace_1_1CodeRepo.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace_1_1CodeRepo.html,2,"['abort', 'recover']","['abort', 'recover']"
Safety,"rnal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Int_t Fill () override;  Fill a Ntuple with current values in fArgs. ;  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:39818,detect,detection,39818,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['detect'],['detection']
Safety,"rnal subprogram used by Create. ; It initializes ""root part"" of the FOAM of the tree of cells. ; Definition at line 354 of file PDEFoam.cxx. ◆ Initialize(). void TMVA::PDEFoam::Initialize ; (; ). inline . Definition at line 173 of file PDEFoam.h. ◆ IsA(). virtual TClass * TMVA::PDEFoam::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TMVA::PDEFoamDecisionTree, TMVA::PDEFoamDiscriminant, TMVA::PDEFoamEvent, TMVA::PDEFoamMultiTarget, and TMVA::PDEFoamTarget.; Definition at line 273 of file PDEFoam.h. ◆ Log(). MsgLogger & TMVA::PDEFoam::Log ; (; ); const. inline . Definition at line 240 of file PDEFoam.h. ◆ MakeAlpha(). void TMVA::PDEFoam::MakeAlpha ; (; ). protected . Internal subprogram used by Create. ; Provides random vector Alpha 0< Alpha(i) < 1 ; Definition at line 636 of file PDEFoam.cxx. ◆ OutputGrow(). void TMVA::PDEFoam::OutputGrow ; (; Bool_t ; finished = false). protected . Overridden function of PDEFoam to avoid native foam output. ; Draw TMVA-process bar instead. ; Definition at line 1459 of file PDEFoam.cxx. ◆ PeekMax(). Long_t TMVA::PDEFoam::PeekMax ; (; ). protected . Internal subprogram used by Create. ; It finds cell with maximal driver integral for the purpose of the division. This function is overridden by the PDEFoam Class to apply cuts on the number of events in the cell (fNmin) and the cell tree depth (GetMaxDepth() > 0) during cell buildup. ; Definition at line 650 of file PDEFoam.cxx. ◆ PrintCell(). void TMVA::PDEFoam::PrintCell ; (; Long_t ; iCell = 0). Prints geometry of and elements of 'iCell', as well as relations to parent and daughter cells. ; Definition at line 894 of file PDEFoam.cxx. ◆ PrintCells(). void TMVA::PDEFoam::PrintCells ; (; void ; ). Prints geometry of ALL cells of the FOAM. ; Definition at line 941 of file PDEFoam.cxx. ◆ Project2(). TH2D * TMVA::PDEFoam::Project2 ; (; Int_t ; idim1, . Int_t ; idim2, . ECellValue ; cell_value = kValue, . PDEFoamKerne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoam.html:33108,avoid,avoid,33108,doc/master/classTMVA_1_1PDEFoam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoam.html,1,['avoid'],['avoid']
Safety,"rnally, randomly, and by accept/reject sampling; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Tue Jun 30 14:33:14 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenContext.html:11590,unsafe,unsafe,11590,root/html602/RooGenContext.html,https://root.cern,https://root.cern/root/html602/RooGenContext.html,2,['unsafe'],['unsafe']
Safety,"rns -1. void UseCurrentStyle(); Replace current attributes by current style. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write this object to the current directory. For more see TObject::Write; Write calls TTree::FlushBaskets before writing the tree. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see TObject::Write; If option & kFlushBasket, call FlushBasket before writing the tree. TTree(const TTree& tt). TTree& operator=(const TTree& tt). void AddTotBytes(Int_t tot); { fTotBytes += tot; }. void AddZipBytes(Int_t zip); { fZipBytes += zip; }. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"). Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99). Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99). return Branch(const char* name, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Overload to avoid confusion between this signature and the template instance. Int_t Debug() const; { return fDebug; }. void Draw(Option_t* opt); { Draw(opt, """", """", 1000000000, 0); }. Long64_t GetAutoFlush() const; {return fAutoFlush;}. Long64_t GetAutoSave() const; {return fAutoSave;}. TBranchRef * GetBranchRef() const; { return fBranchRef; }. Long64_t GetCacheSize() const; { return fCacheSize; }. Long64_t GetChainEntryNumber(Long64_t entry) const; { return entry; }. Long64_t GetChainOffset() const; { return fChainOffset; }. Int_t GetDefaultEntryOffsetLen() const; {return fDefaultEntryOffsetLen;}. Long64_t GetDebugMax() const; { return fDebugMax; }. Long64_t GetDebugMin() const; { return fDebugMin; }. TDirectory * GetDirectory() const; { return fDirectory; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetEntriesFast() const; { return fEntries; }. Long64_t GetEstimate() const; { return fEstimate; }. Int_t GetEvent(Long64_t entry = 0, Int_t getall = 0); { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:128660,avoid,avoid,128660,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['avoid'],['avoid']
Safety,"rns -1. void UseCurrentStyle(); Replace current attributes by current style. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write this object to the current directory. For more see TObject::Write; Write calls TTree::FlushBaskets before writing the tree. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see TObject::Write; If option & kFlushBasket, call FlushBasket before writing the tree. TTree(const TTree& tt). TTree& operator=(const TTree& tt). void AddTotBytes(Int_t tot); { fTotBytes += tot; }. void AddZipBytes(Int_t zip); { fZipBytes += zip; }. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"). Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99). Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99). return Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Overload to avoid confusion between this signature and the template instance. Int_t Debug() const; { return fDebug; }. void Draw(Option_t* opt); { Draw(opt, """", """", 1000000000, 0); }. Long64_t GetAutoFlush() const; {return fAutoFlush;}. Long64_t GetAutoSave() const; {return fAutoSave;}. TBranchRef * GetBranchRef() const; { return fBranchRef; }. Long64_t GetCacheSize() const; { return fCacheSize; }. TClusterIterator GetClusterIterator(Long64_t firstentry). Long64_t GetChainEntryNumber(Long64_t entry) const; { return entry; }. Long64_t GetChainOffset() const; { return fChainOffset; }. Int_t GetDefaultEntryOffsetLen() const; {return fDefaultEntryOffsetLen;}. Long64_t GetDebugMax() const; { return fDebugMax; }. Long64_t GetDebugMin() const; { return fDebugMin; }. TDirectory * GetDirectory() const; { return fDirectory; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetEntriesFast() const; { return fEntries; }. Long64_t GetEstimate() const; { return fEstimate; }. Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:134902,avoid,avoid,134902,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,5,['avoid'],['avoid']
Safety,"rns NULL.; The computed value for the computed distance can be subsequently retrieved from the manager class:; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; TGeoManager::GetSafeDistanceDouble_t GetSafeDistance() constDefinition TGeoManager.h:384; TGeoManager::GetStepDouble_t GetStep() constDefinition TGeoManager.h:386; According the step value, two use cases are possible:. step = TGeoShape::kBig (default behavior; kBig = 1030). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to kBig and a NULL pointer returned. No additional quantity will be computed.; step < kBig. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the safety radius is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provided as input parameter in order to speed-up the search. In addition to the distance computation, the method sets an additional flag telling if the current track will enter inside some daughter of the current volume or it will exit inside its container:; Bool_t TGeoManager::IsStepEntering() const;; TGeoManager::IsStepEnteringBool_t IsStepEntering() constDefinition TGeoManager.h:404; A combined task is to first find the distance to the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined ta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:84549,safe,safety,84549,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['safe'],['safety']
Safety,"roblem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other program) cannot solve your problem uniquely. The error matrix will necessarily be largely meaningless, so the user must remove the under determinedness by reformulating the parameterization. Minuit cannot do this itself.; 5.9.4.3 Numerical Inaccuracies; It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:223543,recover,recovers,223543,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['recover'],['recovers']
Safety,"rojX == GetZaxis() ) {; 2074 stats[2] = stats[7];; 2075 stats[3] = stats[8];; 2076 }; 2077 h1->PutStats(stats);; 2078 }; 2079 else {; 2080 // reset statistics; 2081 h1->ResetStats();; 2082 }; 2083 if (resetEntries) {; 2084 // in case of error calculation (i.e. when Sumw2() is set); 2085 // use the effective entries for the entries; 2086 // since this is the only way to estimate them; 2087 Double_t entries = TMath::Floor( totcont + 0.5); // to avoid numerical rounding; 2088 if (computeErrors) entries = h1->GetEffectiveEntries();; 2089 h1->SetEntries( entries );; 2090 }; 2091 else {; 2092 h1->SetEntries( fEntries );; 2093 }; 2094 ; 2095 return h1;; 2096}; 2097 ; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// internal method performing the projection to a 2D histogram; 2101/// called from TH3::Project3D; 2102 ; 2103TH2D *TH3::DoProject2D(const char* name, const char * title, const TAxis* projX, const TAxis* projY,; 2104 bool computeErrors, bool originalRange,; 2105 bool useUF, bool useOF) const; 2106{; 2107 TH2D *h2 = nullptr;; 2108 ; 2109 // Get range to use as well as bin limits; 2110 Int_t ixmin = std::max(projX->GetFirst(),1);; 2111 Int_t ixmax = std::min(projX->GetLast(),projX->GetNbins());; 2112 Int_t iymin = std::max(projY->GetFirst(),1);; 2113 Int_t iymax = std::min(projY->GetLast(),projY->GetNbins());; 2114 ; 2115 Int_t nx = ixmax-ixmin+1;; 2116 Int_t ny = iymax-iymin+1;; 2117 ; 2118 // Create the histogram, either reseting a preexisting one; 2119 // or creating one from scratch.; 2120 // Does an object with the same name exists?; 2121 TObject *h2obj = gROOT->FindObject(name);; 2122 if (h2obj && h2obj->InheritsFrom(TH1::Class())) {; 2123 if ( h2obj->IsA() != TH2D::Class() ) {; 2124 Error(""DoProject2D"",""Histogram with name %s must be a TH2D and is a %s"",name,h2obj->ClassName());; 2125 return nullptr;; 2126 }; 2127 h2 = (TH2D*)h2obj;; 2128 // reset histogram and its axes; 2129 h2->Reset();; 2130 const TArrayD ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:82456,avoid,avoid,82456,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['avoid'],['avoid']
Safety,"rom sub-string. Check validity of i. char& operator()(Ssiz_t i); Return character at pos i from sub-string. No check on i. TSubString& operator=(const TString& s); Assign string to sub-string. TSubString& operator=(const char* s); Assign char* to sub-string. void ToLower(); Convert sub-string to lower-case. void ToUpper(); Convert sub-string to upper-case. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const; Output error message. void AssertElement(Ssiz_t i) const; Check to make sure a sub-string index is in range. const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSubString.html:3592,detect,detecting,3592,root/html602/TSubString.html,https://root.cern,https://root.cern/root/html602/TSubString.html,2,['detect'],['detecting']
Safety,"rom sub-string. Check validity of i. char& operator()(Ssiz_t i); Return character at pos i from sub-string. No check on i. TSubString& operator=(const TString& s); Assign string to sub-string. TSubString& operator=(const char* s); Assign char* to sub-string. void ToLower(); Convert sub-string to lower-case. void ToUpper(); Convert sub-string to upper-case. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const; Output error message. void AssertElement(Ssiz_t i) const; Check to make sure a sub-string index is in range. const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSubString.html:3673,detect,detecting,3673,root/html604/TSubString.html,https://root.cern,https://root.cern/root/html604/TSubString.html,2,['detect'],['detecting']
Safety,"romVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPacketizer.html:5950,abort,abort,5950,root/html530/TPacketizer.html,https://root.cern,https://root.cern/root/html530/TPacketizer.html,12,['abort'],['abort']
Safety,"roofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlave.html:10892,abort,abort,10892,root/html602/TSlave.html,https://root.cern,https://root.cern/root/html602/TSlave.html,12,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"roposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:133864,safe,safe,133864,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,3,['safe'],['safe']
Safety,"rorHandler (protected). TXSlave(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Create a PROOF slave object. Called via the TProof ctor. void Init(const char* host, Int_t stype); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TXSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TXSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 if it did not ping or in case of error. void Touch(); Touch the client admin file to proof we are alive. void Interrupt(Int_t type); Send interrupt to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. It will be; processed asynchronously by a separate thread. Int_t GetProofdProtocol(TSocket* s); Find out the remote proofd protocol version.; Returns -1 in case of error. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator.; If any output is due, this is returned as a generic message. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. Int_t SendGroupPriority(const char* grp, Int_t priority); Communicate to the coordinator the priprity of the group to which the; user belongs; Return 0 on success. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the socket. void SetInterruptHandler(Bool_t on = kTRUE); Set/Unset the interrupt handler. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSlave.html:9591,abort,abort,9591,root/html528/TXSlave.html,https://root.cern,https://root.cern/root/html528/TXSlave.html,3,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"rospected; model = w[""model""]; ; # Generate data from p.d.f. in given observables; data = model.generate(w.set(""observables""), 1000); ; # Fit model to data; model.fitTo(data, PrintLevel=-1); ; # Plot fitted model and data on frame of first (only) observable; frame = (w.set(""observables"").first()).frame(); data.plotOn(frame); model.plotOn(frame); ; # Overlay plot with model with reference parameters as stored in snapshots; w.loadSnapshot(""reference_fit""); model.plotOn(frame, LineColor=""r""); w.loadSnapshot(""reference_fit_bkgonly""); model.plotOn(frame, LineColor=""r"", LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf510_wsnamedsets.png""); ; # Print workspace contents; w.Print(); ; # Workspace will remain in memory after macro finishes; ROOT.gDirectory.Add(w); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8py.html:4914,safe,safe,4914,doc/master/rf510__wsnamedsets_8py.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html,1,['safe'],['safe']
Safety,"round; uncertainty. It relates the signal in each channel to a master signal strength times the; expected signal in each channel. For the future, perhaps this method should be extended to include the efficiency terms automatically. void AddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an array of expected signal, expected background, and relative; background uncertainty (eg. 0.1 for 10% uncertainty), and the number of channels. void AddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); Arguements are an array of expected signal, expected background, and relative; ratio of background expected in the sideband to that expected in signal region, and the number of channels. RooRealVar* SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value); need to be careful here that the range of observable in the dataset is consistent with the one in the workspace; don't rescale unless necessary. If it is necessary, then rescale by x10 or a defined maximum. RooRealVar* SafeObservableCreation(RooWorkspace* ws, const char* varName, Double_t value, Double_t maximum); need to be careful here that the range of observable in the dataset is consistent with the one in the workspace; don't rescale unless necessary. If it is necessary, then rescale by x10 or a defined maximum. void AddData(Double_t* mainMeas, Double_t* bkgMeas, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); Arguments are an array of results from a main measurement, a measured background,; and relative background uncertainty (eg. 0.1 for 10% uncertainty), and the number of channels. void AddDataWithSideband(Double_t* mainMeas, Double_t* sideband, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); Arguements are an arr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__NumberCountingPdfFactory.html:3948,Safe,SafeObservableCreation,3948,root/html532/RooStats__NumberCountingPdfFactory.html,https://root.cern,https://root.cern/root/html532/RooStats__NumberCountingPdfFactory.html,4,['Safe'],['SafeObservableCreation']
Safety,"roxy;  ; typedef TStlImpProxy< Short_t > TStlShortProxy;  ; typedef TStlImpProxy< UChar_t > TStlUCharProxy;  ; typedef TStlImpProxy< UInt_t > TStlUIntProxy;  ; typedef TStlImpProxy< ULong64_t > TStlULong64Proxy;  ; typedef TStlImpProxy< ULong_t > TStlULongProxy;  ; typedef TStlImpProxy< UShort_t > TStlUShortProxy;  ; typedef TImpProxy< UChar_t > TUCharProxy;  ; typedef TImpProxy< UInt_t > TUIntProxy;  ; typedef TImpProxy< ULong64_t > TULong64Proxy;  ; typedef TImpProxy< ULong_t > TULongProxy;  ; typedef TImpProxy< UShort_t > TUShortProxy;  . Enumerations; enum  ELocation { kOut =0; , kClones; , kSTL; };  0 for the general case, 1 when this a split clases inside a TClonesArray, 2 when this is a split classes inside an STL container. More...;  . Functions; tbb::isolated_task_group * CastToTG (void *p);  ; bool ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; void DefaultStreamer (TBuffer &R__b, const TClass *cl, void *objpointer);  Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer.h. ;  ; const TQObjectInitBehavior * DefineBehavior (TQObject *, TQObject *);  ; const TInitBehavior * DefineBehavior (void *, void *);  ; bool DeleteChangesMemory ();  ; bool DeleteChangesMemoryImpl ();  ; void DisableParBranchProcessing ();  Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ;  ; const TCollection & EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  ; void EnableParBranchProcessing ();  Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in ROOT, activating the required locks. ;  ; void EvalParMultiDim (TF1 *func, Double_t *out, const Double_t *x, std::size_t size, std::size_t rows, Double_t *params);  ; void GenericShowMembers (const char *topClassName, void *obj, TMemberInspector &R__insp, bool transientMember);  ; TString GetArrayType (TStreamerEl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:12866,avoid,avoid,12866,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['avoid'],['avoid']
Safety,"roxy;  ; typedef TStlImpProxy< Short_t > TStlShortProxy;  ; typedef TStlImpProxy< UChar_t > TStlUCharProxy;  ; typedef TStlImpProxy< UInt_t > TStlUIntProxy;  ; typedef TStlImpProxy< ULong64_t > TStlULong64Proxy;  ; typedef TStlImpProxy< ULong_t > TStlULongProxy;  ; typedef TStlImpProxy< UShort_t > TStlUShortProxy;  ; typedef TImpProxy< UChar_t > TUCharProxy;  ; typedef TImpProxy< UInt_t > TUIntProxy;  ; typedef TImpProxy< ULong64_t > TULong64Proxy;  ; typedef TImpProxy< ULong_t > TULongProxy;  ; typedef TImpProxy< UShort_t > TUShortProxy;  . Enumerations; enum  ELocation { kOut =0; , kClones; , kSTL; };  0 for the general case, 1 when this a split clases inside a TClonesArray, 2 when this is a split classes inside an STL container. More...;  . Functions; tbb::isolated_task_group * CastToTG (void *p);  ; bool ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; void DefaultStreamer (TBuffer &R__b, const TClass *cl, void *objpointer);  Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer.h. ;  ; const TQObjectInitBehavior * DefineBehavior (TQObject *, TQObject *);  ; const TInitBehavior * DefineBehavior (void *, void *);  ; bool DeleteChangesMemory ();  ; bool DeleteChangesMemoryImpl ();  ; void DisableParBranchProcessing ();  Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ;  ; const TCollection & EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  ; void EnableParBranchProcessing ();  Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in ROOT, activating the required locks. ;  ; void GenericShowMembers (const char *topClassName, void *obj, TMemberInspector &R__insp, bool transientMember);  ; TString GetArrayType (TStreamerElement *element, const char *subtype, TTreeProxyGenerator::EContainer container);  ; template<typename T > ; TClass * GetClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:12728,avoid,avoid,12728,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['avoid'],['avoid']
Safety,"roxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 455 of file RooAbsCollection.h. ◆ isOwning(). bool RooAbsCollection::isOwning ; (; ); const. inline . Definition at line 369 of file RooAbsCollection.h. ◆ iterator(). RooLinkedListIter RooAbsCollection::iterator ; (; bool ; dir = kIterForward); const. TIterator-style iteration over contained elements. ; NoteThis iterator is slow. Use begin() and end() or range-based for loop instead. . ◆ makeStructureTag(). void RooAbsCollection::makeStructureTag ; (; ). inlineprotected . Definition at line 417 of file RooAbsCollection.h. ◆ makeTypedStructureTag(). void RooAbsCollection::makeTypedStructureTag ; (; ). inlineprotected . Definition at line 418 of file RooAbsCollection.h. ◆ operator=(). RooAbsCollection & RooAbsCollection::operator= ; (; const RooAbsCollection & ; other). Assign values from the elements in other to our elements. ; WarningThis is not a conventional assignment operator. To avoid confusion, prefer using RooAbsCollection::assign(). ; Definition at line 263 of file RooAbsCollection.cxx. ◆ operator[](). RooAbsArg * RooAbsCollection::operator[] ; (; Storage_t::size_type ; i); const. inline . Definition at line 320 of file RooAbsCollection.h. ◆ overlaps() [1/2]. bool RooAbsCollection::overlaps ; (; const RooAbsCollection & ; otherColl); const. inline . Check if this and other collection have common entries. ; Definition at line 249 of file RooAbsCollection.h. ◆ overlaps() [2/2]. template<typename Iterator_t , typename value_type = typename std::remove_pointer<typename std::iterator_traits<Iterator_t>::value_type>, typename = std::enable_if<std::is_convertible<const value_type*, const RooAbsArg*>::value>> . bool RooAbsCollection::overlaps ; (; Iterator_t ; otherCollBegin, . Iterator_t ; otherCollEnd . ); const. inline . Definition at line 238 of file RooAbsCollection.h. ◆ Print(). void RooAbsCollection::Print ; (; Option_t * ; option = nullptr); const. inlineoverridevirtual . This method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:46866,avoid,avoid,46866,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['avoid'],['avoid']
Safety,"rposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSocket.html:13815,timeout,timeout,13815,root/html534/TSocket.html,https://root.cern,https://root.cern/root/html534/TSocket.html,6,['timeout'],['timeout']
Safety,"rray as a TImage object ;  FITS_tutorial4.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:108873,detect,detector,108873,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['detect'],['detector']
Safety,"rrent file so far.; Use TDirectoryFile::SetBufferSize to force a given buffer size. If a name is specified, it will be the name of the key.; If name is not given, the name of the key will be the name as returned; by obj->GetName(). The option can be a combination of:; ""SingleKey"", ""Overwrite"" or ""WriteDelete""; Using the ""Overwrite"" option a previous key with the same name is; overwritten. The previous key is deleted before writing the new object.; Using the ""WriteDelete"" option a previous key with the same name is; deleted only after the new object has been written. This option; is safer than kOverwrite but it is slower.; The ""SingleKey"" option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from this directory via TDirectoryFile::Get. The function returns the total number of bytes written to the directory.; It returns 0 if the object cannot be written. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). Int_t WriteObjectAny(const void* obj, const char* classname, const char* name, Option_t* option = """", Int_t bufsize = 0); Write object from pointer of class classname in this directory; obj may not derive from TObject; see TDirectoryFile::WriteTObject for comments. VERY IMPORTANT NOTE:; The value passed as 'obj' needs to be from a pointer to the type described by classname; For example with:; TopClass *top;; BottomClass *bottom;; top = bottom;; you can do:; directory->WriteObjectAny(top,""top"",""name of object"");; directory->WriteObjectAny(bottom,""bottom"",""name of object"");; BUT YOU CAN NOT DO (it will fail in particular with multiple inheritance):; directory->WriteObjectAny(top,""bottom"",""name of object"");. We STRONGLY recommend to use; TopClass *top = ....;; directory->WriteObject(top,""name of object""). see laso remarks in TDirectoryFile::WriteTObject. Int_t WriteObjectAny(const void* obj, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectoryFile.html:26873,avoid,avoid,26873,root/html528/TDirectoryFile.html,https://root.cern,https://root.cern/root/html528/TDirectoryFile.html,10,['avoid'],['avoid']
Safety,"rrent iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flatened/linearilized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:76671,avoid,avoid,76671,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['avoid'],['avoid']
Safety,"rrent iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:79496,avoid,avoid,79496,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,12,['avoid'],['avoid']
Safety,"rride;  ; void Contains_v (const Double_t *points, Bool_t *inside, Int_t vecsize) const override;  ; Double_t DistFromInside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromInside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override;  ; void DistFromOutside_v (const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override;  ; TGeoVolume * Divide (TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; Int_t GetByteCount () const override;  ; Double_t GetDx1 () const;  ; Double_t GetDx2 () const;  ; Double_t GetDy1 () const;  ; Double_t GetDy2 () const;  ; Double_t GetDz () const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetOppositeCorner (const Double_t *point, Int_t inorm, Double_t *vertex, Double_t *normals) const;  ; void GetVisibleCorner (const Double_t *point, Double_t *vertex, Double_t *normals) const;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"".",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrd2.html:2789,safe,safe,2789,doc/master/classTGeoTrd2.html,https://root.cern,https://root.cern/doc/master/classTGeoTrd2.html,1,['safe'],['safe']
Safety,"rride;; 43 static void ComputeNormalS(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax,; 44 Double_t dz);; 45 Bool_t Contains(const Double_t *point) const override;; 46 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 47 static Double_t; 48 DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 49 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 50 Double_t *safe = nullptr) const override;; 51 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 52 Double_t *step) const override;; 53 static Double_t; 54 DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 static void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t &b, Double_t &delta);; 60 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 61 TGeoVolume *; 62 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 63 const char *GetAxisName(Int_t iaxis) const override;; 64 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 65 void GetBoundingCylinder(Double_t *param) const override;; 66 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 67 Int_t GetByteCount() const override { return 48; }; 68 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 69 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 70 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:2615,safe,safe,2615,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety,"rridevirtual . Creates a TBuffer3D describing this shape. ; Coordinates are in local reference frame. ; Reimplemented from TGeoBBox.; Definition at line 266 of file TGeoScaledShape.cxx. ◆ MakeScaledShape(). TGeoShape * TGeoScaledShape::MakeScaledShape ; (; const char * ; name, . TGeoShape * ; shape, . TGeoScale * ; scale . ). static . Create a scaled shape starting from a non-scaled one. ; Definition at line 277 of file TGeoScaledShape.cxx. ◆ Safety(). Double_t TGeoScaledShape::Safety ; (; const Double_t * ; point, . Bool_t ; in = kTRUE . ); const. overridevirtual . computes the closest distance from given point to this shape, according to option. ; The matching point on the shape is stored in spoint. ; Reimplemented from TGeoBBox.; Definition at line 310 of file TGeoScaledShape.cxx. ◆ Safety_v(). void TGeoScaledShape::Safety_v ; (; const Double_t * ; points, . const Bool_t * ; inside, . Double_t * ; safe, . Int_t ; vecsize . ); const. overridevirtual . Compute safe distance from each of the points in the input array. ; Input: Array of point coordinates, array of statuses for these points, size of the arrays Output: Safety values ; Reimplemented from TGeoBBox.; Definition at line 424 of file TGeoScaledShape.cxx. ◆ SavePrimitive(). void TGeoScaledShape::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented from TGeoBBox.; Definition at line 322 of file TGeoScaledShape.cxx. ◆ SetPoints() [1/2]. void TGeoScaledShape::SetPoints ; (; Double_t * ; points); const. overridevirtual . Mesh points for scaled shapes. ; Reimplemented from TGeoBBox.; Definition at line 344 of file TGeoScaledShape.cxx. ◆ SetPoints() [2/2]. void TGeoScaledShape::SetPoints ; (; Float_t * ; points); const. overridevirtual . Mesh points for scaled shapes. ; Reimplemented from TGeoBBox.; Definition at line 358 of file TGeoScaledShape.cxx. ◆ SetScale(). void TGeoScaledShape::SetScale ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoScaledShape.html:32372,safe,safe,32372,doc/master/classTGeoScaledShape.html,https://root.cern,https://root.cern/doc/master/classTGeoScaledShape.html,1,['safe'],['safe']
Safety,"rridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 213 of file TProofPlayer.h. ◆ SetMaxDrawQueries(). void TProofPlayer::SetMaxDrawQueries ; (; Int_t ; max). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 168 of file TProofPlayer.h. ◆ SetMerging(). void TProofPlayer::SetMerging ; (; Bool_t ; = kTRUE). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 215 of file TProofPlayer.h. ◆ SetOutputFilePath(). void TProofPlayer::SetOutputFilePath ; (; const char * ; fp). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 220 of file TProofPlayer.h. ◆ SetProcessing(). void TProofPlayer::SetProcessing ; (; Bool_t ; on = kTRUE). Set processing bit according to 'on'. ; Definition at line 274 of file TProofPlayer.cxx. ◆ SetStopTimer(). void TProofPlayer::SetStopTimer ; (; Bool_t ; on = kTRUE, . Bool_t ; abort = kFALSE, . Int_t ; timeout = 0 . ). overridevirtual . Enable/disable the timer to stop/abort processing. ; The 'timeout' is in seconds. ; Implements TVirtualProofPlayer.; Definition at line 323 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayer::SetupFeedback ; (; ). protectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:41726,timeout,timeout,41726,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['timeout'],['timeout']
Safety,"rror; doublefNomLumi; TFile*fOut_f; stringstreamfResultsPrefixStr; stringfRowTitle; vector<std::string>fSystToFix; FILE*pFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HistoToWorkspaceFactory(). ~HistoToWorkspaceFactory(). HistoToWorkspaceFactory(string , string , vector<std::string> , double = 200, double = 20, int = 0, int = 6, TFile* = 0). string FilePrefixStr(string ). void ProcessExpectedHisto(TH1* hist, RooWorkspace* proto, string prefix, string productPrefix, string systTerm, double low, double high, int lowBin, int highBin). void AddMultiVarGaussConstraint(RooWorkspace* proto, string prefix, int lowBin, int highBin, vector<std::string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins. void LinInterpWithConstraint(RooWorkspace* proto, TH1* nominal, vector<TH1*> lowHist, vector<TH1*> highHist, vector<std::string> sourceName, string prefix, string productPrefix, string systTerm, int lowBin, int highBin, vector<std::string>& likelihoodTermNames); these are the nominal predictions: eg. the mean of some space of variations; later fill these in a loop over histogram bins; make list of abstract parameters that interpolate in space of variations; range is set using defined macro (see top of the page). string AddNormFactor(RooWorkspace* , string& , string& , RooStats::HistFactory::EstimateSummary& , bool ). void AddEfficiencyTerms(RooWorkspace* proto, string prefix, string interpName, map<std::string,std::pair<double,double> > systMap, vector<std::string>& likelihoodTermNames, vector<std::string>& totSystTermNames); add variables for all the relative overall uncertainties we expect; range is set using defined macro (see top of the page); string range=""[0,-1,1]"";. void MakeTotalExpected(RooWorkspace* proto, string totName, string , string , int lowBin, int highBin, vector<std::string>& syst_x_expectedPrefixNames, vector<std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistoToWorkspaceFactory.html:8861,predict,predictions,8861,root/html534/RooStats__HistFactory__HistoToWorkspaceFactory.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistoToWorkspaceFactory.html,2,['predict'],['predictions']
Safety,"rs a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 120 of file RDFHelpers.hxx. ◆ SaveGraph() [2/2]. template<typename NodeType > . void ROOT::RDF::SaveGraph ; (; NodeType ; node, . const std::string & ; outputFile . ). Create a graphviz representation of the dataframe computation graph, write it to the specified file. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. ; [in]outputFilefile where to save the representation. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 139 of file RDFHelpers.hxx. ◆ splitInEqualRanges(). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:15409,safe,safe,15409,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['safe'],['safe']
Safety,"rs with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1,				 const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:62775,safe,safely,62775,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['safe'],['safely']
Safety,"rs with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:63762,safe,safely,63762,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,9,['safe'],['safely']
Safety,"rs(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5697,recover,recovery,5697,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,3,['recover'],['recovery']
Safety,"rs(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:2383,avoid,avoids,2383,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,2,['avoid'],['avoids']
Safety,"rst();; 334 Int_t ylast = yaxis->GetLast();; 335 ; 336 ; 337 Double_t x, y, z;; 338 Int_t k = 0;; 339 ; 340 for (Int_t i = xfirst; i <= xlast; i++) {; 341 for (Int_t j = yfirst; j <= ylast; j++) {; 342 x = xaxis->GetBinCenter(i);; 343 y = yaxis->GetBinCenter(j);; 344 z = h2->GetBinContent(i, j);; 345 Double_t ez = h2->GetBinError(i, j);; 346 if (z != 0. || ez != 0) {; 347 SetPoint(k, x, y, z);; 348 k++;; 349 }; 350 }; 351 }; 352}; 353 ; 354 ; 355////////////////////////////////////////////////////////////////////////////////; 356/// Graph2D constructor with name, title and three vectors of doubles as input.; 357/// name : name of 2D graph (avoid blanks); 358/// title : 2D graph title; 359/// if title is of the form ""stringt;stringx;stringy;stringz""; 360/// the 2D graph title is set to stringt, the x axis title to stringx,; 361/// the y axis title to stringy,etc; 362 ; 363TGraph2D::TGraph2D(const char *name, const char *title,; 364 Int_t n, Double_t *x, Double_t *y, Double_t *z); 365 : TNamed(name, title), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 366{; 367 Build(n);; 368 ; 369 // Copy the input vectors into local arrays; 370 for (Int_t i = 0; i < fNpoints; ++i) {; 371 fX[i] = x[i];; 372 fY[i] = y[i];; 373 fZ[i] = z[i];; 374 }; 375}; 376 ; 377 ; 378////////////////////////////////////////////////////////////////////////////////; 379/// Graph2D constructor. The arrays fX, fY and fZ should be filled via; 380/// calls to SetPoint; 381 ; 382TGraph2D::TGraph2D(Int_t n); 383 : TNamed(""Graph2D"", ""Graph2D""), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 384{; 385 Build(n);; 386 for (Int_t i = 0; i < fNpoints; i++) {; 387 fX[i] = 0.;; 388 fY[i] = 0.;; 389 fZ[i] = 0.;; 390 }; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Graph2D constructor reading input from filename; 396/// filename is assumed to contain at least three columns of numbers.; 397/// For files separated by a specific delimiter differen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8cxx_source.html:12079,avoid,avoid,12079,doc/master/TGraph2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html,1,['avoid'],['avoid']
Safety,"rsvoid GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; TGeoTube::IsCylTypeBool_t IsCylType() const overrideDefinition TGeoTube.h:77; TGeoTube::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:67; TGeoTube::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoTube::SetTubeDimensionsvoid SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::MakeBuffer3DTBuffer3D * MakeBuffer3D() const override; TGeoTube::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point (px,py) to the object.; TGeoTube::DistFromInsideSstatic Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::GetDzvirtual Double_t GetDz() constDefinition TGeoTube.h:74; TGeoTube::SetPointsvoid SetPoints(Float_t *points) const override; TGeoTube::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTube::fRminDouble_t fRminDefinition TGeoTube.h:20; TGeoTube::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoTube::TGeoTubeTGeoTube(const char *name, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::fDzDouble_t fDzDefinition TGeoTube.h:22; TGeoTube::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoTube::ComputeBBoxvoid ComputeBBox() override; TGeoTube::DistFromOutsideSstatic Double_t DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTube::operator=TGeoTube & operator=(const TGeoTube &)=de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoTube_8h_source.html:24814,safe,safe,24814,doc/master/TGeoTube_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html,1,['safe'],['safe']
Safety,"rt, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); set arb8 params in one step :. void SetPoints(Double_t* points) const; create trd2 mesh points. void SetPoints(Float_t* points) const; create trd2 mesh points. void SetVertex(Double_t* vertex) const; set vertex of a corner according to visibility flags. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrd2.html:15519,Safe,Safety,15519,root/html534/TGeoTrd2.html,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html,3,['Safe'],['Safety']
Safety,"rted from a Double_t to a Float_t In case B fTemperature is converted to a 32 bit unsigned integer In case C fCharge is converted to a 2 bits unsigned integer In case D the array elements of fVertex are converted to an unsigned 10 bits integer In case E fChi2 is converted to a Float_t with mantissa truncated precision at 6 bits In case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer Note that the range specifier must follow the dimension specifier. Case B has more precision (9 to 10 significative digits than case A (6 to 7 digits). See TBufferFile::WriteFloat16 for more information.; see example of use of the Double32_t data type in tutorial double32.C . Implements TBuffer.; Definition at line 678 of file TBufferFile.cxx. ◆ WriteFastArray() [1/15]. void TBufferFile::WriteFastArray ; (; const Bool_t * ; b, . Long64_t ; n . ). overridevirtual . Write array of n bools into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 1982 of file TBufferFile.cxx. ◆ WriteFastArray() [2/15]. void TBufferFile::WriteFastArray ; (; const Char_t * ; c, . Long64_t ; n . ). overridevirtual . Write array of n characters into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details. ; Implements TBuffer.; Reimplemented in TBufferSQL.; Definition at line 2010 of file TBufferFile.cxx. ◆ WriteFastArray() [3/15]. void TBufferFile::WriteFastArray ; (; const Double_t * ; d, . Long64_t ; n . ). overridevirtual . Write array of n doubles into the I/O buffer. ; NoteDue to the current limit of the buffer size, the function aborts execution of the program in case of underflo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:80948,abort,aborts,80948,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['abort'],['aborts']
Safety,"rtesian2D, based on (x,y);; ROOT::Math::Polar2D, based on (r,phi);. 3D coordinate system classes:. ROOT::Math::Cartesian3D, based on (x,y,z);; ROOT::Math::Polar3D, based on (r,theta,phi);; ROOT::Math::Cylindrical3D, based on (rho,z,phi); ROOT::Math::CylindricalEta3D, based on (rho,eta,phi), where eta is the pseudo-rapidity;. 4D coordinate system classes:. ROOT::Math::PxPyPzE4D, based on based on (px,py,pz,E);; ROOT::Math::PxPyPzM4D, based on based on (px,py,pz,M);; ROOT::Math::PtEtaPhiE4D, based on based on (pt,eta,phi,E);; ROOT::Math::PtEtaPhiM4D, based on based on (pt,eta,phi,M);. Users can define the vectors according to the coordinate type, which is the most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types.; 13.12.1.4 Coordinate System Tag; The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are tra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:722274,avoid,avoid,722274,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avoid'],['avoid']
Safety,"rticle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Gdopt(const char* , const char* ). Geant3 specific methods; !!! to be removed with move to TGeo. Set/modify the drawing options.; Deprecated - G3 only. void SetClipBox(const char* , Double_t = -9999, Double_t = 0, Double_t = -9999, Double_t = 0, Double_t = -9999, Double_t = 0); This function allows subtractions (via boolean operation) of BOX shape; from any part of the detector, therefore showing its inner contents; Deprecated - G3 only. void Gdhead(Int_t , const char* , Double_t = 0); Deprecated - G3 only; Deprecated - G3 only. void Gdman(Double_t , Double_t , const char* ); Deprecated - G3 only. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void InitLego(); Set switches for lego transport. TVirtualMCStack* GetStack() const. Get methods. Return the particle stack. { return fStack; }. TVirtualMCDecayer* GetDecayer() const; Return the external decayer. { return fDecayer; }. TRandom* GetRandom() const; Return the random number generator. { return fRandom; }. TVirtualMagField* GetMagField() const; Return the magnetic field. { return fMagField; }. TV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:36667,detect,detector,36667,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,1,['detect'],['detector']
Safety,rts vector<builtin-type>. Graphics. Fix file corruption in TTeXDump::DrawPolyMarker.; Make sure the line width used to draw #sqrt is always >=1. Release 6.04/04; Build System. Fix generation of PCH with CXX flags with spaces ROOT-7478; Implemented option ‘geocad’ with CMake making use of the OpenCASCADE software package.; Fix option ‘rpath’ for CMake and ensure that works for MacOSX 10.11. Core. Fix the location of include files in ROOTINCDIR/include instead of ROOTINCDIR ROOT-7537. Interpreter. Fix redirection ROOT-7053; Take the language and target options from the PCH ROOT-7478 ROOT-6966; Properly recover from a template instantiation failure when looking up a class in the interpreter ROOT-7462; Do not clear pending instantiations upon unloading; fixes missing symbols due to missing function bodies ROOT-7586; Speed up significantly cling’s findType and remove its memory cost in most cases.; Make sure object declared on the interpreter stack are deleted at the end of the process ROOT-7673; Resolve issues with error recovery when the transaction includes template instantiation.; Fix handling of argument that negative integers in TClingCallFunc ROOT-7684. I/O. Fix memory leak in handling of I/O customization rules ROOT-7683; Set CheckSum of StreamerInfo of user classes that have a collection proxy. Tree. Fix ROOT-6885 which affects very large TChain with friend trees.; Fix ROOT-7423 which can stop the TTreeCache from stopping the learning phase when asynchronous prefetching is enabled. TTreeReader. Fix reading of data members of type BasicType[42]; Fix support for large file ROOT-7652. Geom. Fix missing OCC header file for the version ROOT-7536. Bugs. [ROOT-6419] - ROOT-6.00.01 fails to build with geocad support due to conficting function definition; [ROOT-6966] - MacOS 10.9 build cannot run on 10.10; [ROOT-7342] - Conflicting definitions of Printf function; [ROOT-7402] - Fix the inconsistency in ROOT_LINKER_LIBRARY() macro between 5 and 6 versions; [ROOT-7423] - Ac,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:29539,recover,recovery,29539,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['recover'],['recovery']
Safety,"rtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:2225,safe,safe,2225,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,2,['safe'],['safe']
Safety,"rtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoShape.html:7761,safe,safe,7761,root/html530/TGeoShape.html,https://root.cern,https://root.cern/root/html530/TGeoShape.html,1,['safe'],['safe']
Safety,"rue"" underlying distribution <m> describing the data <n>. Since <m> is unknown, the data distribution is used instead, lambda = L(y;n) / L(n;n). Note that this ratio is 1 if the fit is perfect. The chi2 value is then computed according to chi2 = -2*ln(lambda). This parameter can be shown to follow a Chi-square distribution. See for example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221, pp. 437-442 (1984) ; Definition at line 883 of file TFractionFitter.cxx. ◆ GetFitter(). ROOT::Fit::Fitter * TFractionFitter::GetFitter ; (; ); const. Give direct access to the underlying fitter class. ; This can be used e.g. to modify parameter values or step sizes. ; Definition at line 319 of file TFractionFitter.cxx. ◆ GetMCPrediction(). TH1 * TFractionFitter::GetMCPrediction ; (; Int_t ; parm); const. Return the adjusted MC template (Aji) for template (parm). ; Note that the (Aji) times fractions only sum to the total prediction of the fit if all weights are 1. Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if the class is deleted ; Definition at line 961 of file TFractionFitter.cxx. ◆ GetNDF(). Int_t TFractionFitter::GetNDF ; (; ); const. return the number of degrees of freedom in the fit the fNDF parameter has been previously computed during a fit. ; The number of degrees of freedom corresponds to the number of points used in the fit minus the number of templates. ; Definition at line 894 of file TFractionFitter.cxx. ◆ GetPlot(). TH1 * TFractionFitter::GetPlot ; (; ). Return the ""template prediction"" corresponding to the fit result (this is not the same as the weighted sum of template distributions, as template statistical uncertainties are taken into account). ; Note that the name of this histogram will simply be the same as that of the ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". Note also that the hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:27238,predict,prediction,27238,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['prediction']
Safety,"rue;; 255 }; 256 }; 257 ; 258 template<class T>; 259 WrappedMultiTF1Templ<T>::WrappedMultiTF1Templ(const WrappedMultiTF1Templ<T> &rhs) :; 260 BaseParamFunc(rhs),; 261 fLinear(rhs.fLinear),; 262 fPolynomial(rhs.fPolynomial),; 263 fOwnFunc(rhs.fOwnFunc),; 264 fFunc(rhs.fFunc),; 265 fDim(rhs.fDim); 266 //fParams(rhs.fParams); 267 {; 268 // copy constructor; 269 if (fOwnFunc) SetAndCopyFunction(rhs.fFunc);; 270 }; 271 ; 272 template<class T>; 273 WrappedMultiTF1Templ<T> &WrappedMultiTF1Templ<T>::operator= (const WrappedMultiTF1Templ<T> &rhs); 274 {; 275 // Assignment operator; 276 if (this == &rhs) return *this; // time saving self-test; 277 fLinear = rhs.fLinear;; 278 fPolynomial = rhs.fPolynomial;; 279 fOwnFunc = rhs.fOwnFunc;; 280 fDim = rhs.fDim;; 281 //fParams = rhs.fParams;; 282 return *this;; 283 }; 284 ; 285 template <class T>; 286 void WrappedMultiTF1Templ<T>::ParameterGradient(const T *x, const double *par, T *grad) const; 287 {; 288 // evaluate the gradient of the function with respect to the parameters; 289 //IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; 290 // BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; 291 // so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters; 292 ; 293 if (!fLinear) {; 294 // need to set parameter values; 295 fFunc->SetParameters(par);; 296 // no need to call InitArgs (it is called in TF1::GradientPar); 297 double prec = this->GetDerivPrecision();; 298 fFunc->GradientPar(x, grad, prec);; 299 } else { // case of linear functions; 300 unsigned int np = NPar();; 301 for (unsigned int i = 0; i < np; ++i); 302 grad[i] = DoParameterDerivative(x, par, i);; 303 }; 304 }; 305 ; 306 // struct for dealing of generic Hessian computation, since it is available only in TFormula; 307 template <class T>; 308 struct GeneralHessianCalc {; 309 static bool Hessian(TF1 *, const T *, const double *, T *); 310 {; 311 Error(""He",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:10269,avoid,avoid,10269,doc/master/WrappedMultiTF1_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html,1,['avoid'],['avoid']
Safety,"rum. Meth. A372, 469 (1996) [hep-ph/9509307] ; TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum. ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition. ; Monte Carlo inputs: . xini: true underlying spectrum (TH1D, n bins) . bini: reconstructed spectrum (TH1D, n bins) . Adet: response matrix (TH2D, nxn bins) . Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TSVDUnfoldSVD Approach to Data Unfolding.Definition TSVDUnfold.h:46; TSVDUnfold::UnfoldTH1D * Unfold(Int_t kreg)Perform the unfolding with regularisation parameter kreg.Definition TSVDUnfold.cxx:237; where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:1303,detect,detector,1303,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['detect'],['detector']
Safety,"rvables, parameters of interest; and nuisance parameters. Defaults:; observables: determined from data,; global observables = explicit obs - obs from data; parameters of interest: empty,; nuisance parameters: all parameters except parameters of interest. We use NULL to mean not set, so we don't want to fill; with empty RooArgSets. void Print(Option_t* option = """") const; print contents of Model on the default print stream; It can be changed using RooPrintable. void SetWS(RooWorkspace& ws); set a workspace that owns all the necessary components for the analysis. RooWorkspace * GetWS() const; get from TRef. void SetSnapshot(const RooArgSet& set); save snaphot in the workspace; and use values passed with the set. const RooArgSet * GetSnapshot() const; Load the snapshot from ws and return the corresponding set with the snapshot values.; User must delete returned RooArgSet. void LoadSnapshot() const; load the snapshot from ws if it exists. void DefineSetInWS(const char* name, const RooArgSet& set); helper functions to avoid code duplication. void ImportPdfInWS(const RooAbsPdf& pdf); internal function to import Pdf in WS. void ImportDataInWS(RooAbsData& data); internal function to import data in WS. Bool_t SetHasOnlyParameters(const RooArgSet& set, const char* errorMsgPrefix = 0). ModelConfig(RooWorkspace* ws = 0). ModelConfig(const char* name, RooWorkspace* ws = 0). ModelConfig(const char* name, const char* title, RooWorkspace* ws = 0). ModelConfig * Clone(const char* name = """") const; clone. void SetWorkspace(RooWorkspace& ws); alias for SetWS(...). { SetWS(ws); }. void SetProtoData(RooAbsData& data); Set the proto DataSet, add to the the workspace if not already there. SetProtoData(const char* name). void SetPdf(const RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. SetPdf(const char* name). void SetPriorPdf(const RooAbsPdf& pdf); Set the Prior Pdf, add to the the workspace if not already there. SetPriorPdf(const char* name). void SetParamet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ModelConfig.html:9685,avoid,avoid,9685,root/html534/RooStats__ModelConfig.html,https://root.cern,https://root.cern/root/html534/RooStats__ModelConfig.html,6,['avoid'],['avoid']
Safety,"rver::BrowseKey ; (; const char * ; keyname). Read key object and send it back to client. ; Definition at line 1010 of file TApplicationServer.cxx. ◆ Class(). static TClass * TApplicationServer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TApplicationServer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TApplicationServer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 94 of file TApplicationServer.h. ◆ DeclFileName(). static const char * TApplicationServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 94 of file TApplicationServer.h. ◆ ErrorHandler(). void TApplicationServer::ErrorHandler ; (; Int_t ; level, . Bool_t ; abort, . const char * ; location, . const char * ; msg . ). staticprotected . The error handler function. ; It prints the message on stderr and if abort is set it aborts the application. ; Definition at line 1088 of file TApplicationServer.cxx. ◆ ExecLogon(). void TApplicationServer::ExecLogon ; (; ). private . Execute logon macro's. ; There are three levels of logon macros that will be executed: the system logon etc/system.rootlogon.C, the global user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward compatibility also the logon macro as specified by the Rint.Logon environment setting, by default ./rootlogon.C, will be executed. No logon macros will be executed when the system is started with the -n option. ; Definition at line 1277 of file TApplicationServer.cxx. ◆ GetHost(). const char * TApplicationServer::GetHost ; (; ); const. inline . Definition at line 73 of file TApplicationServer.h. ◆ GetOptions(). void TApplicationServer::GetOptions ; (; Int_t * ; argc, . char ** ; argv . ). overridevirtual . Get and handle command line options. ; Fixed format: ""protocol url"" ; Reimplemented from TApplication.; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:25056,abort,abort,25056,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,2,['abort'],"['abort', 'aborts']"
Safety,"ry is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was per",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1028208,Safe,Safety,1028208,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Safe'],['Safety']
Safety,"ry on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:9718,avoid,avoid,9718,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,2,['avoid'],['avoid']
Safety,"ryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = __null); Geometry checking. Opional overlap checkings (by sampling and by mesh). Optional; boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mil. random rays inside EACH volume and calling; FindNextBoundary() + Safety() for each call. The timing is normalized by the; number of crossings computed at stage 2 and presented as percentage.; One can get a picture on which are the most ""burned"" volumes during; transportation from geometry point of view. Another plot of the timing per; volume vs. number of daughters is produced.; All histos are saved in the file statistics.root. Int_t PropagateInGeom(Double_t* , Double_t* ); Propagate from START along DIR from boundary to boundary until exiting; geometry. Fill array of hits. void Score(TGeoVolume* , Int_t , Double_t ); Score a hit for VOL. void SetNmeshPoints(Int_t npoints = 1000); Set number of points to be generated on the shape outline when checking for overlaps. Double_t TimingPerVolume(TGeoVolume* ); Compute timing per ""FindNextBoundary"" + ""Safety"" call. Volume must be; in the current path. void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Shoot nrays with random directions from starti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoChecker.html:12736,Safe,Safety,12736,root/html602/TGeoChecker.html,https://root.cern,https://root.cern/root/html602/TGeoChecker.html,2,['Safe'],['Safety']
Safety,"ryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ;   kSetBranchStatus = (1ULL << ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TTree; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:47212,detect,detection,47212,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,1,['detect'],['detection']
Safety,"s ();  Static method to check if threads exist. ;  ; static Int_t Exit (void *ret=nullptr);  Static method which terminates the execution of the calling thread. ;  ; static TThread * GetThread (const char *name);  Static method to find a thread by name. ;  ; static TThread * GetThread (Long_t id);  Static method to find a thread by id. ;  ; static Int_t GetTime (ULong_t *absSec, ULong_t *absNanoSec);  Static method to get the current time. ;  ; static void Initialize ();  Initialize the Thread package. ;  ; static Bool_t IsInitialized ();  Return true, if the TThread objects have been initialize. ;  ; static Long_t Join (Long_t id, void **ret=nullptr);  Static method to join a thread by id. ;  ; static Int_t Kill (const char *name);  Static method to kill thread by name. ;  ; static Int_t Kill (Long_t id);  Static method to kill the thread by id. ;  ; static Int_t Lock ();  Static method to lock the main thread mutex. ;  ; static void Printf (const char *fmt,...);  Static method providing a thread safe printf. Appends a newline. ;  ; static void Ps ();  Static method listing the existing threads. ;  ; static void ps ();  ; static TThread * Self ();  Static method returning pointer to current thread. ;  ; static Long_t SelfId ();  Static method returning the id for the current thread. ;  ; static Int_t SetCancelAsynchronous ();  Static method to set the cancellation response type of the calling thread to asynchronous, i.e. ;  ; static Int_t SetCancelDeferred ();  Static method to set the cancellation response type of the calling thread to deferred, i.e. ;  ; static Int_t SetCancelOff ();  Static method to turn off thread cancellation. ;  ; static Int_t SetCancelOn ();  Static method to turn on thread cancellation. ;  ; static Int_t Sleep (ULong_t secs, ULong_t nanos=0);  Static method to sleep the calling thread. ;  ; static Int_t TryLock ();  Static method to try to lock the main thread mutex. ;  ; static void ** Tsd (void *dflt, Int_t k);  Static method returning a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTThread.html:13103,safe,safe,13103,doc/master/classTThread.html,https://root.cern,https://root.cern/doc/master/classTThread.html,1,['safe'],['safe']
Safety,"s += contLevel->GetSize();; }. nGraphs = 0;. TCanvas* c1 = new TCanvas(""c1"",""Contour List"",610,0,600,600);; c1->SetTopMargin(0.15);; TH2F *hr = new TH2F(""hr"",; ""#splitline{Negative contours are returned first (highest to lowest). Positive contours are returned from}{lowest to highest. On this plot Negative contours are drawn in red and positive contours in blue.}"",; 2, -2, 2, 2, 0, 6.5);. hr->Draw();; Double_t x0, y0, z0;; TLatex l;; l.SetTextSize(0.03);; char val[20];. for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(i);; if (i<3) z0 = contours[2-i];; else z0 = contours[i];; printf(""Z-Level Passed in as: Z = %f\n"", z0);. // Get first graph from list on curves on this level; curv = (TGraph*)contLevel->First();; for(j = 0; j < contLevel->GetSize(); j++){; curv->GetPoint(0, x0, y0);; if (z0<0) curv->SetLineColor(kRed);; if (z0>0) curv->SetLineColor(kBlue);; nGraphs ++;; printf(""\tGraph: %d -- %d Elements\n"", nGraphs,curv->GetN());. // Draw clones of the graphs to avoid deletions in case the 1st; // pad is redrawn.; gc = (TGraph*)curv->Clone();; gc->Draw(""C"");. sprintf(val,""%g"",z0);; l.DrawLatex(x0,y0,val);; curv = (TGraph*)contLevel->After(curv); // Get Next graph; }; }; c1->Update();; printf(""\n\n\tExtracted %d Contours and %d Graphs \n"", TotalConts, nGraphs );; gStyle->SetTitleW(0.);; gStyle->SetTitleH(0.);; return c1;; }. Double_t SawTooth(Double_t x, Double_t WaveLen){. // This function is specific to a sawtooth function with period; // WaveLen, symmetric about x = 0, and with amplitude = 1. Each segment; // is 1/4 of the wavelength.; //; // |; // /\ |; // / \ |; // / \ |; // / \; // /--------\--------/------------; // |\ /; // | \ /; // | \ /; // | \/; //. Double_t y;; if ( (x < -WaveLen/2) || (x > WaveLen/2)) y = -99999999; // Error X out of bounds; if (x <= -WaveLen/4) {; y = x + 2.0;; } else if ((x > -WaveLen/4) && (x <= WaveLen/4)) {; y = -x ;; } else if (( x > WaveLen/4) && (x <= WaveLen/2)) {; y = x - 2.0;; }; return y;; }; The following opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:42312,avoid,avoid,42312,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,6,['avoid'],['avoid']
Safety,"s Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeAssembly. class TGeoVolumeAssembly: public TGeoVolume. TGeoVolume - the base class representing solids. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put togeather a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolumeAssembly.html:1097,avoid,avoid,1097,root/html528/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html528/TGeoVolumeAssembly.html,4,['avoid'],['avoid']
Safety,"s ONLY and the others; 161MANY as in GEANT3, where this concept was introduced:; 162 1. The part of a MANY node B extruding its container A will never be ""seen""; 163during navigation, as if B was in fact the result of the intersection of A and B.; 164 2. If we have two nodes A (ONLY) and B (MANY) inside the same container, all; 165points in the overlapping region of A and B will be designated as belonging to A.; 166 3. If A an B in the above case were both MANY, points in the overlapping; 167part will be designated to the one defined first. Both nodes must have the; 168same medium.; 169 4. The slices of a divided MANY will be as well MANY.; 170 ; 171One needs to know that navigation inside geometry parts MANY nodes is much; 172slower. Any overlapping part can be defined based on composite shapes - this; 173is always recommended.; 174 ; 175### Replicating volumes; 176 ; 177 What can we do if our chamber contains two identical wires instead of one ?; 178What if then we would need 1000 chambers in our detector ? Should we create; 1792000 wires and 1000 chamber volumes ? No, we will just need to replicate the; 180ones that we have already created.; 181 ; 182~~~ {.cpp}; 183 chamber->AddNode(wire_co, 1, new TGeoTranslation(-0.2,0,0));; 184 chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));; 185~~~; 186 ; 187 The 2 nodes that we have created inside chamber will both point to a wire_co; 188object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:9544,detect,detector,9544,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['detect'],['detector']
Safety,"s TPostScript. Writing several canvases to the same Postscript or PDF file:. if the Postscript or PDF file name finishes with ""("", the file is not closed; if the Postscript or PDF file name finishes with "")"" and the file has been opened; with ""("", the file is closed. Example:. {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); //write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); canvas is added to ""c1.ps"" and ps file is closed; }. In the previous example replacing ""ps"" by ""pdf"" will create a multi-pages PDF file. Note that the following sequence writes the canvas to ""c1.ps"" and closes the ps file.:; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps"");. The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be; a little inconvenient to have the action of opening/closing a file; being atomic with printing a page. Particularly if pages are being; generated in some loop one needs to detect the special cases of first; and last page and then munge the argument to Print() accordingly. The ""["" and ""]"" can be used instead of ""("" and "")"". Example:. c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.ps""); // actually print canvas to file; }// end loop; c1.Print(""file.ps]""); // No actual print, just close. As before, the same macro is valid for PDF files. It is possible to print a canvas into an animated GIF file by specifying the; file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay; between the subimages' display. If NN is ommitted the delay between; subimages is zero. Each picture is added in the animation thanks to a loop; similar to the following one:. for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; }// end loop. The delay between each frame must be specified in each Print() statement.; If t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:52491,detect,detect,52491,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,6,['detect'],['detect']
Safety,"s TPostScript. Writing several canvases to the same Postscript or PDF file:. if the Postscript or PDF file name finishes with ""("", the file is not closed; if the Postscript or PDF file name finishes with "")"" and the file has been opened; with ""("", the file is closed. Example:. {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); //write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); canvas is added to ""c1.ps"" and ps file is closed; }. In the previous example replacing ""ps"" by ""pdf"" will create a multi-pages PDF file. Note that the following sequence writes the canvas to ""c1.ps"" and closes the ps file.:; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps"");. The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be; a little inconvenient to have the action of opening/closing a file; being atomic with printing a page. Particularly if pages are being; generated in some loop one needs to detect the special cases of first; and last page and then munge the argument to Print() accordingly. The ""["" and ""]"" can be used instead of ""("" and "")"". Example:. c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.ps""); // actually print canvas to file; }// end loop; c1.Print(""file.ps]""); // No actual print, just close. As before, the same macro is valid for PDF files. It is possible to print a pad into an animated GIF file by specifying the; file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay; between the subimages' display. If NN is ommitted the delay between; subimages is zero. Each picture is added in the animation thanks to a loop; similar to the following one:. for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; }// end loop. The delay between each frame must be specified in each Print() statement. void Ran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:50395,detect,detect,50395,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,4,['detect'],['detect']
Safety,"s a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ;  RadioNuclides.CMacro that demonstrates usage of radioactive elements/materials/mixtures with TGeo pac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:109068,detect,detector,109068,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['detect'],['detector']
Safety,"s an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for example, to initialize some non-persistent data members after the persistent data is read. In this case, the custom streamer can use the StreamerInfo record to decompose a self-identifying object in the exact same manner as the generated s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootio.html:8825,avoid,avoids,8825,doc/master/rootio.html,https://root.cern,https://root.cern/doc/master/rootio.html,1,['avoid'],['avoids']
Safety,"s an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general pl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSAViewer.html:27160,timeout,timeout,27160,root/html528/TGLSAViewer.html,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html,2,['timeout'],['timeout']
Safety,"s an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general pl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLSAViewer.html:27280,timeout,timeout,27280,root/html530/TGLSAViewer.html,https://root.cern,https://root.cern/root/html530/TGLSAViewer.html,2,['timeout'],['timeout']
Safety,"s an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLSAViewer.h 36895 2010-11-24 11:46:09Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general pl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLSAViewer.html:27280,timeout,timeout,27280,root/html532/TGLSAViewer.html,https://root.cern,https://root.cern/root/html532/TGLSAViewer.html,4,['timeout'],['timeout']
Safety,"s and streamer info structures All irrelevant data will be cleaned ; Definition at line 559 of file TXMLFile.cxx. ◆ ReadKeysList(). Int_t TXMLFile::ReadKeysList ; (; TDirectory * ; dir, . XMLNodePointer_t ; topnode . ). protected . Read list of keys for directory. ; Definition at line 630 of file TXMLFile.cxx. ◆ ReadStreamerElement(). void TXMLFile::ReadStreamerElement ; (; XMLNodePointer_t ; node, . TStreamerInfo * ; info . ). protected . read and reconstruct single TStreamerElement from xml node ; Definition at line 825 of file TXMLFile.cxx. ◆ Recover(). Int_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:66885,recover,recover,66885,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recover']
Safety,"s at low z; 109 ; 110public:; 111 // constructors; 112 TGeoTrap();; 113 TGeoTrap(Double_t dz, Double_t theta, Double_t phi);; 114 TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1,; 115 Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 116 TGeoTrap(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1,; 117 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 118 // destructor; 119 ~TGeoTrap() override;; 120 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 121 Double_t *safe = nullptr) const override;; 122 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 123 Double_t *step) const override;; 124 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 125 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 126 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 127 Double_t *step) const override;; 128 TGeoVolume *; 129 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 130 Double_t GetTheta() const { return fTheta; }; 131 Double_t GetPhi() const { return fPhi; }; 132 Double_t GetH1() const { return fH1; }; 133 Double_t GetBl1() const { return fBl1; }; 134 Double_t GetTl1() const { return fTl1; }; 135 Double_t GetAlpha1() const { return fAlpha1; }; 136 Double_t GetH2() const { return fH2; }; 137 Double_t GetBl2() const { return fBl2; }; 138 Double_t GetTl2() const { return fTl2; }; 139 Double_t GetAlpha2() const { return fAlpha2; }; 140 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 141 void SetDimensions(Double_t *param) override;; 142 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:6563,safe,safe,6563,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"s been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; ; the parameters are badly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:10146,recover,recovers,10146,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['recover'],['recovers']
Safety,"s been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; that the solution is not well-defined, for example that there are more; unknowns than there are data points, or that the parameterization of the; fit contains a linear dependence. If this is the case, then MINUIT (or any; other program) cannot solve your problem uniquely, and the error matrix; will necessarily be largely meaningless, so the user must remove the; underdeterminedness by reformulating the parameterization. MINUIT cannot; do this itself. Numerical inaccuracies:. It is possible that the apparent lack of positive-definiteness is in fact; only due to excessive roundoff errors in numerical calculations in the; user function or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or if; the parameters are badly sc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuit.html:10147,recover,recovers,10147,root/html602/TMinuit.html,https://root.cern,https://root.cern/root/html602/TMinuit.html,4,['recover'],['recovers']
Safety,"s box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoBBox.html:14976,safe,safe,14976,root/html528/TGeoBBox.html,https://root.cern,https://root.cern/root/html528/TGeoBBox.html,4,['safe'],['safe']
Safety,"s classes"" usage. ;  GUI tutorialsExample code which illustrates how to use the ROOT GUI ;  Histograms tutorialsExamples showing the ""histograms' classes"" usage. ;  HTTP tutorialsExamples showing the HTTP interface ;  Image tutorialsExamples showing the TImage class usage ;  IO tutorialsThese tutorials illustrate some of the capabilities of the ROOT IO subsystem ;  Math tutorialsExamples showing the Math classes ;  Matrix tutorialsExamples showing how to use TMatrix ;  Monte Carlo tutorialsMonte Carlo examples ;  TMemStat tutorialsExamples showing the TMemStat class ;  Multi Layer Perceptron tutorialsExamples showing the Multi Layer Perceptron classes ;  Multicore tutorialsThese examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing ;  Net tutorialsExamples showing the net classes ;  Physics tutorialsPhysics examples ;  ►Proof tutorialsThese examples aim to illustrate the usage of PROOF ;  ProcFileElementsClass to hold information about the processed elements of a file ;  ProofAuxSelector used for auxiliary actions in the PROOF tutorials ;  ProofEventSelector for generic processing with Event ;  ProofEventProcSelector to process trees containing Event structures ;  ProofFriendsSelector to process tree friends ;  ProofNtupleSelector to fill a simple ntuple ;  ProofPythiaSelector to generate Monte Carlo events with Pythia8 ;  ProofSimpleSelector to fill a set of histograms ;  ProofSimpleFileSelector to fill a set of histograms and merging via file ;  ProofStdVecSelector for generic processing with stdlib collections ;  ProofTestsAuxilliary selector used to test PROOF functionality ;  PyRoot tutorialsExamples showing how to write python script for Root ;  Pythia tutorialsExamples showing the pythia usage ;  Quadratic programming package.Example showing the usage of the quadratic programming package quadp ;  R tutorialsExamples showing the R interface ;  RooFit TutorialsThese tutorials illustrate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/modules.html:10754,safe,safety,10754,doc/v614/modules.html,https://root.cern,https://root.cern/doc/v614/modules.html,2,['safe'],['safety']
Safety,"s classes"" usage. ;  GUI tutorialsExample code which illustrates how to use the ROOT GUI ;  Histograms tutorialsExamples showing the ""histograms' classes"" usage. ;  HTTP tutorialsExamples showing the HTTP interface ;  Image tutorialsExamples showing the TImage class usage ;  IO tutorialsThese tutorials illustrate some of the capabilities of the ROOT IO subsystem ;  Math tutorialsExamples showing the Math classes ;  Matrix tutorialsExamples showing how to use TMatrix ;  Monte Carlo tutorialsMonte Carlo examples ;  TMemStat tutorialsExamples showing the TMemStat class ;  Multi Layer Perceptron tutorialsExamples showing the Multi Layer Perceptron classes ;  Multicore tutorialsThese examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing ;  Net tutorialsExamples showing the net classes ;  Physics tutorialsPhysics examples ;  ►Proof tutorialsThese examples aim to illustrate the usage of PROOF ;  ProcFileElementsClass to hold information about the processed elements of a file ;  ProofAuxSelector used for auxiliary actions in the PROOF tutorials ;  ProofEventSelector for generic processing with Event ;  ProofEventProcSelector to process trees containing Event structures ;  ProofFriendsSelector to process tree friends ;  ProofNtupleSelector to fill a simple ntuple ;  ProofPythiaSelector to generate Monte Carlo events with Pythia8 ;  ProofSimpleSelector to fill a set of histograms ;  ProofSimpleFileSelector to fill a set of histograms and merging via file ;  ProofStdVecSelector for generic processing with stdlib collections ;  ProofTestsAuxilliary selector used to test PROOF functionality ;  PyRoot tutorialsExamples showing how to write python script for Root ;  Pythia tutorialsExamples showing the pythia usage ;  Quadratic programming package.Example showing the use of the quadratic programming package quadp ;  R tutorialsExamples showing the R interface ;  RooFit TutorialsThese tutorials illustrate t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/modules.html:10499,safe,safety,10499,doc/v610/modules.html,https://root.cern,https://root.cern/doc/v610/modules.html,2,['safe'],['safety']
Safety,"s distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; int. TPaletteAxis inherits from TBox and TPave. The methods allowing to specify the palette position are inherited from these two classes.; The palette can be interactively moved and resized. The context menu can be used to set the axis attributes.; It is possible to select a range on the axis to set the min/max in z; As default labels and ticks are drawn by TGAxis at equidistant (lin or log) points as controlled by SetNdivisions. If option ""CJUST"" is given labels and ticks are justified at the color boundaries defined by the contour levels. In this case no optimization can be done. It is responsibility of the user to adjust minimum, maximum of the histogram and/or the contour levels to get a reasonable look of the plot. Only overlap of the labels is avoided if too many contour levels are used.; This option is especially useful with user defined contours. An example is shown here:; {; gStyle->SetOptStat(0);; auto c = new TCanvas(""c"",""exa_CJUST"",300,10,400,400);; auto hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; // Fill histograms randomly; TRandom3 randomNum;; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; randomNum.Rannor(px,py);; hpxpy->Fill(px,py);; }; hpxpy->SetMaximum(200);; Double_t zcontours[5] = {0, 20, 40, 80, 120};; hpxpy->SetContour(5, zcontours);; hpxpy->GetZaxis()->SetTickSize(0.01);; hpxpy->GetZaxis()->SetLabelOffset(0.01);; gPad->SetRightMargin(0.13);; hpxpy->SetTitle(""User contours, CJUST"");; hpxpy->Draw(""COL Z CJUST"");; }; c#define c(i)Definition RSha256.hxx:101; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPaletteAxis.html:2840,avoid,avoided,2840,doc/master/classTPaletteAxis.html,https://root.cern,https://root.cern/doc/master/classTPaletteAxis.html,1,['avoid'],['avoided']
Safety,"s fills only used elements depending on dimension and type; 404 GetStats(s1);; 405 h1->GetStats(s2);; 406 }; 407 // get number of entries now because afterwards UpdateBinContent will change it; 408 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 409 ; 410 ; 411 // Perform the Add.; 412 Double_t factor = 1;; 413 if (h1p->GetNormFactor() != 0); 414 factor = h1p->GetNormFactor() / h1p->GetSumOfWeights();; 415 for (bin = 0; bin < fNcells; bin++) {; 416 Double_t y = this->RetrieveBinContent(bin) + c1 * h1p->RetrieveBinContent(bin);; 417 UpdateBinContent(bin, y);; 418 if (fSumw2.fN) {; 419 Double_t esq = factor * factor * h1p->GetBinErrorSqUnchecked(bin);; 420 fSumw2.fArray[bin] += c1 * c1 * factor * factor * esq;; 421 }; 422 }; 423 ; 424 // update statistics (do here to avoid changes by SetBinContent); 425 if (resetStats) {; 426 // statistics need to be reset in case coefficient are negative; 427 ResetStats();; 428 } else {; 429 for (Int_t i = 0; i < kNstat; i++) {; 430 if (i == 1) s1[i] += c1 * c1 * s2[i];; 431 else s1[i] += c1 * s2[i];; 432 }; 433 PutStats(s1);; 434 SetEntries(entries);; 435 }; 436 return kTRUE;; 437}; 438 ; 439////////////////////////////////////////////////////////////////////////////////; 440/// Adds the input bin into the partition cell matrix. This method is called; 441/// in AddBin() and ChangePartition().; 442 ; 443void TH2Poly::AddBinToPartition(TH2PolyBin *bin); 444{; 445 // Cell Info; 446 Int_t nl, nr, mb, mt; // Max/min indices of the cells that contain the bin; 447 Double_t xclipl, xclipr, yclipb, yclipt; // x and y coordinates of a cell; 448 Double_t binXmax, binXmin, binYmax, binYmin; // The max/min bin coordinates; 449 ; 450 binXmax = bin->GetXMax();; 451 binXmin = bin->GetXMin();; 452 binYmax = bin->GetYMax();; 453 binYmin = bin->GetYMin();; 454 nl = (Int_t)(floor((binXmin - fXaxis.GetXmin())/fStepX));; 455 nr = (Int_t)(floor((binXmax - fXaxis.GetXmin())/fStepX));; 456 mb = (Int_t)(floor((binYmin - fYaxis.GetXmin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:16317,avoid,avoid,16317,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['avoid'],['avoid']
Safety,"s in the efficiency and background estimate. The signal is always assumed to be Poisson; background may be Poisson, Gaussian, or user-supplied; efficiency may be Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum. Meth. A551:493-503,2005.; TLimit class computes 95% C.L. limits using the Likelihood ratio semi-Bayesian method ( method; see e.g. T. Junk, NIM A434, p. 435-443, 1999). It takes signal background and data histograms wrapped in a TLimitDataSource as input, and runs a set of Monte Carlo experiments in order to compute the limits. If needed, inputs are fluctuated according to systematic.; 13.14.2 Specialized Classes for Fitting; TFractionFitter fits Monte Carlo (MC) fractions to data histogram (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993) 219-228). It takes into account both data and Monte Carlo statistical uncertainties through a likelihood fit using Poisson statistics. However, the template (MC) predictions are also varied within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimization with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content.; TMultiDimFit implements multi-dimensional function parametrization for multi-dimensional data by fitting them to multi-dimensional data using polynomial or Chebyshev or Legendre polynomial; TSpectrum contains advanced spectra processing functions for 1- and 2-dimensional background estimation, smoothing, deconvolution, peak search and fitting, and orthogonal transformations.; RooFit is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to acces",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:766388,predict,predictions,766388,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['predict'],['predictions']
Safety,"s not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 11 methods from RFC 3253 */; 10550 /* ORDERPATCH (RFC 3648) */; 10551 /* ACL (RFC 3744) */; 10552 /* SEARCH (RFC 5323) */; 10553 /* + MicroSoft extensions; 10554 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10555 ; 10556 /* REPORT method (RFC 3253) */; 10557 {""REPORT"", 1, 1, 1, 1, 1},; 10558 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10559 /* It was defined for WEBDAV in RFC 3253, Sec. 3.6; 10560 * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems; 10561 * to be useful for REST in case a ""GET request with body"" is; 10562 * required. */; 10563 ; 10564 {NULL, 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:302888,safe,safe,302888,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"s not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 11 methods from RFC 3253 */; 10551 /* ORDERPATCH (RFC 3648) */; 10552 /* ACL (RFC 3744) */; 10553 /* SEARCH (RFC 5323) */; 10554 /* + MicroSoft extensions; 10555 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10556 ; 10557 /* REPORT method (RFC 3253) */; 10558 {""REPORT"", 1, 1, 1, 1, 1},; 10559 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10560 /* It was defined for WEBDAV in RFC 3253, Sec. 3.6; 10561 * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems; 10562 * to be useful for REST in case a ""GET request with body"" is; 10563 * required. */; 10564 ; 10565 {NULL, 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:302921,safe,safe,302921,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"s null (default), clear the input data info. ; Definition at line 9538 of file TProof.cxx. ◆ ClearPackage(). Int_t TProof::ClearPackage ; (; const char * ; package). Remove a specific package. ; Returns 0 in case of success and -1 in case of error. ; Definition at line 7857 of file TProof.cxx. ◆ ClearPackages(). Int_t TProof::ClearPackages ; (; ). Remove all packages. ; Returns 0 in case of success and -1 in case of error. ; Definition at line 7840 of file TProof.cxx. ◆ Close(). void TProof::Close ; (; Option_t * ; opt = """"). Close all open slave servers. ; Client can decide to shutdown the remote session by passing option is 'S' or 's'. Default for clients is detach, if supported. Masters always shutdown the remote counterpart. ; Definition at line 1798 of file TProof.cxx. ◆ CloseProgressDialog(). void TProof::CloseProgressDialog ; (; ). Close progress dialog. ; Definition at line 9283 of file TProof.cxx. ◆ Collect() [1/4]. Int_t TProof::Collect ; (; const TSlave * ; sl, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from slave sl. ; Returns the number of slaves that responded (=1). If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2669 of file TProof.cxx. ◆ Collect() [2/4]. Int_t TProof::Collect ; (; ESlaves ; list = kActive, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2727 of file TProof.cxx. ◆ Collect() [3/4]. Int_t TProof::Collect ; (; TList * ; slaves, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:76989,timeout,timeout,76989,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['timeout'],['timeout']
Safety,"s objects within that frame.Definition RooPlot.h:45; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf510_wsnamedsetsDefinition rf510_wsnamedsets.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8C.html:8712,safe,safe,8712,doc/master/rf510__wsnamedsets_8C.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html,1,['safe'],['safe']
Safety,"s of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). Option compress is used to specify the compression level:; compress = 0 objects written to this file will not be compressed.; compress = 1 minimal compression level but fast. compress = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map() shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:26095,detect,detected,26095,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['detect'],['detected']
Safety,"s or step sizes. ; Definition at line 319 of file TFractionFitter.cxx. ◆ GetMCPrediction(). TH1 * TFractionFitter::GetMCPrediction ; (; Int_t ; parm); const. Return the adjusted MC template (Aji) for template (parm). ; Note that the (Aji) times fractions only sum to the total prediction of the fit if all weights are 1. Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if the class is deleted ; Definition at line 961 of file TFractionFitter.cxx. ◆ GetNDF(). Int_t TFractionFitter::GetNDF ; (; ); const. return the number of degrees of freedom in the fit the fNDF parameter has been previously computed during a fit. ; The number of degrees of freedom corresponds to the number of points used in the fit minus the number of templates. ; Definition at line 894 of file TFractionFitter.cxx. ◆ GetPlot(). TH1 * TFractionFitter::GetPlot ; (; ). Return the ""template prediction"" corresponding to the fit result (this is not the same as the weighted sum of template distributions, as template statistical uncertainties are taken into account). ; Note that the name of this histogram will simply be the same as that of the ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if the class is deleted ; Definition at line 621 of file TFractionFitter.cxx. ◆ GetProb(). Double_t TFractionFitter::GetProb ; (; ); const. return the fit probability ; Definition at line 903 of file TFractionFitter.cxx. ◆ GetRanges(). void TFractionFitter::GetRanges ; (; Int_t & ; minX, . Int_t & ; maxX, . Int_t & ; minY, . Int_t & ; maxY, . Int_t & ; minZ, . Int_t & ; maxZ . ); const. private . Used internally to obtain the bin ranges according to the dimensionality of the histogram and the limits set by hand. ; Definition at line 639 of file TFractionFitter.cxx. ◆ GetResult(). void TFractionFitter::GetResult ; (; Int_t ; parm, . Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:27885,predict,prediction,27885,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['predict'],['prediction']
Safety,"s part of ROOT, the GenVector package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:. Every class and function is in the ROOT::Math namespace.; Member function names start with upper-case letter, apart some exceptions (see the next section about CLHEP compatibility). 13.12.1.8 Compatibility with CLHEP Vector Classes. For backward compatibility with CLHEP the vector classes can be constructed from a CLHEP HepVector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessorsx(), y(), and z() (and t() for the 4D).; We provide vector member function with the same naming convention as CLHEP for the most used functions like x(), y() and z(). 13.12.1.9 Connection to Linear Algebra Package; In some use cases, like in track reconstruction, it is needed to use the content of the vector and rotation classes in conjunction with linear algebra operations. We prefer to avoid any direct dependency to any linear algebra package. However, we provide some hooks to convert to and from linear algebra classes. The vector and the transformation classes have methods which allow to get and set their data members (like SetCoordinates and GetCoordinates) passing either a generic iterator or a pointer to a contiguous set of data, like a C array. This allows an easy connection with the linear algebra package, which in turn, allows creation of matrices using C arrays (like the ROOT TMatrix classes) or iterators (SMatrix classes). Multiplication between linear algebra matrices and GenVector vectors is possible by using the template free functions ROOT::Math::VectorUtil::Mult. This function works for any linear algebra matrix, which implements the operator (i,j) and with first matrix element at i=j=0.; 13.12.2 Example: 3D Vector Classes; To avoid exposing template parameter to the users, typedef’s are defined for all types of vectors based on double’s and float’s. To use them, one must in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:726938,avoid,avoid,726938,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avoid'],['avoid']
Safety,"s shown.; 3358 ; 3359Double_t TFormula::DoEval(const double * x, const double * params) const; 3360{; 3361 if(!fReadyToExecute); 3362 {; 3363 Error(""Eval"", ""Formula is invalid and not ready to execute "");; 3364 for (auto it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3365 TFormulaFunction fun = *it;; 3366 if (!fun.fFound) {; 3367 printf(""%s is unknown.\n"", fun.GetName());; 3368 }; 3369 }; 3370 return TMath::QuietNaN();; 3371 }; 3372 ; 3373 // Lazy initialization is set and needed when reading from a file; 3374 if (!fClingInitialized && fLazyInitialization) {; 3375 // try recompiling the formula. We need to lock because this is not anymore thread safe; 3376 R__LOCKGUARD(gROOTMutex);; 3377 // check again in case another thread has initialized the formula (see ROOT-10994); 3378 if (!fClingInitialized) {; 3379 auto thisFormula = const_cast<TFormula*>(this);; 3380 thisFormula->ReInitializeEvalMethod();; 3381 }; 3382 if (!fClingInitialized) {; 3383 Error(""DoEval"", ""Formula has error and it is not properly initialized "");; 3384 return TMath::QuietNaN();; 3385 }; 3386 }; 3387 ; 3388 if (fLambdaPtr && TestBit(TFormula::kLambda)) {// case of lambda functions; 3389 std::function<double(double *, double *)> & fptr = * ( (std::function<double(double *, double *)> *) fLambdaPtr);; 3390 assert(x);; 3391 //double * v = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3392 double * v = const_cast<double*>(x);; 3393 double * p = (params) ? const_cast<double*>(params) : const_cast<double*>(fClingParameters.data());; 3394 return fptr(v, p);; 3395 }; 3396 ; 3397 ; 3398 Double_t result = 0;; 3399 void* args[2];; 3400 double * vars = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3401 args[0] = &vars;; 3402 if (fNpar <= 0) {; 3403 (*fFuncPtr)(nullptr, 1, args, &result);; 3404 } else {; 3405 double *pars = (params) ? const_cast<double *>(params) : const_cast<double *>(fClingParameters.data());; 3406 args[1] = &pars;; 3407 (*fFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:128356,safe,safe,128356,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['safe'],['safe']
Safety,"s sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:22997,timeout,timeout,22997,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,4,['timeout'],['timeout']
Safety,"s sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:22275,timeout,timeout,22275,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,4,['timeout'],['timeout']
Safety,"s some information about the network in the terminal. void GatherInformations(); Collect information about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMLPAnalyzer.html:7646,risk,risk,7646,root/html534/TMLPAnalyzer.html,https://root.cern,https://root.cern/root/html534/TMLPAnalyzer.html,6,['risk'],['risk']
Safety,"s stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoShape.html:21179,safe,safe,21179,root/html534/TGeoShape.html,https://root.cern,https://root.cern/root/html534/TGeoShape.html,2,['safe'],['safe']
Safety,"s stored in TFiles: for example, these files might not be writeable, just readable. In addition, modifying in place a TTree causes a new TTree instance to be written and the previous one to be deleted. For this reasons, ROOT offers the concept of friends for TTree and TChain: if is good practice to rely on friend trees rather than adding a branch manually. An Example. // A simple example with histograms and a tree; //; // This program creates :; // - a one dimensional histogram; // - a two dimensional histogram; // - a profile histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file.; ; #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h""; ; //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; ; // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; ; // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;; ; // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; ; Float_t px,py,pz;; ; // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:12209,detect,detector,12209,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['detect'],['detector']
Safety,"s the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TThread.html:14261,safe,safe,14261,root/html532/TThread.html,https://root.cern,https://root.cern/root/html532/TThread.html,4,['safe'],['safe']
Safety,"s the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread(const TThread& ). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TThread.html:15138,safe,safe,15138,root/html602/TThread.html,https://root.cern,https://root.cern/root/html602/TThread.html,4,['safe'],['safe']
Safety,"s the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integral));; }; The biggest application of the memory-safe interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is strongly encouraged and appreciated.; Removal of some memory-unsafe interfaces. The final bool takeOwnership parameter of the RooAddition and RooStats::HistFactory::PiecewiseInterpolation constructors was removed. This is to avoid situations where ownership is not clear to the compiler. Now, ownership of the input RooAbsArgs is never passed in the constructor. If you want the pass input ownership to the created object, please use addOwnedComponents. If you want to be extra safe, make sure the inputs are in an owning collection and then std::move the collection, so that the ownership is always clear.; Example:; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; should become:; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));. Deprecation of legacy iterators; The following methods related to the RooFit legacy iterators are deprecated and will be removed in ROOT 6.34. They s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:11408,avoid,avoid,11408,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['avoid'],['avoid']
Safety,"s the window size in pixels along X; 476/// \param[in] wh is the window size in pixels along Y; 477 ; 478void TCanvas::Constructor(const char *name, const char *title, Int_t wtopx,; 479 Int_t wtopy, Int_t ww, Int_t wh); 480{; 481 if (gThreadXAR) {; 482 void *arr[8];; 483 arr[1] = this; arr[2] = (void*)name; arr[3] = (void*)title;; 484 arr[4] = &wtopx; arr[5] = &wtopy; arr[6] = &ww; arr[7] = &wh;; 485 if ((*gThreadXAR)(""CANV"", 8, arr, nullptr)) return;; 486 }; 487 ; 488 Init();; 489 SetBit(kMenuBar,true);; 490 if (wtopx < 0) {; 491 wtopx = -wtopx;; 492 SetBit(kMenuBar,false);; 493 }; 494 fCw = ww;; 495 fCh = wh;; 496 fCanvasID = -1;; 497 TCanvas *old = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(name);; 498 if (old && old->IsOnHeap()) {; 499 Warning(""Constructor"",""Deleting canvas with same name: %s"",name);; 500 delete old;; 501 }; 502 if (gROOT->IsBatch()) { //We are in Batch mode; 503 fWindowTopX = fWindowTopY = 0;; 504 fWindowWidth = ww;; 505 fWindowHeight = wh;; 506 fCw = ww;; 507 fCh = wh;; 508 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, name, fCw, fCh);; 509 if (!fCanvasImp) return;; 510 fBatch = kTRUE;; 511 } else { //normal mode with a screen window; 512 Float_t cx = gStyle->GetScreenFactor();; 513 auto factory = gROOT->IsWebDisplay() ? gBatchGuiFactory : gGuiFactory;; 514 fCanvasImp = factory->CreateCanvasImp(this, name, Int_t(cx*wtopx), Int_t(cx*wtopy), UInt_t(cx*ww), UInt_t(cx*wh));; 515 if (!fCanvasImp) return;; 516 ; 517 if (!gROOT->IsBatch() && fCanvasID == -1); 518 fCanvasID = fCanvasImp->InitWindow();; 519 ; 520 fCanvasImp->ShowMenuBar(TestBit(kMenuBar));; 521 fBatch = kFALSE;; 522 }; 523 ; 524 CreatePainter();; 525 ; 526 fName = GetNewCanvasName(name); // avoid Modified() signal from SetName; 527 SetTitle(title); // requires fCanvasImp set; 528 Build();; 529 ; 530 // Popup canvas; 531 fCanvasImp->Show();; 532}; 533 ; 534////////////////////////////////////////////////////////////////////////////////; 535/// Initialize the TCanvas members.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:16752,avoid,avoid,16752,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avoid'],['avoid']
Safety,"s the wrapped object and allow to call its methods. ; Definition at line 286 of file TThreadedObject.hxx. ◆ SetAtSlot(). template<class T > . void ROOT::TThreadedObject< T >::SetAtSlot ; (; unsigned ; i, . std::shared_ptr< T > ; v . ). inline . Set the value of a particular slot. ; This method is thread-safe as long as concurrent calls access different slots (i.e. pass a different argument) and no thread accesses slot i via the arrow operator, so mixing usage of SetAtSlot with usage of the arrow operator can be dangerous. ; Definition at line 227 of file TThreadedObject.hxx. ◆ SnapshotMerge(). template<class T > . std::unique_ptr< T > ROOT::TThreadedObject< T >::SnapshotMerge ; (; TThreadedObjectUtils::MergeFunctionType< T > ; mergeFunction = TThreadedObjectUtils::MergeTObjects<T>). inline . Merge all the thread private objects. ; Can be called many times. It does create a new instance of class T to represent the ""Sum"" object. This method is not thread safe: correct or acceptable behaviours depend on the nature of T and of the merging function. ; Definition at line 312 of file TThreadedObject.hxx. Member Data Documentation. ◆ fDirectories. template<class T > . std::deque<TDirectory*> ROOT::TThreadedObject< T >::fDirectories. private . A TDirectory per slot. ; Definition at line 332 of file TThreadedObject.hxx. ◆ fgMaxSlots. template<class T > . constexpr const TNumSlots ROOT::TThreadedObject< T >::fgMaxSlots {64}. staticconstexpr . The initial number of empty processing slots that a TThreadedObject is constructed with by default. ; Deprecated: TThreadedObject grows as more slots are required. ; Definition at line 155 of file TThreadedObject.hxx. ◆ fIsMerged. template<class T > . bool ROOT::TThreadedObject< T >::fIsMerged. private . Remember if the objects have been merged already. ; Definition at line 335 of file TThreadedObject.hxx. ◆ fModel. template<class T > . std::unique_ptr<T> ROOT::TThreadedObject< T >::fModel. private . Use to store a ""model"" of the object. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:9270,safe,safe,9270,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['safe'],['safe']
Safety,"s to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TMap*fAssignedPackMap {worker,packetizer} of lat assignement; TVirtualPacketizer*fCurrentPacketizer being currently processed; TList*fPacketizersPacketizers to be processed; TIter*fPacketizersIterIterator on fPacketizers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerMulti(); Destructor. TDSetElement * GetNextPacket(TSlave* wrk, TMessage* r); Get next packet from the current packetizer.; If the current packetizer is done, move to next.; Retun null when all packetizers are done. TVirtualPacketizer * CreatePacketizer(TDSet* dset, TList* wrks, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Create a packetizer for dataset 'dset'; Return null on failure. TPacketizerMulti(). TPacketizerMulti(const TPacketizerMulti& ). void operator=(const TPacketizerMulti& ). Int_t GetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls). Float_t GetCurrentRate(Bool_t& all). void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE). void MarkBad(TSlave* wrk, TProofProgressStatus* st, TList** missing); { if (fCurrent) fCurrent->MarkBad(wrk, st, missing); return; }. Int_t AddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing). Int_t GetActiveWorkers(); { if (fCurrent) return fCurrent->GetActiveWorkers(); return 0; }. » Author: G. Ganis Jan 2010 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Mon Jul 4 15:35:36 2011 » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPacketizerMulti.html:10532,abort,abort,10532,root/html530/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html530/TPacketizerMulti.html,1,['abort'],['abort']
Safety,"s to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TMap*fAssignedPackMap {worker,packetizer} of lat assignement; TVirtualPacketizer*fCurrentPacketizer being currently processed; TList*fPacketizersPacketizers to be processed; TIter*fPacketizersIterIterator on fPacketizers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerMulti(); Destructor. TDSetElement * GetNextPacket(TSlave* wrk, TMessage* r); Get next packet from the current packetizer.; If the current packetizer is done, move to next.; Retun null when all packetizers are done. TVirtualPacketizer * CreatePacketizer(TDSet* dset, TList* wrks, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Create a packetizer for dataset 'dset'; Return null on failure. TPacketizerMulti(). TPacketizerMulti(const TPacketizerMulti& ). void operator=(const TPacketizerMulti& ). Int_t GetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls). Float_t GetCurrentRate(Bool_t& all). void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE). void MarkBad(TSlave* wrk, TProofProgressStatus* st, TList** missing); { if (fCurrent) fCurrent->MarkBad(wrk, st, missing); return; }. Int_t AddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing). Int_t GetActiveWorkers(); { if (fCurrent) return fCurrent->GetActiveWorkers(); return 0; }. » Author: G. Ganis Jan 2010 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:20:59 2011 » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPacketizerMulti.html:10532,abort,abort,10532,root/html532/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html532/TPacketizerMulti.html,2,['abort'],['abort']
Safety,"s to send to each processor. The TTree::Process method is used to specify the selector and the entries. Before we can use TTree::Process we need to make a selector. We can call the TTree::MakeSelector method. It creates two files similar to TTree::MakeClass.; In the resulting files is a class that is a descendent of TSelector and implements the following methods:. TSelector::Begin() - this method is called every time a loop over the tree starts. This is a convenient place to create your histograms.; TSelector::Notify() - it is called at the first entry of a new tree in a chain.; TSelector::Process() - it is called to process an event. It is the user’s responsibility to read the corresponding entry in memory (may be just a partial read). Once the entry is in memory one can apply a selection and if the event is selected histograms can be filled. Processing stops when this function returns kFALSE. It combines the methods TSelector::ProcessCut() and TSelector::ProcessFill() in one, avoiding the necessity to maintain the state in the class to communicate between these two functions. It reduces the information that needs to be shared between them and promotes a more granular data access by reading branches as they are needed.; TSelector::Terminate() - it is called at the end of a loop on a TTree. This is a convenient place to draw and fit your histograms.; TSelector::Version() - this function provides backward compatibility for old versions and support for the future upgrades.; The TSelector, unlike the resulting class from MakeClass, separates the processing into a ProcessCut() and ProcessFill(), so we can limit reading of branches to the ones we need.; When a selector is used with a TChain in methods Process(), ProcessFill(), ProcessCut(), you must use the pointer to the current TTree to call the method GetEntry(entry). The parameter entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use. fChain-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:644512,avoid,avoiding,644512,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avoid'],['avoiding']
Safety,"s updates timer; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0); Constructor. ~TVirtualPacketizer(); Destructor. Long64_t GetEntries(Bool_t tree, TDSetElement* e); Get entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. void StopProcess(Bool_t abort); Stop process. TDSetElement* CreateNewPacket(TDSetElement* base, Long64_t first, Long64_t num); Creates a new TDSetElement from from base packet starting from; the first entry with num entries.; The function returns a new created objects which have to be deleted. Bool_t HandleTimer(TTimer* timer); Send progress message to client. void SetInitTime(); Set the initialization time. TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0). void operator=(const TVirtualPacketizer& ). Bool_t IsValid() const; { return fValid; }. Long64_t GetEntriesProcessed() const; { return (fProgressStatus? fProgressStatus->GetEntries() : 0); }. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); { ent = GetEntriesProcessed(); bytes = GetBytesRead(); calls = GetReadCalls(); return 0; }. Float_t GetCurrentRate(Bool_t& all); { all = kTRUE; return (fProgressStatus? fProgressStatus->GetCurrentRate() : 0.); }. Long64_t GetTotalEntries() const; { return fTotalEnt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPacketizer.html:8901,abort,abort,8901,root/html528/TVirtualPacketizer.html,https://root.cern,https://root.cern/root/html528/TVirtualPacketizer.html,1,['abort'],['abort']
Safety,"s() [7/9]. TGraphErrors::TGraphErrors ; (; const TGraphErrors & ; gr). TGraphErrors copy constructor. ; Definition at line 170 of file TGraphErrors.cxx. ◆ TGraphErrors() [8/9]. TGraphErrors::TGraphErrors ; (; const TH1 * ; h). TGraphErrors constructor importing its parameters from the TH1 object passed as argument. ; Definition at line 204 of file TGraphErrors.cxx. ◆ TGraphErrors() [9/9]. TGraphErrors::TGraphErrors ; (; const char * ; filename, . const char * ; format = ""%lg %lg %lg %lg"", . Option_t * ; option = """" . ). GraphErrors constructor reading input from filename. ; filename is assumed to contain at least 2 columns of numbers; Convention for format (default=""%lg %lg %lg %lg""). format = lg lg read only 2 first columns into X,Y; format = lg lg lg read only 3 first columns into X,Y and EY; format = lg lg lg lg read only 4 first columns into X,Y,EX,EY. For files separated by a specific delimiter different from ' ' and \\t (e.g. ; in csv files) you can avoid using %*s to bypass this delimiter by explicitly specify the option argument, e.g. option="" \\t,;"" for columns of figures separated by any of these characters (‘’ ', '\t', ',', ';') used once (e.g.""1;1"") or in a combined way ("" 1;,;; 1""`).; Note in that case, the instantiation is about 2 times slower. In case a delimiter is specified, the format ""%lg %lg %lg"" will read X,Y,EX. ; Definition at line 235 of file TGraphErrors.cxx. ◆ ~TGraphErrors(). TGraphErrors::~TGraphErrors ; (; ). override . TGraphErrors default destructor. ; Definition at line 368 of file TGraphErrors.cxx. Member Function Documentation. ◆ AddPointError(). void TGraphErrors::AddPointError ; (; Double_t ; x, . Double_t ; y, . Double_t ; ex = 0., . Double_t ; ey = 0. . ). virtual . Add a point with errorbars to the graph. ; Definition at line 377 of file TGraphErrors.cxx. ◆ Allocate(). Double_t ** TGraphErrors::Allocate ; (; Int_t ; newsize). inlineoverrideprotectedvirtual . Allocate internal data structures for newsize points. ; Reimplemented f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphErrors.html:36957,avoid,avoid,36957,doc/master/classTGraphErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphErrors.html,1,['avoid'],['avoid']
Safety,"s) constFill node copy numbers of current branch into an array.Definition TGeoNavigator.cxx:444; TGeoNavigator::CheckPathBool_t CheckPath(const char *path) constCheck if a geometry path is valid without changing the state of the navigator.Definition TGeoNavigator.cxx:256; TGeoNavigator::SetOutsidevoid SetOutside(Bool_t flag=kTRUE)Definition TGeoNavigator.h:148; TGeoNavigator::SetStartSafevoid SetStartSafe(Bool_t flag=kTRUE)Definition TGeoNavigator.h:136; TGeoNavigator::IsEnteringBool_t IsEntering() constDefinition TGeoNavigator.h:140; TGeoNavigator::GetMotherMatrixTGeoHMatrix * GetMotherMatrix(Int_t up=1) constDefinition TGeoNavigator.h:156; TGeoNavigator::fCurrentVolumeTGeoVolume * fCurrentVolumecache of statesDefinition TGeoNavigator.h:74; TGeoNavigator::fLastNodeTGeoNode * fLastNodetop physical nodeDefinition TGeoNavigator.h:77; TGeoNavigator::SetCldirCheckedvoid SetCldirChecked(Double_t *dir)Definition TGeoNavigator.h:193; TGeoNavigator::fThreadIdInt_t fThreadIdlast safety returned from parallel world (negative if invalid)Definition TGeoNavigator.h:54; TGeoNavigator::LocalToMasterBombvoid LocalToMasterBomb(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:237; TGeoNavigator::SetPWSafetyCachingstatic void SetPWSafetyCaching(Bool_t b)Definition TGeoNavigator.h:231; TGeoNavigator::GetPWSafetyEstimateFromCacheDouble_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) constDefinition TGeoNavigator.h:208; TGeoNavigator::fDirectionDouble_t fDirection[3]current pointDefinition TGeoNavigator.h:50; TGeoNavigator::PopDummyvoid PopDummy(Int_t ipop=9999)Definition TGeoNavigator.h:280; TGeoNavigator::GetTouchedClusterInt_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result)Make the cluster of overlapping nodes in a voxel, containing point in reference of the mother.Definition TGeoNavigator.cxx:2245; TGeoNavigator::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t stepmax=TGeoShape::Big(), const char *path="""",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:26145,safe,safety,26145,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['safe'],['safety']
Safety,"s). Sometimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX, halfY, halfZ);; TGeoVolume *vol_tub = gGeoManager->MakeTube(""TUB_VOL"", ""mat2"", rmin, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoShape.html:4062,safe,safe,4062,root/html528/TGeoShape.html,https://root.cern,https://root.cern/root/html528/TGeoShape.html,4,['safe'],['safe']
Safety,"s);  ; static void MeanSquaredErrorGradients (TMatrixT< AReal > &dY, const TMatrixT< AReal > &Y, const TMatrixT< AReal > &output, const TMatrixT< AReal > &weights);  ; static AReal CrossEntropy (const TMatrixT< AReal > &Y, const TMatrixT< AReal > &output, const TMatrixT< AReal > &weights);  Sigmoid transformation is implicitly applied, thus output should hold the linear activations of the last layer in the net. ;  ; static void CrossEntropyGradients (TMatrixT< AReal > &dY, const TMatrixT< AReal > &Y, const TMatrixT< AReal > &output, const TMatrixT< AReal > &weights);  ; static AReal SoftmaxCrossEntropy (const TMatrixT< AReal > &Y, const TMatrixT< AReal > &output, const TMatrixT< AReal > &weights);  Softmax transformation is implicitly applied, thus output should hold the linear activations of the last layer in the net. ;  ; static void SoftmaxCrossEntropyGradients (TMatrixT< AReal > &dY, const TMatrixT< AReal > &Y, const TMatrixT< AReal > &output, const TMatrixT< AReal > &weights);  ; Output Functions; Output functions transform the activations output of the output layer in the network to a valid prediction YHat for the desired usage of the network, e.g.; the identity function for regression or the sigmoid transformation for two-class classification. . static void Sigmoid (TMatrixT< AReal > &YHat, const TMatrixT< AReal > &);  ; static void Softmax (TMatrixT< AReal > &YHat, const TMatrixT< AReal > &);  ; Regularization; For each regularization type, two functions are required, one named <Type>Regularization that evaluates the corresponding regularization functional for a given weight matrix and the Add<Type>RegularizationGradients, that adds the regularization component in the gradients to the provided matrix. . static AReal L1Regularization (const TMatrixT< AReal > &W);  ; static void AddL1RegularizationGradients (TMatrixT< AReal > &A, const TMatrixT< AReal > &W, AReal weightDecay);  ; static AReal L2Regularization (const TMatrixT< AReal > &W);  ; static void AddL2R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html:11932,predict,prediction,11932,doc/master/classTMVA_1_1DNN_1_1TReference.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html,1,['predict'],['prediction']
Safety,"s)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←. RooProofDriverSelector. TProofDraw; ←. TProofDrawEntryList. TProofDrawEventList. TProofDrawGraph. TProofDrawHist. TProofDrawListOfGraphs. TProofDrawListOfPolyMarkers3D. TProofDrawPolyMarker3D. TProofDrawProfile.  [more...]. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelector.html:9836,Abort,Abort,9836,root/html602/TSelector.html,https://root.cern,https://root.cern/root/html602/TSelector.html,4,['Abort'],['Abort']
Safety,"s)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfActivetrue if task is active; Int_tfBreakin=1 if a break point set at task extry; Int_tfBreakout=1 if a break point set at task exit; Bool_tfHasExecutedTrue if task has executed; TStringTNamed::fNameobject identifier; TStringfOptionOption specified in ExecuteTask; TList*fTasksList of Tasks; TStringTNamed::fTitleobject title; static TTask*fgBeginTaskpointer to task initiator; static TTask*fgBreakPointpointer to current break point. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TTask. Function documentation; TTask(); Default constructor invoked when reading a TTask object from a file. TTask(const char* name, const char* title); Standard constructor. TTask& operator=(const TTask& tt); assignment operator (PLEASE DO NOT USE THIS IS WRONG). TTask(const TTask& task); Copy constructor. ~TTask(); Delete a task and its subtasks. void Abort(); Abort current tree of tasks.; After this call, the tree of tasks is ready to be executed again.; The application must take care of cleaning data structures created; by previous executions. void Browse(TBrowser* b); Browse the list of tasks.; It is recommended to add the top level task to the list of; ROOT browsables by:; gROOT->GetListOfBrowsables()->Add(myTopLevelTask). void CleanTasks(); Reset tasks state: breakpoints and execute flags; also invokes the Clear function of each task to clear all data; structures created by a previous execution of a task. void Clear(Option_t* option = """"); Recursively call the Clear function of this task and its subtasks.; The Clear function must be implemented for each derived class; to clear all data structures created by a previous execution of a task.; This function is automatically called by the CleanTasks function. void Continue(); Resume execution at the current break point. void Exec(Option_t* option); Dummy Execute.; This function must be redefined in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTask.html:9959,Abort,Abort,9959,root/html602/TTask.html,https://root.cern,https://root.cern/root/html602/TTask.html,4,['Abort'],['Abort']
Safety,"s)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TSelector::EAbortfAbortAbort status; TList*fInputList of objects available during processing; TObject*fObject!Current object if processing object (vs. TTree); TStringfOptionOption given to TTree::Process; TSelectorList*fOutput!List of objects created during processing; Long64_tfStatusSelector status. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←. RooProofDriverSelector. TProofDraw; ←. TProofDrawEntryList. TProofDrawEventList. TProofDrawGraph. TProofDrawHist. TProofDrawListOfGraphs. TProofDrawListOfPolyMarkers3D. TProofDrawPolyMarker3D. TProofDrawProfile.  [more...]. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelector.html:10039,abort,aborted,10039,root/html602/TSelector.html,https://root.cern,https://root.cern/root/html602/TSelector.html,8,['abort'],['aborted']
Safety,"s*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidComputeTwist(); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoArb8.html:2827,safe,safe,2827,root/html532/TGeoArb8.html,https://root.cern,https://root.cern/root/html532/TGeoArb8.html,2,['safe'],['safe']
Safety,"s, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:101013,detect,detected,101013,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['detect'],['detected']
Safety,"s, but may take (much) longer to calculate NoteTo include the uncertainty from the expected number of events, the Normalization() argument with ScaleType RooAbsReal::RelativeExpected has to be passed, e.g. pdf.plotOn(frame, VisualizeError(fitResult), Normalization(1.0, RooAbsReal::RelativeExpected));; RooAbsReal::RelativeExpected@ RelativeExpectedDefinition RooAbsReal.h:276. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma . Reimplemented from RooAbsPdf.; Definition at line 133 of file RooAbsPdf.cxx. ◆ plotOn() [5/5]. RooPlot * RooSimultaneous::plotOn ; (; RooPlot * ; frame, . RooLinkedList & ; cmdList . ); const. overridevirtual . Back-end for plotOn() implementation on RooSimultaneous which needs special handling because a RooSimultaneous PDF cannot project out its index category via integration. ; plotOn() will abort if this is requested without providing a projection dataset. ; Reimplemented from RooAbsPdf.; Definition at line 597 of file RooSimultaneous.cxx. ◆ selectNormalization(). void RooSimultaneous::selectNormalization ; (; const RooArgSet * ; normSet = nullptr, . bool ; force = false . ). overrideprotectedvirtual . Interface function used by test statistics to freeze choice of observables for interpretation of fraction coefficients. ; Needed here because a RooSimultaneous works like a RooAddPdf when plotted ; Reimplemented from RooAbsReal.; Definition at line 938 of file RooSimultaneous.cxx. ◆ selectNormalizationRange(). void RooSimultaneous::selectNormalizationRange ; (; const char * ; normRange2 = nullptr, . bool ; force = false . ). overrideprotectedvirtual . Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ; Needed here because a RooSimultaneous works like a RooAddPdf when plotted ; Reimplemented from RooAbsReal.; Definition at line 950 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:98098,abort,abort,98098,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['abort'],['abort']
Safety,"s, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoParaboloid&operator=(const TGeoParaboloid&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParaboloidDimensions(Double_t rlo, Double_t rhi, Double_t dz); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaboloid.html:9030,Safe,SafetyPhi,9030,root/html534/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html,1,['Safe'],['SafetyPhi']
Safety,"s, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; std::pair< double, double > GetLoopSafetyCandidates (double point[3], std::vector< int > &candidates, double margin=0.) const;  Method to find potentially relevant candidate bounding boxes for safety calculation given a point. ;  ; void InitSafetyVoxel (TGeoVoxelGridIndex const &);  Method to initialize the safety voxel at a specific 3D voxel (grid) index. ;  ; Double_t SafetyBVH (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster) ;  ; Double_t SafetyLoop (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (trivial loop version for comparison/debugging) ;  ; Double_t SafetyOrig (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world (original version based on TGeoVoxelFinder) ;  ; void TestVoxelGrid ();  ; Double_t VoxelSafety (Double_t point[3], Double_t safmax=1.E30);  Compute safety for the parallel world used BVH structure with addiditional on-the-fly 3D grid/voxel caching —> essentially an O(1) algorithm !) ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoParallelWorld.h>. Inheritance diagram for TGeoParallelWorld:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ AccelerationMode. enum class TGeoParallelWorld::AccelerationMode. strong . EnumeratorkVoxelFinder ; kBVH . Definition at line 28 of file TGeoParallelWorld.h. Constructor & Destructor Documentation. ◆ TGeoParallelWorld() [1/3]. TGeoParallelWorld::TGeoParallelWorld ; (; const TGeoParallelWorld & ; ). protecteddelete . switch between different algorithm implementations . ◆ TGeoParallelWorld() [2/3]. TGeoParallelWorld::TGeoParall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:16587,safe,safety,16587,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['safe'],['safety']
Safety,"s. ; At the moment two engine kinds are supported:. civetweb or http (default); fastcgi. Examples: // creates civetweb web server with http port 8080; serv->CreateEngine(""http:8080"");; serv->CreateEngine(""civetweb:8080"");; serv->CreateEngine("":8080"");; // creates fastcgi server with port 9000; serv->CreateEngine(""fastcgi:9000"");; One could apply additional parameters, using URL syntax: serv->CreateEngine(""http:8080?thrds=10""); . Definition at line 419 of file THttpServer.cxx. ◆ CreateItem(). Bool_t THttpServer::CreateItem ; (; const char * ; fullname, . const char * ; title . ). Create item in sniffer. ; Definition at line 1455 of file THttpServer.cxx. ◆ CreateServerThread(). void THttpServer::CreateServerThread ; (; ). Creates special thread to process all requests, directed to http server. ; Should be used with care - only dedicated instance of TRootSniffer is allowed By default THttpServer allows to access global lists pointers gROOT or gFile. To be on the safe side, all kind of such access performed from the main thread. Therefore usage of specialized thread means that no any global pointers will be accessible by THttpServer ; Definition at line 515 of file THttpServer.cxx. ◆ DeclFileName(). static const char * THttpServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 198 of file THttpServer.h. ◆ ExecuteHttp(). Bool_t THttpServer::ExecuteHttp ; (; std::shared_ptr< THttpCallArg > ; arg). Execute HTTP request. ; Executes http request, specified in THttpCallArg structure.; Method can be called from any thread Actual execution will be done in main ROOT thread, where analysis code is running. ; Definition at line 642 of file THttpServer.cxx. ◆ ExecuteWS(). Bool_t THttpServer::ExecuteWS ; (; std::shared_ptr< THttpCallArg > & ; arg, . Bool_t ; external_thrd = kFALSE, . Bool_t ; wait_process = kFALSE . ). Execute WS request. ; Execute WS related operation. ; Definition at line 1299 of file THttpServer.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:23725,safe,safe,23725,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['safe'],['safe']
Safety,"s. ;  ; void SetImageAutoSave (Bool_t s);  ; void SetImageCount (Int_t ic);  ; void SetImageGUIBaseName (const TString &gname);  ; void SetImageGUIOutMode (Int_t m);  Set output mode for GUI operation: 1 - animated gif; 2 - a series of pngs. ;  ; void SetImageName (const TString &name);  ; void SetRotateScene (Bool_t rotateScene);  ; void SetWDolly (Double_t w);  ; void SetWPhi (Double_t w);  ; void SetWTheta (Double_t w);  ; void Start ();  Start the auto-rotator. ;  ; void StartImageAutoSave (const TString &filename);  Start saving into a set of images. ;  ; void StartImageAutoSaveAnimatedGif (const TString &filename);  Start saving into animated gif. ;  ; void StartImageAutoSaveWithGUISettings ();  Start auto-saving images as set-up via GUI. ;  ; void Stop ();  Stop the auto-rotator. ;  ; void StopImageAutoSave ();  Stops automatic saving of images. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Timeout ();  Called on every timer timeout. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLAutoRotator.html:2913,timeout,timeout,2913,doc/master/classTGLAutoRotator.html,https://root.cern,https://root.cern/doc/master/classTGLAutoRotator.html,1,['timeout'],['timeout']
Safety,"s. For large systems this kind of defensive measures can make quite a difference in compile time. Also never include a header file when a forward declaration is enough. On include header files for base classes or classes that are used by value in the class definition.; Implementation file layout; Each implementation file has the following layout:. Module identification line; Author line; Copyright notice; Class description comments (see above); Header file includes; Actual method implementation. For a typical example see TObject.cxx.; Note the mandatory method separator line:; ////////////////////////////////////////; exactly 80 characters long.; Preferred Coding Style; Here we describe our preferred coding style. Coding style is very personal and we don't want to force our views on anybody. But for any contributions to the ROOT system that we have to maintain we would like you to follow our coding style.; Indentation; To be able to keep as much code as possible in the visible part of the editor of to avoid over abundant line wrapping we use indentation of 3 spaces. No tabs since they give the code always a different look depending on the tab settings of the original coder. If everything looks nicely lined up with a tab setting of 4 spaces, it does not look so nicely anymore when the tab setting is changed to 3, 5, etc. spaces.; Placing Braces and Spaces; The other issue that always comes up in C/C++ styling is the placement of braces and spaces. Unlike the indent size, there are few technical reasons to choose one placement strategy over the other, but the preferred way, as shown to us by the prophets Kernighan and Ritchie, is to put the opening brace last on the line, and put the closing brace first, thus:; if (x is true) {; we do y; }; However, there is one special case, namely functions: they have the opening brace at the beginning of the next line, thus:; int function (int x); {; body of function; }; Functions are special (you can't nest them in C/C++).; Note t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:6848,avoid,avoid,6848,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['avoid'],['avoid']
Safety,"s. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of risk evolution.␛[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can safely be ignored if only a; : few (<3) occur. If more warnings are generated,; : the fitting fails.; : A remedy may be to increase the value; : ␛[1mGDValidEveFrac␛[0m to 1.0 (or a larger value).; : In addition, if ␛[1mGDPathEveFrac␛[0m is too high; : the same warnings may occur since the events; : used for error estimation are also used for; : path estimation.; : Another possibility is to modify the model - ; : See above on tuning the rule ensemble.; : ; : ␛[1mThe error rate was still decreasing at the end of the path␛[0m; : Too few steps in path! Increase ␛[1mGDNSteps␛[0m.; : ; : ␛[1mReached minimum early in the search␛[0m; : Minimum was found early in the fitting. This; : may indicate that the used ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:56017,risk,risk,56017,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['risk'],['risk']
Safety,"s. To alleviate this, the new class RooBinSamplingPdf has been added to RooFit. Also see arxiv:2012.02746.; More accurate residual and pull distributions; When making residual or pull distributions with RooPlot::residHist or RooPlot::pullHist, the histogram is now compared with the curve’s average values within a given bin by default, ensuring that residual and pull distributions are valid for strongly curved distributions. The old default behaviour was to interpolate the curve at the bin centres, which can still be enabled by setting the useAverage parameter of RooPlot::residHist or RooPlot::pullHist to false.; Improved recovery from invalid parameters; When a function in RooFit is undefined (Poisson with negative mean, PDF with negative values, etc), RooFit can now pass information about the “badness” of the violation to the minimiser. The minimiser can use this to compute a gradient to find its way out of the undefined region. This can drastically improve its ability to recover when unstable fit models are used, for example RooPolynomial.; For details, see the RooFit tutorial rf612_recoverFromInvalidParameters.C and arxiv:2012.02746.; Modernised RooDataHist; RooDataHist was partially modernised to improve const-correctness, to reduce side effects as well as its memory footprint, and to make it ready for RooFit’s faster batch evaluations. Derived classes that directly access protected members might need to be updated. This holds especially for direct accesses to _curWeight, _curWeightErrLo, etc, which have been removed. (It doesn’t make sense to write to these members from const functions when the same information can be retrieved using an index access operator of an array.) All similar accesses in derived classes should be replaced by the getters get_curWeight() or better get_wgt(i), which were also supported in ROOT <v6.24. More details on what happened:. Reduced side effects. This code produces undefined behaviour because the side effect of get(i), i.e., loadin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:22034,recover,recover,22034,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['recover'],['recover']
Safety,"s.; 8214 //; 8215 // fClusterRangeEnd contains the last entries number of a cluster range.; 8216 // In particular this means that the 'next' cluster starts at fClusterRangeEnd[]+1; 8217 // fClusterSize contains the size in number of entries of all the cluster; 8218 // within the given range.; 8219 // The last range (and the only one if fNClusterRange is zero) start at; 8220 // fNClusterRange[fNClusterRange-1]+1 and ends at the end of the TTree. The; 8221 // size of the cluster in this range is given by the value of fAutoFlush.; 8222 //; 8223 // For example printing the beginning and end of each the ranges can be done by:; 8224 //; 8225 // Printf(""%-16s %-16s %-16s %5s"",; 8226 // ""Cluster Range #"", ""Entry Start"", ""Last Entry"", ""Size"");; 8227 // Int_t index= 0;; 8228 // Long64_t clusterRangeStart = 0;; 8229 // if (fNClusterRange) {; 8230 // for( ; index < fNClusterRange; ++index) {; 8231 // Printf(""%-16d %-16lld %-16lld %5lld"",; 8232 // index, clusterRangeStart, fClusterRangeEnd[index], fClusterSize[index]);; 8233 // clusterRangeStart = fClusterRangeEnd[index] + 1;; 8234 // }; 8235 // }; 8236 // Printf(""%-16d %-16lld %-16lld %5lld"",; 8237 // index, prevEntry, fEntries - 1, fAutoFlush);; 8238 //; 8239 ; 8240 // Note: We store the entry number corresponding to the end of the cluster; 8241 // rather than its start in order to avoid using the array if the cluster; 8242 // size never varies (If there is only one value of AutoFlush for the whole TTree).; 8243 ; 8244 if( fAutoFlush != autof) {; 8245 if ((fAutoFlush > 0 || autof > 0) && fFlushedBytes) {; 8246 // The mechanism was already enabled, let's record the previous; 8247 // cluster if needed.; 8248 MarkEventCluster();; 8249 }; 8250 fAutoFlush = autof;; 8251 }; 8252}; 8253 ; 8254////////////////////////////////////////////////////////////////////////////////; 8255/// Mark the previous event as being at the end of the event cluster.; 8256///; 8257/// So, if fEntries is set to 10 (and this is the first cluster) when MarkEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:320805,avoid,avoid,320805,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avoid'],['avoid']
Safety,"s.CScript illustrating the use of transparency with ||-Coord ;  radialgradients.CThis tutorial demonstrates how to use radial gradients, custom colors, transparency ;  transp.CThis demo shows how to use transparency ;  transp_text.CThis macro is based on labels1.C by Rene Brun ;  transparentpad.CThis macro demonstrates semi-transparent pads ;  ► cont;  cnt001_basictseq.C Example showing possible usages of the TSeq class ;  TListAndSTL.C This is an example of using TList with STL algoritms in CLING ;  ► eve;  alice_esd.CComplex example showing ALICE ESD track visualization ;  alice_esd_html_summary.CHtml table and event summary for alice_esd.C ;  alice_esd_split.CComplex example showing ALICE ESD visualization in several views ;  alice_vsd.CComplex example showing ALICE VSD visualization ;  annotation.CDemonstrates usage of TGLAnnotation class ;  arrow.CDemonstrates usage of TEveArrow class ;  arrow_standalone.CHow to use EVE without the standard window ;  assembly.CGeometry detector assembly example ;  box.CDemonstrates usage of TEveBox class ;  boxset.CDemonstrates usage of TEveBoxSet class ;  boxset_cones.CDemonstrates usage of 'cone' mode in TEveBoxSet class ;  calo_detail.CCalorimeter detailed view by using TEveCaloDataVec as data-source ;  calorimeters.CDemonstrates usage of EVE calorimetry classes ;  camera_restore.C;  compound.CDemonstrates usage of EVE compound objects - class TEveCompound ;  csgdemo.CCombinatorial Solid Geometry example ;  geom_alias.CDemonstates usage of geometry aliases - merge ALICE ITS with ATLAS MUON ;  geom_alice_its.CShows geometry of ALICE ITS ;  geom_alice_tpc.CShows geometry of ALICE TPC ;  geom_atlas.CShows ATLAS geometry ;  geom_atlas_playback.CPlays back event-recording of a root session running geom_atlas.C tutorial ;  geom_cms.CShows CMS geometry ;  geom_cms_playback.CPlays back event-recording of a root session running geom_cms.C tutorial ;  geom_cms_stereo.CShows CMS geometry in stereo mode ;  geom_default.CDemonstrates usag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:101166,detect,detector,101166,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['detect'],['detector']
Safety,"s.find(lvs->GetName()) ;; 853 if (tmp) {; 854 leafNodes.remove(*tmp) ;; 855 leafNodes.add(*lvs) ;; 856 }; 857 }; 858 }; 859 }; 860 ; 861 // check if this arg is also in the projection set; 862 if(nullptr != projectedVars && projectedVars->find(arg->GetName())) {; 863 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 864 << ""\"" cannot be both a dependent and a projected variable."" << std::endl;; 865 return nullptr;; 866 }; 867 }; 868 ; 869 // Remove the projected variables from the list of leaf nodes, if necessary.; 870 if(nullptr != projectedVars) leafNodes.remove(*projectedVars,true);; 871 ; 872 // Make a deep-clone of ourself so later operations do not disturb our original state; 873 cloneSet = new RooArgSet;; 874 if (RooArgSet(*this).snapshot(*cloneSet, true)) {; 875 coutE(Plotting) << ""RooAbsPdf::createPlotProjection("" << GetName() << "") Couldn't deep-clone PDF, abort,"" << std::endl ;; 876 return nullptr ;; 877 }; 878 RooAbsReal *theClone= static_cast<RooAbsReal*>(cloneSet->find(GetName()));; 879 ; 880 // The remaining entries in our list of leaf nodes are the external; 881 // dependents (x) and parameters (p) of the projection. Patch them back; 882 // into the theClone. This orphans the nodes they replace, but the orphans; 883 // are still in the cloneList and so will be cleaned up eventually.; 884 //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;; 885 ; 886 std::unique_ptr<RooArgSet> plotLeafNodes{leafNodes.selectCommon(dependentVars)};; 887 theClone->recursiveRedirectServers(*plotLeafNodes,false,false,false);; 888 ; 889 // Create the set of normalization variables to use in the projection integrand; 890 RooArgSet normSet(dependentVars);; 891 if(nullptr != projectedVars) normSet.add(*projectedVars);; 892 if(nullptr != condObs) {; 893 normSet.remove(*condObs,true,true) ;; 894 }; 895 ; 896 // Try to create a valid projection integral. If no variables are to be projected,; 897 // create a null project",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:35051,abort,abort,35051,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['abort'],['abort']
Safety,"s/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage the user must only provide an implementation of the FCNBase class to M and parameters and uncertainties in form of std::vector containers.; 3.5.2 Memory allocation and thread safety; Differently to the version of M , the version has its own memory manager (StackAllocator. The user can select between the standard dynamic memory allocation and deallocation (default) and performance-optimized stack–like allocation (optional). However, the library is not thread save using stack–allocation.; 3.5.3 M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in whic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:30672,safe,safety,30672,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['safe'],['safety']
Safety,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IBaseParam.html:1663,avoid,avoid,1663,root/html534/ROOT__Math__IBaseParam.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseParam.html,2,['avoid'],['avoid']
Safety,"s; Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights. This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the RooFit::AsymptoticError() command argument in RooAbsPdf::fitTo(). See also this writeup on extended weighted fits that is also linked from the reference guide. The pull request that introduced this feature might also be a good reference.; Compile your code with memory safe interfaces; If you define the ROOFIT_MEMORY_SAFE_INTERFACES preprocessor macro, the RooFit interface changes in a way such that memory leaks are avoided.; The most prominent effect of this change is that many functions that used to return an owning pointer (e.g., a pointer to an object that you need to manually delete) are then returning a std::unique_pt for automatic memory management.; For example this code would not compile anymore, because there is the risk that the caller forgets to delete params:; RooArgSet * params = pdf.getParameters(nullptr);; If you wrap such return values in a std::unique_ptr, then your code will compile both with and without memory safe interfaces:; std::unique_ptr<RooArgSet> params{pdf.getParameters(nullptr)};; Also some virtual RooFit functions like RooAbsReal::createIntegral() are returning a different type conditional on ROOFIT_MEMORY_SAFE_INTERFACES. If you are overriding such a function, you need to use the RooFit::OwningPtr return type, which is an alias for std::unique_ptr in memory-safe mode or an alias for a raw pointer otherwise.; RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(...) const override; {; std::unique_ptr<RooAbsReal> integral;; // Prepare a std::unique_ptr as the return value; ...; // Use the RooFit::makeOwningPtr<T>() helper to translate the; // std::unique_ptr to the actual return type (either std::unique_ptr<T> or T*).; return RooFit::makeOwningPtr<RooAbsReal>(std::move(integ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:9657,risk,risk,9657,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['risk'],['risk']
Safety,"s; public:. enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:19659,recover,recovered,19659,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,2,['recover'],['recovered']
Safety,"s;}; 367 ; 368 /**; 369 Change R - Polar3D coordinates only; 370 */; 371 DisplacementVector3D<CoordSystem, Tag>& SetR (Scalar rr) { fCoordinates.SetR(rr); return *this;}; 372 ; 373 /**; 374 Change Theta - Polar3D coordinates only; 375 */; 376 DisplacementVector3D<CoordSystem, Tag>& SetTheta (Scalar ang) { fCoordinates.SetTheta(ang); return *this;}; 377 ; 378 /**; 379 Change Phi - Polar3D or CylindricalEta3D coordinates; 380 */; 381 DisplacementVector3D<CoordSystem, Tag>& SetPhi (Scalar ang) { fCoordinates.SetPhi(ang); return *this;}; 382 ; 383 /**; 384 Change Rho - CylindricalEta3D coordinates only; 385 */; 386 DisplacementVector3D<CoordSystem, Tag>& SetRho (Scalar rr) { fCoordinates.SetRho(rr); return *this;}; 387 ; 388 /**; 389 Change Eta - CylindricalEta3D coordinates only; 390 */; 391 DisplacementVector3D<CoordSystem, Tag>& SetEta (Scalar etaval) { fCoordinates.SetEta(etaval); return *this;}; 392 ; 393 ; 394 // ------ Operations combining two vectors ------; 395 // -- need to have the specialized version in order to avoid; 396 ; 397 /**; 398 Return the scalar (dot) product of two displacement vectors.; 399 It is possible to perform the product for any type of vector coordinates,; 400 but they must have the same coordinate system tag; 401 */; 402 template< class OtherCoords >; 403 Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 404 return X()*v.X() + Y()*v.Y() + Z()*v.Z();; 405 }; 406 /**; 407 Return the scalar (dot) product of two vectors.; 408 It is possible to perform the product for any classes; 409 implementing x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:12551,avoid,avoid,12551,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['avoid'],['avoid']
Safety,"sA(). void TClass::SetGlobalIsA ; (; IsAGlobalFunc_t ; func). This function installs a global IsA function for this class. ; The global IsA function will be used if there is no local IsA function (fIsA); A global IsA function has the signature:; TClass *func( TClass *cl, const void *obj);; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; 'cl' is a pointer to the TClass object that corresponds to the 'pointer type' used to retrieve the value 'obj'; For example with: TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::TNamedTNamed()Definition TNamed.h:36; mTMarker mDefinition textangle.C:8; and the global IsA function would be called with TObject::Class() as the first parameter and the exact numerical value in the pointer 'o'.; In other word, inside the global IsA function. it is safe to C-style cast the value of 'obj' into a pointer to the class described by 'cl'. ; Definition at line 6300 of file TClass.cxx. ◆ SetImplFileName(). void TClass::SetImplFileName ; (; const char * ; implFileName). inline . Definition at line 560 of file TClass.h. ◆ SetLastReadInfo(). void TClass::SetLastReadInfo ; (; TVirtualStreamerInfo * ; info). inline . Definition at line 445 of file TClass.h. ◆ SetMemberStreamer(). void TClass::SetMemberStreamer ; (; const char * ; name, . MemberStreamerFunc_t ; strm . ). Install a new member streamer (p will be copied). ; Definition at line 6744 of file TClass.cxx. ◆ SetMerge(). void TClass::SetMerge ; (; ROOT::MergeFunc_t ; mergeFunc). Install a new wrapper around 'Merge'. ; Definition at line 6969 of file TClass.cxx. ◆ SetNew(). void TClass::SetNew ; (; ROOT::NewFunc_t ; newFunc). Install a new wrapper around 'new'. ; Definition at line 6985 of file TClass.cxx. ◆ SetNewArray(). void TClass::SetNewArray ; (; ROOT::NewArrFunc_t ; newArrayFunc). Install a new wrapper around 'new []'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:117513,safe,safe,117513,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['safe'],['safe']
Safety,"sA(). void TClass::SetGlobalIsA ; (; IsAGlobalFunc_t ; func). This function installs a global IsA function for this class. ; The global IsA function will be used if there is no local IsA function (fIsA); A global IsA function has the signature:; TClass *func( TClass *cl, const void *obj);; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; 'cl' is a pointer to the TClass object that corresponds to the 'pointer type' used to retrieve the value 'obj'; For example with: TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::TNamedTNamed()Definition TNamed.h:36; mTMarker mDefinition textangle.C:8; and the global IsA function would be called with TObject::Class() as the first parameter and the exact numerical value in the pointer 'o'.; In other word, inside the global IsA function. it is safe to C-style cast the value of 'obj' into a pointer to the class described by 'cl'. ; Definition at line 6367 of file TClass.cxx. ◆ SetImplFileName(). void TClass::SetImplFileName ; (; const char * ; implFileName). inline . Definition at line 560 of file TClass.h. ◆ SetLastReadInfo(). void TClass::SetLastReadInfo ; (; TVirtualStreamerInfo * ; info). inline . Definition at line 445 of file TClass.h. ◆ SetMemberStreamer(). void TClass::SetMemberStreamer ; (; const char * ; name, . MemberStreamerFunc_t ; strm . ). Install a new member streamer (p will be copied). ; Definition at line 6811 of file TClass.cxx. ◆ SetMerge(). void TClass::SetMerge ; (; ROOT::MergeFunc_t ; mergeFunc). Install a new wrapper around 'Merge'. ; Definition at line 7036 of file TClass.cxx. ◆ SetNew(). void TClass::SetNew ; (; ROOT::NewFunc_t ; newFunc). Install a new wrapper around 'new'. ; Definition at line 7052 of file TClass.cxx. ◆ SetNewArray(). void TClass::SetNewArray ; (; ROOT::NewArrFunc_t ; newArrayFunc). Install a new wrapper around 'new []'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:117514,safe,safe,117514,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['safe'],['safe']
Safety,"sBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfIgnoreDupignore duplicates, don't issue warning; TStringfRcNameresource file base name; THashList*fTablehash table containing env records. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEnv(const char* name = """"); Create a resource table and read the (possibly) three resource files, i.e; $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>), $HOME/<name> and; ./<name>. ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You can; read additional user defined resource files by creating addtional TEnv; objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; the $HOME/<name> resource file will be skipped. This might be useful in; case the home directory resides on an automounted remote file system; and one wants to avoid the file system from being mounted. ~TEnv(); Delete the resource table. const char * Getvalue(const char* name); Returns the character value for a named resouce. Int_t GetValue(const char* name, Int_t dflt); Returns the integer value for a resource. If the resource is not found; return the dflt value. Double_t GetValue(const char* name, Double_t dflt); Returns the double value for a resource. If the resource is not found; return the dflt value. const char * GetValue(const char* name, const char* dflt); Returns the character value for a named resouce. If the resource is; not found the dflt value is returned. TEnvRec * Lookup(const char* n); Loop over all resource records and return the one with name.; Return 0 in case name is not in the resoucre table. void Print(Option_t* option = """") const; Print all resources or the global, user or local resources separately. void PrintEnv(EEnvLevel level = kEnvAll) const; Print all resources for a certain le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEnv.html:8635,avoid,avoid,8635,root/html528/TEnv.html,https://root.cern,https://root.cern/root/html528/TEnv.html,6,['avoid'],['avoid']
Safety,"sDeclsMap_t &headersClassesMap,; 3379 const std::string &detectedUmbrella,; 3380 bool payLoadOnly = false); 3381{; 3382 std::string headerName;; 3383 ; 3384 if (genreflex::verbose); 3385 std::cout << ""Class-headers Mapping:\n"";; 3386 std::string headersClassesMapString = """";; 3387 for (auto const & classHeaders : headersClassesMap) {; 3388 if (genreflex::verbose); 3389 std::cout << "" o "" << classHeaders.first << "" --> "";; 3390 headersClassesMapString += ""\"""";; 3391 headersClassesMapString += classHeaders.first + ""\"""";; 3392 for (auto const & header : classHeaders.second) {; 3393 headerName = (detectedUmbrella == header || payLoadOnly) ? ""payloadCode"" : ""\"""" + header + ""\"""";; 3394 headersClassesMapString += "", "" + headerName;; 3395 if (genreflex::verbose); 3396 std::cout << "", "" << headerName;; 3397 if (payLoadOnly); 3398 break;; 3399 }; 3400 if (genreflex::verbose); 3401 std::cout << std::endl;; 3402 headersClassesMapString += "", \""@\"",\n"";; 3403 }; 3404 headersClassesMapString += ""nullptr"";; 3405 return headersClassesMapString;; 3406}; 3407 ; 3408////////////////////////////////////////////////////////////////////////////////; 3409 ; 3410bool IsImplementationName(const std::string &filename); 3411{; 3412 return !ROOT::TMetaUtils::IsHeaderName(filename);; 3413}; 3414 ; 3415////////////////////////////////////////////////////////////////////////////////; 3416/// Check if the argument is a sane cling argument. Performing the following checks:; 3417/// 1) It does not start with ""--"" and is not the --param option.; 3418 ; 3419bool IsCorrectClingArgument(const std::string& argument); 3420{; 3421 if (ROOT::TMetaUtils::BeginsWith(argument,""--"") && !ROOT::TMetaUtils::BeginsWith(argument,""--param"")) return false;; 3422 return true;; 3423}; 3424 ; 3425////////////////////////////////////////////////////////////////////////////////; 3426bool NeedsSelection(const char* name); 3427{; 3428 static const std::vector<std::string> namePrfxes {; 3429 ""array<"",; 3430 ""unique_ptr<""};; 34",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:134948,detect,detectedUmbrella,134948,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['detect'],['detectedUmbrella']
Safety,"sInfo (const TClass *cl);  Specify class which typename will not be stored in JSON Several classes can be configured To exclude typeinfo for all classes, call TBufferJSON::SetTypenameTag("""") ;  ; void SetStreamerElementNumber (TStreamerElement *elem, Int_t comp_type) final;  Function is called from TStreamerInfo WriteBuffer and ReadBuffer functions and add/verify next element of json structure This calls allows separate data, correspondent to one class member, from another. ;  ; void SetTypenameTag (const char *tag=""_typename"");  Configures _typename tag in JSON structures By default ""_typename"" field in JSON structures used to store class information One can specify alternative tag like ""$typename"" or ""xy"", but such JSON can not be correctly used in JSROOT If empty string is provided, class information will not be stored. ;  ; void SetTypeversionTag (const char *tag=nullptr);  Configures _typeversion tag in JSON One can specify name of the JSON tag like ""_typeversion"" or ""$tv"" which will be used to store class version Such tag can be used to correctly recover objects from JSON If empty string is provided (default), class version will not be stored. ;  ; void SkipObjectAny () final;  Skip any kind of object from buffer. ;  ; TString StoreObject (const void *obj, const TClass *cl);  Store provided object as JSON structure Allows to configure different TBufferJSON properties before converting object into JSON Actual object class must be specified here Method can be safely called once - after that TBufferJSON instance must be destroyed Code should look like: ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void StreamObject (TObject *obj) override;  ; void StreamObject (void *obj, const char *className, const TClass *onFileClass=nullptr) override;  stream object to/from buffer ;  ; void StreamObject (void *obj, const std::type_info &typeinfo, const TClass *onFileClass=nullp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:13423,recover,recover,13423,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['recover'],['recover']
Safety,"sManager::fAddr. private . ! HTTP address of the server ; Definition at line 46 of file RWebWindowsManager.hxx. ◆ fAssgnExec. std::unique_ptr<TExec> ROOT::RWebWindowsManager::fAssgnExec. private . ! special exec to assign thread id via ProcessEvents ; Definition at line 55 of file RWebWindowsManager.hxx. ◆ fDeleteCallback. WebWindowDeleteCallback_t ROOT::RWebWindowsManager::fDeleteCallback. private . ! function called when RWebWindow is destroyed ; Definition at line 57 of file RWebWindowsManager.hxx. ◆ fExternalProcessEvents. bool ROOT::RWebWindowsManager::fExternalProcessEvents {false}. private . ! indicate that there are external process events engine ; Definition at line 54 of file RWebWindowsManager.hxx. ◆ fIdCnt. unsigned ROOT::RWebWindowsManager::fIdCnt {0}. private . ! counter for identifiers ; Definition at line 50 of file RWebWindowsManager.hxx. ◆ fLaunchTmout. float ROOT::RWebWindowsManager::fLaunchTmout {30.}. private . ! timeout in seconds to start browser process, default 30s ; Definition at line 53 of file RWebWindowsManager.hxx. ◆ fMutex. std::recursive_mutex ROOT::RWebWindowsManager::fMutex. private . ! main mutex, used for window creations ; Definition at line 49 of file RWebWindowsManager.hxx. ◆ fServer. std::unique_ptr<THttpServer> ROOT::RWebWindowsManager::fServer. private . ! central communication with the all used displays ; Definition at line 45 of file RWebWindowsManager.hxx. ◆ fSessionKey. std::string ROOT::RWebWindowsManager::fSessionKey. private . ! secret session key used on client to code connections keys ; Definition at line 47 of file RWebWindowsManager.hxx. ◆ fShowCallback. WebWindowShowCallback_t ROOT::RWebWindowsManager::fShowCallback. private . ! function called for each RWebWindow::Show call ; Definition at line 56 of file RWebWindowsManager.hxx. ◆ fUseHttpThrd. bool ROOT::RWebWindowsManager::fUseHttpThrd {false}. private . ! use special thread for THttpServer ; Definition at line 51 of file RWebWindowsManager.hxx. ◆ fUseSenderThr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:22939,timeout,timeout,22939,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['timeout'],['timeout']
Safety,"sName (Int_t iaxis) const override;  ; Double_t GetAxisRange (Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;  ; void GetBoundingCylinder (Double_t *param) const override;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections, Bool_t localFrame) const override;  Stub implementation to avoid forcing implementation at this stage. ;  ; Int_t GetByteCount () const override;  ; virtual Double_t GetDX () const;  ; virtual Double_t GetDY () const;  ; virtual Double_t GetDZ () const;  ; virtual Double_t GetFacetArea (Int_t index=0) const;  ; Int_t GetFittingBox (const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;  ; TGeoShape * GetMakeRuntimeShape (TGeoShape *mother, TGeoMatrix *mat) const override;  ; void GetMeshNumbers (Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;  ; Int_t GetNmeshVertices () const override;  ; virtual const Double_t * GetOrigin () const;  ; virtual Bool_t GetPointsOnFacet (Int_t index, Int_t npoints, Double_t *array) const;  ; Bool_t GetPointsOnSegments (Int_t npoints, Double_t *array) const override;  ; void InspectShape () const override;  ; TClass * IsA () const override;  ; Bool_t IsCylType () const override;  ; virtual Bool_t IsNullBox () const;  ; Bool_t IsValidBox () const override;  ; TBuffer3D * MakeBuffer3D () const override;  ; Double_t Safety (const Double_t *point, Bool_t in=kTRUE) const override;  ; void Safety_v (const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBoxDimensions (Double_t dx, Double_t dy, Double_t dz, Double_t *origin=nullptr);  ; void SetBoxPoints (Double_t *points) const;  ; void SetDimensions (Double_t *param) override;  ; void SetPoints (Double_t *points) const override;  ; void SetPoints (Float_t *points) const override;  ; void SetSegsAndPols (TBuffer3D &buffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:3505,safe,safe,3505,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['safe'],['safe']
Safety,"sOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoConeSeg&operator=(const TGeoConeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidTGeoCone::SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidSetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoConeSeg.html:9991,Safe,SafetyPhi,9991,root/html534/TGeoConeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html,1,['Safe'],['SafetyPhi']
Safety,"sOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTubeSeg&operator=(const TGeoTubeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSeg.html:10057,Safe,SafetyPhi,10057,root/html534/TGeoTubeSeg.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html,1,['Safe'],['SafetyPhi']
Safety,"sRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:53055,timeout,timeout,53055,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,8,['timeout'],['timeout']
Safety,"sRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:50268,timeout,timeout,50268,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,['timeout'],['timeout']
Safety,sTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:41401,avoid,avoids,41401,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,4,['avoid'],['avoids']
Safety,"s_nodecay;; 1614 using ret_type = typename TTraits::CallableTraits<decltype(f)>::ret_type;; 1615 ForeachSlot(RDFInternal::AddSlotParameter<ret_type>(f, arg_types()), columns);; 1616 }; 1617 ; 1618 // clang-format off; 1619 ////////////////////////////////////////////////////////////////////////////; 1620 /// \brief Execute a user-defined function requiring a processing slot index on each entry (*instant action*).; 1621 /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; 1622 /// \param[in] columns Names of the columns/branches in input to the user function.; 1623 ///; 1624 /// Same as `Foreach`, but the user-defined function takes an extra; 1625 /// `unsigned int` as its first parameter, the *processing slot index*.; 1626 /// This *slot index* will be assigned a different value, `0` to `poolSize - 1`,; 1627 /// for each thread of execution.; 1628 /// This is meant as a helper in writing thread-safe `Foreach`; 1629 /// actions when using `RDataFrame` after `ROOT::EnableImplicitMT()`.; 1630 /// The user-defined processing callable is able to follow different; 1631 /// *streams of processing* indexed by the first parameter.; 1632 /// `ForeachSlot` works just as well with single-thread execution: in that; 1633 /// case `slot` will always be `0`.; 1634 ///; 1635 /// ### Example usage:; 1636 /// ~~~{.cpp}; 1637 /// myDf.ForeachSlot([](unsigned int s, int i){ std::cout << ""Slot "" << s << "": ""<< i << std::endl;}, {""myIntColumn""});; 1638 /// ~~~; 1639 // clang-format on; 1640 template <typename F>; 1641 void ForeachSlot(F f, const ColumnNames_t &columns = {}); 1642 {; 1643 using ColTypes_t = TypeTraits::RemoveFirstParameter_t<typename TTraits::CallableTraits<F>::arg_types>;; 1644 constexpr auto nColumns = ColTypes_t::list_size;; 1645 ; 1646 const auto validColumnNames = GetValidatedColumnNames(nColumns, columns);; 1647 CheckAndFillDSColumns(validColumnNames, ColTypes_t());; 1648 ; 1649 using Helper_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:91312,safe,safe,91312,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['safe'],['safe']
Safety,"safe;; 10502 int is_idempotent;; 10503 int is_cacheable;; 10504};; 10505 ; 10506 ; 10507/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10508static const struct mg_http_method_info http_methods[] = {; 10509 /* HTTP (RFC 2616) */; 10510 {""GET"", 0, 1, 1, 1, 1},; 10511 {""POST"", 1, 1, 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 11 methods from RFC 3253 */; 10550 /* ORDERPATCH (RFC 3648) */; 10551 /* ACL (RFC 3744) */; 10552 /* SEA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:302358,safe,safe,302358,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"safe;; 10503 int is_idempotent;; 10504 int is_cacheable;; 10505};; 10506 ; 10507 ; 10508/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10509static const struct mg_http_method_info http_methods[] = {; 10510 /* HTTP (RFC 2616) */; 10511 {""GET"", 0, 1, 1, 1, 1},; 10512 {""POST"", 1, 1, 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 11 methods from RFC 3253 */; 10551 /* ORDERPATCH (RFC 3648) */; 10552 /* ACL (RFC 3744) */; 10553 /* SEA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:302391,safe,safe,302391,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['safe'],['safe']
Safety,"sage on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:6825,abort,abort,6825,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,2,['abort'],['abort']
Safety,"samples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTube.html:2594,safe,safe,2594,root/html532/TGeoTube.html,https://root.cern,https://root.cern/root/html532/TGeoTube.html,2,['safe'],['safe']
Safety,"saved in the high bits of fSeekPdir; Long64_tfSeekKeyLocation of object on file; Long64_tfSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. private:. static TKey::EStatusBitskIsDirectoryFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKey.html:10196,avoid,avoid,10196,root/html602/TKey.html,https://root.cern,https://root.cern/root/html602/TKey.html,4,['avoid'],['avoid']
Safety,"sc.emplace_back(node ? node->GetNumber() - offset : 0);; 529 TGeoVolume *vol = node ? node->GetVolume() : topvolume;; 530 ; 531 auto &desc = fDesc[cnt++];; 532 ; 533 sortarr.emplace_back(&desc);; 534 ; 535 desc.name = node ? node->GetName() : vol->GetName();; 536 ; 537 auto shape = dynamic_cast<TGeoBBox *>(vol->GetShape());; 538 if (shape) {; 539 desc.vol = TMath::Sqrt(shape->GetDX() * shape->GetDX() + shape->GetDY() * shape->GetDY() +; 540 shape->GetDZ() * shape->GetDZ());; 541 desc.nfaces = CountShapeFaces(shape);; 542 }; 543 ; 544 CopyMaterialProperties(vol, desc);; 545 ; 546 auto chlds = node ? node->GetNodes() : vol->GetNodes();; 547 ; 548 PackMatrix(desc.matr, node ? node->GetMatrix() : nullptr);; 549 ; 550 if (chlds); 551 for (int n = 0; n <= chlds->GetLast(); ++n) {; 552 auto chld = dynamic_cast<TGeoNode *>(chlds->At(n));; 553 desc.chlds.emplace_back(chld->GetNumber() - offset);; 554 }; 555 }; 556 ; 557 // recover numbers; 558 cnt = 0;; 559 for (auto node : fNodes) {; 560 auto number = numbers[cnt++];; 561 if (node); 562 node->SetNumber(number);; 563 }; 564 ; 565 // sort in volume descent order; 566 std::sort(sortarr.begin(), sortarr.end(), [](RGeomNode *a, RGeomNode *b) { return a->vol > b->vol; });; 567 ; 568 cnt = 0;; 569 for (auto &elem : sortarr) {; 570 fSortMap.emplace_back(elem->id);; 571 elem->sortid = cnt++; // keep place in sorted array to correctly apply cut; 572 }; 573 ; 574 MarkVisible(); // set visibility flags; 575 ; 576 ProduceIdShifts();; 577}; 578 ; 579/////////////////////////////////////////////////////////////////////; 580/// Get volume for specified nodeid; 581/// If specific volume was configured, it will be returned for nodeid==0; 582 ; 583TGeoVolume *RGeomDescription::GetVolume(int nodeid); 584{; 585 auto node = fNodes[nodeid];; 586 if (node); 587 return node->GetVolume();; 588 return nodeid == 0 ? fDrawVolume : nullptr;; 589}; 590 ; 591/////////////////////////////////////////////////////////////////////; 592/// Set visibility flag f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:14779,recover,recover,14779,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['recover'],['recover']
Safety,"se class for event management and navigation.; TEveException Exception-type thrown by Eve classes.; TEveFrameBox Description of a 2D or 3D frame that can be used to visually group a set of objects.; TEveFrameBoxGL GL-renderer for TEveFrameBox class.; TEveGDoubleValuator Composite GUI element for selection of range (label, two number-entries and double-slider).; TEveGListTreeEditorFrame Composite GUI frame for parallel display of a TGListTree and TEveGedEditor.; TEveGTriVecValuator Composite GUI element for setting three numerical values (label, three number-entries).; TEveGValuator Composite GUI element for single value selection (supports label, number-entry and slider).; TEveGValuatorBase Base class for composite GUI elements for setting of numeric values.; TEveGedEditor Specialization of TGedEditor for proper update propagation to TEveManager.; TEveGedNameFrame Top name-frame used in EVE.; TEveGedNameTextButton Button for GED name-frame.; TEveGeoManagerHolder Exception-safe wrapper for temporary setting of gGeoManager variable.; TEveGeoNode Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement.; TEveGeoNodeEditor Editor for TEveGeoNode class.; TEveGeoPolyShape A shape with arbitrary tesselation for visualization of CSG shapes.; TEveGeoShape Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).; TEveGeoShapeExtract Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts.; TEveGeoShapeProjected ; TEveGeoTopNode Top-level TEveGeoNode with a pointer to TGeoManager and controls for steering of TGeoPainter.; TEveGeoTopNodeEditor Editor for TEveGeoTopNode class.; TEveGridStepper Provide discrete position coordinates for placement of objects on regular grids.; TEveGridStepperEditor Editor for TEveGridStepper class.; TEveGridStepperSubEditor Sub-edit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:58568,safe,safe,58568,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,10,['safe'],['safe']
Safety,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 30568 2009-10-06 07:17:59Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html:8210,avoid,avoid,8210,root/html526/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html,1,['avoid'],['avoid']
Safety,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_double_.html:8210,avoid,avoid,8210,root/html528/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_double_.html,1,['avoid'],['avoid']
Safety,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html:8212,avoid,avoid,8212,root/html530/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html,1,['avoid'],['avoid']
Safety,"se energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(double pt); ====== Set member functions for coordinates in other systems =======. void SetEta(double eta). void SetPhi(double phi). void SetE(double energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html:8212,avoid,avoid,8212,root/html532/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_double_.html,2,['avoid'],['avoid']
Safety,"se of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void UnixSignal(ESignals sig, void* h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:36404,timeout,timeout,36404,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,4,['timeout'],['timeout']
Safety,"se of the main TTree!"";; 1256 Error(""AddFriend"", msg, reshuffledTreeName, friendTree.GetName());; 1257 return false;; 1258 }; 1259 return true;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is much like adding another branch to the tree without taking the risk; 1279/// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; 1280/// method. The tree in the diagram below has two friends (friend_tree1 and; 1281/// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:45831,risk,risk,45831,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['risk'],['risk']
Safety,"se {; 3536 fprintf(file, ""%s(const_cast<%s &>( rhs ).%s)\n"",element->GetName(),protoname.Data(),element->GetName());; 3537 }; 3538 }; 3539 }; 3540 }; 3541 fprintf(file,""{\n"");; 3542 fprintf(file,"" // This is NOT a copy constructor. This is actually a move constructor (for stl container's sake).\n"");; 3543 fprintf(file,"" // Use at your own risk!\n"");; 3544 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3545 ; 3546 R__WriteMoveBodyPointersArrays(file, protoname, next);; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Write down the body of the 'move' constructor.; 3551 ; 3552static void R__WriteOddOperatorEqualBody(FILE *file, const TString &protoname, TIter &next); 3553{; 3554 fprintf(file,""{\n"");; 3555 fprintf(file,"" // This is NOT a copy operator=. This is actually a move operator= (for stl container's sake).\n"");; 3556 fprintf(file,"" // Use at your own risk!\n"");; 3557 fprintf(file,"" (void)rhs; // avoid warning about unused parameter\n"");; 3558 ; 3559 TStreamerElement *element = 0;; 3560 next.Reset();; 3561 while ((element = (TStreamerElement*)next())) {; 3562 if (element->IsBase()) {; 3563 fprintf(file, "" %s::operator=(const_cast<%s &>( rhs ));\n"", element->GetName(),protoname.Data());; 3564 } else {; 3565 if (element->GetArrayLength() <= 1) {; 3566 if (R__IsUniquePtr(element)) {; 3567 fprintf(file, "" %s = std::move((const_cast<%s &>( rhs ).%s));\n"",element->GetName(),protoname.Data(),element->GetName());; 3568 } else {; 3569 fprintf(file, "" %s = (const_cast<%s &>( rhs ).%s);\n"",element->GetName(),protoname.Data(),element->GetName());; 3570 }; 3571 }; 3572 }; 3573 }; 3574 ; 3575 R__WriteMoveBodyPointersArrays(file, protoname, next);; 3576 ; 3577 fprintf(file, "" return *this;\n"");; 3578}; 3579 ; 3580////////////////////////////////////////////////////////////////////////////////; 3581 ; 3582static void R__WriteDestructorBody(FILE *file, TIter &next); 3583{; 3584 TStreamerElement *e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:144239,risk,risk,144239,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,"['avoid', 'risk']","['avoid', 'risk']"
Safety,"se(). Int_t TBasket::ReadBasketBuffersUncompressedCase ; (; ). private . By-passing buffer unzipping has been requested and is possible (only 1 entry in this basket). ; Definition at line 358 of file TBasket.cxx. ◆ ReadBasketBuffersUnzip(). Int_t TBasket::ReadBasketBuffersUnzip ; (; char * ; buffer, . Int_t ; size, . bool ; mustFree, . TFile * ; file . ). private . We always create the TBuffer for the basket but it hold the buffer from the cache. ; Definition at line 380 of file TBasket.cxx. ◆ ReadBasketBytes(). Int_t TBasket::ReadBasketBytes ; (; Long64_t ; pos, . TFile * ; file . ). Read basket buffers in memory and cleanup. ; Read first bytes of a logical record starting at position pos return record length (first 4 bytes of record). ; Definition at line 698 of file TBasket.cxx. ◆ ReadResetBuffer(). void TBasket::ReadResetBuffer ; (; Int_t ; basketnumber). protectedvirtual . Reset the read basket TBuffer memory allocation if needed. ; This allows to reduce the number of memory allocation while avoiding to always use the maximum size. ; Definition at line 733 of file TBasket.cxx. ◆ ResetEntryOffset(). void TBasket::ResetEntryOffset ; (; ). private . Definition at line 441 of file TBasket.cxx. ◆ SetBranch(). void TBasket::SetBranch ; (; TBranch * ; branch). inline . Definition at line 148 of file TBasket.h. ◆ SetNevBufSize(). void TBasket::SetNevBufSize ; (; Int_t ; n). inline . Definition at line 149 of file TBasket.h. ◆ SetReadMode(). void TBasket::SetReadMode ; (; ). virtual . Set read mode of basket. ; Definition at line 925 of file TBasket.cxx. ◆ SetWriteMode(). void TBasket::SetWriteMode ; (; ). virtual . Set write mode of basket. ; Definition at line 934 of file TBasket.cxx. ◆ Streamer(). void TBasket::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TObject.; Reimplemented in TBasketSQL.; Definition at line 943 of file TBasket.cxx. ◆ StreamerNVirtual(). void TBasket::StreamerNVirtual ; (; TBuffer & ; ClassDef_Stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasket.html:28485,avoid,avoiding,28485,doc/master/classTBasket.html,https://root.cern,https://root.cern/doc/master/classTBasket.html,1,['avoid'],['avoiding']
Safety,"seconds.; 5914 * This will allow to stop the server after some seconds, instead; 5915 * of having to wait for a long socket timeout. */; 5916 int ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5917 ; 5918 int check_pollerr = 0;; 5919 if ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5920 /* If we wait for only one file descriptor, wait on error as well */; 5921 pfd[0].events |= POLLERR;; 5922 check_pollerr = 1;; 5923 }; 5924 ; 5925 do {; 5926 int result;; 5927 ; 5928 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5929 /* Shut down signal */; 5930 return -2;; 5931 }; 5932 ; 5933 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5934 ms_now = milliseconds;; 5935 }; 5936 ; 5937 result = poll(pfd, n, ms_now);; 5938 if (result != 0) {; 5939 /* Poll returned either success (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:174671,timeout,timeout,174671,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"seconds.; 5915 * This will allow to stop the server after some seconds, instead; 5916 * of having to wait for a long socket timeout. */; 5917 int ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5918 ; 5919 int check_pollerr = 0;; 5920 if ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5921 /* If we wait for only one file descriptor, wait on error as well */; 5922 pfd[0].events |= POLLERR;; 5923 check_pollerr = 1;; 5924 }; 5925 ; 5926 do {; 5927 int result;; 5928 ; 5929 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5930 /* Shut down signal */; 5931 return -2;; 5932 }; 5933 ; 5934 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5935 ms_now = milliseconds;; 5936 }; 5937 ; 5938 result = poll(pfd, n, ms_now);; 5939 if (result != 0) {; 5940 /* Poll returned either success (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:174703,timeout,timeout,174703,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['timeout'],['timeout']
Safety,"section(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoIntersection& ). EGeoBoolType GetBooleanOperator() const. TGeoIntersection(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoIntersection.html:10219,safe,safe,10219,root/html604/TGeoIntersection.html,https://root.cern,https://root.cern/root/html604/TGeoIntersection.html,5,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"section(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. TGeoBoolNode& operator=(const TGeoIntersection& ). EGeoBoolType GetBooleanOperator() const. TGeoIntersection(); constructors. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoIntersection.html:10219,safe,safe,10219,root/html602/TGeoIntersection.html,https://root.cern,https://root.cern/root/html602/TGeoIntersection.html,5,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"sed in degrees.; A poly-line is a set of joint segments. It is defined by a set of N points in a 2D space. Its constructor is:; TPolyLine(Int_t n,Double_t* x,Double_t* y,Option_t* option); Where n is the number of points, and x and y are arrays of n elements with the coordinates of the points. TPolyLine can be used by it self, but is also a base class for other objects, such as curly arcs.; 9.4.2 Circles and Ellipses; An ellipse can be truncated and rotated. It is defined by its center (x1,y1) and two radii r1 and r2. A minimum and maximum angle may be specified (phimin,phimax). The ellipse may be rotated with an angle theta. All these angles are in degrees. The attributes of the outline line are set via TAttLine, of the fill area - via TAttFill class. They are described in “Graphical Objects Attributes”. Different types of ellipses. When an ellipse sector is drawn only, the lines between the center and the end points of the sector are drawn by default. By specifying the drawn option “only”, these lines can be avoided. Alternatively, the method SetNoEdges() can be called. To remove completely the ellipse outline, specify zero (0) as a line style.; The TEllipse constructor is:; TEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2,; Double_t phimin, Double_t phimax, Double_t theta); An ellipse may be created with:; root[] e = new TEllipse(0.2,0.2,0.8,0.3); root[] e->Draw(); 9.4.3 Rectangles; The class TBox defines a rectangle. It is a base class for many different higher-level graphical primitives. Its bottom left coordinates x1, y1 and its top right coordinates x2, y2, defines a box. The constructor is:; TBox(Double_t x1,Double_t y1,Double_t x2,Double_t y2); It may be used as in:; root[] b = new TBox(0.2,0.2,0.8,0.3); root[] b->SetFillColor(5); root[] b->Draw(). A rectangle with a border. A TWbox is a rectangle (TBox) with a border size and a border mode. The attributes of the outline line and of the fill area are described in “Graphical Objects Attributes”; 9.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:321961,avoid,avoided,321961,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avoid'],['avoided']
Safety,"see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; AutoSave is automatically called by TTree::Fill when the number of bytes; generated since the previous AutoSave is greater than fAutoSave bytes.; This function may also be invoked by the user, for example every; N entries.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The follo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:40687,recover,recovered,40687,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['recover'],['recovered']
Safety,"see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; AutoSave is automatically called by TTree::Fill when the number of bytes; generated since the previous AutoSave is greater than fAutoSave bytes.; This function may also be invoked by the user, for example every; N entries.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromize; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occured while writing; the header to the file. How to write a Tree in one process and view it from another process. The follow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:38542,recover,recovered,38542,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['recover'],['recovered']
Safety,"semiaxis length. TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(Double_t* point, Double_t* dir) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoParaboloid.html:12998,safe,safe,12998,root/html528/TGeoParaboloid.html,https://root.cern,https://root.cern/root/html528/TGeoParaboloid.html,1,['safe'],['safe']
Safety,"sent to.; Returns -1 in case of error. Int_t BroadcastFile(const char* file, Int_t opt, const char* rfile = 0, TProof::ESlaves list = kAllUnique); Broadcast file to all workers in the specified list. Returns the number of workers; the buffer was sent to.; Returns -1 in case of error. void ReleaseMonitor(TMonitor* mon); Release the used monitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:42135,timeout,timeout,42135,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,12,['timeout'],['timeout']
Safety,"sent to.; Returns -1 in case of error. Int_t BroadcastFile(const char* file, Int_t opt, const char* rfile = 0, TProof::ESlaves list = kAllUnique); Broadcast file to all workers in the specified list. Returns the number of workers; the buffer was sent to.; Returns -1 in case of error. void ReleaseMonitor(TMonitor* mon); Release the used monitor to be used, making sure to delete newly created; monitors. Int_t Collect(const TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from slave sl. Returns the number of slaves that; responded (=1).; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection.; Collect also stops its execution from time to time to check for new; workers in Dynamic Startup mode. Int_t PollForNewWorkers(); Asks the PROOF ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:45991,timeout,timeout,45991,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,18,['timeout'],['timeout']
Safety,"ser (Firefox, Chrome, Opera, Safari, IE11) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a server snapshot of running macro tutorials/http/httpserver.C from ROOT tutorials.; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; auto serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following URL parameters are supported:. Name; Description. thrds=N; number of threads used by the civetweb (default is 10). top=name; configure top name, visible in the web browser. auth_file=filename; authentication file name, created with htdigets utility. auth_domain=domain; authentication domain. loopback; bind specified port to loopback 127.0.0.1 address. debug; enable debug mode, server returns html page with request info. websocket_timeout=tm; set web sockets timeout in seconds (default 300). websocket_disable; disable web sockets handling (default enabled). cors=domain; define value for CORS header “Access-Control-Allow-Origin” in server response. log=filename; configure civetweb log file. max_age=value; configures “Cache-Control: max_age=value” http header for all file-related requests, default 3600. nocache; try to fully disable cache control for file requests. winsymlinks=no; do not resolve symbolic links on file system (Windows only), default true. dirlisting=no; enable/disable directory listing for browsing filesystem (default no). If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); One also can provide extra arguments for THttpServer itself:. Name; Description. readonly, ro; use server in read-only mode (default). readwrite, rw; use server in read-write mode. global; let scan global directories for canvases and files (default). noglobal; disable scan of global directori",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:2161,timeout,timeout,2161,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,['timeout'],['timeout']
Safety,"sers in other groups, and on the analysis; of historical logging data (i.e. usage of CPU by the group in a; previous time slot, as recorded in TPerfStats::WriteQueryLog()). Currently the group priority is obtained by a query in a SQL DB; table proofpriority, which has the format:; CREATE TABLE proofpriority (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; group VARCHAR(32) NOT NULL,; priority INT; ). Int_t SendAsynMessage(const char* msg, Bool_t lf = kTRUE); Send an asychronous message to the master / client .; Masters will forward up the message to the client.; The client prints 'msg' of stderr and adds a '\n'/'\r' depending on; 'lf' being kTRUE (default) or kFALSE.; Returns the return value from TSocket::Send(TMessage &) . void FlushLogFile(); Reposition the read pointer in the log file to the very end.; This allows to ""hide"" useful debug messages during normal operations; while preserving the possibility to have them in case of problems. void HandleException(Int_t sig); Exception handler: we do not try to recover here, just exit. Int_t HandleDataSets(TMessage* mess, TString* slb = 0); Handle here requests about datasets. void HandleSubmerger(TMessage* mess); Handle a message of type kPROOF_SUBMERGER. void HandleFork(TMessage* mess); Cloning itself via fork. Not implemented. Int_t Fork(); Fork a child.; If successful, return 0 in the child process and the child pid in the parent; process. The child pid is registered for reaping.; Return <0 in the parent process in case of failure. void ResolveKeywords(TString& fname, const char* path = 0); Replace <ord>, <user>, <u>, <group>, <stag>, <qnum> and <file> placeholders in fname. Int_t GetSessionStatus(); Return the status of this session:; 0 idle; 1 running; 2 being terminated (currently unused); 3 queued; 4 idle timed-out (not set in here but in TIdleTOTimer::Notify); This is typically run in the reader thread, so access needs to be protected. Int_t UpdateSessionStatus(Int_t xst = -1); Update the session status in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:28774,recover,recover,28774,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['recover'],['recover']
Safety,"set in ASCII form to given stream. A line is written for each element contained in the form; <argName> = <argValue>. The <argValue> part of each element is written by the arguments'; writeToStream() function. Bool_t readFromStream(istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose = kFALSE); Read the contents of the argset in ASCII form from given stream. The stream is read to end-of-file and each line is assumed to be; of the form. <argName> = <argValue>. Lines starting with argNames not matching any element in the list; will be ignored with a warning message. In addition limited C++ style; preprocessing and flow control is provided. The following constructions; are recognized:. > #include ""include.file"". Include given file, recursive inclusion OK. > if (<boolean_expression>); > <name> = <value>; > ....; > else if (<boolean_expression>). > else. > endif. All expressions are evaluated by RooFormula, and may involve any of; the sets variables. > echo <Message>. Print console message while reading from stream. > abort. Force termination of read sequence with error status. The value of each argument is read by the arguments readFromStream; function. TObject* clone(const char* newname) const; { return new RooArgSet(*this,newname); }. TObject* create(const char* newname) const; { return new RooArgSet(newname); }. RooArgSet& operator=(const RooArgSet& other); { RooAbsCollection::operator=(other) ; return *this ;}. Bool_t add(const RooAbsArg& var, Bool_t silent=kFALSE). Bool_t addOwned(RooAbsArg& var, Bool_t silent=kFALSE). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent=kFALSE). Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). » Last changed: Mon Dec 7 13:45:58 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgSet.html:21945,abort,abort,21945,root/html526/RooArgSet.html,https://root.cern,https://root.cern/root/html526/RooArgSet.html,1,['abort'],['abort']
Safety,"set. Efficient analysis in Python; Class reference. Cheat sheet; These are the operations which can be performed with RDataFrame. Transformations; Transformations are a way to manipulate the data. Transformation Description . Alias() Introduce an alias for a particular column name. . DefaultValueFor() If the value of the input column is missing, provide a default value instead. . Define() Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the pts of ""good"" muons). . DefinePerSample() Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. . DefineSlot() Same as Define(), but the user-defined function must take an extra unsigned int slot as its first parameter. slot will take a different value, 0 to nThreads - 1, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case slot will always be 0. . DefineSlotEntry() Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see here. . Filter() Filter rows based on user-defined conditions. . FilterAvailable() Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. . FilterMissing() Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. . Range() Filter rows based on entry number (single-thread only). . Redefine() Overwrite the value and/or type of an existing column. See Define() for more information. . RedefineSlot() Overwrite the value and/or type of an existing column. See DefineSlot() for more information. . Rede",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:3604,safe,safe,3604,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['safe'],['safe']
Safety,"setBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tSavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExitStatus(TVirtualProofPlayer::EExitStatus); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutputFilePath(const char* fp); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVirtualProofPlayer(); TVirtualProofPlayer(const TVirtualProofPlayer&); virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidUpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualProofPlayer.html:10219,abort,abort,10219,root/html602/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualProofPlayer.html,4,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"seudo-rapidity.; Users can define the Vectors according to the coordinate type which is most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment operator =. The coordinate system classes are templated on the scalar type for maximum flexibility, and to minimize memory usage for some use cases. Coordinate System Tag; The 2D and 3D point and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D (and ROOT::Math::DisplacementVector2D) and ROOT::Math::PositionVector3D (and ROOT::Math::PositionVector2D) classes. A default tag, ROOT::Math::DefaultCoordinateSystemTag, exists for users who don't need this functionality. Concrete Vector typedefs; To avoid exposing templated parameters to the users, typedefs are defined for all types of vectors based an doubles and floats. The table below lists the double versions; the float counterpart ends on an extra F, such as ROOT::Math::XYPointF instead of ROOT::Math::XYPoint. Point2D; Type definitions for points in two dimensions, based on ROOT::Math::PositionVector2D, are defined by Math/Point2D.h:. ROOT::Math::XYPoint vector based on x,y coordinates (cartesian); ROOT::Math::Polar2DPoint vector based on r,phi coordinates (polar). Vector2D; Type definitions for vectors in two dimensions, based on ROOT::Math::DisplacementVector2D, are defined by Math/Vector2D.h:. ROOT::Math::XYVector vector based on x,y coordinates (cartesian); ROOT::Math::Polar2DVector vector based on r,phi coordinates (polar). Point3D; Type definitions for points in three dimensions, based on ROOT::Math::PositionVector3D, are defined by Math/Point3D.h:. ROOT::Math::XYZPoint point based on x,y,z coordinates (cartesian); ROOT::Math::Polar3DPoint point based on r,theta,phi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:3486,avoid,avoid,3486,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['avoid'],['avoid']
Safety,"sformation package.Definition TGeoMatrix.h:38; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoTrapDefinition TGeoArb8.h:96; TGeoTrap::~TGeoTrap~TGeoTrap() override; TGeoTrap::TGeoTrapTGeoTrap(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoTrap::fTl2Double_t fTl2Definition TGeoArb8.h:107; TGeoTrap::GetTl1Double_t GetTl1() constDefinition TGeoArb8.h:134; TGeoTrap::GetPhiDouble_t GetPhi() constDefinition TGeoArb8.h:131; TGeoTrap::fBl2Double_t fBl2Definition TGeoArb8.h:106; TGeoTrap::fAlpha2Double_t fAlpha2Definition TGeoArb8.h:108; TGeoTrap::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoTrap::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTrap::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTrap::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoTrap::fBl1Double_t fBl1Definition TGeoArb8.h:102; TGeoTrap::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::fH1Double_t fH1Definition TGeoArb8.h:101; TGeoTrap::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTrap::fPhiDouble_t fPhiDefinition TGeoArb8.h:100; TGeoTrap::GetAlpha2Double_t GetAlpha2() constDefinition TGeoArb8.h:139; TGeoTrap::GetThetaDouble_t GetTheta() constDefinition TGeoArb8.h:130; TGeoTrap::TGeoTrapTGeoTrap(); TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap::fTl1Double_t fTl1Definition TGeoArb8.h:103; TGeoTrap::f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoArb8_8h_source.html:18009,safe,safe,18009,doc/master/TGeoArb8_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html,1,['safe'],['safe']
Safety,"sh_back(TMath::Max( (UInt_t)V[ivar].Length(), minL ));; 952 maxL = TMath::Max( vLengths.back(), maxL );; 953 }; 954 ; 955 // count column length; 956 UInt_t clen = maxL+1;; 957 for (UInt_t icol=0; icol<nvar; icol++) clen += vLengths[icol]+1;; 958 ; 959 // bar line; 960 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 961 logger << Endl;; 962 ; 963 // title bar; 964 logger << setw(maxL+1) << "" "";; 965 for (UInt_t icol=0; icol<nvar; icol++) logger << setw(vLengths[icol]+1) << V[icol];; 966 logger << Endl;; 967 ; 968 // the numbers; 969 for (UInt_t irow=0; irow<nvar; irow++) {; 970 logger << setw(maxL) << V[irow] << "":"";; 971 for (UInt_t icol=0; icol<nvar; icol++) {; 972 logger << setw(vLengths[icol]+1) << TString::Format( ""%+1.3f"", M(irow,icol) );; 973 }; 974 logger << Endl;; 975 }; 976 ; 977 // bar line; 978 for (UInt_t i=0; i<clen; i++) logger << ""-"";; 979 logger << Endl;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// formatted output of matrix (with labels); 984 ; 985void TMVA::Tools::FormattedOutput( const TMatrixD& M,; 986 const std::vector<TString>& vert, const std::vector<TString>& horiz,; 987 MsgLogger& logger ); 988{; 989 // sanity check: matrix must be quadratic; 990 UInt_t nvvar = vert.size();; 991 UInt_t nhvar = horiz.size();; 992 ; 993 // get length of each variable, and maximum length; 994 UInt_t minL = 7;; 995 UInt_t maxL = minL;; 996 std::vector<UInt_t> vLengths;; 997 for (UInt_t ivar=0; ivar<nvvar; ivar++) {; 998 vLengths.push_back(TMath::Max( (UInt_t)vert[ivar].Length(), minL ));; 999 maxL = TMath::Max( vLengths.back(), maxL );; 1000 }; 1001 ; 1002 // count column length; 1003 UInt_t minLh = 7;; 1004 UInt_t maxLh = minLh;; 1005 std::vector<UInt_t> hLengths;; 1006 for (UInt_t ivar=0; ivar<nhvar; ivar++) {; 1007 hLengths.push_back(TMath::Max( (UInt_t)horiz[ivar].Length(), minL ));; 1008 maxLh = TMath::Max( hLengths.back(), maxLh );; 1009 }; 1010 ; 1011 UInt_t clen = maxLh+1;; 1012 for (UInt_t icol=0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:34159,sanity check,sanity check,34159,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['sanity check'],['sanity check']
Safety,"shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoChecker.html:15707,safe,safe,15707,root/html530/TGeoChecker.html,https://root.cern,https://root.cern/root/html530/TGeoChecker.html,9,['safe'],['safe']
Safety,"should have full path to the item. ;  ; Bool_t CreateItem (const char *fullname, const char *title);  Create item element. ;  ; void CreateOwnTopFolder ();  Create own TFolder structures independent from gROOT This allows to have many independent TRootSniffer instances At the same time such sniffer lost access to all global lists and folders. ;  ; virtual void * FindInHierarchy (const char *path, TClass **cl=nullptr, TDataMember **member=nullptr, Int_t *chld=nullptr);  Search element with specified path Returns pointer on element Optionally one could obtain element class, member description and number of childs. ;  ; TObject * FindTObjectInHierarchy (const char *path);  Search element in hierarchy, derived from TObject. ;  ; const char * GetAutoLoad () const;  return name of configured autoload scripts (or 0) ;  ; const char * GetItemField (const char *fullname, const char *name);  Return field for specified item. ;  ; virtual ULong_t GetItemHash (const char *itemname);  Get hash function for specified item used to detect any changes in the specified object. ;  ; virtual ULong_t GetStreamerInfoHash ();  ; TFolder * GetTopFolder (Bool_t force=kFALSE);  Returns top TFolder instance for the sniffer. ;  ; Bool_t HasRestriction (const char *item_name);  Made fast check if item with specified name is in restriction list If returns true, requires precise check with CheckRestriction() method. ;  ; TClass * IsA () const override;  ; Bool_t IsReadOnly () const;  Returns readonly mode. ;  ; Bool_t IsScanGlobalDir () const;  Returns true when sniffer allowed to scan global directories. ;  ; virtual Bool_t IsStreamerInfoItem (const char *);  ; Bool_t Produce (const std::string &path, const std::string &file, const std::string &options, std::string &res);  Method produce different kind of data out of object. ;  ; Bool_t RegisterCommand (const char *cmdname, const char *method, const char *icon);  Register command which can be executed from web interface. ;  ; Bool_t RegisterObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:2251,detect,detect,2251,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['detect'],['detect']
Safety,"shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to gStyle->SetOptFit(111). Statistics box editing; The following example show how to remove and add a line in a statistics box.; ; TCanvas *statsEditing() {; // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();; ; // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *listOfLines = ps->GetListOfLines();; ; // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; listOfLines->Remove(tconst);; ; // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; listOfLines->Add(myt);; ; // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);; ; se->Modified();; return se;; }; kRed@ kRedDefinition Rtypes.h:66; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TPad::Modifiedvoid Modified(Bool_t flag=true) overrideMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPaveStats.html:7713,avoid,avoid,7713,doc/master/classTPaveStats.html,https://root.cern,https://root.cern/doc/master/classTPaveStats.html,1,['avoid'],['avoid']
Safety,"sian PDF"", y, meany, sigmay); ; # Construct uncorrelated product pdf; # -------------------------------------------------------------------; ; # Multiply gaussx and gaussy into a two-dimensional pdf gaussxy; gaussxy = ROOT.RooProdPdf(""gaussxy"", ""gaussx*gaussy"", [gaussx, gaussy]); ; # Sample pdf, plot projection on x and y; # ---------------------------------------------------------------------------; ; # Generate 10000 events in x and y from gaussxy; data = gaussxy.generate({x, y}, 10000); ; # Plot x distribution of data and projection of gaussxy x = Int(dy); # gaussxy(x,y); xframe = x.frame(Title=""X projection of gauss(x)*gauss(y)""); data.plotOn(xframe); gaussxy.plotOn(xframe); ; # Plot x distribution of data and projection of gaussxy y = Int(dx); # gaussxy(x,y); yframe = y.frame(Title=""Y projection of gauss(x)*gauss(y)""); data.plotOn(yframe); gaussxy.plotOn(yframe); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf304_uncorrprod"", ""rf304_uncorrprod"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); ; c.SaveAs(""rf304_uncorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigmax' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigmay' with range [-inf, inf] of the RooGaussian 'gaussy' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on x integrates over variables (y); [#1] INFO:Plotting -- RooAbsReal::plotOn(gaussxy) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf304_uncorrprod.py. tutorialsroofitrf304_uncorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf304__uncorrprod_8py.html:2339,safe,safe,2339,doc/master/rf304__uncorrprod_8py.html,https://root.cern,https://root.cern/doc/master/rf304__uncorrprod_8py.html,2,['safe'],['safe']
Safety,"sibility() : set volume visibility.; 198 - TGeoVolume::VisibleDaughters() : set daughters visibility.; 199All these actions automatically updates the current view if any.; 200 ; 201### Checking the geometry; 202 ; 203 Several checking methods are accessible from the volume context menu. They; 204generally apply only to the visible parts of the drawn geometry in order to; 205ease geometry checking, and their implementation is in the TGeoChecker class; 206from the painting package.; 207 ; 208#### Checking a given point.; 209 Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; 210This method is drawing the daughters of the volume containing the point one; 211level down, printing the path to the deepest physical node holding this point.; 212It also computes the closest distance to any boundary. The point will be drawn; 213in red, as well as a sphere having this closest distance as radius. In case a; 214non-zero distance is given by the user as fifth argument of CheckPoint, this; 215distance will be used as radius of the safety sphere.; 216 ; 217\image html geom_checkpoint.jpg; 218 ; 219#### Shooting random points.; 220 Can be called from TGeoVolume::RandomPoints() (context menu function) and; 221it will draw this volume with current visualization settings. Random points; 222are generated in the bounding box of the top drawn volume. The points are; 223classified and drawn with the color of their deepest container. Only points; 224in visible nodes will be drawn.; 225 ; 226\image html geom_random1.jpg; 227 ; 228 ; 229#### Raytracing.; 230 Can be called from TGeoVolume::RandomRays() (context menu of volumes) and; 231will shoot rays from a given point in the local reference frame with random; 232directions. The intersections with displayed nodes will appear as segments; 233having the color of the touched node. Drawn geometry will be then made invisible; 234in order to enhance rays.; 235 ; 236\image html geom_random2.jpg; 237*/; 238 ; 239#include <",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:12022,safe,safety,12022,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['safe'],['safety']
Safety,"side the polygon. void ConvexCheck(); Check polygon convexity. void Draw(Option_t* option = """"); Draw the polygon. void FinishPolygon(); Decompose polygon in a convex outscribed part and a list of daughter; polygons that have to be substracted to get the actual one. void GetVertices(Double_t* x, Double_t* y) const; Fill list of vertices into provided arrays. void GetConvexVertices(Double_t* x, Double_t* y) const; Fill list of vertices of the convex outscribed polygon into provided arrays. Bool_t IsRightSided(const Double_t* point, Int_t ind1, Int_t ind2) const; Check if POINT is right-sided with respect to the segment defined by IND1 and IND2. Bool_t IsSegConvex(Int_t i1, Int_t i2 = -1) const; Check if a segment [0..fNvert-1] belongs to the outscribed convex pgon. Bool_t IsIllegalCheck() const; Check for illegal crossings between non-consecutive segments. void OutscribedConvex(); Compute indices for the outscribed convex polygon. Double_t Safety(const Double_t* point, Int_t& isegment) const; Compute minimum distance from POINT to any segment. Returns segment index. void SetNextIndex(Int_t index = -1); Sets the next polygone index. If index<0 sets all indices consecutive; in increasing order. void SetXY(Double_t* x, Double_t* y); Set X/Y array pointer for the polygon and daughters. TGeoPolygon(); constructors. Int_t GetNvert() const; {return fNvert;}. Int_t GetNconvex() const; {return fNconvex;}. Double_t * GetX(); {return fX;}. Double_t * GetY(); {return fY;}. Bool_t IsClockwise() const; {return !TObject::TestBit(kGeoACW);}. Bool_t IsConvex() const; {return TObject::TestBit(kGeoConvex);}. Bool_t IsFinished() const; {return TObject::TestBit(kGeoFinishPolygon);}. void SetConvex(Bool_t flag = kTRUE); {TObject::SetBit(kGeoConvex,flag);}. » Author: Mihaela Gheata 05/01/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions reg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPolygon.html:9056,Safe,Safety,9056,root/html534/TGeoPolygon.html,https://root.cern,https://root.cern/root/html534/TGeoPolygon.html,1,['Safe'],['Safety']
Safety,"side the polygon. void ConvexCheck(); Check polygon convexity. void Draw(Option_t* option = """"); Draw the polygon. void FinishPolygon(); Decompose polygon in a convex outscribed part and a list of daughter; polygons that have to be substracted to get the actual one. void GetVertices(Double_t* x, Double_t* y) const; Fill list of vertices into provided arrays. void GetConvexVertices(Double_t* x, Double_t* y) const; Fill list of vertices of the convex outscribed polygon into provided arrays. Bool_t IsRightSided(const Double_t* point, Int_t ind1, Int_t ind2) const; Check if POINT is right-sided with respect to the segment defined by IND1 and IND2. Bool_t IsSegConvex(Int_t i1, Int_t i2 = -1) const; Check if a segment [0..fNvert-1] belongs to the outscribed convex pgon. Bool_t IsIllegalCheck() const; Check for illegal crossings between non-consecutive segments. void OutscribedConvex(); Compute indices for the outscribed convex polygon. Double_t Safety(const Double_t* point, Int_t& isegment) const; Compute minimum distance from POINT to any segment. Returns segment index. void SetNextIndex(Int_t index = -1); Sets the next polygone index. If index<0 sets all indices consecutive; in increasing order. void SetXY(Double_t* x, Double_t* y); Set X/Y array pointer for the polygon and daughters. TGeoPolygon(); constructors. Int_t GetNvert() const; {return fNvert;}. Int_t GetNconvex() const; {return fNconvex;}. Double_t * GetX(); {return fX;}. Double_t * GetY(); {return fY;}. Bool_t IsClockwise() const; {return !TObject::TestBit(kGeoACW);}. Bool_t IsConvex() const; {return TObject::TestBit(kGeoConvex);}. Bool_t IsFinished() const; {return TObject::TestBit(kGeoFinishPolygon);}. void SetConvex(Bool_t flag = kTRUE); {TObject::SetBit(kGeoConvex,flag);}. » Author: Mihaela Gheata 05/01/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions reg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoPolygon.html:9598,Safe,Safety,9598,root/html604/TGeoPolygon.html,https://root.cern,https://root.cern/root/html604/TGeoPolygon.html,1,['Safe'],['Safety']
