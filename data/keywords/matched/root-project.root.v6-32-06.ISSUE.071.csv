id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/root-project/root/issues/11397:1449,performance,Memor,Memory,1449,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1523,performance,Memor,Memory,1523,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1597,performance,Memor,Memory,1597,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1671,performance,Memor,Memory,1671,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1745,performance,Memor,Memory,1745,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1819,performance,Memor,Memory,1819,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1893,performance,Memor,Memory,1893,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:212,reliability,doe,does,212,"[RF] Memory leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:991,safety,test,test,991,"[RF] Memory leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1113,safety,test,test,1113,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:991,testability,test,test,991,"[RF] Memory leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1113,testability,test,test,1113,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:5,usability,Memor,Memory,5,"[RF] Memory leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:293,usability,memor,memory,293,"[RF] Memory leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:415,usability,Minim,Minimization,415,"[RF] Memory leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:877,usability,Memor,Memory,877,"[RF] Memory leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1231,usability,Memor,Memory,1231,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1301,usability,Memor,Memory,1301,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1375,usability,Memor,Memory,1375,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1449,usability,Memor,Memory,1449,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1523,usability,Memor,Memory,1523,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1597,usability,Memor,Memory,1597,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1671,usability,Memor,Memory,1671,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1745,usability,Memor,Memory,1745,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1819,usability,Memor,Memory,1819,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/issues/11397:1893,usability,Memor,Memory,1893,"y leak when using any function that returns an owning pointer in PyROOT; - [x] Checked for duplicates. ### Describe the bug. It seems that in pyROOT, the NLL variable created from `RooAbsPdf.createNLL` does not get disposed of properly when the variable went out of scope, causing a memory leak. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). x.setRange(""SideBandLo"", 0, 2). x.setRange(""SideBandHi"", 6, 10). ds = pdf.generate(ROOT.RooArgSet(x), 11000). import psutil. def _memstat(mem0, mem1):. MB = 1024 * 1024. rss_mb = mem1.rss // MB. vms_mb = mem1.vms // MB. rss_delta_mb = (mem1.rss - mem0.rss) / MB. vms_delta_mb = (mem1.vms - mem0.vms) / MB. print(f""Memory stat: RSS={rss_mb} MB, VMS={vms_mb} MB. Delta RSS={rss_delta_mb:.2f} MB VMS={vms_delta_mb:.2f} MB""). . def test(pdf, ds):. nll = pdf.createNLL(ds). . proc = psutil.Process(). mem0 = proc.memory_info(). for i in range(int(1e4)):. test(pdf, ds). if (i%1000 == 0):. mem1 = proc.memory_info(). _memstat(mem0, mem1). mem0 = mem1. ```. This gives. ```. Memory stat: RSS=4009 MB, VMS=5170 MB. Delta RSS=0.00 MB VMS=0.00 MB. Memory stat: RSS=4116 MB, VMS=5278 MB. Delta RSS=107.25 MB VMS=107.15 MB. Memory stat: RSS=4224 MB, VMS=5386 MB. Delta RSS=108.02 MB VMS=108.10 MB. Memory stat: RSS=4333 MB, VMS=5495 MB. Delta RSS=109.05 MB VMS=109.21 MB. Memory stat: RSS=4439 MB, VMS=5601 MB. Delta RSS=106.48 MB VMS=106.48 MB. Memory stat: RSS=4547 MB, VMS=5709 MB. Delta RSS=108.02 MB VMS=107.85 MB. Memory stat: RSS=4656 MB, VMS=5820 MB. Delta RSS=109.05 MB VMS=110.36 MB. Memory stat: RSS=4764 MB, VMS=5927 MB. Delta RSS=108.02 MB VMS=107.75 MB. Memory stat: RSS=4872 MB, VMS=6035 MB. Delta RSS=108.02 MB VMS=107.95 MB. Memory stat: RSS=4979 MB, VMS=6144 MB. Delta RSS=106.81 MB VMS=108.52 MB. ```. ### Setup. ROOT 6.24, 6.26 (from LCG).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11397
https://github.com/root-project/root/pull/11398:427,safety,avoid,avoid,427,"Respect the user-provided number of entries to be displayed; Fixes #11390. Improves the workflow of `DisplayHelper::Exec` as follows:. 1. We always check whether there are entries to be displayed with `RDisplay::HasNext`. If so, add one row to the display object. 2. If no more entries should be displayed, signal this node has finished its job. Make sure the call to `StopProcessing` is done only once with a boolean flag, to avoid early stop of the execution due to more stop signals than the children who actually have finished their job.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11398
https://github.com/root-project/root/pull/11398:307,security,sign,signal,307,"Respect the user-provided number of entries to be displayed; Fixes #11390. Improves the workflow of `DisplayHelper::Exec` as follows:. 1. We always check whether there are entries to be displayed with `RDisplay::HasNext`. If so, add one row to the display object. 2. If no more entries should be displayed, signal this node has finished its job. Make sure the call to `StopProcessing` is done only once with a boolean flag, to avoid early stop of the execution due to more stop signals than the children who actually have finished their job.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11398
https://github.com/root-project/root/pull/11398:478,security,sign,signals,478,"Respect the user-provided number of entries to be displayed; Fixes #11390. Improves the workflow of `DisplayHelper::Exec` as follows:. 1. We always check whether there are entries to be displayed with `RDisplay::HasNext`. If so, add one row to the display object. 2. If no more entries should be displayed, signal this node has finished its job. Make sure the call to `StopProcessing` is done only once with a boolean flag, to avoid early stop of the execution due to more stop signals than the children who actually have finished their job.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11398
https://github.com/root-project/root/pull/11398:12,usability,user,user-provided,12,"Respect the user-provided number of entries to be displayed; Fixes #11390. Improves the workflow of `DisplayHelper::Exec` as follows:. 1. We always check whether there are entries to be displayed with `RDisplay::HasNext`. If so, add one row to the display object. 2. If no more entries should be displayed, signal this node has finished its job. Make sure the call to `StopProcessing` is done only once with a boolean flag, to avoid early stop of the execution due to more stop signals than the children who actually have finished their job.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11398
https://github.com/root-project/root/pull/11398:88,usability,workflow,workflow,88,"Respect the user-provided number of entries to be displayed; Fixes #11390. Improves the workflow of `DisplayHelper::Exec` as follows:. 1. We always check whether there are entries to be displayed with `RDisplay::HasNext`. If so, add one row to the display object. 2. If no more entries should be displayed, signal this node has finished its job. Make sure the call to `StopProcessing` is done only once with a boolean flag, to avoid early stop of the execution due to more stop signals than the children who actually have finished their job.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11398
https://github.com/root-project/root/pull/11398:369,usability,Stop,StopProcessing,369,"Respect the user-provided number of entries to be displayed; Fixes #11390. Improves the workflow of `DisplayHelper::Exec` as follows:. 1. We always check whether there are entries to be displayed with `RDisplay::HasNext`. If so, add one row to the display object. 2. If no more entries should be displayed, signal this node has finished its job. Make sure the call to `StopProcessing` is done only once with a boolean flag, to avoid early stop of the execution due to more stop signals than the children who actually have finished their job.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11398
https://github.com/root-project/root/pull/11398:439,usability,stop,stop,439,"Respect the user-provided number of entries to be displayed; Fixes #11390. Improves the workflow of `DisplayHelper::Exec` as follows:. 1. We always check whether there are entries to be displayed with `RDisplay::HasNext`. If so, add one row to the display object. 2. If no more entries should be displayed, signal this node has finished its job. Make sure the call to `StopProcessing` is done only once with a boolean flag, to avoid early stop of the execution due to more stop signals than the children who actually have finished their job.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11398
https://github.com/root-project/root/pull/11398:473,usability,stop,stop,473,"Respect the user-provided number of entries to be displayed; Fixes #11390. Improves the workflow of `DisplayHelper::Exec` as follows:. 1. We always check whether there are entries to be displayed with `RDisplay::HasNext`. If so, add one row to the display object. 2. If no more entries should be displayed, signal this node has finished its job. Make sure the call to `StopProcessing` is done only once with a boolean flag, to avoid early stop of the execution due to more stop signals than the children who actually have finished their job.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11398
https://github.com/root-project/root/pull/11400:175,deployability,depend,depend,175,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:702,deployability,manag,manage,702,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:981,deployability,contain,contained,981,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1361,deployability,configurat,configurations,1361,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:702,energy efficiency,manag,manage,702,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:79,integrability,Batch,BatchMode,79,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:136,integrability,Batch,BatchMode,136,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:175,integrability,depend,depend,175,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:541,integrability,interfac,interface,541,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:600,integrability,Batch,BatchMode,600,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:788,integrability,Batch,BatchMode,788,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:999,integrability,Batch,BatchMode,999,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1073,integrability,batch,batchMode,1073,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1116,integrability,wrap,wraps,1116,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1159,integrability,interfac,interface,1159,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1361,integrability,configur,configurations,1361,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1413,integrability,Batch,BatchMode,1413,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1502,integrability,Batch,BatchMode,1502,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:527,interoperability,client-serv,client-server,527,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:541,interoperability,interfac,interface,541,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1144,interoperability,client-serv,client-server,1144,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1159,interoperability,interfac,interface,1159,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:175,modifiability,depend,depend,175,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:541,modifiability,interfac,interface,541,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1159,modifiability,interfac,interface,1159,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1361,modifiability,configur,configurations,1361,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:79,performance,Batch,BatchMode,79,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:136,performance,Batch,BatchMode,136,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:270,performance,cach,caching,270,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:310,performance,cach,cached,310,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:600,performance,Batch,BatchMode,600,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:709,performance,memor,memory,709,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:788,performance,Batch,BatchMode,788,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:936,performance,cach,cache,936,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:999,performance,Batch,BatchMode,999,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1073,performance,batch,batchMode,1073,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1355,performance,cach,cache,1355,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1413,performance,Batch,BatchMode,1413,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1460,performance,Cach,CachingOpt,1460,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1502,performance,Batch,BatchMode,1502,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:175,safety,depend,depend,175,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:702,safety,manag,manage,702,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1448,safety,Test,TestProdPdf,1448,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1477,safety,test,test,1477,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1361,security,configur,configurations,1361,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:175,testability,depend,depend,175,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1448,testability,Test,TestProdPdf,1448,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1472,testability,unit,unit,1472,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:1477,testability,test,test,1477,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:709,usability,memor,memory,709,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11400:798,usability,support,support,798,"[RF] New mechanism to evaluate a `RooProdPdf` for a given normalization set in BatchMode; The RooProdPdf is not trivial to deal with in BatchMode, because its. actual servers depend on the normalization set. One should rather think of the RooProdPdf as something like a caching. PDF, but instead of creating a cached HistPdf for a given normalization. set, it creates an internal computation graph representing the. normalized product for a given normalization set. This internal computation graph is not expsed via the usual. client-server interface. However, this is strictly required for the new. BatchMode: internal computation graphs are not allowed because the. RooFitDriver would not be able to manage memory copies between host and. device, and also schedeuling. For this reason, BatchMode support is removed from the RooProdPdf class. We only keep a `RooProdPdf::calculateBatch` function that can be used to. evaluated a given cache element when all the internal args are contained. in the BatchMode data map. To correctly evaluate these computation graphs in the batchMode, a new. class is introduced that wraps them with the correct client-server. interface. Instances of this class are then created for each ProdPdf in. the original computation graph, and the ProdPdfs are replaced with these. objects. This means all the different RooProdPdf cache configurations are now. correctly dealt with in the BatchMode, making the. `RooProdPdf/TestProdPdf.CachingOpt` unit test also pass with the. BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11400
https://github.com/root-project/root/pull/11401:187,deployability,depend,depend,187,"[RF] Consider the `SplitRange` in overlap checks for simultaneous PDFs; When the `SplitRange` command arguemnt is used in. `RooAbsPdf::createNLL`, the actual range names used for the fit depend on the channel, with the range names suffixed by the category name. This should be considered correctly in the overlap checks. Closes #11396.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11401
https://github.com/root-project/root/pull/11401:187,integrability,depend,depend,187,"[RF] Consider the `SplitRange` in overlap checks for simultaneous PDFs; When the `SplitRange` command arguemnt is used in. `RooAbsPdf::createNLL`, the actual range names used for the fit depend on the channel, with the range names suffixed by the category name. This should be considered correctly in the overlap checks. Closes #11396.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11401
https://github.com/root-project/root/pull/11401:187,modifiability,depend,depend,187,"[RF] Consider the `SplitRange` in overlap checks for simultaneous PDFs; When the `SplitRange` command arguemnt is used in. `RooAbsPdf::createNLL`, the actual range names used for the fit depend on the channel, with the range names suffixed by the category name. This should be considered correctly in the overlap checks. Closes #11396.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11401
https://github.com/root-project/root/pull/11401:187,safety,depend,depend,187,"[RF] Consider the `SplitRange` in overlap checks for simultaneous PDFs; When the `SplitRange` command arguemnt is used in. `RooAbsPdf::createNLL`, the actual range names used for the fit depend on the channel, with the range names suffixed by the category name. This should be considered correctly in the overlap checks. Closes #11396.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11401
https://github.com/root-project/root/pull/11401:53,testability,simul,simultaneous,53,"[RF] Consider the `SplitRange` in overlap checks for simultaneous PDFs; When the `SplitRange` command arguemnt is used in. `RooAbsPdf::createNLL`, the actual range names used for the fit depend on the channel, with the range names suffixed by the category name. This should be considered correctly in the overlap checks. Closes #11396.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11401
https://github.com/root-project/root/pull/11401:187,testability,depend,depend,187,"[RF] Consider the `SplitRange` in overlap checks for simultaneous PDFs; When the `SplitRange` command arguemnt is used in. `RooAbsPdf::createNLL`, the actual range names used for the fit depend on the channel, with the range names suffixed by the category name. This should be considered correctly in the overlap checks. Closes #11396.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11401
https://github.com/root-project/root/pull/11401:94,usability,command,command,94,"[RF] Consider the `SplitRange` in overlap checks for simultaneous PDFs; When the `SplitRange` command arguemnt is used in. `RooAbsPdf::createNLL`, the actual range names used for the fit depend on the channel, with the range names suffixed by the category name. This should be considered correctly in the overlap checks. Closes #11396.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11401
https://github.com/root-project/root/pull/11401:321,usability,Close,Closes,321,"[RF] Consider the `SplitRange` in overlap checks for simultaneous PDFs; When the `SplitRange` command arguemnt is used in. `RooAbsPdf::createNLL`, the actual range names used for the fit depend on the channel, with the range names suffixed by the category name. This should be considered correctly in the overlap checks. Closes #11396.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11401
https://github.com/root-project/root/pull/11402:48,deployability,patch,patches,48,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 20; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11401. 2. https://github.com/root-project/root/pull/11406. Only the last commit that changes the PDF cloning behavior, also excluding the `testRooSimultaneous` changes in that commit",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11402
https://github.com/root-project/root/pull/11402:175,deployability,patch,patches,175,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 20; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11401. 2. https://github.com/root-project/root/pull/11406. Only the last commit that changes the PDF cloning behavior, also excluding the `testRooSimultaneous` changes in that commit",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11402
https://github.com/root-project/root/pull/11402:48,safety,patch,patches,48,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 20; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11401. 2. https://github.com/root-project/root/pull/11406. Only the last commit that changes the PDF cloning behavior, also excluding the `testRooSimultaneous` changes in that commit",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11402
https://github.com/root-project/root/pull/11402:175,safety,patch,patches,175,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 20; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11401. 2. https://github.com/root-project/root/pull/11406. Only the last commit that changes the PDF cloning behavior, also excluding the `testRooSimultaneous` changes in that commit",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11402
https://github.com/root-project/root/pull/11402:439,safety,test,testRooSimultaneous,439,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 20; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11401. 2. https://github.com/root-project/root/pull/11406. Only the last commit that changes the PDF cloning behavior, also excluding the `testRooSimultaneous` changes in that commit",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11402
https://github.com/root-project/root/pull/11402:48,security,patch,patches,48,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 20; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11401. 2. https://github.com/root-project/root/pull/11406. Only the last commit that changes the PDF cloning behavior, also excluding the `testRooSimultaneous` changes in that commit",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11402
https://github.com/root-project/root/pull/11402:175,security,patch,patches,175,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 20; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11401. 2. https://github.com/root-project/root/pull/11406. Only the last commit that changes the PDF cloning behavior, also excluding the `testRooSimultaneous` changes in that commit",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11402
https://github.com/root-project/root/pull/11402:439,testability,test,testRooSimultaneous,439,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 20; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11401. 2. https://github.com/root-project/root/pull/11406. Only the last commit that changes the PDF cloning behavior, also excluding the `testRooSimultaneous` changes in that commit",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11402
https://github.com/root-project/root/pull/11402:409,usability,behavi,behavior,409,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 20; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11401. 2. https://github.com/root-project/root/pull/11406. Only the last commit that changes the PDF cloning behavior, also excluding the `testRooSimultaneous` changes in that commit",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11402
https://github.com/root-project/root/pull/11403:42,availability,operat,operator,42,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11403:136,availability,error,error,136,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11403:136,performance,error,error,136,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11403:136,safety,error,error,136,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11403:151,safety,input,input,151,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11403:213,safety,test,tested,213,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11403:105,security,stride,stride,105,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11403:213,testability,test,tested,213,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11403:136,usability,error,error,136,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11403:151,usability,input,input,151,[TMVA][SOIFE] Fix warnings in the Softmax operator; ## This Pull request:. - Initialize the size and the stride of the axis. - throw an error when the input tensor has more than 5 dimensions. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11403
https://github.com/root-project/root/pull/11404:107,availability,operat,operators,107,[TMVA][SOFIE] Fuse Conv or ConvTranspose and Add; ## This Pull request:. Fuse Conv or ConvTranpose and Add operators.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11404
https://github.com/root-project/root/pull/11405:70,availability,operat,operator,70,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:513,deployability,configurat,configuration,513,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:5,energy efficiency,core,core,5,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:513,integrability,configur,configuration,513,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:61,interoperability,platform,platform,61,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:201,interoperability,platform,platform,201,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:674,interoperability,platform,platform,674,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:513,modifiability,configur,configuration,513,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:97,performance,memor,memory,97,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:301,performance,memor,memory,301,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:575,performance,memor,memory,575,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:702,performance,memor,memory,702,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:683,reliability,doe,does,683,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:19,safety,test,test,19,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:336,safety,detect,detect,336,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:451,safety,detect,detects,451,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:250,security,hack,hack,250,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:336,security,detect,detect,336,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:451,security,detect,detects,451,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:513,security,configur,configuration,513,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:19,testability,test,test,19,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:97,usability,memor,memory,97,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:301,usability,memor,memory,301,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:575,usability,memor,memory,575,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11405:702,usability,memor,memory,702,"v626 core: Disable test for already deleted object.; On some platform operator delete taints the memory, so even right after the deletion the information stored by ~TObject is already erased. On those platform we no longer rely on the kNotDelete bit hack and rely on the system (which has tainted the memory assumingly for a reason) to detect the use-after-delete problems. Introduce 2 new functions. TObject::IsDestructed (used by TClonesArray) that detects that the destructor has been run and is active in all configuration. This should be used if the code knows that the memory has not been freed/deleted. ROOT::Detail::HasBeenDeleted(TObject*) with returns true if the platform does not taint the memory and if the kNotDeleted is not set (in all other case, it returns false). This fixes #11330. Backport of https://github.com/root-project/root/pull/11334.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11405
https://github.com/root-project/root/pull/11406:262,availability,state,state,262,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:292,availability,state,state,292,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:722,deployability,fail,failed,722,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:314,energy efficiency,model,model,314,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:335,energy efficiency,model,model,335,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:459,energy efficiency,model,models,459,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:36,integrability,Batch,BatchMode,36,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:126,integrability,Batch,BatchMode,126,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:262,integrability,state,state,262,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:292,integrability,state,state,292,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:667,integrability,Batch,BatchMode,667,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:642,modifiability,exten,extended,642,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:36,performance,Batch,BatchMode,36,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:126,performance,Batch,BatchMode,126,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:515,performance,perform,performance,515,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:667,performance,Batch,BatchMode,667,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:722,reliability,fail,failed,722,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:565,safety,test,testRooSimultaneous,565,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:594,safety,test,test,594,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:314,security,model,model,314,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:335,security,model,model,335,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:459,security,model,models,459,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:446,testability,simul,simultaneous,446,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:565,testability,test,testRooSimultaneous,565,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:594,testability,test,test,594,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:515,usability,perform,performance,515,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11406:549,usability,workflow,workflows,549,"[RF] Always clone the PDF in RooFit BatchMode `RooAbsPdf::createNLL`; Unlike in the old RooFit, the PDF was not cloned in the BatchMode when a. likelihood object was created with `RooAbsPdf::createNLL`. This caused. trouble in a few places, because changing the state of the NLL changed. the state of the original model. Actually, the model was already cloned when a RooSimultaneous was used,. and because the cloning is only expensive for large simultaneous models,. this change is not expected to have a negative performance impact for. realistic workflows. The `testRooSimultaneous` closure test with a one-channel. RooSimultaneous is now extended to use also the BatchMode, because this. was one of the cases where it failed before the suggested change in this. commit. This PR includes a second technical commit with some code modernization in `stressRooFit`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11406
https://github.com/root-project/root/pull/11407:154,deployability,updat,update,154,"[hist] Fix in THnBase::Add the computation of the running sums; The sum of weight, weight square and weigth * x used for statistics computation where not update when adding/merging THnBase classes. This fixes #11333.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11407
https://github.com/root-project/root/pull/11407:154,safety,updat,update,154,"[hist] Fix in THnBase::Add the computation of the running sums; The sum of weight, weight square and weigth * x used for statistics computation where not update when adding/merging THnBase classes. This fixes #11333.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11407
https://github.com/root-project/root/pull/11407:154,security,updat,update,154,"[hist] Fix in THnBase::Add the computation of the running sums; The sum of weight, weight square and weigth * x used for statistics computation where not update when adding/merging THnBase classes. This fixes #11333.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11407
https://github.com/root-project/root/pull/11408:63,usability,command,command,63,[cmake] Protect against empty COMPILE_DEFINITIONS in genreflex command; This applies the change made to ROOT_GENERATE_DICTIONARY in the main branch commit 08ab7e0306 to GENREFLEX_GENERATE_DICTIONARY. This commit in conjunction with 08ab7e0306 fixes #11312. See commit 08ab7e0306 and issue #11312 for more details on the issue and solution.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11408
https://github.com/root-project/root/pull/11409:25,deployability,version,version,25,[hist] Fix I/O for older version of TNDArray objects; . This PR fixes #10382.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11409
https://github.com/root-project/root/pull/11409:25,integrability,version,version,25,[hist] Fix I/O for older version of TNDArray objects; . This PR fixes #10382.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11409
https://github.com/root-project/root/pull/11409:25,modifiability,version,version,25,[hist] Fix I/O for older version of TNDArray objects; . This PR fixes #10382.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11409
https://github.com/root-project/root/pull/11409:11,performance,I/O,I/O,11,[hist] Fix I/O for older version of TNDArray objects; . This PR fixes #10382.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11409
https://github.com/root-project/root/pull/11410:342,deployability,manag,management,342,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:342,energy efficiency,manag,management,342,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:266,integrability,Batch,BatchMode,266,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:241,interoperability,compatib,compatible,241,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:226,performance,perform,performant,226,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:266,performance,Batch,BatchMode,266,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:335,performance,memor,memory,335,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:342,safety,manag,management,342,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:123,security,hardcod,hardcoded,123,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:226,usability,perform,performant,226,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/pull/11410:335,usability,memor,memory,335,"[RF] Use VectorDataStore by default in all RooDataSet constructors; There still was a constructor of `RooDataSet` that was hardcoded to use. the TreeDataStore. This needs to be changed, because the. RooVectorDataStore is more performant and compatible with the new. BatchMode. This PR also includes some other commits that improve the memory management in the dataset classes with `std::unique_ptr`.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11410
https://github.com/root-project/root/issues/11411:72,interoperability,convers,conversion,72,"[PyROOT] Python list of strings -> std::initializer_list< std::string > conversion is broken; This is a spinoff from #10092 . The following reproducer segfaults:. ```python. import ROOT. ROOT.gInterpreter.Declare("""""". void foo (const std::initializer_list< std::string > &columns) {}. """"""). ROOT.foo([""x""]). ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11411
https://github.com/root-project/root/pull/11412:24,performance,memor,memory,24,"[PyROOT][10454] Prevent memory hogging issue when checking for enums; As reported in issue #10454, calling `ClassInfo_IsEnum()` repeatedly increases the memory consumption of the program. This does not happen with `TEnum::GetEnum()`, which can be used instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11412
https://github.com/root-project/root/pull/11412:153,performance,memor,memory,153,"[PyROOT][10454] Prevent memory hogging issue when checking for enums; As reported in issue #10454, calling `ClassInfo_IsEnum()` repeatedly increases the memory consumption of the program. This does not happen with `TEnum::GetEnum()`, which can be used instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11412
https://github.com/root-project/root/pull/11412:193,reliability,doe,does,193,"[PyROOT][10454] Prevent memory hogging issue when checking for enums; As reported in issue #10454, calling `ClassInfo_IsEnum()` repeatedly increases the memory consumption of the program. This does not happen with `TEnum::GetEnum()`, which can be used instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11412
https://github.com/root-project/root/pull/11412:16,safety,Prevent,Prevent,16,"[PyROOT][10454] Prevent memory hogging issue when checking for enums; As reported in issue #10454, calling `ClassInfo_IsEnum()` repeatedly increases the memory consumption of the program. This does not happen with `TEnum::GetEnum()`, which can be used instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11412
https://github.com/root-project/root/pull/11412:16,security,Preven,Prevent,16,"[PyROOT][10454] Prevent memory hogging issue when checking for enums; As reported in issue #10454, calling `ClassInfo_IsEnum()` repeatedly increases the memory consumption of the program. This does not happen with `TEnum::GetEnum()`, which can be used instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11412
https://github.com/root-project/root/pull/11412:24,usability,memor,memory,24,"[PyROOT][10454] Prevent memory hogging issue when checking for enums; As reported in issue #10454, calling `ClassInfo_IsEnum()` repeatedly increases the memory consumption of the program. This does not happen with `TEnum::GetEnum()`, which can be used instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11412
https://github.com/root-project/root/pull/11412:153,usability,memor,memory,153,"[PyROOT][10454] Prevent memory hogging issue when checking for enums; As reported in issue #10454, calling `ClassInfo_IsEnum()` repeatedly increases the memory consumption of the program. This does not happen with `TEnum::GetEnum()`, which can be used instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11412
https://github.com/root-project/root/pull/11413:159,energy efficiency,Current,Currently,159,"[PyROOT] Improve output of CPPMethod::GetPrototype; Given the following function declared to ROOT and accessed via a Python proxy:. ```. int foo(int x);. ```. Currently accessing its `func_doc`, which in turn calls `CPPMethod::GetPrototype`, gives:. 'int ::foo(int x)'. The extra set of '::' can be avoided by checking that the function is not declared inside a namespace. Note: this is a check, may be not worthy in the end if we find places that rely on those extra ""::"" being present.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11413
https://github.com/root-project/root/pull/11413:124,interoperability,prox,proxy,124,"[PyROOT] Improve output of CPPMethod::GetPrototype; Given the following function declared to ROOT and accessed via a Python proxy:. ```. int foo(int x);. ```. Currently accessing its `func_doc`, which in turn calls `CPPMethod::GetPrototype`, gives:. 'int ::foo(int x)'. The extra set of '::' can be avoided by checking that the function is not declared inside a namespace. Note: this is a check, may be not worthy in the end if we find places that rely on those extra ""::"" being present.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11413
https://github.com/root-project/root/pull/11413:299,safety,avoid,avoided,299,"[PyROOT] Improve output of CPPMethod::GetPrototype; Given the following function declared to ROOT and accessed via a Python proxy:. ```. int foo(int x);. ```. Currently accessing its `func_doc`, which in turn calls `CPPMethod::GetPrototype`, gives:. 'int ::foo(int x)'. The extra set of '::' can be avoided by checking that the function is not declared inside a namespace. Note: this is a check, may be not worthy in the end if we find places that rely on those extra ""::"" being present.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11413
https://github.com/root-project/root/pull/11413:102,security,access,accessed,102,"[PyROOT] Improve output of CPPMethod::GetPrototype; Given the following function declared to ROOT and accessed via a Python proxy:. ```. int foo(int x);. ```. Currently accessing its `func_doc`, which in turn calls `CPPMethod::GetPrototype`, gives:. 'int ::foo(int x)'. The extra set of '::' can be avoided by checking that the function is not declared inside a namespace. Note: this is a check, may be not worthy in the end if we find places that rely on those extra ""::"" being present.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11413
https://github.com/root-project/root/pull/11413:169,security,access,accessing,169,"[PyROOT] Improve output of CPPMethod::GetPrototype; Given the following function declared to ROOT and accessed via a Python proxy:. ```. int foo(int x);. ```. Currently accessing its `func_doc`, which in turn calls `CPPMethod::GetPrototype`, gives:. 'int ::foo(int x)'. The extra set of '::' can be avoided by checking that the function is not declared inside a namespace. Note: this is a check, may be not worthy in the end if we find places that rely on those extra ""::"" being present.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11413
https://github.com/root-project/root/issues/11414:22,deployability,fail,fails,22,"[RF] Renaming dataset fails when total number of dataset in workspace reached 10; - [x] Checked for duplicates. ### Describe the bug. If the number of dataset in a workspace is larger than or equal to 10. Renaming a dataset inside the workspace will not work in the sense that calling `ws.data(<new_dataset_name>)` will return nil and calling `ws.data(<old_dataset_name>)` will return the correct dataset but with the name changed. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.ObjectHandling). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). n_dataset = 10. for i in range(n_dataset):. 	dataset= pdf.generate(ROOT.RooArgSet(x), ROOT.RooFit.NumEvents(1000), ROOT.RooFit.Name(f""asimovData_{i}"")). 	ws.Import(dataset). ws.data(""asimovData_0"").SetName(""combData""). # this gives nil. print(ws.data(""combData"")). # this gives ""combData"". print(ws.data(""asimovData_0"").GetName()). ```. If `n_dataset` is changed to 9, `ws.data(""combData"")` will give the correct dataset and `ws.data(""asimovData_0"")` will give nil. ### Setup. ROOT 6.24, 6.26 (from LCG)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11414
https://github.com/root-project/root/issues/11414:22,reliability,fail,fails,22,"[RF] Renaming dataset fails when total number of dataset in workspace reached 10; - [x] Checked for duplicates. ### Describe the bug. If the number of dataset in a workspace is larger than or equal to 10. Renaming a dataset inside the workspace will not work in the sense that calling `ws.data(<new_dataset_name>)` will return nil and calling `ws.data(<old_dataset_name>)` will return the correct dataset but with the name changed. ### To Reproduce. ```Python. import ROOT. ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.ObjectHandling). ws = ROOT.RooWorkspace(). ws.factory(""Gaussian::pdf(x[0,10],mu[4,0,10],sigma[1.0,0.1,10.0])""). pdf = ws.pdf(""pdf""). x = ws.var(""x""). n_dataset = 10. for i in range(n_dataset):. 	dataset= pdf.generate(ROOT.RooArgSet(x), ROOT.RooFit.NumEvents(1000), ROOT.RooFit.Name(f""asimovData_{i}"")). 	ws.Import(dataset). ws.data(""asimovData_0"").SetName(""combData""). # this gives nil. print(ws.data(""combData"")). # this gives ""combData"". print(ws.data(""asimovData_0"").GetName()). ```. If `n_dataset` is changed to 9, `ws.data(""combData"")` will give the correct dataset and `ws.data(""asimovData_0"")` will give nil. ### Setup. ROOT 6.24, 6.26 (from LCG)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11414
https://github.com/root-project/root/pull/11415:208,availability,operat,operator,208,[TMVA][SOFIE] Broadcasting; ## This Pull request:. - Implement UnidirectionalBroadcasting and MultidirectionalBroadcasting according to numpy's broadcasting rules. - Broadcast the input tensors of the binary operator to the same shape. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11415
https://github.com/root-project/root/pull/11415:180,safety,input,input,180,[TMVA][SOFIE] Broadcasting; ## This Pull request:. - Implement UnidirectionalBroadcasting and MultidirectionalBroadcasting according to numpy's broadcasting rules. - Broadcast the input tensors of the binary operator to the same shape. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11415
https://github.com/root-project/root/pull/11415:257,safety,test,tested,257,[TMVA][SOFIE] Broadcasting; ## This Pull request:. - Implement UnidirectionalBroadcasting and MultidirectionalBroadcasting according to numpy's broadcasting rules. - Broadcast the input tensors of the binary operator to the same shape. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11415
https://github.com/root-project/root/pull/11415:257,testability,test,tested,257,[TMVA][SOFIE] Broadcasting; ## This Pull request:. - Implement UnidirectionalBroadcasting and MultidirectionalBroadcasting according to numpy's broadcasting rules. - Broadcast the input tensors of the binary operator to the same shape. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11415
https://github.com/root-project/root/pull/11415:180,usability,input,input,180,[TMVA][SOFIE] Broadcasting; ## This Pull request:. - Implement UnidirectionalBroadcasting and MultidirectionalBroadcasting according to numpy's broadcasting rules. - Broadcast the input tensors of the binary operator to the same shape. ## Checklist:. - [x] tested changes locally.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11415
https://github.com/root-project/root/pull/11416:20,deployability,observ,observables,20,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:538,deployability,observ,observables,538,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:468,energy efficiency,model,model,468,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:45,integrability,Batch,BatchMode,45,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:64,integrability,Batch,BatchMode,64,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:168,integrability,Batch,BatchMode,168,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:366,integrability,Batch,BatchMode,366,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:393,integrability,Batch,BatchMode,393,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:575,integrability,Batch,BatchMode,575,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:854,integrability,Batch,BatchMode,854,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:796,modifiability,extens,extensively,796,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:45,performance,Batch,BatchMode,45,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:64,performance,Batch,BatchMode,64,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:168,performance,Batch,BatchMode,168,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:366,performance,Batch,BatchMode,366,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:393,performance,Batch,BatchMode,393,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:575,performance,Batch,BatchMode,575,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:854,performance,Batch,BatchMode,854,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:101,safety,test,testGlobalObservables,101,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:130,safety,test,test,130,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:705,safety,test,test,705,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:789,safety,test,tested,789,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:822,safety,test,tests,822,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:468,security,model,model,468,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:20,testability,observ,observables,20,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:101,testability,test,testGlobalObservables,101,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:124,testability,unit,unit,124,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:130,testability,test,test,130,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:538,testability,observ,observables,538,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:700,testability,unit,unit,700,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:705,testability,test,test,705,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:789,testability,test,tested,789,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:817,testability,unit,unit,817,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:822,testability,test,tests,822,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11416:5,usability,Support,Support,5,"[RF] Support global observables from data in BatchMode; The new BatchMode is adjusted such that the `testGlobalObservables` unit. test is passing when always using the BatchMode for fitting. This also. means the following adjustments had to be made:. 1. Implement resetting of data for the RooFitDriver. 2. Always clone the created constraint term, also in the new. BatchMode, because the new BatchMode mutates the computation graph. and it's not good if the original model is changed. 3. Implement the correct treatment of taking global observables from. the dataset in the BatchMode. This PR also includes a commit with some code modernization of the `RooAbsPdf`, and it also removes the low-level unit test for the RooFitDriver, which is not needed anymore now that the RooFitDriver is tested extensively by every unit tests that makes use of the new BatchMode.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11416
https://github.com/root-project/root/pull/11417:287,usability,Close,Closes,287,"[RF] Correctly override `SetName` in RooDataHist and RooDataSet; When overriding `SetName` in RooDataHist and RooDataSet, we need to use the function from the direct base class RooAbsData, because this one is already overriding the TNamed function to deal with the RooNameReg correctly. Closes #11414.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11417
https://github.com/root-project/root/issues/11418:269,integrability,event,events,269,"[RF] Wrong CmdArg name in documentation of RooAbsPdf class; In the documentation of the [RooAbsPdf ](https://root.cern.ch/doc/master/classRooAbsPdf.html) class, methods related to dataset generation have a CmdArg variable named ""NumEvent"" which specifies the number of events to generate. However, the correct variable name should be ""NumEvents"" instead (i.e. `RooFit::NumEvent` does not exist but `RooFit::NumEvents` does).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11418
https://github.com/root-project/root/issues/11418:245,interoperability,specif,specifies,245,"[RF] Wrong CmdArg name in documentation of RooAbsPdf class; In the documentation of the [RooAbsPdf ](https://root.cern.ch/doc/master/classRooAbsPdf.html) class, methods related to dataset generation have a CmdArg variable named ""NumEvent"" which specifies the number of events to generate. However, the correct variable name should be ""NumEvents"" instead (i.e. `RooFit::NumEvent` does not exist but `RooFit::NumEvents` does).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11418
https://github.com/root-project/root/issues/11418:213,modifiability,variab,variable,213,"[RF] Wrong CmdArg name in documentation of RooAbsPdf class; In the documentation of the [RooAbsPdf ](https://root.cern.ch/doc/master/classRooAbsPdf.html) class, methods related to dataset generation have a CmdArg variable named ""NumEvent"" which specifies the number of events to generate. However, the correct variable name should be ""NumEvents"" instead (i.e. `RooFit::NumEvent` does not exist but `RooFit::NumEvents` does).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11418
https://github.com/root-project/root/issues/11418:310,modifiability,variab,variable,310,"[RF] Wrong CmdArg name in documentation of RooAbsPdf class; In the documentation of the [RooAbsPdf ](https://root.cern.ch/doc/master/classRooAbsPdf.html) class, methods related to dataset generation have a CmdArg variable named ""NumEvent"" which specifies the number of events to generate. However, the correct variable name should be ""NumEvents"" instead (i.e. `RooFit::NumEvent` does not exist but `RooFit::NumEvents` does).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11418
https://github.com/root-project/root/issues/11418:379,reliability,doe,does,379,"[RF] Wrong CmdArg name in documentation of RooAbsPdf class; In the documentation of the [RooAbsPdf ](https://root.cern.ch/doc/master/classRooAbsPdf.html) class, methods related to dataset generation have a CmdArg variable named ""NumEvent"" which specifies the number of events to generate. However, the correct variable name should be ""NumEvents"" instead (i.e. `RooFit::NumEvent` does not exist but `RooFit::NumEvents` does).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11418
https://github.com/root-project/root/issues/11418:418,reliability,doe,does,418,"[RF] Wrong CmdArg name in documentation of RooAbsPdf class; In the documentation of the [RooAbsPdf ](https://root.cern.ch/doc/master/classRooAbsPdf.html) class, methods related to dataset generation have a CmdArg variable named ""NumEvent"" which specifies the number of events to generate. However, the correct variable name should be ""NumEvents"" instead (i.e. `RooFit::NumEvent` does not exist but `RooFit::NumEvents` does).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11418
https://github.com/root-project/root/issues/11418:26,usability,document,documentation,26,"[RF] Wrong CmdArg name in documentation of RooAbsPdf class; In the documentation of the [RooAbsPdf ](https://root.cern.ch/doc/master/classRooAbsPdf.html) class, methods related to dataset generation have a CmdArg variable named ""NumEvent"" which specifies the number of events to generate. However, the correct variable name should be ""NumEvents"" instead (i.e. `RooFit::NumEvent` does not exist but `RooFit::NumEvents` does).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11418
https://github.com/root-project/root/issues/11418:67,usability,document,documentation,67,"[RF] Wrong CmdArg name in documentation of RooAbsPdf class; In the documentation of the [RooAbsPdf ](https://root.cern.ch/doc/master/classRooAbsPdf.html) class, methods related to dataset generation have a CmdArg variable named ""NumEvent"" which specifies the number of events to generate. However, the correct variable name should be ""NumEvents"" instead (i.e. `RooFit::NumEvent` does not exist but `RooFit::NumEvents` does).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11418
https://github.com/root-project/root/pull/11419:348,deployability,contain,containing,348,"[RF] Consider all curves for `RooPlot::pullHist` in multi-range fits; When plotting a pdf in 2 separate ranges, 2 RooCurve objects are created with the same name . When using pullHist or whatever function of RooPlot accessing the RooCurve by its name, only the last of the two curve can be retrieved. Since RooPlot has no way to access its list of containing objects, apart than given the name, only the RooCurve with the upper range will be used. Code to reproduce the problem:. ```Python. import ROOT as r. ws = r.RooWorkspace(""workspace""). x = ws.factory(""x[-10, 10]""). x.setRange(""lo"", -10, -5). x.setRange(""hi"", 5, 10). pdf = ws.factory(""Gaussian::pdf(x, m1[0], s1[3])""). ds = pdf.generate(r.RooArgSet(x), 1000). fr = x.frame(). ds.plotOn(fr). pdf.plotOn(fr, r.RooFit.Range(""lo,hi"")). pull = fr.pullHist(). c = r.TCanvas(). fr2 = x.frame(). fr2.addPlotable(pull, ""P""). fr2.Draw(). ```. This commit suggests to fix the issue by also considering the ranges of all the other curves that have the same name as the first curve that was found. Closes #9741.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11419
https://github.com/root-project/root/pull/11419:878,energy efficiency,Draw,Draw,878,"[RF] Consider all curves for `RooPlot::pullHist` in multi-range fits; When plotting a pdf in 2 separate ranges, 2 RooCurve objects are created with the same name . When using pullHist or whatever function of RooPlot accessing the RooCurve by its name, only the last of the two curve can be retrieved. Since RooPlot has no way to access its list of containing objects, apart than given the name, only the RooCurve with the upper range will be used. Code to reproduce the problem:. ```Python. import ROOT as r. ws = r.RooWorkspace(""workspace""). x = ws.factory(""x[-10, 10]""). x.setRange(""lo"", -10, -5). x.setRange(""hi"", 5, 10). pdf = ws.factory(""Gaussian::pdf(x, m1[0], s1[3])""). ds = pdf.generate(r.RooArgSet(x), 1000). fr = x.frame(). ds.plotOn(fr). pdf.plotOn(fr, r.RooFit.Range(""lo,hi"")). pull = fr.pullHist(). c = r.TCanvas(). fr2 = x.frame(). fr2.addPlotable(pull, ""P""). fr2.Draw(). ```. This commit suggests to fix the issue by also considering the ranges of all the other curves that have the same name as the first curve that was found. Closes #9741.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11419
https://github.com/root-project/root/pull/11419:216,security,access,accessing,216,"[RF] Consider all curves for `RooPlot::pullHist` in multi-range fits; When plotting a pdf in 2 separate ranges, 2 RooCurve objects are created with the same name . When using pullHist or whatever function of RooPlot accessing the RooCurve by its name, only the last of the two curve can be retrieved. Since RooPlot has no way to access its list of containing objects, apart than given the name, only the RooCurve with the upper range will be used. Code to reproduce the problem:. ```Python. import ROOT as r. ws = r.RooWorkspace(""workspace""). x = ws.factory(""x[-10, 10]""). x.setRange(""lo"", -10, -5). x.setRange(""hi"", 5, 10). pdf = ws.factory(""Gaussian::pdf(x, m1[0], s1[3])""). ds = pdf.generate(r.RooArgSet(x), 1000). fr = x.frame(). ds.plotOn(fr). pdf.plotOn(fr, r.RooFit.Range(""lo,hi"")). pull = fr.pullHist(). c = r.TCanvas(). fr2 = x.frame(). fr2.addPlotable(pull, ""P""). fr2.Draw(). ```. This commit suggests to fix the issue by also considering the ranges of all the other curves that have the same name as the first curve that was found. Closes #9741.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11419
https://github.com/root-project/root/pull/11419:329,security,access,access,329,"[RF] Consider all curves for `RooPlot::pullHist` in multi-range fits; When plotting a pdf in 2 separate ranges, 2 RooCurve objects are created with the same name . When using pullHist or whatever function of RooPlot accessing the RooCurve by its name, only the last of the two curve can be retrieved. Since RooPlot has no way to access its list of containing objects, apart than given the name, only the RooCurve with the upper range will be used. Code to reproduce the problem:. ```Python. import ROOT as r. ws = r.RooWorkspace(""workspace""). x = ws.factory(""x[-10, 10]""). x.setRange(""lo"", -10, -5). x.setRange(""hi"", 5, 10). pdf = ws.factory(""Gaussian::pdf(x, m1[0], s1[3])""). ds = pdf.generate(r.RooArgSet(x), 1000). fr = x.frame(). ds.plotOn(fr). pdf.plotOn(fr, r.RooFit.Range(""lo,hi"")). pull = fr.pullHist(). c = r.TCanvas(). fr2 = x.frame(). fr2.addPlotable(pull, ""P""). fr2.Draw(). ```. This commit suggests to fix the issue by also considering the ranges of all the other curves that have the same name as the first curve that was found. Closes #9741.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11419
https://github.com/root-project/root/pull/11419:1043,usability,Close,Closes,1043,"[RF] Consider all curves for `RooPlot::pullHist` in multi-range fits; When plotting a pdf in 2 separate ranges, 2 RooCurve objects are created with the same name . When using pullHist or whatever function of RooPlot accessing the RooCurve by its name, only the last of the two curve can be retrieved. Since RooPlot has no way to access its list of containing objects, apart than given the name, only the RooCurve with the upper range will be used. Code to reproduce the problem:. ```Python. import ROOT as r. ws = r.RooWorkspace(""workspace""). x = ws.factory(""x[-10, 10]""). x.setRange(""lo"", -10, -5). x.setRange(""hi"", 5, 10). pdf = ws.factory(""Gaussian::pdf(x, m1[0], s1[3])""). ds = pdf.generate(r.RooArgSet(x), 1000). fr = x.frame(). ds.plotOn(fr). pdf.plotOn(fr, r.RooFit.Range(""lo,hi"")). pull = fr.pullHist(). c = r.TCanvas(). fr2 = x.frame(). fr2.addPlotable(pull, ""P""). fr2.Draw(). ```. This commit suggests to fix the issue by also considering the ranges of all the other curves that have the same name as the first curve that was found. Closes #9741.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11419
https://github.com/root-project/root/pull/11420:31,deployability,updat,updates,31,"[RF] Some RooFit documentation updates; * Explain better which functions should be used to get category indices. * Make documentation of RooChi2Var less verbose. * Avoid duplicate deprecation notice in `RooDataHist::set()`: the `RooDataHist::set()` function is marked deprecated in the header file with `R__SUGGEST_ALTERNATIVE`. This already adds a deprecation notice to the doxygen, so it is not necessary to add a `\deprecated` tag manually to the documentation. https://root.cern.ch/doc/v626/classRooDataHist.html#a3053f0f1a21eb39bb2508be61e30d8b9. * Replace `NumEvent()` with the correct `NumEvents()` in the RooAbsPdf documentation. Closes #11418.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11420
https://github.com/root-project/root/pull/11420:31,safety,updat,updates,31,"[RF] Some RooFit documentation updates; * Explain better which functions should be used to get category indices. * Make documentation of RooChi2Var less verbose. * Avoid duplicate deprecation notice in `RooDataHist::set()`: the `RooDataHist::set()` function is marked deprecated in the header file with `R__SUGGEST_ALTERNATIVE`. This already adds a deprecation notice to the doxygen, so it is not necessary to add a `\deprecated` tag manually to the documentation. https://root.cern.ch/doc/v626/classRooDataHist.html#a3053f0f1a21eb39bb2508be61e30d8b9. * Replace `NumEvent()` with the correct `NumEvents()` in the RooAbsPdf documentation. Closes #11418.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11420
https://github.com/root-project/root/pull/11420:164,safety,Avoid,Avoid,164,"[RF] Some RooFit documentation updates; * Explain better which functions should be used to get category indices. * Make documentation of RooChi2Var less verbose. * Avoid duplicate deprecation notice in `RooDataHist::set()`: the `RooDataHist::set()` function is marked deprecated in the header file with `R__SUGGEST_ALTERNATIVE`. This already adds a deprecation notice to the doxygen, so it is not necessary to add a `\deprecated` tag manually to the documentation. https://root.cern.ch/doc/v626/classRooDataHist.html#a3053f0f1a21eb39bb2508be61e30d8b9. * Replace `NumEvent()` with the correct `NumEvents()` in the RooAbsPdf documentation. Closes #11418.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11420
https://github.com/root-project/root/pull/11420:31,security,updat,updates,31,"[RF] Some RooFit documentation updates; * Explain better which functions should be used to get category indices. * Make documentation of RooChi2Var less verbose. * Avoid duplicate deprecation notice in `RooDataHist::set()`: the `RooDataHist::set()` function is marked deprecated in the header file with `R__SUGGEST_ALTERNATIVE`. This already adds a deprecation notice to the doxygen, so it is not necessary to add a `\deprecated` tag manually to the documentation. https://root.cern.ch/doc/v626/classRooDataHist.html#a3053f0f1a21eb39bb2508be61e30d8b9. * Replace `NumEvent()` with the correct `NumEvents()` in the RooAbsPdf documentation. Closes #11418.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11420
https://github.com/root-project/root/pull/11420:17,usability,document,documentation,17,"[RF] Some RooFit documentation updates; * Explain better which functions should be used to get category indices. * Make documentation of RooChi2Var less verbose. * Avoid duplicate deprecation notice in `RooDataHist::set()`: the `RooDataHist::set()` function is marked deprecated in the header file with `R__SUGGEST_ALTERNATIVE`. This already adds a deprecation notice to the doxygen, so it is not necessary to add a `\deprecated` tag manually to the documentation. https://root.cern.ch/doc/v626/classRooDataHist.html#a3053f0f1a21eb39bb2508be61e30d8b9. * Replace `NumEvent()` with the correct `NumEvents()` in the RooAbsPdf documentation. Closes #11418.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11420
https://github.com/root-project/root/pull/11420:120,usability,document,documentation,120,"[RF] Some RooFit documentation updates; * Explain better which functions should be used to get category indices. * Make documentation of RooChi2Var less verbose. * Avoid duplicate deprecation notice in `RooDataHist::set()`: the `RooDataHist::set()` function is marked deprecated in the header file with `R__SUGGEST_ALTERNATIVE`. This already adds a deprecation notice to the doxygen, so it is not necessary to add a `\deprecated` tag manually to the documentation. https://root.cern.ch/doc/v626/classRooDataHist.html#a3053f0f1a21eb39bb2508be61e30d8b9. * Replace `NumEvent()` with the correct `NumEvents()` in the RooAbsPdf documentation. Closes #11418.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11420
https://github.com/root-project/root/pull/11420:450,usability,document,documentation,450,"[RF] Some RooFit documentation updates; * Explain better which functions should be used to get category indices. * Make documentation of RooChi2Var less verbose. * Avoid duplicate deprecation notice in `RooDataHist::set()`: the `RooDataHist::set()` function is marked deprecated in the header file with `R__SUGGEST_ALTERNATIVE`. This already adds a deprecation notice to the doxygen, so it is not necessary to add a `\deprecated` tag manually to the documentation. https://root.cern.ch/doc/v626/classRooDataHist.html#a3053f0f1a21eb39bb2508be61e30d8b9. * Replace `NumEvent()` with the correct `NumEvents()` in the RooAbsPdf documentation. Closes #11418.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11420
https://github.com/root-project/root/pull/11420:623,usability,document,documentation,623,"[RF] Some RooFit documentation updates; * Explain better which functions should be used to get category indices. * Make documentation of RooChi2Var less verbose. * Avoid duplicate deprecation notice in `RooDataHist::set()`: the `RooDataHist::set()` function is marked deprecated in the header file with `R__SUGGEST_ALTERNATIVE`. This already adds a deprecation notice to the doxygen, so it is not necessary to add a `\deprecated` tag manually to the documentation. https://root.cern.ch/doc/v626/classRooDataHist.html#a3053f0f1a21eb39bb2508be61e30d8b9. * Replace `NumEvent()` with the correct `NumEvents()` in the RooAbsPdf documentation. Closes #11418.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11420
https://github.com/root-project/root/pull/11420:638,usability,Close,Closes,638,"[RF] Some RooFit documentation updates; * Explain better which functions should be used to get category indices. * Make documentation of RooChi2Var less verbose. * Avoid duplicate deprecation notice in `RooDataHist::set()`: the `RooDataHist::set()` function is marked deprecated in the header file with `R__SUGGEST_ALTERNATIVE`. This already adds a deprecation notice to the doxygen, so it is not necessary to add a `\deprecated` tag manually to the documentation. https://root.cern.ch/doc/v626/classRooDataHist.html#a3053f0f1a21eb39bb2508be61e30d8b9. * Replace `NumEvent()` with the correct `NumEvents()` in the RooAbsPdf documentation. Closes #11418.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11420
https://github.com/root-project/root/issues/11421:793,availability,Sli,Slice,793,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3007,availability,error,errors,3007,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3031,availability,Sli,Slice,3031,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3065,availability,error,errors,3065,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3367,availability,Operat,Operating,3367,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3442,availability,down,download,3442,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:695,deployability,depend,depends,695,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1792,deployability,build,build,1792,"ice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3355,deployability,version,version,3355,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3424,deployability,instal,install,3424,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1241,energy efficiency,model,model,1241,"=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdP",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1295,energy efficiency,model,model,1295,". If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = R",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1379,energy efficiency,model,model,1379,"""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, N",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3299,energy efficiency,reduc,reduce,3299,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:695,integrability,depend,depends,695,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:907,integrability,Compon,Components,907,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:2968,integrability,Compon,Components,2968,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3355,integrability,version,version,3355,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:907,interoperability,Compon,Components,907,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:2968,interoperability,Compon,Components,2968,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:695,modifiability,depend,depends,695,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:813,modifiability,Paramet,Parameters,813,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:907,modifiability,Compon,Components,907,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1282,modifiability,paramet,parameter,1282," your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1332,modifiability,paramet,parameter,1332," to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Condition",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1406,modifiability,paramet,parameter,1406,"s master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often se",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:2968,modifiability,Compon,Components,2968,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3254,modifiability,Paramet,Parameters,3254,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3355,modifiability,version,version,3355,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3007,performance,error,errors,3007,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3065,performance,error,errors,3065,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:661,reliability,doe,does,661,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:793,reliability,Sli,Slice,793,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3031,reliability,Sli,Slice,3031,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:695,safety,depend,depends,695,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:848,safety,test,tested,848,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1746,safety,input,input,1746,"rind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data,",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3007,safety,error,errors,3007,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3065,safety,error,errors,3065,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1241,security,model,model,1241,"=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdP",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1295,security,model,model,1295,". If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = R",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1379,security,model,model,1379,"""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, N",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:695,testability,depend,depends,695,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:848,testability,test,tested,848,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3551,testability,context,context,3551,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3580,testability,context,context,3580,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:457,usability,clear,clear,457,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:505,usability,behavi,behavior,505,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:924,usability,Visual,VisualizeError,924,"[RF] RooCmdArg pythonization drops temporary RooArgSets too early; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1450,usability,behavi,behavior,1450," A clear and concise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1468,usability,clear,clear,1468,"ise description of what the wrong behavior is. -->. When using the pythonization of _some_ `RooCmdArgs` together with the `RooArgSet` pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {m",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1601,usability,behavi,behavior,1601,"pythonization, the created set is dropped too early. It does not always cause a segfault (depends on the `RooCmdArg`) but it is visible in `valgrind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArg",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:1746,usability,input,input,1746,"rind`. I've seen this happen with `Minos`, `Slice`, `Project`, `Parameters` and SelectVar, while I tested `Conditional`, `Constrain`, `ExternalConstraints`, `Components` and `VisualizeError` and they show no issue (not even in `valgrind`). . I _think_ the difference is wether the `RooArgSet` is stored as a `RooArgSet` in the `RooCmdArg` (works fine) or as a `TObject*` (dropped early). I've also noticed that this happens only when you combine the two pythonizations, e.g. both. ```Python. model.fitTo(data, Minos = ROOT.RooArgSet(parameter)). model.fitTo(data, ROOT.RooFit.Minos({parameter})). ```. work fine, only. ```Python. model.fitTo(data, Minos = {parameter}). ```. is affected. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. No use after free. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data,",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3007,usability,error,errors,3007,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3065,usability,error,errors,3065,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/issues/11421:3175,usability,Visual,VisualizeError,3175,"our code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). y = ROOT.RooRealVar('y', '', 0, 1). mu = ROOT.RooRealVar(""mu"", """", 0.5, 0, 1). gx = ROOT.RooGaussian(""gx"", """", x, mu, ROOT.RooFit.RooConst(0.2)). gy = ROOT.RooGaussian(""gy"", """", y, mu, ROOT.RooFit.RooConst(0.2)). g = ROOT.RooProdPdf(""g"", '', [gx, gy]). # works. condg1 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = (gy, {y})). condg2 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, y)). condg3 = ROOT.RooProdPdf(""g"", '', {gx}, Conditional = ({gy}, {y})). data = g.generate({x,y}, NumEvents = 10000). # often segfaults, valgrind reports problems. g.fitTo(data, Minos = {mu}, PrintLevel = -1). # both of these work. g.fitTo(data, ROOT.RooFit.Minos({mu}), PrintLevel = -1). g.fitTo(data, Minos = ROOT.RooArgSet(mu), PrintLevel = -1). # works. constr = ROOT.RooGaussian('c', '', mu, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.01)). g.fitTo(data, ExternalConstraints = {constr}, PrintLevel = -1). # works. gWithConstr = ROOT.RooProdPdf('gWC', '', [g, constr]). gWithConstr.fitTo(data, Constrain = {mu}, PrintLevel = -1). frame = x.frame(). # works. g.plotOn(frame, Components = {g}). # segfault/valgrind errors. g.plotOn(frame, Slice = {y}). # segfault/valgrind errors. g.plotOn(frame, Project = {y}). fitres = g.fitTo(data, PrintLevel = -1, Save = True). g.plotOn(frame, VisualizeError = (fitres, {x})). # valgrind reports problems. g.paramOn(frame, Parameters = {mu}). # segfault. datax = data.reduce(SelectVars = {x}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT 6.26.07 from LCG dev4. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11421
https://github.com/root-project/root/pull/11422:71,availability,avail,available,71,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11422:102,availability,failur,failure,102,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11422:102,deployability,fail,failure,102,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11422:110,deployability,observ,observed,110,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11422:102,performance,failur,failure,102,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11422:71,reliability,availab,available,71,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11422:102,reliability,fail,failure,102,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11422:71,safety,avail,available,71,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11422:71,security,availab,available,71,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11422:110,testability,observ,observed,110,[pyroot][tmva] Fix importing RTensor pythonization when RTensor is not available; This should fix the failure observed when RDF is not built that one needs to not include the RTensor pythonizations.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11422
https://github.com/root-project/root/pull/11423:13,deployability,Updat,Update,13,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:54,deployability,modul,modules,54,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:46,energy efficiency,load,loading,46,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:157,energy efficiency,load,loaded,157,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:54,modifiability,modul,modules,54,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:46,performance,load,loading,46,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:157,performance,load,loaded,157,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:13,safety,Updat,Update,13,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:54,safety,modul,modules,54,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:13,security,Updat,Update,13,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11423:220,security,Sign,Signed-off-by,220,"[cxxmodules] Update redeclaration chain after loading modules; Before we do name lookups, we must ensure any later redeclaration of the DeclContext has been loaded, since they may add names to the result of this lookup. Signed-off-by: Jun Zhang <jun@junz.org>.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11423
https://github.com/root-project/root/pull/11424:211,deployability,fail,fail,211,"[ACLiC] For macOS, make sure the syslib exists:; macOS 13 again moves many libraries into the binary blob: these files do not exist anymore on disk, but the linker ""knows what to do"". Linking against them would fail (""file not found""), so rely on the non-system libraries to pull them in. An exception are /usr/lib/system/libsystem_... which *do* exist on disk but must not be linked against.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11424
https://github.com/root-project/root/pull/11424:143,performance,disk,disk,143,"[ACLiC] For macOS, make sure the syslib exists:; macOS 13 again moves many libraries into the binary blob: these files do not exist anymore on disk, but the linker ""knows what to do"". Linking against them would fail (""file not found""), so rely on the non-system libraries to pull them in. An exception are /usr/lib/system/libsystem_... which *do* exist on disk but must not be linked against.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11424
https://github.com/root-project/root/pull/11424:356,performance,disk,disk,356,"[ACLiC] For macOS, make sure the syslib exists:; macOS 13 again moves many libraries into the binary blob: these files do not exist anymore on disk, but the linker ""knows what to do"". Linking against them would fail (""file not found""), so rely on the non-system libraries to pull them in. An exception are /usr/lib/system/libsystem_... which *do* exist on disk but must not be linked against.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11424
https://github.com/root-project/root/pull/11424:211,reliability,fail,fail,211,"[ACLiC] For macOS, make sure the syslib exists:; macOS 13 again moves many libraries into the binary blob: these files do not exist anymore on disk, but the linker ""knows what to do"". Linking against them would fail (""file not found""), so rely on the non-system libraries to pull them in. An exception are /usr/lib/system/libsystem_... which *do* exist on disk but must not be linked against.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11424
https://github.com/root-project/root/pull/11424:292,safety,except,exception,292,"[ACLiC] For macOS, make sure the syslib exists:; macOS 13 again moves many libraries into the binary blob: these files do not exist anymore on disk, but the linker ""knows what to do"". Linking against them would fail (""file not found""), so rely on the non-system libraries to pull them in. An exception are /usr/lib/system/libsystem_... which *do* exist on disk but must not be linked against.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11424
https://github.com/root-project/root/pull/11425:659,availability,slo,slots,659,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:771,availability,slo,slots,771,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:866,availability,slo,slots,866,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1126,availability,slo,slot,1126,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1490,deployability,version,version,1490,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1490,integrability,version,version,1490,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1266,interoperability,compatib,compatible,1266,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1459,interoperability,compatib,compatibility,1459,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1490,modifiability,version,version,1490,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:659,reliability,slo,slots,659,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:771,reliability,slo,slots,771,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:866,reliability,slo,slots,866,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1126,reliability,slo,slot,1126,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:286,safety,detect,detecting,286,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1430,safety,prevent,prevent,1430,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:286,security,detect,detecting,286,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1020,security,hack,hacks,1020,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1430,security,preven,prevent,1430,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:152,usability,command,command,152,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:734,usability,command,command,734,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:946,usability,command,command,946,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1180,usability,command,command,1180,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1229,usability,command,command,1229,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1615,usability,command,command,1615,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11425:1665,usability,Close,Closes,1665,"[RF] Always pass RooArgSets to RooCmdArgs by value; As reported in issue https://github.com/root-project/root/issues/11421, the fact that in the RooFit command. arguments, the `RooArgSet`s are often stored by pointer is still a. problem. I attempted before to circumvent the problem by detecting. potential lifetime issues by having a dedicated `RooArgSet&&` overloads. that resulted in RooCmdArgs that owned copied of the RooArgSets. However, this still didn't work for the case where the Python collection. pythonizations are used in PyROOT, because there the `RooArgSet &&`. overloads are not hit. I realized now that the `RooCmdArg` class already has the slots to store. RooArgSets by value, which was alredy used by a few RooFit command. arguments. When these `set` slots are used, there are no ownership. issues. This commit suggests to always use these `set` slots for RooArgSets. This entailed changing the functions that make use of the command. arguments, migrating from `defineObject` to `defineSet`. All the hacks to get owned copies of the RooArgSets and `RooArgSet&&`. overloads can now be removed. Now that the slot indices for the sets was changed in many RooFit. command arguments, there is only the caveat that command arguments are. not backwards compatible anymore. However, this should not be any. problem because `RooCmdArgs` are not supposed to be written to files. anyway. To explicitely disallow this and prevent any silet backwards. compatibility issue, the class version of the RooCmdArg was set to zero. to disable IO. A first commit in this PR fixes also an other issue where the wrong command argument name was used in the RooMCStudy. Closes https://github.com/root-project/root/issues/11421.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11425
https://github.com/root-project/root/pull/11426:274,deployability,version,versions,274,[hist] Backport in 6.26 some fixes in hist; This Pull request back ports in 6.26 some recent hist fixes:. - correct handling of fitting option WW (PR #11316 ). - fix label merge for mixed axis (PR #11045). - fix stats sum in THn and THnSparse (PR #11407). - fix reading old versions of THn and THnSparse (PR #11409).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11426
https://github.com/root-project/root/pull/11426:274,integrability,version,versions,274,[hist] Backport in 6.26 some fixes in hist; This Pull request back ports in 6.26 some recent hist fixes:. - correct handling of fitting option WW (PR #11316 ). - fix label merge for mixed axis (PR #11045). - fix stats sum in THn and THnSparse (PR #11407). - fix reading old versions of THn and THnSparse (PR #11409).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11426
https://github.com/root-project/root/pull/11426:274,modifiability,version,versions,274,[hist] Backport in 6.26 some fixes in hist; This Pull request back ports in 6.26 some recent hist fixes:. - correct handling of fitting option WW (PR #11316 ). - fix label merge for mixed axis (PR #11045). - fix stats sum in THn and THnSparse (PR #11407). - fix reading old versions of THn and THnSparse (PR #11409).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11426
https://github.com/root-project/root/pull/11427:48,deployability,patch,patches,48,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 21; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11416. excluding the first commit with the code modernization. 2. https://github.com/root-project/root/pull/11417. 3. https://github.com/root-project/root/pull/11419. 4. https://github.com/root-project/root/pull/10842",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11427
https://github.com/root-project/root/pull/11427:175,deployability,patch,patches,175,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 21; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11416. excluding the first commit with the code modernization. 2. https://github.com/root-project/root/pull/11417. 3. https://github.com/root-project/root/pull/11419. 4. https://github.com/root-project/root/pull/10842",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11427
https://github.com/root-project/root/pull/11427:48,safety,patch,patches,48,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 21; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11416. excluding the first commit with the code modernization. 2. https://github.com/root-project/root/pull/11417. 3. https://github.com/root-project/root/pull/11419. 4. https://github.com/root-project/root/pull/10842",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11427
https://github.com/root-project/root/pull/11427:175,safety,patch,patches,175,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 21; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11416. excluding the first commit with the code modernization. 2. https://github.com/root-project/root/pull/11417. 3. https://github.com/root-project/root/pull/11419. 4. https://github.com/root-project/root/pull/10842",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11427
https://github.com/root-project/root/pull/11427:48,security,patch,patches,48,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 21; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11416. excluding the first commit with the code modernization. 2. https://github.com/root-project/root/pull/11417. 3. https://github.com/root-project/root/pull/11419. 4. https://github.com/root-project/root/pull/10842",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11427
https://github.com/root-project/root/pull/11427:175,security,patch,patches,175,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 21; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11416. excluding the first commit with the code modernization. 2. https://github.com/root-project/root/pull/11417. 3. https://github.com/root-project/root/pull/11419. 4. https://github.com/root-project/root/pull/10842",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11427
https://github.com/root-project/root/pull/11428:44,availability,error,errors,44,[RF] New mechanism for logging and throwing errors in RooFit; Draft PR for now.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11428
https://github.com/root-project/root/pull/11428:23,deployability,log,logging,23,[RF] New mechanism for logging and throwing errors in RooFit; Draft PR for now.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11428
https://github.com/root-project/root/pull/11428:44,performance,error,errors,44,[RF] New mechanism for logging and throwing errors in RooFit; Draft PR for now.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11428
https://github.com/root-project/root/pull/11428:23,safety,log,logging,23,[RF] New mechanism for logging and throwing errors in RooFit; Draft PR for now.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11428
https://github.com/root-project/root/pull/11428:44,safety,error,errors,44,[RF] New mechanism for logging and throwing errors in RooFit; Draft PR for now.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11428
https://github.com/root-project/root/pull/11428:23,security,log,logging,23,[RF] New mechanism for logging and throwing errors in RooFit; Draft PR for now.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11428
https://github.com/root-project/root/pull/11428:23,testability,log,logging,23,[RF] New mechanism for logging and throwing errors in RooFit; Draft PR for now.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11428
https://github.com/root-project/root/pull/11428:44,usability,error,errors,44,[RF] New mechanism for logging and throwing errors in RooFit; Draft PR for now.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11428
https://github.com/root-project/root/issues/11429:610,availability,Operat,Operating,610,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:282,deployability,build,builds,282,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:389,deployability,build,builds-with-clang-and-lld,389,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:589,deployability,version,version,589,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:589,integrability,version,version,589,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:589,modifiability,version,version,589,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:138,performance,time,time,138,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:188,performance,content,contents,188,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:497,reliability,doe,does,497,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:218,safety,compl,complete,218,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:784,safety,review,reviews,784,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:218,security,compl,complete,218,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:650,testability,context,context,650,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:784,testability,review,reviews,784,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:434,usability,behavi,behavior,434,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11429:490,usability,tool,tools,490,".pcm files not deterministic/reproducible; - [x] Checked for duplicates. ### Describe the bug. The binary data of .pcm files changes each time it is generated, although sources and actual contents are unchanged. For a complete rationale why this is wanted, see https://reproducible-builds.org/. Or if you favor a view from the LLVM developers:. https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html. ### Expected behavior. As long as sources (including compiler or any tools) does not change, the binary representation of .pcm files stays the same. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux. ### Additional context. This is likely an issue of upstream LLVM, similar to https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=877359, fixed https://reviews.llvm.org/rG2751b69dd3945ef9bd1298c16dca5b59076f8f17. As the latter is already included in LLVM 9.0, the issue is likely not fixed for pcm files. This may be fixed with LLVM 13.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11429
https://github.com/root-project/root/issues/11430:5,availability,error,error,5,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7057,availability,fault,fault,7057,"an.hxx ROOT/TypeTraits.hxx TUnixSystem.h root_std_complex.h GuiTypes.h TApplicationImp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Exp",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7141,availability,Error,Error,7141,"mp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7226,availability,Error,Error,7226,"nuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that tr",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7266,availability,Error,Error,7266,"InspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideal",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8476,availability,Operat,Operating,8476,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:421,deployability,build,build,421,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:599,deployability,version,version,599,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:947,deployability,Modul,Modules,947,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1279,deployability,Stack,Stack,1279,"re very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1335,deployability,Modul,Modules,1335,"ce ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<ch",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1409,deployability,modul,modules,1409,". I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1453,deployability,modul,modules,1453,"VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x00000000016",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1517,deployability,modul,modules,1517,"e=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x000000000168620",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1717,deployability,build,build,1717,"-- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/sr",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1734,deployability,instal,install,1734,"usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:2751,deployability,Stack,Stack,2751,"goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/g",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7107,deployability,build,build,7107,"complex.h GuiTypes.h TApplicationImp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise descript",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7302,deployability,build,build,7302,"roup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7359,deployability,version,version,7359,"ClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7624,deployability,instal,installed,7624,"Enums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7651,deployability,version,version,7651,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7674,deployability,version,version,7674,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7817,deployability,Instal,InstalledDir,7817,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7858,deployability,version,version,7858,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7881,deployability,version,version,7881,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8024,deployability,Instal,InstalledDir,8024,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8389,deployability,build,build,8389,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8456,deployability,version,version,8456,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1846,energy efficiency,Core,Core,1846,"ocal/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:2354,energy efficiency,alloc,allocator,2354,"ake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compi",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:2576,energy efficiency,core,core,2576,"akeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclud",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:2696,energy efficiency,core,core,2696,"r command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:2805,energy efficiency,core,core,2805," [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:3610,energy efficiency,core,core,3610,stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TD,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:3654,energy efficiency,core,core,3654,OT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFile,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:3704,energy efficiency,core,core,3704,ling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h ,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:3748,energy efficiency,core,core,3748, Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:3791,energy efficiency,core,core,3791,ai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:3835,energy efficiency,core,core,3835,ing_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPlugin,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:3879,energy efficiency,core,core,3879,/home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h T,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:3923,energy efficiency,core,core,3923,th /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h TProcessUUID.h TQClass.h TQCommand.h TQConnec,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:3966,energy efficiency,core,core,3966, /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h TProcessUUID.h TQClass.h TQCommand.h TQConnection.h TQObject.h TRedirectOutputGuard.h TR,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:4012,energy efficiency,core,core,4012,e/cai/root/bld/externals -excludePath /home/cai/root/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h TProcessUUID.h TQClass.h TQCommand.h TQConnection.h TQObject.h TRedirectOutputGuard.h TRefCnt.h TRef.h TRegexp.h TRemoteObject.h TROOT,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:4061,energy efficiency,core,core,4061,oot/bld/builtins -writeEmptyRootPCM -m _Builtin_intrinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h TProcessUUID.h TQClass.h TQCommand.h TQConnection.h TQObject.h TRedirectOutputGuard.h TRefCnt.h TRef.h TRegexp.h TRemoteObject.h TROOT.h TRootIOCtor.h TStopwatch.h TStorage.h TString.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:4111,energy efficiency,core,core,4111,trinsics -mByproduct _Builtin_intrinsics -mByproduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h TProcessUUID.h TQClass.h TQCommand.h TQConnection.h TQObject.h TRedirectOutputGuard.h TRefCnt.h TRef.h TRegexp.h TRemoteObject.h TROOT.h TRootIOCtor.h TStopwatch.h TStorage.h TString.h TStringLong.h TStyle.h TSysEvtHandler.h TSystemD,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:4158,energy efficiency,core,core,4158,oduct ROOT_Foundation_Stage1_NoRTTI -mByproduct ROOT_Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h TProcessUUID.h TQClass.h TQCommand.h TQConnection.h TQObject.h TRedirectOutputGuard.h TRefCnt.h TRef.h TRegexp.h TRemoteObject.h TROOT.h TRootIOCtor.h TStopwatch.h TStorage.h TString.h TStringLong.h TStyle.h TSysEvtHandler.h TSystemDirectory.h TSystemFile.h TSystem.h TTask.h TThr,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:4211,energy efficiency,core,core,4211,Foundation_C -mByproduct ROOT_Rtypes -D__STDC_NO_COMPLEX__ -D__COMPLEX_H__ -D_COMPLEX_H -D__CLANG_STDATOMIC_H -compilerI/usr/include/c++/v1 -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h TProcessUUID.h TQClass.h TQCommand.h TQConnection.h TQObject.h TRedirectOutputGuard.h TRefCnt.h TRef.h TRegexp.h TRemoteObject.h TROOT.h TRootIOCtor.h TStopwatch.h TStorage.h TString.h TStringLong.h TStyle.h TSysEvtHandler.h TSystemDirectory.h TSystemFile.h TSystem.h TTask.h TThreadSlots.h TTime.h TTimer.h TTimeStamp.h TUri.h TUrl.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7018,energy efficiency,core,core,7018,"ingView.hxx ROOT/StringUtils.hxx ROOT/span.hxx ROOT/TypeTraits.hxx TUnixSystem.h root_std_complex.h GuiTypes.h TApplicationImp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: pos",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7057,energy efficiency,fault,fault,7057,"an.hxx ROOT/TypeTraits.hxx TUnixSystem.h root_std_complex.h GuiTypes.h TApplicationImp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Exp",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7079,energy efficiency,core,core,7079,"s.hxx TUnixSystem.h root_std_complex.h GuiTypes.h TApplicationImp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7123,energy efficiency,core,core,7123,"pes.h TApplicationImp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7193,energy efficiency,core,core,7193,"nuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7803,energy efficiency,model,model,7803,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8010,energy efficiency,model,model,8010,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:599,integrability,version,version,599,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:697,integrability,wrap,wrapper,697,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:996,integrability,messag,message,996,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1799,integrability,messag,message,1799,"braries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:4361,integrability,Messag,MessageTypes,4361,/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h TProcessUUID.h TQClass.h TQCommand.h TQConnection.h TQObject.h TRedirectOutputGuard.h TRefCnt.h TRef.h TRegexp.h TRemoteObject.h TROOT.h TRootIOCtor.h TStopwatch.h TStorage.h TString.h TStringLong.h TStyle.h TSysEvtHandler.h TSystemDirectory.h TSystemFile.h TSystem.h TTask.h TThreadSlots.h TTime.h TTimer.h TTimeStamp.h TUri.h TUrl.h TUUID.h TVersionCheck.h TVirtualAuth.h TVirtualFFT.h TVirtualGL.h TVirtualMonitoring.h TVirtualMutex.h TVirtualPadEditor.h TVirtualPad.h TVirtualPadPain,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7359,integrability,version,version,7359,"ClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7651,integrability,version,version,7651,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7674,integrability,version,version,7674,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7858,integrability,version,version,7858,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7881,integrability,version,version,7881,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8456,integrability,version,version,8456,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:697,interoperability,wrapper,wrapper,697,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:935,interoperability,share,share,935,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:996,interoperability,messag,message,996,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1323,interoperability,share,share,1323,"t, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::c",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1799,interoperability,messag,message,1799,"braries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:4361,interoperability,Messag,MessageTypes,4361,/lib/clang/13.0.0/include -compilerI/usr/include -compilerI/usr/lib/clang/13.0.0/include -compilerI/usr/include -I/home/cai/root/bld/include -I/usr/local/include -I/usr/local/include -I/home/cai/root/bld/ginclude -I/home/cai/root/root-6.26.06/core/base/inc -I/home/cai/root/root-6.26.06/core/foundation/inc -I/home/cai/root/root-6.26.06/core/cont/inc -I/home/cai/root/root-6.26.06/core/gui/inc -I/home/cai/root/root-6.26.06/core/meta/inc -I/home/cai/root/root-6.26.06/core/clib/inc -I/home/cai/root/root-6.26.06/core/rint/inc -I/home/cai/root/root-6.26.06/core/zip/inc -I/home/cai/root/root-6.26.06/core/thread/inc -I/home/cai/root/root-6.26.06/core/textinput/inc -I/home/cai/root/root-6.26.06/core/clingutils/inc -I/home/cai/root/root-6.26.06/core/base/v7/inc -I/home/cai/root/root-6.26.06/core/foundation/v7/inc -I/home/cai/root/root-6.26.06/core/unix/inc -I/usr/include ROOT/TErrorDefaultHandler.hxx ROOT/TSequentialExecutor.hxx ROOT/StringConv.hxx Buttons.h Bytes.h Byteswap.h KeySymbols.h MessageTypes.h Riostream.h Rtypes.h TApplication.h TAtt3D.h TAttAxis.h TAttBBox2D.h TAttBBox.h TAttFill.h TAttLine.h TAttMarker.h TAttPad.h TAttText.h TBase64.h TBenchmark.h TBuffer3D.h TBuffer3DTypes.h TBuffer.h TColor.h TColorGradient.h TDatime.h TDirectory.h TEnv.h TException.h TExec.h TFileCollection.h TFileInfo.h TFolder.h TInetAddress.h TMacro.h TMathBase.h TMD5.h TMemberInspector.h TMessageHandler.h TNamed.h TNotifyLink.h TObject.h TObjString.h TParameter.h TPluginManager.h TPoint.h TPRegexp.h TProcessID.h TProcessUUID.h TQClass.h TQCommand.h TQConnection.h TQObject.h TRedirectOutputGuard.h TRefCnt.h TRef.h TRegexp.h TRemoteObject.h TROOT.h TRootIOCtor.h TStopwatch.h TStorage.h TString.h TStringLong.h TStyle.h TSysEvtHandler.h TSystemDirectory.h TSystemFile.h TSystem.h TTask.h TThreadSlots.h TTime.h TTimer.h TTimeStamp.h TUri.h TUrl.h TUUID.h TVersionCheck.h TVirtualAuth.h TVirtualFFT.h TVirtualGL.h TVirtualMonitoring.h TVirtualMutex.h TVirtualPadEditor.h TVirtualPad.h TVirtualPadPain,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:599,modifiability,version,version,599,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:947,modifiability,Modul,Modules,947,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1011,modifiability,pac,package,1011,"reeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1122,modifiability,pac,package,1122,"ot/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1217,modifiability,variab,variables,1217,". for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x000000080",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1335,modifiability,Modul,Modules,1335,"ce ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<ch",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1409,modifiability,modul,modules,1409,". I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1453,modifiability,modul,modules,1453,"VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x00000000016",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1517,modifiability,modul,modules,1517,"e=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x000000000168620",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7359,modifiability,version,version,7359,"ClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7651,modifiability,version,version,7651,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7674,modifiability,version,version,7674,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7858,modifiability,version,version,7858,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7881,modifiability,version,version,7881,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8456,modifiability,version,version,8456,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:5,performance,error,error,5,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7057,performance,fault,fault,7057,"an.hxx ROOT/TypeTraits.hxx TUnixSystem.h root_std_complex.h GuiTypes.h TApplicationImp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Exp",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7141,performance,Error,Error,7141,"mp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7226,performance,Error,Error,7226,"nuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that tr",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7266,performance,Error,Error,7266,"InspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideal",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7291,performance,time,times,7291,".h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run o",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1083,reliability,doe,does,1083,"itHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7057,reliability,fault,fault,7057,"an.hxx ROOT/TypeTraits.hxx TUnixSystem.h root_std_complex.h GuiTypes.h TApplicationImp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Exp",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:5,safety,error,error,5,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:947,safety,Modul,Modules,947,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1335,safety,Modul,Modules,1335,"ce ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<ch",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1409,safety,modul,modules,1409,". I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1453,safety,modul,modules,1453,"VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x00000000016",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1517,safety,modul,modules,1517,"e=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x000000000168620",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7057,safety,fault,fault,7057,"an.hxx ROOT/TypeTraits.hxx TUnixSystem.h root_std_complex.h GuiTypes.h TApplicationImp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Exp",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7141,safety,Error,Error,7141,"mp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7226,safety,Error,Error,7226,"nuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that tr",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7266,safety,Error,Error,7266,"InspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideal",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8343,safety,input,input,8343,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1925,security,Sign,Signals,1925,"local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1995,security,Sign,Signals,1995,"sage):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -e",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:2034,security,Sign,SignalHandler,2034,"ackage_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -e",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:2053,security,Sign,Signals,2053,"andard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program arguments: /home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1 -v2 -f G__Core.cxx -cxxmodule -s /home/cai/root/bld/lib/libCore.so -excludePath /home/cai/root/root-6.26.06 -excludePath /home/cai/root/bld/ginclude -excludePath /home/cai/root/bld/externals -excludePath /home",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7803,security,model,model,7803,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8010,security,model,model,8010,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8574,testability,context,context,8574,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8603,testability,context,context,8603,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:5,usability,error,error,5,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:467,usability,command,command,467,"make error on FreeBSD13.1; - [ ] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. I was build ROOT from source on a FreeBSD VM. after command: cmake -Dall=ON -Dcuda=OFF -Dalien=OFF -Doracle=OFF ../root-6.26.06,. I got a warning:. Looking for XROOTD. -- Found Xrootd version num: 4.10.0 (setting -DROOTXRDVERS=400100000). -- libXrdMain not found: xproofd will be a wrapper around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1700,usability,command,command,1700," around xrootd. -- include_dirs: /usr/local/include/xrootd;/usr/local/include/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/roo",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:1776,usability,stop,stopped,1776,"e/xrootd/private. -- libraries: /usr/local/lib/libXrdUtils.so;/usr/local/lib/libXrdClient.so;/usr/local/lib/libXrdCl.so. CMake Warning (dev) at /usr/local/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:438 (message):. The package name passed to `find_package_handle_standard_args` (PkgConfig). does not match the name of the calling package (Arrow). This can lead to. problems in calling code that expects `find_package` result variables. (e.g., `_FOUND`) to follow a certain pattern. Call Stack (most recent call first):. /usr/local/share/cmake/Modules/FindPkgConfig.cmake:99 (find_package_handle_standard_args). cmake/modules/FindArrow.cmake:39 (include). cmake/modules/SearchInstalledSoftware.cmake:17 (_find_package). cmake/modules/SearchInstalledSoftware.cmake:1040 (find_package). CMakeLists.txt:245 (include). This warning is for project developers. Use -Wno-dev to suppress it. I just ignored it. after command: cmake --build . --target install, everything goes well and then it stopped with following message. [ 52%] Generating G__Core.cxx, ../lib/Core.pcm. #0 0x00000000044aaf65 llvm::sys::PrintStackTrace(llvm::raw_ostream&) Signals.cpp:0:0. #1 0x00000000044a91b6 llvm::sys::RunSignalHandlers() Signals.cpp:0:0. #2 0x00000000044ab726 SignalHandler(int) Signals.cpp:0:0. #3 0x0000000804b32580 (/lib/libthr.so.3+0x1a580). #4 0x0000000804b31b3f (/lib/libthr.so.3+0x19b3f). #5 0x00007ffffffff2d3 ([vdso]+0x2d3). #6 0x0000000804e8ee84 strlen (/lib/libc.so.7+0x157e84). #7 0x000000000161c729 std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string<std::nullptr_t>(char const*) rootcling_stage1.cxx:0:0. #8 0x000000000161c673 GetEtcDir() rootcling_stage1.cxx:0:0. #9 0x0000000001686202 RootClingMain(int, char**, bool) (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1686202). #10 0x0000000001697075 ROOT_rootcling_Driver (/home/cai/root/bld/core/rootcling_stage1/src/rootcling_stage1+0x1697075). Stack dump:. 0.	Program argum",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7141,usability,Error,Error,7141,"mp.h TBrowser.h TBrowserImp.h TCanvasImp.h TClassMenuItem.h TContextMenu.h TContextMenuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7226,usability,Error,Error,7226,"nuImp.h TControlBarImp.h TGuiFactory.h TInspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that tr",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7266,usability,Error,Error,7266,"InspectorImp.h TObjectSpy.h TToggleGroup.h TToggle.h TBaseClass.h TClassGenerator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideal",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:7339,usability,help,help,7339,"Generator.h TClass.h TClassRef.h TClassStreamer.h TDataMember.h TDataType.h TDictAttributeMap.h TDictionary.h TEnumConstant.h TEnum.h TFileMergeInfo.h TFunction.h TFunctionTemplate.h TGenericClassInfo.h TGlobal.h TInterpreter.h TInterpreterValue.h TIsAProxy.h TListOfDataMembers.h TListOfEnums.h TListOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the require",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8066,usability,behavi,behavior,8066,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8084,usability,clear,clear,8084,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8198,usability,behavi,behavior,8198,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11430:8343,usability,input,input,8343,"istOfEnumsWithLock.h TListOfFunctions.h TListOfFunctionTemplates.h TMemberStreamer.h TMethodArg.h TMethodCall.h TMethod.h TProtoClass.h TRealData.h TSchemaHelper.h TSchemaRule.h TSchemaRuleSet.h TStatusBitsChecker.h TStreamerElement.h TStreamer.h TVirtualIsAProxy.h TVirtualRefProxy.h TVirtualStreamerInfo.h TVirtualArray.h TVirtualObject.h Getline.h /home/cai/root/root-6.26.06/core/base/inc/LinkDef.h . Segmentation fault. gmake[2]: *** [core/CMakeFiles/G__Core.dir/build.make:470: core/G__Core.cxx] Error 1. gmake[1]: *** [CMakeFiles/Makefile2:33018: core/CMakeFiles/G__Core.dir/all] Error 2. gmake: *** [Makefile:156: all] Error 2. I've tried some times, the build never success, here I come for help. reeBSD# gcc --version . gcc (FreeBSD Ports Collection) 11.3.0. Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO. warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. the compiler I installed:. FreeBSD# c++ --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. FreeBSD# clang --version. FreeBSD clang version 13.0.0 (git@github.com:llvm/llvm-project.git llvmorg-13.0.0-0-gd7b669b3a303). Target: x86_64-unknown-freebsd13.1. Thread model: posix. InstalledDir: /usr/bin. -->. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ### Setup. <!--. 1. ROOT version 6.26.06. 2. Operating system FreeBSD13.1. 3. How you obtained ROOT: built it from source. -->. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11430
https://github.com/root-project/root/issues/11431:0,deployability,Instal,Installing,0,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:103,deployability,configurat,configuration,103,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:170,deployability,Instal,Installing,170,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:321,deployability,modul,modules,321,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:515,deployability,modul,module,515,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1461,deployability,modul,module,1461,".10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1568,deployability,modul,module,1568,"e ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different director",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1668,deployability,modul,module,1668,"port(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the run",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1770,deployability,modul,module,1770,"ile ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in th",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1812,deployability,Fail,Failed,1812,"1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1963,deployability,instal,installed,1963,"_load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2400,deployability,instal,installed,2400," last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2473,deployability,instal,installed,2473,"mdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/pyth",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2613,deployability,instal,installed,2613,".10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2829,deployability,build,build,2829,"cppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2943,deployability,instal,install,2943,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2986,deployability,modul,modules,2986,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2994,deployability,instal,installed,2994,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3064,deployability,version,version,3064,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3120,deployability,instal,installed,3120,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3151,deployability,build,build,3151,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3426,deployability,contain,contains,3426,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3533,deployability,modul,modules,3533,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3794,deployability,instal,installed,3794,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3860,deployability,patch,patchelf,3860,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3896,deployability,patch,patchelf,3896,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3312,energy efficiency,gpu,gpu,3312,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:103,integrability,configur,configuration,103,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2815,integrability,Configur,Configure,2815,"o import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTAL",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3064,integrability,version,version,3064,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1262,interoperability,share,shared,1262,"TALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:103,modifiability,configur,configuration,103,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:321,modifiability,modul,modules,321,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:473,modifiability,pac,packages,473,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:515,modifiability,modul,module,515,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:690,modifiability,pac,package,690,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1461,modifiability,modul,module,1461,".10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1528,modifiability,pac,packages,1528,"b.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1568,modifiability,modul,module,1568,"e ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different director",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1627,modifiability,pac,packages,1627,"import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAK",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1668,modifiability,modul,module,1668,"port(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the run",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1728,modifiability,pac,packages,1728,"bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_L",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1770,modifiability,modul,module,1770,"ile ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in th",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2238,modifiability,pac,packages,2238,"o.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAK",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2815,modifiability,Configur,Configure,2815,"o import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTAL",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2986,modifiability,modul,modules,2986,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3064,modifiability,version,version,3064,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3490,modifiability,pac,packages,3490,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3533,modifiability,modul,modules,3533,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3312,performance,gpu,gpu,3312,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3500,performance,CACH,CACHE,3500,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3602,performance,CACH,CACHE,3602,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1812,reliability,Fail,Failed,1812,"1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:321,safety,modul,modules,321,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:515,safety,modul,module,515,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1338,safety,except,exception,1338,"OT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGI",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1357,safety,except,exception,1357,"mple that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1461,safety,modul,module,1461,".10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1568,safety,modul,module,1568,"e ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different director",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1668,safety,modul,module,1668,"port(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the run",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1770,safety,modul,module,1770,"ile ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in th",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2986,safety,modul,modules,2986,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3533,safety,modul,modules,3533,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3860,safety,patch,patchelf,3860,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3896,safety,patch,patchelf,3896,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:103,security,configur,configuration,103,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2815,security,Configur,Configure,2815,"o import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTAL",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3758,security,modif,modify,3758,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3860,security,patch,patchelf,3860,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3896,security,patch,patchelf,3896,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:400,testability,Trace,Traceback,400,"Installing with CMAKE_INSTALL_PYTHONDIR different from CMAKE_INSTALL_LIBDIR leads to incorrect runpath configuration; - [x] Checked for duplicates. ### Describe the bug. Installing ROOT with a path for `CMAKE_INSTALL_PYTHONDIR` different than the one for `CMAKE_INSTALL_LIBDIR` leads to problems trying to use the Python modules provided by ROOT, such as the example that follows. ```. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:1378,testability,Trace,Traceback,1378,"`. $ rootbrowse. Traceback (most recent call last):. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 60, in <module>. importlib.import_module(libcppyy_mod_name). File ""/usr/lib/python3.10/importlib/__init__.py"", line 126, in import_module. return _bootstrap._gcd_import(name[level:], package, level). File ""<frozen importlib._bootstrap>"", line 1050, in _gcd_import. File ""<frozen importlib._bootstrap>"", line 1027, in _find_and_load. File ""<frozen importlib._bootstrap>"", line 1006, in _find_and_load_unlocked. File ""<frozen importlib._bootstrap>"", line 674, in _load_unlocked. File ""<frozen importlib._bootstrap>"", line 571, in module_from_spec. File ""<frozen importlib._bootstrap_external>"", line 1176, in create_module. File ""<frozen importlib._bootstrap>"", line 241, in _call_with_frames_removed. ImportError: libcppyy_backend3_10.so.6.26: cannot open shared object file: No such file or directory. During handling of the above exception, another exception occurred:. Traceback (most recent call last):. File ""/usr/local/bin/rootbrowse"", line 10, in <module>. import cmdLineUtils. File ""/usr/local/lib/python3.10/dist-packages/cmdLineUtils.py"", line 82, in <module>. import ROOT. File ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see abov",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3678,testability,context,context,3678,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:2589,usability,behavi,behavior,2589,"e ""/usr/local/lib/python3.10/dist-packages/ROOT/__init__.py"", line 22, in <module>. import cppyy. File ""/usr/local/lib/python3.10/dist-packages/cppyy/__init__.py"", line 62, in <module>. raise ImportError(. ImportError: Failed to import libcppyy3_10. Please check that ROOT has been built for Python 3.10. ```. A check with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/e",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/issues/11431:3164,usability,command,command,3164,"heck with `readelf` reveals the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR` is the reason for this problem. ```. $ readelf -a /usr/local/lib/root/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. ```. $ readelf -a /usr/local/lib/python3.10/dist-packages/libcppyy3_10.so | grep -i runpath. 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN:$ORIGIN/../lib/root]. ```. As you can see above, the libraries installed to `CMAKE_INSTALL_PYTHONDIR` have the same runpath as the ones installed to `CMAKE_INSTALL_LIBDIR`, which shouldn't be the case if the two are different directories. ### Expected behavior. The libraries installed to `CMAKE_INSTALL_PYTHONDIR` should have the runpath set to the correct relative location of `CMAKE_INSTALL_LIBDIR` (`$ORIGIN/../../../lib/root` in the previous example). ### To Reproduce. 1. Configure the build with `CMAKE_INSTALL_PYTHONDIR` different from `CMAKE_INSTALL_LIBDIR` and with rpath enabled. 2. Compile and install as usual. 3. Try to use the python modules installed by ROOT, such as by running `rootbrowse`. ### Setup. - ROOT version 6.26/06. - Ubuntu 22.04 running on WSL2. - ROOT installed from source with the build config command `CUDACXX=/usr/local/cuda-11.7/bin/nvcc cmake -C config.cmake .. -DCMAKE_CUDA_ARCHITECTURES='86' -Dgnuinstall=ON -Dcuda=ON -Dcudnn=ON -Dtmva-gpu=ON -Dsoversion=ON -Dfortran=ON -DPYTHON_EXECUTABLE=/usr/bin/python -Drpath=ON`, where the file `config.cmake` contains. ```. set(CMAKE_INSTALL_PYTHONDIR ""lib/python3.10/dist-packages"" CACHE PATH ""python libraries and modules (same as LIBDIR)""). set(CMAKE_INSTALL_SYSCONFDIR ""/etc/root"" CACHE PATH ""read-only single-machine data (etc/root)""). ```. ### Additional context. A temporary workaround while this issue is not resolved is to manually modify the runpath of the libraries installed to `CMAKE_INSTALL_PYTHONDIR`, e.g. using `chrpath` or [`patchelf`](https://github.com/NixOS/patchelf).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11431
https://github.com/root-project/root/pull/11432:328,deployability,updat,updated,328,"[cmake] Current Xcode issues a warning on -undefined dynamic_lookup:; ld: warning: -undefined dynamic_lookup may not work with chained fixups. Rely on explicit linking, and only specify -undefined dynamic_lookup where really needed. # This Pull request:. ## Changes or fixes:. ## Checklist:. - [ ] tested changes locally. - [ ] updated the docs (if necessary). This PR fixes # .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11432
https://github.com/root-project/root/pull/11432:8,energy efficiency,Current,Current,8,"[cmake] Current Xcode issues a warning on -undefined dynamic_lookup:; ld: warning: -undefined dynamic_lookup may not work with chained fixups. Rely on explicit linking, and only specify -undefined dynamic_lookup where really needed. # This Pull request:. ## Changes or fixes:. ## Checklist:. - [ ] tested changes locally. - [ ] updated the docs (if necessary). This PR fixes # .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11432
https://github.com/root-project/root/pull/11432:178,interoperability,specif,specify,178,"[cmake] Current Xcode issues a warning on -undefined dynamic_lookup:; ld: warning: -undefined dynamic_lookup may not work with chained fixups. Rely on explicit linking, and only specify -undefined dynamic_lookup where really needed. # This Pull request:. ## Changes or fixes:. ## Checklist:. - [ ] tested changes locally. - [ ] updated the docs (if necessary). This PR fixes # .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11432
https://github.com/root-project/root/pull/11432:298,safety,test,tested,298,"[cmake] Current Xcode issues a warning on -undefined dynamic_lookup:; ld: warning: -undefined dynamic_lookup may not work with chained fixups. Rely on explicit linking, and only specify -undefined dynamic_lookup where really needed. # This Pull request:. ## Changes or fixes:. ## Checklist:. - [ ] tested changes locally. - [ ] updated the docs (if necessary). This PR fixes # .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11432
https://github.com/root-project/root/pull/11432:328,safety,updat,updated,328,"[cmake] Current Xcode issues a warning on -undefined dynamic_lookup:; ld: warning: -undefined dynamic_lookup may not work with chained fixups. Rely on explicit linking, and only specify -undefined dynamic_lookup where really needed. # This Pull request:. ## Changes or fixes:. ## Checklist:. - [ ] tested changes locally. - [ ] updated the docs (if necessary). This PR fixes # .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11432
https://github.com/root-project/root/pull/11432:328,security,updat,updated,328,"[cmake] Current Xcode issues a warning on -undefined dynamic_lookup:; ld: warning: -undefined dynamic_lookup may not work with chained fixups. Rely on explicit linking, and only specify -undefined dynamic_lookup where really needed. # This Pull request:. ## Changes or fixes:. ## Checklist:. - [ ] tested changes locally. - [ ] updated the docs (if necessary). This PR fixes # .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11432
https://github.com/root-project/root/pull/11432:298,testability,test,tested,298,"[cmake] Current Xcode issues a warning on -undefined dynamic_lookup:; ld: warning: -undefined dynamic_lookup may not work with chained fixups. Rely on explicit linking, and only specify -undefined dynamic_lookup where really needed. # This Pull request:. ## Changes or fixes:. ## Checklist:. - [ ] tested changes locally. - [ ] updated the docs (if necessary). This PR fixes # .",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11432
https://github.com/root-project/root/pull/11433:207,availability,Sla,SlaveBegin,207,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:296,availability,error,error,296,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:763,availability,error,error,763,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:877,availability,Sla,SlaveBegin,877,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:1343,availability,error,error,1343,"laveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:1809,availability,error,error,1809,"laveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:296,performance,error,error,296,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:763,performance,error,error,763,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:1343,performance,error,error,1343,"laveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:1809,performance,error,error,1809,"laveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:207,reliability,Sla,SlaveBegin,207,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:877,reliability,Sla,SlaveBegin,877,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:296,safety,error,error,296,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:763,safety,error,error,763,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:1343,safety,error,error,1343,"laveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:1809,safety,error,error,1809,"laveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:296,usability,error,error,296,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:763,usability,error,error,763,"[proof] use proper string type to store object name in TProofDraw; Fixing compiler warning:. ```. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx: In member function virtual void TProofDrawHist::SlaveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:1343,usability,error,error,1343,"laveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11433:1809,usability,error,error,1809,"laveBegin(TTree*):. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:51: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~^~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:789:30: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 789 | PDB(kDraw,1) Info(""SlaveBegin"", ""original object '%s' not found"". | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. 790 | "" or it is not a histogram"", objname);. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:784:60: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 784 | TH1 *hist = dynamic_cast<TH1*> (fInput->FindObject(objname));. | ~~~~~~~~~~~~~~~~~~^~~~~~~~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:783:38: error: dangling pointer to an unnamed temporary may be used [-Werror=dangling-pointer=]. 783 | if (objname && strlen(objname) > 0 && strcmp(objname, ""htemp"")) {. | ~~~~~~~~~~~~~~~~^~~. /home/linev/git/root6/proof/proofplayer/src/TProofDraw.cxx:782:62: note: unnamed temporary defined here. 782 | const char *objname = fTreeDrawArgsParser.GetObjectName();. | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11433
https://github.com/root-project/root/pull/11435:94,deployability,updat,update,94,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:213,deployability,build,build,213,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:281,deployability,updat,updated,281,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:374,deployability,instal,installing,374,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:389,deployability,build,build,389,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:511,deployability,build,build,511,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:521,deployability,instal,install,521,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:547,deployability,updat,updated,547,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:115,interoperability,bind,bindings,115,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:115,modifiability,bind,bindings,115,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:444,modifiability,interm,intermediate,444,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:269,reliability,doe,doesn,269,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:94,safety,updat,update,94,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:281,safety,updat,updated,281,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:547,safety,updat,updated,547,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:94,security,updat,update,94,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:281,security,updat,updated,281,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:547,security,updat,updated,547,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/pull/11435:593,usability,Close,Closes,593,"[cmake][PyROOT] Properly deal with PyROOT pythonization sources; Before this commit, when you update the code in. `bindings/pyroot/pythonizations/python/ROOT/_pythonization` and recompile ROOT, the corresponding `build` directory (`root_build/lib/ROOT/_pythonization`) doesn't get updated, and consequently also not the `root_install/lib/ROOT/_pythonization` directory when installing the build. This commit fixes this situation by introducing intermediate CMake targets, resulting in the Python sources in the build and install directories being updated when changed in the source directory. Closes #11233.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11435
https://github.com/root-project/root/issues/11436:29,deployability,contain,containing,29,"Missing StreamerInfo in file containing nested collection that is non-split but stored member wise; With example below, the resulting file is missing the StreamerInfo for the `Inside` class preventing schema evolution for this class. . ```C++. #include <vector>. #include ""TTree.h"". #include ""TFile.h"". struct Inside {. int fValue;. };. struct Middle {. std::vector<Inside> fInside;. };. struct Outer {. std::vector<Middle> fMiddle;. };. void writefile(bool empty = true, const char *filename = ""forceinfo.root""). {. TFile *f = TFile::Open(filename, ""RECREATE"");. TTree *t = new TTree(""t"", ""t"");. Outer object;. t->Branch(""object."", &object);. if (!empty) {. Inside in;. Middle m;. m.fInside.push_back(in);. object.fMiddle.push_back(m);. }. t->Fill();. f->Write();. delete f;. }. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11436
https://github.com/root-project/root/issues/11436:201,integrability,schema,schema,201,"Missing StreamerInfo in file containing nested collection that is non-split but stored member wise; With example below, the resulting file is missing the StreamerInfo for the `Inside` class preventing schema evolution for this class. . ```C++. #include <vector>. #include ""TTree.h"". #include ""TFile.h"". struct Inside {. int fValue;. };. struct Middle {. std::vector<Inside> fInside;. };. struct Outer {. std::vector<Middle> fMiddle;. };. void writefile(bool empty = true, const char *filename = ""forceinfo.root""). {. TFile *f = TFile::Open(filename, ""RECREATE"");. TTree *t = new TTree(""t"", ""t"");. Outer object;. t->Branch(""object."", &object);. if (!empty) {. Inside in;. Middle m;. m.fInside.push_back(in);. object.fMiddle.push_back(m);. }. t->Fill();. f->Write();. delete f;. }. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11436
https://github.com/root-project/root/issues/11436:190,safety,prevent,preventing,190,"Missing StreamerInfo in file containing nested collection that is non-split but stored member wise; With example below, the resulting file is missing the StreamerInfo for the `Inside` class preventing schema evolution for this class. . ```C++. #include <vector>. #include ""TTree.h"". #include ""TFile.h"". struct Inside {. int fValue;. };. struct Middle {. std::vector<Inside> fInside;. };. struct Outer {. std::vector<Middle> fMiddle;. };. void writefile(bool empty = true, const char *filename = ""forceinfo.root""). {. TFile *f = TFile::Open(filename, ""RECREATE"");. TTree *t = new TTree(""t"", ""t"");. Outer object;. t->Branch(""object."", &object);. if (!empty) {. Inside in;. Middle m;. m.fInside.push_back(in);. object.fMiddle.push_back(m);. }. t->Fill();. f->Write();. delete f;. }. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11436
https://github.com/root-project/root/issues/11436:190,security,preven,preventing,190,"Missing StreamerInfo in file containing nested collection that is non-split but stored member wise; With example below, the resulting file is missing the StreamerInfo for the `Inside` class preventing schema evolution for this class. . ```C++. #include <vector>. #include ""TTree.h"". #include ""TFile.h"". struct Inside {. int fValue;. };. struct Middle {. std::vector<Inside> fInside;. };. struct Outer {. std::vector<Middle> fMiddle;. };. void writefile(bool empty = true, const char *filename = ""forceinfo.root""). {. TFile *f = TFile::Open(filename, ""RECREATE"");. TTree *t = new TTree(""t"", ""t"");. Outer object;. t->Branch(""object."", &object);. if (!empty) {. Inside in;. Middle m;. m.fInside.push_back(in);. object.fMiddle.push_back(m);. }. t->Fill();. f->Write();. delete f;. }. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11436
https://github.com/root-project/root/issues/11437:673,availability,error,error,673,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:818,availability,avail,available,818,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1360,availability,failur,failures,1360,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1511,availability,error,error,1511,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:8,deployability,Build,Build,8,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:377,deployability,instal,install,377,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:486,deployability,instal,install,486,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:744,deployability,fail,fails,744,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:884,deployability,instal,install-to-build-directory,884,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1223,deployability,DEPEND,DEPENDS,1223,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1360,deployability,fail,failures,1360,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1412,deployability,build,build,1412,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1421,deployability,fail,fail,1421,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1545,deployability,fail,fails,1545,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1875,deployability,log,logic,1875,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1223,integrability,DEPEND,DEPENDS,1223,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:31,interoperability,incompatib,incompatible,31,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:105,interoperability,bind,bindings,105,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:201,interoperability,bind,bindings,201,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1615,interoperability,compatib,compatible,1615,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1761,interoperability,bind,bindings,1761,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:105,modifiability,bind,bindings,105,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:201,modifiability,bind,bindings,201,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1223,modifiability,DEPEND,DEPENDS,1223,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1761,modifiability,bind,bindings,1761,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:673,performance,error,error,673,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1360,performance,failur,failures,1360,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1511,performance,error,error,1511,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:744,reliability,fail,fails,744,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:818,reliability,availab,available,818,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1360,reliability,fail,failures,1360,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1421,reliability,fail,fail,1421,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1545,reliability,fail,fails,1545,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:673,safety,error,error,673,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:818,safety,avail,available,818,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1223,safety,DEPEND,DEPENDS,1223,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1511,safety,error,error,1511,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1649,safety,except,except,1649,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1875,safety,log,logic,1875,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:818,security,availab,available,818,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1875,security,log,logic,1875,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1223,testability,DEPEND,DEPENDS,1223,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1875,testability,log,logic,1875,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:407,usability,COMMAND,COMMAND,407,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:516,usability,COMMAND,COMMAND,516,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:673,usability,error,error,673,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1068,usability,COMMAND,COMMAND,1068,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1144,usability,COMMAND,COMMAND,1144,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/issues/11437:1511,usability,error,error,1511,"[cmake] Build tries to compile incompatible pythonization sources with Python 2; ## The problem. In the [bindings/pyroot/pythonizations/CMakeLists.txt](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt) file, the following code is used to compile the Python sources. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). install(CODE ""execute_process(COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source})""). install(CODE ""execute_process(COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source})""). endforeach(). ```. However, with this `execute_process` trick, there is no error code checking, so it often happens that the compilation actually fails with Python 2 because the Pythonizations use features that are only available in Python 3! I notice this when trying to replace this ""install-to-build-directory"" trick with proper CMake targets, kind of like this:. ```cmake. # Compile .py files. foreach(py_source ${py_sources}). add_custom_command(TARGET ${libname}. COMMAND ${python_executable} -m py_compile ${localruntimedir}/${py_source}. COMMAND ${python_executable} -O -m py_compile ${localruntimedir}/${py_source}. DEPENDS ${localruntimedir}/${py_source}. COMMENT ""Compiling ${py_source} for ${libname}""). endforeach(). ```. With `add_custom_command`, failures in compiling the Python sources causes the build to fail (as it should be I think). ## What needs to be done to fix this issue. * Have CMakes error out when Python compilation fails by using `add_custom_command`. * Make the Pythonization sources compatible with Python 2... * ... except for the sources that should [only be used for Python 3](https://github.com/root-project/root/blob/master/bindings/pyroot/pythonizations/CMakeLists.txt#L17). For these, the compilation should be done only with Python 3 (logic to do this needs to be added to the CMakeLists.txt)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11437
https://github.com/root-project/root/pull/11438:60,deployability,contain,contains,60,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:69,deployability,automat,automatic,69,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:148,deployability,automat,automatically,148,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:361,deployability,build,build,361,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:254,integrability,sub,subprocess,254,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1095,integrability,sub,subprocess,1095,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1516,integrability,sub,subprocess,1516,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1544,integrability,sub,subprocess,1544,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1571,integrability,sub,subprocess,1571,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:956,interoperability,specif,specifies,956,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:475,modifiability,extens,extensions,475,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:512,modifiability,extens,extensions,512,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:640,modifiability,extens,extensions,640,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:780,modifiability,extens,extensions,780,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:850,modifiability,extens,extensions,850,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:975,modifiability,extens,extensions,975,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1070,modifiability,extens,extensions,1070,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1156,modifiability,deco,decode,1156,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:41,safety,test,test,41,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1063,safety,test,test,1063,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1723,safety,test,test,1723,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:41,testability,test,test,41,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:69,testability,automat,automatic,69,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:148,testability,automat,automatically,148,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1063,testability,test,test,1063,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11438:1723,testability,test,test,1723,"[RF] Add missing `override` keywords in `test`; This commit contains automatic changes done by `clang-tidy`. This commit was generated more or less automatically with this Python. script that uses `clang-tidy`:. ```Python. import os. import glob. import subprocess. import tqdm. """""". For clang-tidy to work, you have to copy the compile_commands.json from the. build directory back into the repo directory (just like in. .ci/copy_headers.sh). """""". def get_sources(directory, extensions):. files = []. for ext in extensions:. files += glob.glob(. os.path.join(directory, ""**/*"" + ext), recursive=True. ). return files. """""". Recursively find extensions in directory, to figure out whic hextensions. should be globbed for. find . -type f -name '*.*' | sed 's|.*\.||' | sort -u. """""". extensions = ["".h"", "".hpp"", "".hxx"", "".cpp"", "".cc"", "".cxx""]. """""". Some extensions are recognized as C and not as C++ files by clang-tidy. We. need to rename them, and this dict specifies how file extensions should be. replaced. """""". rename_dict = {"".h"": "".hpp""}. files = get_sources(""test"", extensions). cflags = (. subprocess.check_output([""root-config"", ""--cflags""]).strip().decode(""utf-8""). ). for file in tqdm.tqdm(files):. file_renamed = file. for ext, ext_renamed in rename_dict.items():. if file.endswith(ext):. file_renamed = file.replace(ext, ext_renamed). if file_renamed != file:. os.rename(file, file_renamed). cmd = [. ""clang-tidy"",. ""-checks=modernize-use-override"",. ""--fix"",. file_renamed,. ""--"",. ] + cflags.split("" ""). subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL). if file_renamed != file:. os.rename(file_renamed, file). """""". Finally, replace the ClassDef with the ClassDefOverride macros. find test -type f -print | xargs sed -i 's/ClassDef(/ClassDefOverride(/'. ...and change back the ClassDefOverride of non-overriding base classes. """""". ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11438
https://github.com/root-project/root/pull/11439:119,availability,cluster,cluster,119,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:271,availability,cluster,cluster,271,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:362,availability,cluster,cluster,362,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:16,deployability,resourc,resource,16,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:119,deployability,cluster,cluster,119,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:150,deployability,resourc,resources,150,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:215,deployability,resourc,resource,215,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:271,deployability,cluster,cluster,271,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:362,deployability,cluster,cluster,362,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:16,energy efficiency,resourc,resource,16,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:150,energy efficiency,resourc,resources,150,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:215,energy efficiency,resource usag,resource usage,215,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:480,integrability,repositor,repository,480,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:42,interoperability,distribut,distributed,42,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:65,interoperability,distribut,distributed,65,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:480,interoperability,repositor,repository,480,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:16,performance,resourc,resource,16,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:150,performance,resourc,resources,150,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:215,performance,resourc,resource,215,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:16,safety,resourc,resource,16,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:54,safety,test,tests,54,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:98,safety,test,tests,98,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:150,safety,resourc,resources,150,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:215,safety,resourc,resource,215,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:253,safety,test,tests,253,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:324,safety,test,test,324,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:522,safety,test,tests,522,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:341,security,sign,signal,341,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:16,testability,resourc,resource,16,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:54,testability,test,tests,54,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:98,testability,test,tests,98,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:150,testability,resourc,resources,150,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:215,testability,resourc,resource,215,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:253,testability,test,tests,253,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:324,testability,test,test,324,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:522,testability,test,tests,522,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/pull/11439:207,usability,clear,clearer,207,"Improvements on resource restrictions for distributed tests; The distributed RDataFrame tutorials/tests have to create cluster objects, which take up resources on the machine. This is another step towards a clearer resource usage for both tutorials and tests. Whenever a cluster object is created, it now uses RESOURCE_LOCK test property to signal that no other cluster object should be created while the previous one is still running. This PR addresses the tutorials in the root repository, a sibling PR will address the tests in roottest",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11439
https://github.com/root-project/root/issues/11440:589,deployability,contain,containing,589,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:720,deployability,instal,install,720,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:734,deployability,version,versions,734,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:15,energy efficiency,Draw,Draw,15,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:319,energy efficiency,Draw,Draw,319,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:354,energy efficiency,Draw,Draw,354,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:734,integrability,version,versions,734,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:734,modifiability,version,versions,734,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:20,reliability,doe,does,20,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:121,reliability,doe,does,121,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:486,testability,simpl,simple,486,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/issues/11440:486,usability,simpl,simple,486,"[TTree] TTree::Draw does not fill histogram.; I am not sure if it is a real bug or a known issue but the following macro does not fill the histogram `hpx`:. ```. void ntuple_example() {. auto hpx = new TH1F(""hpx"", ""hpx"", 100, -1., 1.);. auto f = new TFile(""hsimple.root"");. auto tree = (TTree*)f->Get(""ntuple"");. tree->Draw(""px >> hpx"","""",""goff"");. hpx->Draw();. }. ```. To make it work it is enough to swap the histogram creation line and the TFile creation line. So the workaround is simple but that might be confusing if people first create the histogram(s) and then attach the file(s) containing the tree(s): the histogram(s) will be empty. I see that on Mac. I see this issue until 6:20 at least (I was not able to install older versions)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11440
https://github.com/root-project/root/pull/11441:56,safety,Prevent,Prevents,56,Cppy nulls; # This Pull request:. ## Changes or fixes:. Prevents some null ptr access. Detected by clang-tidy.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11441
https://github.com/root-project/root/pull/11441:87,safety,Detect,Detected,87,Cppy nulls; # This Pull request:. ## Changes or fixes:. Prevents some null ptr access. Detected by clang-tidy.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11441
https://github.com/root-project/root/pull/11441:56,security,Preven,Prevents,56,Cppy nulls; # This Pull request:. ## Changes or fixes:. Prevents some null ptr access. Detected by clang-tidy.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11441
https://github.com/root-project/root/pull/11441:79,security,access,access,79,Cppy nulls; # This Pull request:. ## Changes or fixes:. Prevents some null ptr access. Detected by clang-tidy.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11441
https://github.com/root-project/root/pull/11441:87,security,Detect,Detected,87,Cppy nulls; # This Pull request:. ## Changes or fixes:. Prevents some null ptr access. Detected by clang-tidy.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11441
https://github.com/root-project/root/issues/11442:44,usability,interact,interactive,44,[cling] Default to O2 instead of O1 for non-interactive usage; As per the discussion at https://mattermost.web.cern.ch/root/pl/xxntcn9dztdtjnk9tpbtx9oarh .,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11442
https://github.com/root-project/root/pull/11443:1,energy efficiency,core,core,1,"[core/base] Null ptr access safety; # This Pull request:. ## Changes or fixes:. In some corner cases, there might be some nullptr access problems. This solves the warnings found by clang-tidy",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11443
https://github.com/root-project/root/pull/11443:28,safety,safe,safety,28,"[core/base] Null ptr access safety; # This Pull request:. ## Changes or fixes:. In some corner cases, there might be some nullptr access problems. This solves the warnings found by clang-tidy",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11443
https://github.com/root-project/root/pull/11443:21,security,access,access,21,"[core/base] Null ptr access safety; # This Pull request:. ## Changes or fixes:. In some corner cases, there might be some nullptr access problems. This solves the warnings found by clang-tidy",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11443
https://github.com/root-project/root/pull/11443:130,security,access,access,130,"[core/base] Null ptr access safety; # This Pull request:. ## Changes or fixes:. In some corner cases, there might be some nullptr access problems. This solves the warnings found by clang-tidy",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11443
https://github.com/root-project/root/pull/11444:8,safety,sanit,sanity,8,TString sanity check nchar not larger than capacity; # This Pull request:. ## Changes or fixes:. A potential memleak or sanity-check in TString found by clang-tidy.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11444
https://github.com/root-project/root/pull/11444:120,safety,sanit,sanity-check,120,TString sanity check nchar not larger than capacity; # This Pull request:. ## Changes or fixes:. A potential memleak or sanity-check in TString found by clang-tidy.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11444
https://github.com/root-project/root/pull/11444:8,security,sanit,sanity,8,TString sanity check nchar not larger than capacity; # This Pull request:. ## Changes or fixes:. A potential memleak or sanity-check in TString found by clang-tidy.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11444
https://github.com/root-project/root/pull/11444:120,security,sanit,sanity-check,120,TString sanity check nchar not larger than capacity; # This Pull request:. ## Changes or fixes:. A potential memleak or sanity-check in TString found by clang-tidy.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11444
https://github.com/root-project/root/pull/11445:134,deployability,updat,updated,134,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:419,deployability,depend,depends,419,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:568,deployability,fail,fail,568,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:419,integrability,depend,depends,419,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:240,interoperability,specif,specifit,240,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:290,modifiability,paramet,parameter,290,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:356,modifiability,variab,variable,356,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:419,modifiability,depend,depends,419,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:447,modifiability,paramet,parameters,447,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:568,reliability,fail,fail,568,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:96,safety,test,tests,96,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:134,safety,updat,updated,134,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:419,safety,depend,depends,419,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:525,safety,test,test,525,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:605,safety,test,testRooAbsReal,605,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:660,safety,test,tests,660,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:134,security,updat,updated,134,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:91,testability,unit,unit,91,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:96,testability,test,tests,96,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:419,testability,depend,depends,419,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:520,testability,unit,unit,520,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:525,testability,test,test,525,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:605,testability,test,testRooAbsReal,605,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:655,testability,unit,unit,655,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/pull/11445:660,testability,test,tests,660,"[RF] Fix recently-introduced `RooAbsReal::getPropagatedError` problems and add several new unit tests; The recent commit `565e9aa19a` updated the `getPropagatedError` with. some additional checks, but these checks caused segfaults in some. specifit usecases:. * where the `RooAbsReal` is a parameter in the fit result itself. * where the `RooAbsReal` is a variable unrelated to the fit result. * where the `RooAbsReal` depends only on some of the parameters in the. fit result. This commit fixes these usecases again. A unit test that checks that these usecases don't fail anymore is now. implemented in `testRooAbsReal`. This PR also adds some other new unit tests that cover recent PRs and issues.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11445
https://github.com/root-project/root/issues/11447:404,availability,consist,consistent,404,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:199,deployability,configurat,configuration,199,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:769,deployability,integr,integral,769,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:862,deployability,integr,integral,862,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1097,deployability,configurat,configuration,1097,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1447,energy efficiency,reduc,reduced,1447,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:199,integrability,configur,configuration,199,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:769,integrability,integr,integral,769,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:862,integrability,integr,integral,862,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1097,integrability,configur,configuration,1097,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:769,interoperability,integr,integral,769,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:862,interoperability,integr,integral,862,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:199,modifiability,configur,configuration,199,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:769,modifiability,integr,integral,769,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:862,modifiability,integr,integral,862,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1097,modifiability,configur,configuration,1097,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:30,reliability,doe,doesn,30,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:213,reliability,doe,doesn,213,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:550,reliability,doe,doesn,550,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:769,reliability,integr,integral,769,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:862,reliability,integr,integral,862,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1527,reliability,doe,doesn,1527,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:326,safety,test,test,326,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1310,safety,test,test,1310,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1319,safety,test,testRooSimultaneous,1319,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:199,security,configur,configuration,199,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:769,security,integr,integral,769,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:862,security,integr,integral,862,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1097,security,configur,configuration,1097,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:321,testability,unit,unit,321,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:326,testability,test,test,326,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:769,testability,integr,integral,769,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:862,testability,integr,integral,862,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:916,testability,context,context,916,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1305,testability,unit,unit,1305,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1310,testability,test,test,1310,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1319,testability,test,testRooSimultaneous,1319,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1396,testability,context,context,1396,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:404,usability,consist,consistent,404,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:490,usability,clear,clear,490,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1010,usability,workflow,workflow,1010,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11447:1033,usability,behavi,behavior,1033,"[RF] NLL from RooSimultaneous doesn't give the expected value in multi-range fits; ### Describe the bug. Following up on #11396, I noticed that a NLL created from a RooSimultaneous in a multi-ranged configuration doesn't give the expected value. In https://github.com/root-project/root/pull/11445, I tried to implement a unit test that was checking exactly that, but the NLL from RooSimultaneous was not consistent with a mathematically equivalent sum of NLLs per category. It is still not clear whether the difference is only a constant factor that doesn't influence the fit result, but this is potentially a but that even has an influence on the results. I suspect that it is actually biasing the fit result, because in multi-ranged fits the NLL is computed using an integral of the top-level PDF that is created with `createIntegral`, and I'm not sure if the integral of a RooSimultaneous is well defined in that context. Please @AlkaidCheng, take note of this, because this is a potential problem for your workflow. ### Expected behavior. The NLL value from a RooSimultaneous in a multi-range configuration should be the same value as the normalized combination of individual NLLs created in the individual categories. ### To Reproduce. Comment out the final part of the `MultiRangeFitWithSplitRange` unit test in `testRooSimultaneous`. ### Setup. Arch Linux with ROOT master. ### Additional context. - The priority level of this issue can be reduced if it turns out that the difference in the NLL value is a constant that doesn't affect the fit result",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11447
https://github.com/root-project/root/issues/11448:1295,availability,Operat,Operating,1295,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:164,deployability,build,building,164,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:173,deployability,depend,dependent,173,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:351,deployability,depend,dependent,351,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:376,deployability,build,build,376,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:1245,deployability,instal,install,1245,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:1274,deployability,version,version,1274,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:680,energy efficiency,Current,Currently,680,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:173,integrability,depend,dependent,173,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:351,integrability,depend,dependent,351,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:1274,integrability,version,version,1274,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:173,modifiability,depend,dependent,173,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:183,modifiability,pac,packages,183,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:351,modifiability,depend,dependent,351,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:1158,modifiability,paramet,parameter,1158,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:1274,modifiability,version,version,1274,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:173,safety,depend,dependent,173,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:351,safety,depend,dependent,351,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:173,testability,depend,dependent,173,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:351,testability,depend,dependent,351,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:213,usability,tool,tool,213,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:275,usability,Tool,Tools,275,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:326,usability,tool,tool,326,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:451,usability,behavi,behavior,451,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:466,usability,minim,minimal,466,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/issues/11448:1171,usability,support,support,1171,"Irrelevant binaries in CMake export set; - [x] Checked for duplicates. ### Describe the bug. CMake EXPORT sets should only reference targets which are required for building dependent packages, not every auxiliary tool. I.e.:. 1. Libraries (implies corresponding headers). 2. Tools like code generators, preprocessors ... If a tool may be invoked by a dependent project during build, include it in the export set, otherwise, leave it out. ### Expected behavior. Only minimal set of programs is referenced by the `ROOTConfig-targets*cmake` file. E.g. `hadd` should not be exported, but it is: . `list(APPEND _cmake_import_check_files_for_ROOT::hadd ""${_IMPORT_PREFIX}/bin/hadd"" )`. Currently, the following binaries are exported:. ```. ""${_IMPORT_PREFIX}/bin/hadd"". ""${_IMPORT_PREFIX}/bin/hist2workspace"". ""${_IMPORT_PREFIX}/bin/proofserv.exe"". ""${_IMPORT_PREFIX}/bin/rmkdepend"". ""${_IMPORT_PREFIX}/bin/root"". ""${_IMPORT_PREFIX}/bin/rootcling"". ""${_IMPORT_PREFIX}/bin/root.exe"". ""${_IMPORT_PREFIX}/bin/rootnb.exe"". ""${_IMPORT_PREFIX}/bin/rootn.exe"". ""${_IMPORT_PREFIX}/bin/roots.exe"". ""${_IMPORT_PREFIX}/bin/xpdtest"". ```. ROOT already has the `CMAKENOEXPORT` parameter to support this with `ROOT_EXECUTABLE`. ### To Reproduce. `cmake; make; make install`. ### Setup. 1. ROOT version: 6.26.06. 2. Operating system: Linux.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11448
https://github.com/root-project/root/pull/11449:157,availability,state,state,157,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:340,deployability,Updat,Update,340,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:365,deployability,depend,dependency,365,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:17,energy efficiency,draw,draw,17,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:66,energy efficiency,load,load,66,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:84,energy efficiency,draw,draw,84,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:171,energy efficiency,draw,draw,171,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:319,energy efficiency,model,model,319,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:157,integrability,state,state,157,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:365,integrability,depend,dependency,365,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:386,integrability,compon,components,386,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:386,interoperability,compon,components,386,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:365,modifiability,depend,dependency,365,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:386,modifiability,compon,components,386,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:66,performance,load,load,66,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:340,safety,Updat,Update,340,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:365,safety,depend,dependency,365,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:319,security,model,model,319,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:340,security,Updat,Update,340,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11449:365,testability,depend,dependency,365,"[webgeom] direct draw TGeoVolume, produce standalone JSON; 1. Let load and directly draw `TGeoVolume` object in geometry viewer - disregard of `TGeoManager` state. 2. Let draw `TGeoVolumeAssembly` from `RBrowser`. 3. Functionality to produce JSON from geometry viewer data, such JSON can be used on JSROOT for three.js model generation. 4. Update JSROOT. 5. Remove dependency from EVE7 components in geometry viewer.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11449
https://github.com/root-project/root/pull/11451:59,safety,review,reviewed,59,[readspeed] Misc improvements and fixes; This PR is better reviewed commit by commit.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11451
https://github.com/root-project/root/pull/11451:59,testability,review,reviewed,59,[readspeed] Misc improvements and fixes; This PR is better reviewed commit by commit.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11451
https://github.com/root-project/root/pull/11452:0,deployability,Updat,Update,0,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:20,deployability,version,version,20,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:63,deployability,version,version,63,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:95,deployability,updat,updated,95,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:171,deployability,updat,update,171,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:205,deployability,instal,installation,205,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:231,deployability,configurat,configuration,231,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:20,integrability,version,version,20,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:63,integrability,version,version,63,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:231,integrability,configur,configuration,231,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:20,modifiability,version,version,20,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:63,modifiability,version,version,63,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:231,modifiability,configur,configuration,231,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:0,safety,Updat,Update,0,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:95,safety,updat,updated,95,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:171,safety,updat,update,171,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:0,security,Updat,Update,0,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:95,security,updat,updated,95,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:171,security,updat,update,171,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:231,security,configur,configuration,231,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:7,usability,minim,minimum,7,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11452:50,usability,minim,minimum,50,Update minimum dask version found with cmake; The minimum dask version in requirements.txt was updated to 2022.02 by https://github.com/root-project/root/pull/11371. Also update it when looking for a dask installation in the cmake configuration.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11452
https://github.com/root-project/root/pull/11453:0,deployability,Updat,Update,0,Update minimum dask version found with cmake; Backport of https://github.com/root-project/root/pull/11452,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11453
https://github.com/root-project/root/pull/11453:20,deployability,version,version,20,Update minimum dask version found with cmake; Backport of https://github.com/root-project/root/pull/11452,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11453
https://github.com/root-project/root/pull/11453:20,integrability,version,version,20,Update minimum dask version found with cmake; Backport of https://github.com/root-project/root/pull/11452,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11453
https://github.com/root-project/root/pull/11453:20,modifiability,version,version,20,Update minimum dask version found with cmake; Backport of https://github.com/root-project/root/pull/11452,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11453
https://github.com/root-project/root/pull/11453:0,safety,Updat,Update,0,Update minimum dask version found with cmake; Backport of https://github.com/root-project/root/pull/11452,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11453
https://github.com/root-project/root/pull/11453:0,security,Updat,Update,0,Update minimum dask version found with cmake; Backport of https://github.com/root-project/root/pull/11452,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11453
https://github.com/root-project/root/pull/11453:7,usability,minim,minimum,7,Update minimum dask version found with cmake; Backport of https://github.com/root-project/root/pull/11452,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11453
https://github.com/root-project/root/pull/11455:237,integrability,interfac,interface,237,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:877,integrability,Batch,BatchMode,877,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:237,interoperability,interfac,interface,237,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:237,modifiability,interfac,interface,237,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:877,performance,Batch,BatchMode,877,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:358,reliability,doe,doesn,358,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:701,reliability,doe,doesn,701,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:72,safety,compl,complicated,72,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:629,safety,compl,complicated,629,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:72,security,compl,complicated,72,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:629,security,compl,complicated,629,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:718,testability,simul,simultaneous,718,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/pull/11455:923,usability,Close,Closes,923,"[RF] Re-implement multi-range fits; Multi-range fits in RooFit are more complicated than they should be. In principle, all that is required is to change the normalization range of the PDF to the union of the ranges. There is a RooAbdPdf interface to suggest that this could be done easily like this:. ```C++. pdf.setNormRange(""range1,range2""). ```. But this doesn't work well for RooAddPdfs, which is probably why it was chosen to implement mulit-range fits as a sum of separate RooNLLVars. But in this case, the PDFs are normalized separately, and extra terms need to be introduced to correct for that. This resulted in lots of complicated code, and still there are issues like #11447, i.e. is still doesn't work for simultaneous fits. That's why I decided to fix the `setNormRange()` for RooAddPdfs, and then starting from that re-implement multi-ranged fits in both the new BatchMode and the old RooFit based on that. . Closes #11447.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11455
https://github.com/root-project/root/issues/11456:284,deployability,version,versions,284,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:284,integrability,version,versions,284,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:431,interoperability,standard,standard,431,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:284,modifiability,version,versions,284,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:29,reliability,doe,does,29,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:392,reliability,doe,does,392,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:696,testability,context,context,696,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:0,usability,Document,Documentation,0,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:162,usability,clear,clear,162,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:305,usability,document,documentation,305,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:327,usability,clear,clearly,327,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/issues/11456:621,usability,document,documentation,621,"Documentation of TH1::GetRMS does not mention the fact that it is not the RMS anymore; ### Is your feature request related to a problem? Please describe. <!--. A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]"". -->. In previous versions of the ROOT documentation, it was clearly mentioned that e.g. `TH1::GetRMS` for historical reasons does not in fact calculate RMS but the standard deviation. Now this section is just empty:. https://root.cern.ch/doc/master/classTH1.html#a8fdcbb1ef23f99d5b28c1f10e947c957. ### Describe the solution you'd like. Re-introduce this documentation. ### Describe alternatives you've considered. ### Additional context.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11456
https://github.com/root-project/root/pull/11457:275,availability,error,error,275,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:536,deployability,observ,observed,536,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:570,deployability,manag,management,570,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:570,energy efficiency,manag,management,570,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:275,performance,error,error,275,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:563,performance,memor,memory,563,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:275,safety,error,error,275,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:570,safety,manag,management,570,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:536,testability,observ,observed,536,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:275,usability,error,error,275,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11457:563,usability,memor,memory,563,[PyROOT] Fixes for garbage collection in Python 3.11; According to the list of changes in Python 3.11:. https://docs.python.org/3.11/whatsnew/3.11.html. types defined with the Py_TPFLAGS_HAVE_GC flag set but with no traverse function (PyTypeObject.tp_traverse) will cause an error. The above is true for a few types that are defined in cppyy. This commit removes the aforementioned flag from those type definitions with no traverse function. It also sets the right flags for the nonified object type; this fixes the teardown GC crashes observed when the internal memory management of ROOT was involved (e.g. the garbage collection of a tree that belongs to a file). This PR fixes https://github.com/root-project/root/issues/10799.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11457
https://github.com/root-project/root/pull/11458:57,reliability,doe,doesn,57,[tutorials] Simplify TMVA_SOFIE_RDataFrame.py.; Probably doesn't even work...,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11458
https://github.com/root-project/root/pull/11458:12,testability,Simpl,Simplify,12,[tutorials] Simplify TMVA_SOFIE_RDataFrame.py.; Probably doesn't even work...,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11458
https://github.com/root-project/root/pull/11458:12,usability,Simpl,Simplify,12,[tutorials] Simplify TMVA_SOFIE_RDataFrame.py.; Probably doesn't even work...,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11458
https://github.com/root-project/root/pull/11459:99,availability,operat,operator,99,[tmva][sofie] Fix ConvTranspose for multiple channels; . This Pull request fixes the COnvTranspose operator when the number of inputs channels is larger than 1.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11459
https://github.com/root-project/root/pull/11459:127,safety,input,inputs,127,[tmva][sofie] Fix ConvTranspose for multiple channels; . This Pull request fixes the COnvTranspose operator when the number of inputs channels is larger than 1.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11459
https://github.com/root-project/root/pull/11459:127,usability,input,inputs,127,[tmva][sofie] Fix ConvTranspose for multiple channels; . This Pull request fixes the COnvTranspose operator when the number of inputs channels is larger than 1.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11459
https://github.com/root-project/root/issues/11460:148,modifiability,scal,scalability,148,"TF2 (with same name) construction can not be made thread safe without taking a lock; In commit 2812b568571a6ff25c72fffe8a1ecd32b7d6f811, we improve scalability of `TF1` creation by adding an explicit parameter to the constructor to allow the user to request ""please do not add to global list"". However this was not applied to the classes derived from `TF1`, i.e. `TF2, TF3, etc.`. Philippe.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11460
https://github.com/root-project/root/issues/11460:200,modifiability,paramet,parameter,200,"TF2 (with same name) construction can not be made thread safe without taking a lock; In commit 2812b568571a6ff25c72fffe8a1ecd32b7d6f811, we improve scalability of `TF1` creation by adding an explicit parameter to the constructor to allow the user to request ""please do not add to global list"". However this was not applied to the classes derived from `TF1`, i.e. `TF2, TF3, etc.`. Philippe.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11460
https://github.com/root-project/root/issues/11460:79,performance,lock,lock,79,"TF2 (with same name) construction can not be made thread safe without taking a lock; In commit 2812b568571a6ff25c72fffe8a1ecd32b7d6f811, we improve scalability of `TF1` creation by adding an explicit parameter to the constructor to allow the user to request ""please do not add to global list"". However this was not applied to the classes derived from `TF1`, i.e. `TF2, TF3, etc.`. Philippe.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11460
https://github.com/root-project/root/issues/11460:148,performance,scalab,scalability,148,"TF2 (with same name) construction can not be made thread safe without taking a lock; In commit 2812b568571a6ff25c72fffe8a1ecd32b7d6f811, we improve scalability of `TF1` creation by adding an explicit parameter to the constructor to allow the user to request ""please do not add to global list"". However this was not applied to the classes derived from `TF1`, i.e. `TF2, TF3, etc.`. Philippe.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11460
https://github.com/root-project/root/issues/11460:57,safety,safe,safe,57,"TF2 (with same name) construction can not be made thread safe without taking a lock; In commit 2812b568571a6ff25c72fffe8a1ecd32b7d6f811, we improve scalability of `TF1` creation by adding an explicit parameter to the constructor to allow the user to request ""please do not add to global list"". However this was not applied to the classes derived from `TF1`, i.e. `TF2, TF3, etc.`. Philippe.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11460
https://github.com/root-project/root/issues/11460:79,security,lock,lock,79,"TF2 (with same name) construction can not be made thread safe without taking a lock; In commit 2812b568571a6ff25c72fffe8a1ecd32b7d6f811, we improve scalability of `TF1` creation by adding an explicit parameter to the constructor to allow the user to request ""please do not add to global list"". However this was not applied to the classes derived from `TF1`, i.e. `TF2, TF3, etc.`. Philippe.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11460
https://github.com/root-project/root/issues/11460:242,usability,user,user,242,"TF2 (with same name) construction can not be made thread safe without taking a lock; In commit 2812b568571a6ff25c72fffe8a1ecd32b7d6f811, we improve scalability of `TF1` creation by adding an explicit parameter to the constructor to allow the user to request ""please do not add to global list"". However this was not applied to the classes derived from `TF1`, i.e. `TF2, TF3, etc.`. Philippe.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11460
https://github.com/root-project/root/pull/11462:72,performance,content,content,72,[cmake] Correct typo in REFLEX_GENERATE_DICTIONARY. ; This corrects the content of https://github.com/root-project/root/commit/6efc1684a62d37ccfa582cbbe3605995201ea7cb [cmake] Protect against empty COMPILE_DEFINITIONS in genreflex command.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11462
https://github.com/root-project/root/pull/11462:231,usability,command,command,231,[cmake] Correct typo in REFLEX_GENERATE_DICTIONARY. ; This corrects the content of https://github.com/root-project/root/commit/6efc1684a62d37ccfa582cbbe3605995201ea7cb [cmake] Protect against empty COMPILE_DEFINITIONS in genreflex command.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11462
https://github.com/root-project/root/pull/11463:35,deployability,build,builds,35,"[readspeed] Fix readspeed in noimt builds; I extracted this commit from #11451 so it can be reviewed and merged on its own, since the nightly builds are affected by this issue.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11463
https://github.com/root-project/root/pull/11463:142,deployability,build,builds,142,"[readspeed] Fix readspeed in noimt builds; I extracted this commit from #11451 so it can be reviewed and merged on its own, since the nightly builds are affected by this issue.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11463
https://github.com/root-project/root/pull/11463:92,safety,review,reviewed,92,"[readspeed] Fix readspeed in noimt builds; I extracted this commit from #11451 so it can be reviewed and merged on its own, since the nightly builds are affected by this issue.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11463
https://github.com/root-project/root/pull/11463:92,testability,review,reviewed,92,"[readspeed] Fix readspeed in noimt builds; I extracted this commit from #11451 so it can be reviewed and merged on its own, since the nightly builds are affected by this issue.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11463
https://github.com/root-project/root/pull/11464:60,availability,operat,operator,60,[tmva][sofie] Fix warning with unused input tensor in Shape operator; Fix a warning when compiling the generated code of the Shape operator.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11464
https://github.com/root-project/root/pull/11464:131,availability,operat,operator,131,[tmva][sofie] Fix warning with unused input tensor in Shape operator; Fix a warning when compiling the generated code of the Shape operator.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11464
https://github.com/root-project/root/pull/11464:38,safety,input,input,38,[tmva][sofie] Fix warning with unused input tensor in Shape operator; Fix a warning when compiling the generated code of the Shape operator.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11464
https://github.com/root-project/root/pull/11464:38,usability,input,input,38,[tmva][sofie] Fix warning with unused input tensor in Shape operator; Fix a warning when compiling the generated code of the Shape operator.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11464
https://github.com/root-project/root/pull/11466:2539,availability,cluster,cluster,2539,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3326,availability,operat,operation,3326,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3405,availability,cluster,cluster,3405,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:188,deployability,contain,containers,188,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2539,deployability,cluster,cluster,2539,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3405,deployability,cluster,cluster,3405,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3420,deployability,updat,updated,3420,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2461,energy efficiency,Current,Currently,2461,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2961,energy efficiency,Load,LoadClusters,2961,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3056,energy efficiency,Load,LoadClusters,3056,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:37,integrability,buffer,buffered,37,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:450,integrability,buffer,buffers,450,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:718,integrability,buffer,buffered,718,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:1992,integrability,buffer,buffers,1992,"g back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all pa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2699,integrability,buffer,buffering,2699,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2791,integrability,wrap,wrapping,2791,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3013,integrability,buffer,buffered,3013,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2213,interoperability,format,format,2213,"e cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:423,performance,I/O,I/O,423,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:658,performance,disk,disk,658,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:752,performance,throughput,throughput,752,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:822,performance,disk,disk,822,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:868,performance,perform,performance,868,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:1680,performance,I/O,I/O,1680,"he option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be access",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2547,performance,cach,caching,2547,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2609,performance,perform,performant,2609,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2961,performance,Load,LoadClusters,2961,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3056,performance,Load,LoadClusters,3056,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3304,performance,perform,perform,3304,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:733,safety,avoid,avoids,733,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3367,safety,test,tested,3367,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3420,safety,updat,updated,3420,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2676,security,access,accessed,2676,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2980,security,access,accessing,2980,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3420,security,updat,updated,3420,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:307,testability,unit,unit,307,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2485,testability,plan,plans,2485,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3367,testability,test,tested,3367,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:82,usability,support,support,82,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:868,usability,perform,performance,868,"[ntuple,daos] Page concatenation for buffered page-groups; This pull request adds support for the concatenation of RNTuple pages into 'cages' that are then written to, and read from, DAOS containers as a single value of the key-value object store under the same attribute key, thus the smallest addressable unit. Pages from the same page-group are concatenated in the order they are handled on the DAOS side through vector I/O from the sealed pages' buffers. The name 'cage' is a portmanteau of ""concatenated pages"" and suggests the fact that pages caged together must be read together in DAOS. This change emancipates the DAOS backend from the original, on-disk ntuple page size. The option to concatenate sealed and buffered pages avoids unnecessary throughput constraints caused by the original page size (e.g., the on-disk default, 64KiB, generally leads to lower performance than pages an order of magnitude larger, e.g. 1MiB), particularly if the pattern of data analysis is based on reading back entire page-group ranges at once. On the other hand, this change ties the reader to the new, concatenated sizes; in DAOS key-value stores, it is impossible to read only a part of the value. It is important that the cage size limit be set adequately for the use-case during writing to DAOS. ## Changes or fixes:. - `RNTupleWriteOptions` provides a way to `SetMaxCageSize()` (default: caging enabled with 1 MiB cages), the maximum size a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2501,usability,support,support,2501,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:2609,usability,perform,performant,2609,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11466:3304,usability,perform,perform,3304,"a concatenation of pages from the same page-group can achieve. - `RPageSinkDaos::CommitSealedPageVImpl()` maps pages from the same page-group to the same attribute key, thus concatenating them on the DAOS-side (i.e. relies on scatter-gathered I/O) until the cage limit is reached. The cage sizes can vary due to page compression and the length of page-groups, thus it is calculated and stored to be referenced when reading back. - `RWOperation` is generalized to allow many IOVs associated with one attribute key in a request, enabling the non-contiguous buffers of sealed pages to be aggregated into a cage under the same position ID in the object store. . - `RNTupleLocator`: leverages the changes introduced by PR #11828; all DAOS locators use the type `kDaos` and payload format `RNTupleLocatorObject64`. To locate pages within a cage, the 64-bit payload encodes the cage index in the LS half and the offset in the MS half. If caging is disabled, the offset remains zero, and each 'cage' is trivially the sealed page. - Currently, there are no plans to enable support for page-wise reading without cluster caching if the desired page is caged, as that use-case is not performant and thus not recommended. Caged pages in DAOS should be accessed with the page buffering read option turned on. By disallowing the reading of a single caged page when the wrapping cage size is unknown, the cage sizes - or upper bounds for them - do not need to be passed to `RPageSourceDaos`; they are trivially devised in `RPageSourceDaos::LoadClusters()` by accessing all page locators in a buffered page-group. . - `RPageSourceDaos::LoadClusters()` and `RPageSourceDaos::PopulatePageFromCluster()` extract the cage position and offset-in-cage from each sealed page's `RNTupleLocator::fPosition`. The former function has been changed to coalesce the page locators by cage index and perform a single read operation per cage. ## Checklist:. - [x] tested changes locally + HPE `delphi` cluster. - [x] updated the docs.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11466
https://github.com/root-project/root/pull/11467:9,deployability,updat,update,9,[jsroot] update three.js to r145; Fix two bugs with composite shape in jsroot. Adjust eve7 code.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11467
https://github.com/root-project/root/pull/11467:52,deployability,compos,composite,52,[jsroot] update three.js to r145; Fix two bugs with composite shape in jsroot. Adjust eve7 code.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11467
https://github.com/root-project/root/pull/11467:52,modifiability,compos,composite,52,[jsroot] update three.js to r145; Fix two bugs with composite shape in jsroot. Adjust eve7 code.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11467
https://github.com/root-project/root/pull/11467:9,safety,updat,update,9,[jsroot] update three.js to r145; Fix two bugs with composite shape in jsroot. Adjust eve7 code.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11467
https://github.com/root-project/root/pull/11467:9,security,updat,update,9,[jsroot] update three.js to r145; Fix two bugs with composite shape in jsroot. Adjust eve7 code.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11467
https://github.com/root-project/root/pull/11468:84,deployability,modul,modules,84,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:622,deployability,patch,patch,622,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:495,energy efficiency,model,model,495,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:645,energy efficiency,current,current,645,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:361,interoperability,semant,semantically,361,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:84,modifiability,modul,modules,84,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:333,performance,time,time,333,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:84,safety,modul,modules,84,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:622,safety,patch,patch,622,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:495,security,model,model,495,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:607,security,modif,modifier,607,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:622,security,patch,patch,622,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:742,security,control,control,742,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:742,testability,control,control,742,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11468:408,usability,user,user,408,"gcc12's regex header file relies on a std::vector<int> instance, export it; The C++ modules marks the std::vector<int> instantiation as not visible because it came from the `regex` header file which we did not explicitly include. root-project/root@a785402 introduces checks if certain declaration is visible in dictionary generation time which was intending to semantically improve the coherence by what the user ""allowed"" (or requested) rootcling to see vs what it can see globally. While this model works well it seems to not work for template instantiations as they won't be re-instantiated with visible modifier. This patch works around the current issue seen with libstdc++ 12 but a better solution would be to implement a finer grained control over the implicit template instatiations when generating a dictionary. Fixes root-project/root#11329.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11468
https://github.com/root-project/root/pull/11470:252,availability,operat,operator,252,"[DF] Fix RDF compilation with gcc < 7.3; Before gcc 7.3 there is an issue passing a non-movable pair<string, unique_ptr<T>> into unordered_map::insert. A standalone reproducer is at https://godbolt.org/z/1ror6sqPx . This patch works around it by using operator[] + assignment instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11470
https://github.com/root-project/root/pull/11470:221,deployability,patch,patch,221,"[DF] Fix RDF compilation with gcc < 7.3; Before gcc 7.3 there is an issue passing a non-movable pair<string, unique_ptr<T>> into unordered_map::insert. A standalone reproducer is at https://godbolt.org/z/1ror6sqPx . This patch works around it by using operator[] + assignment instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11470
https://github.com/root-project/root/pull/11470:221,safety,patch,patch,221,"[DF] Fix RDF compilation with gcc < 7.3; Before gcc 7.3 there is an issue passing a non-movable pair<string, unique_ptr<T>> into unordered_map::insert. A standalone reproducer is at https://godbolt.org/z/1ror6sqPx . This patch works around it by using operator[] + assignment instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11470
https://github.com/root-project/root/pull/11470:221,security,patch,patch,221,"[DF] Fix RDF compilation with gcc < 7.3; Before gcc 7.3 there is an issue passing a non-movable pair<string, unique_ptr<T>> into unordered_map::insert. A standalone reproducer is at https://godbolt.org/z/1ror6sqPx . This patch works around it by using operator[] + assignment instead.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11470
https://github.com/root-project/root/issues/11473:146,availability,error,error,146,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:35,deployability,version,version,35,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:79,deployability,instal,install,79,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:93,deployability,version,version,93,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:35,integrability,version,version,35,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:93,integrability,version,version,93,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:35,modifiability,version,version,35,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:93,modifiability,version,version,93,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:146,performance,error,error,146,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:131,safety,detect,detection,131,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:146,safety,error,error,146,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:131,security,detect,detection,131,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:146,usability,error,error,146,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:206,usability,user,user-images,206,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/issues/11473:320,usability,user,user-images,320,Bitdefender found a virus in WIN64 version of Root 6.26; Unfortunately I can't install Win64 version of Root 6.26 becasue of virus detection. See error during unzip and Btdefender report. ![error1](https://user-images.githubusercontent.com/75624059/193414303-f5b7d9c8-4837-431d-b7e2-e7f04c94e34b.JPG). ![error2](https://user-images.githubusercontent.com/75624059/193414309-ece88fe7-b75c-47ce-ac39-620b567ba7b3.JPG).,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11473
https://github.com/root-project/root/pull/11474:98,deployability,depend,depends,98,"[cling] Add initial readthedocs-based documentation for cling.; Move root-project/cling#469. This depends on PR #11360. cc: @sarabellei, @davidlange6",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11474
https://github.com/root-project/root/pull/11474:98,integrability,depend,depends,98,"[cling] Add initial readthedocs-based documentation for cling.; Move root-project/cling#469. This depends on PR #11360. cc: @sarabellei, @davidlange6",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11474
https://github.com/root-project/root/pull/11474:98,modifiability,depend,depends,98,"[cling] Add initial readthedocs-based documentation for cling.; Move root-project/cling#469. This depends on PR #11360. cc: @sarabellei, @davidlange6",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11474
https://github.com/root-project/root/pull/11474:98,safety,depend,depends,98,"[cling] Add initial readthedocs-based documentation for cling.; Move root-project/cling#469. This depends on PR #11360. cc: @sarabellei, @davidlange6",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11474
https://github.com/root-project/root/pull/11474:98,testability,depend,depends,98,"[cling] Add initial readthedocs-based documentation for cling.; Move root-project/cling#469. This depends on PR #11360. cc: @sarabellei, @davidlange6",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11474
https://github.com/root-project/root/pull/11474:38,usability,document,documentation,38,"[cling] Add initial readthedocs-based documentation for cling.; Move root-project/cling#469. This depends on PR #11360. cc: @sarabellei, @davidlange6",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11474
https://github.com/root-project/root/pull/11475:741,availability,redund,redundantly,741,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:741,deployability,redundan,redundantly,741,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:784,energy efficiency,model,models,784,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:722,integrability,event,events,722,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:235,modifiability,variab,variable,235,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:288,modifiability,variab,variables,288,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:443,modifiability,variab,variable,443,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:741,reliability,redundan,redundantly,741,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:132,safety,isol,isolation,132,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:178,safety,isol,isolation,178,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:432,safety,isol,isolation,432,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:741,safety,redund,redundantly,741,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:774,safety,isol,isolation,774,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:132,security,iso,isolation,132,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:178,security,iso,isolation,178,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:227,security,control,control,227,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:432,security,iso,isolation,432,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:774,security,iso,isolation,774,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:784,security,model,models,784,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:132,testability,isol,isolation,132,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:178,testability,isol,isolation,178,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:227,testability,control,control,227,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:432,testability,isol,isolation,432,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/pull/11475:774,testability,isol,isolation,774,"[RF] Fix tutorial for `RooStats::SPlot`; The tutorial is actually using the SPlots class wrong. It is calculating. sWeights for the isolation based on the invariant mass and the isolation. itself. Thats wrong. For sPlots, the control variable should not be in. the set of discriminating variables for the likelihood fit! See. https://arxiv.org/pdf/physics/0402083.pdf. That means when using the SPlot class, you should exclude the isolation. variable from the dataset that you pass. Big thanks to Dongliang for reporting this on the ROOT Forum! https://root-forum.cern.ch/t/strange-results-in-rs301-splot-c. A second commit applies some other improvements to the tutorial:. * Code modernization. * Don't define number of events in toy data redundantly. * Add also plots of isolation models",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11475
https://github.com/root-project/root/issues/11476:38,availability,error,errors,38,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:449,deployability,observ,observables,449,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:982,deployability,observ,observed,982,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:138,energy efficiency,model,model,138,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:38,performance,error,errors,38,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:38,safety,error,errors,38,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:493,safety,test,testProdOfSum,493,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:1272,safety,test,test,1272,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:1370,safety,test,test,1370,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:138,security,model,model,138,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:449,testability,observ,observables,449,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:493,testability,test,testProdOfSum,493,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:958,testability,context,context,958,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:982,testability,observ,observed,982,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:1267,testability,unit,unit,1267,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:1272,testability,test,test,1272,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:1365,testability,unit,unit,1365,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:1370,testability,test,test,1370,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:38,usability,error,errors,38,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/issues/11476:317,usability,behavi,behavior,317,"[RF] RooAddPdf still emits unexpected errors about missing normalization sets; ### Describe the bug. If you generate a toy dataset from a model that is a product of sums, you still get the `Evaluating RooAddPdf without a defined normalization set` warnings, even though the normalization set is defined. ### Expected behavior. There should be no such warnings, because the normalization set is defined. When you generate toy data for a given set of observables. ### To Reproduce. ```c++. void testProdOfSum(). {. RooWorkspace ws{""ws""};. ws.factory(""Gaussian::gs(x[0,10], mu[2, 0, 10], sg[2, 0.1, 10])"");. ws.factory(""Exponential::ex(x, lm[-0.1, -10, 0])"");. ws.factory(""SUM::gs_ex(f[0.5, 0, 1] * gs, ex)"");. ws.factory(""Gaussian::gs_1(x, mu_1[4, 0, 10], sg_1[2, 0.1, 10])"");. ws.factory(""PROD::pdf(gs_1, gs_ex)"");. std::unique_ptr<RooDataSet>data{ws.pdf(""pdf"")->generate(*ws.var(""x""), 10000)};. }. ```. ### Setup. ROOT `master` on Arch Linux. ### Additional context. This issue was observed when running the reproducer code from the related JIRA issues [ROOT-9436](https://sft.its.cern.ch/jira/browse/ROOT-9436) and [ROOT-10483](https://sft.its.cern.ch/jira/browse/ROOT-10483). If this GitHub issue is fixed, this should also be taken as a opportunity to implement a unit test that covers the linked JIRA issues, which was already fixed in 6.24 but there is yet no unit test that covers it. There are also two more JIRA issues that might be related to this one:. * https://sft.its.cern.ch/jira/browse/ROOT-9649 (*by now, it was checked that it's unrelated*). * https://sft.its.cern.ch/jira/browse/ROOT-10814 (*by now, it was checked that it's unrelated*).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11476
https://github.com/root-project/root/pull/11477:312,energy efficiency,load,loading,312,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:421,energy efficiency,load,loadValues,421,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:464,energy efficiency,reduc,reduce,464,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:489,energy efficiency,reduc,reduction,489,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:630,energy efficiency,load,load,630,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:116,integrability,buffer,buffers,116,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:174,integrability,buffer,buffers,174,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:199,integrability,buffer,buffers,199,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:243,integrability,buffer,buffers,243,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:331,integrability,buffer,buffers,331,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:536,integrability,buffer,buffers,536,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:664,integrability,buffer,buffers,664,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:312,performance,load,loading,312,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:421,performance,load,loadValues,421,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:630,performance,load,load,630,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:733,performance,perform,performance,733,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:745,performance,overhead,overhead,745,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:766,safety,safe,safeter,766,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:967,safety,test,test,967,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:962,testability,unit,unit,962,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:967,testability,test,test,967,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11477:733,usability,perform,performance,733,"[RF] Make no distinction in VectorDataStore between `get` and getNative; The `RooVectorDataStore` had two different buffers to store the row data in: the so-called ""attached buffers"" and the ""native buffers"". The problem is that when external buffers are attached, the call to `RooVectorDataStore::get()` is not loading the native buffers anymore, which is breaking some code that assumes this, like `RooVectorDataStore::loadValues`, which is used in `RooDataSet::reduce`. This breaks the reduction of datasets with externally attached buffers, which breaks the copy constructor of the `RooNLLVar`. This commit suggests to always load both the native and attached buffers if `RooVectorDataStore::get()` is called. This has almost no performance overhead and is much safeter. Since this change fixes the copy constructor of the `RooNLLVar`, which is used when plotting the NLL, this commit fixes this JIRA ticket: https://sft.its.cern.ch/jira/browse/ROOT-9752. A unit test that covers the problem reported in the JIRA ticket is also added.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11477
https://github.com/root-project/root/pull/11478:18,availability,error,error,18,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:64,availability,error,error,64,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:109,availability,error,error,109,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:135,interoperability,convers,conversion,135,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:198,interoperability,convers,conversion,198,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:18,performance,error,error,18,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:64,performance,error,error,64,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:109,performance,error,error,109,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:18,safety,error,error,18,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:64,safety,error,error,64,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:109,safety,error,error,109,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:18,usability,error,error,18,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:64,usability,error,error,64,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11478:109,usability,error,error,109,"Fix a compilation error on Win64; Fix the following compilation error on Win64:. ```. ReadSpeed.cxx(334,89): error C2398: Element '1': conversion from 'unsigned __int64' to 'T' requires a narrowing conversion. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11478
https://github.com/root-project/root/pull/11480:1846,availability,cluster,cluster,1846,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:43,deployability,contain,container,43,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:90,deployability,manag,management,90,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:113,deployability,contain,container,113,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:187,deployability,contain,container,187,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:268,deployability,contain,container,268,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:507,deployability,contain,container-wide,507,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:991,deployability,contain,container,991,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1159,deployability,fail,fail,1159,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1732,deployability,contain,container,1732,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1846,deployability,cluster,cluster,1846,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1897,deployability,updat,updated,1897,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:90,energy efficiency,manag,management,90,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:394,integrability,sub,subspace,394,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:808,interoperability,distribut,distributed,808,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:130,modifiability,exten,extending,130,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1549,modifiability,reu,reused,1549,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1159,reliability,fail,fail,1159,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:90,safety,manag,management,90,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1416,safety,valid,validate,1416,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1477,safety,except,exception,1477,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1534,safety,valid,validation,1534,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1638,safety,test,test,1638,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1821,safety,test,tested,1821,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1897,safety,updat,updated,1897,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:780,security,hash,hashes,780,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1044,security,hash,hash,1044,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1188,security,hash,hash,1188,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1416,security,validat,validate,1416,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1534,security,validat,validation,1534,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1897,security,updat,updated,1897,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:872,testability,simpl,simplify,872,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1323,testability,context,context,1323,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1633,testability,Unit,Unit,1633,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1638,testability,test,test,1638,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1643,testability,coverag,coverage,1643,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:1821,testability,test,tested,1821,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:14,usability,Support,Support,14,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:140,usability,support,support,140,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:222,usability,Support,Support,222,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11480:872,usability,simpl,simplify,872,"[ntuple,daos] Support multiple ntuples per container; This pull request introduces ntuple management at the DAOS container level, extending support for more than one ntuple to populate a container. ## Changes or fixes:. - Support for up to 2\^32 - 1 ntuples in a DAOS container, by assigning an index to a previously-unused portion of the DAOS Object ID address space. The index thus induces a subspace dedicated for all objects belonging to a given ntuple. The zeroth space (index `0`) is reserved for any container-wide metadata objects that may need to be stored in the future. - `ROOT::Experimental::Detail::RDaosContainerNTupleLocator` is a structure that concentrates the functionality for locating and retrieving stored metadata from an ntuple by its name. - The structure hashes the name into a well-distributed 32-bit index. Collisions are expressly forbidden to simplify implementation; a different ntuple name must be provided to the sink upon creation if an ntuple stored in the container with another name happens to have the same hash (index). - The sink (in `RPageSinkDaos` ctor) uses the locator to assign an index for a new ntuple, which may fail if the name's resulting hash collides with some other ntuple present unless the name matches. Overwriting (""recreating"") an existing ntuple is allowed in this context. - The source (in `RPageSourceDaos::AttachImpl()`) locates the ntuple by the name to validate that it is indeed present in storage (otherwise, an exception is thrown). The objects that are read for this validation are reused as part of the ntuple metadata deserialization procedure when attaching. . - Unit test coverage is provided for the following cases: write and read from different ntuples in a container; and attempt to open an ntuple that was not stored there. ## Checklist:. - [x] tested changes locally + cluster on single client with libdaos 2.2.0. - [x] updated the docs (if necessary). This PR fixes #10958.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11480
https://github.com/root-project/root/pull/11481:41,availability,operat,operators,41,"[tmva][sofie] Move parser definition for operators in implementation; Move definition of free function defining the parser operator functions in the implementation, since these are only for internal use. This should fix some of the issues seen when using PCH.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11481
https://github.com/root-project/root/pull/11481:123,availability,operat,operator,123,"[tmva][sofie] Move parser definition for operators in implementation; Move definition of free function defining the parser operator functions in the implementation, since these are only for internal use. This should fix some of the issues seen when using PCH.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11481
https://github.com/root-project/root/issues/11482:2214,availability,Operat,Operating,2214,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:2289,availability,down,download,2289,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:76,deployability,observ,observable,76,"[RF] `plotSamplingHint` can cause evaluation outside the ""safe"" range of an observable; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:731,deployability,contain,contains,731,"[RF] `plotSamplingHint` can cause evaluation outside the ""safe"" range of an observable; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1182,deployability,contain,contains,1182,"oot/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1696,deployability,build,build,1696,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:2202,deployability,version,version,2202,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:2271,deployability,instal,install,2271,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:654,energy efficiency,optim,optimal,654,"[RF] `plotSamplingHint` can cause evaluation outside the ""safe"" range of an observable; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1133,energy efficiency,current,current,1133," in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:2160,energy efficiency,Draw,Draw,2160,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:2202,integrability,version,version,2202,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:2202,modifiability,version,version,2202,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:58,safety,safe,safe,58,"[RF] `plotSamplingHint` can cause evaluation outside the ""safe"" range of an observable; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:962,safety,safe,safe,962,"[RF] `plotSamplingHint` can cause evaluation outside the ""safe"" range of an observable; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1650,safety,input,input,1650,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1751,safety,test,testRooHistPdfBinning,1751,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:76,testability,observ,observable,76,"[RF] `plotSamplingHint` can cause evaluation outside the ""safe"" range of an observable; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1751,testability,test,testRooHistPdfBinning,1751,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:2379,testability,context,context,2379,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:2408,testability,context,context,2408,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:478,usability,clear,clear,478,"[RF] `plotSamplingHint` can cause evaluation outside the ""safe"" range of an observable; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:526,usability,behavi,behavior,526,"[RF] `plotSamplingHint` can cause evaluation outside the ""safe"" range of an observable; - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """",",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1092,usability,stop,stop,1092,"Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, h",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1275,usability,behavi,behavior,1275,"OOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install`",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1293,usability,clear,clear,1293,"g reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary downloa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1505,usability,behavi,behavior,1505,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11482:1650,usability,input,input,1650,"->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. When plotting a RooFit function the `RooCurve` will try to use the `plotSamplingHint` method to get a list of optimal point locations. When using a `RooHistPdf` or `RooHistFunc` the list contains points a little (~1e-8*range) before and after each bin boundary. . If the bins are aligned to the range (as they often are), one point per side falls outside the range. However, there is no guarantee that the function is safe to execute there, so this may cause a NaN to be inserted in the plot. Furthermore, when this happens the `RooCurve` seems to stop collecting points and just uses the current list, which in case of an histogram only contains the bin boundaries, meaning that the curve is not smooth between bins. ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The function is evaluated only in range, no NaN in frame, smooth function between bin boundaries. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```C++. void testRooHistPdfBinning() {. RooRealVar x(""x"", """", 0., 1);. . RooGenericPdf sqrtPdf(""sqrtPdf"", ""sqrt(x)"", x);. . TH1F h(""h"", """", 2, 0., 1);. h.Fill(0.2, 2);. h.Fill(0.8, 1);. RooDataHist dh(""dh"", """", x, RooFit::Import(h));. RooHistPdf hpdf(""hpdf"", """", x, dh);. . RooRealVar frac(""frac"", """", 0.5, 0, 1);. RooAddPdf p(""p"", """", RooArgSet(sqrtPdf, hpdf), frac);. . auto frame = x.frame();. p.plotOn(frame);. frame->Draw();. }. ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. Centos7, ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11482
https://github.com/root-project/root/issues/11483:681,availability,Error,Error,681,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:776,availability,Error,Error,776,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:872,availability,Error,Error,872,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:636,energy efficiency,Current,Current,636,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:699,energy efficiency,Load,LoadTree,699,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:794,energy efficiency,Load,LoadTree,794,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:890,energy efficiency,Load,LoadTree,890,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:681,performance,Error,Error,681,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:699,performance,Load,LoadTree,699,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:776,performance,Error,Error,776,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:794,performance,Load,LoadTree,794,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:872,performance,Error,Error,872,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:890,performance,Load,LoadTree,890,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:81,reliability,doe,does,81,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:681,safety,Error,Error,681,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:776,safety,Error,Error,776,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:872,safety,Error,Error,872,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:1119,safety,valid,valid,1119,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:644,usability,behavi,behaviour,644,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:681,usability,Error,Error,681,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:776,usability,Error,Error,776,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:872,usability,Error,Error,872,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:1195,usability,minim,minimal,1195,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11483:1397,usability,behavi,behaviour,1397,"Cannot use globs with `?#` syntax in TChain::Add; As the title reads: TChain Add does not properly resolve globs with `?#`. Consider:. ```cpp. auto dfWriter0 = ROOT::RDataFrame(5).Define(""z"", ""42"");. dfWriter0.Snapshot<int>(""tree"", ""specTestFile0.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile00.root"", {""z""});. dfWriter0.Snapshot<int>(""tree"", ""specTestFile000.root"", {""z""});. TChain c{};. c.Add(""specTestFile0*.root?#tree"");. for(auto i = 0u; i < c.GetEntries(); ++i). 	c.GetEntry(i);. gSystem->Unlink((""specTestFile0.root""));. gSystem->Unlink((""specTestFile00.root""));. gSystem->Unlink((""specTestFile000.root""));. ```. Current behaviour --> invalid parsing:. ```. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile0.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile00.root#tree. Error in <TChain::LoadTree>: Cannot find tree with name in file [...]/specTestFile000.root#tree. ```. . @vepadulano and I just saw [here](https://root.cern/doc/master/classTChain.html#a78a896924ac6c7d3691b7e013bcbfb1c) that the question mark is a valid wildcard in the glob expansion of `Add`. Note that in this particular minimal reproducer, I can alternatively use:. ```cpp. TChain c{""tree""};. c.Add(""specTestFile0*.root"");. ```. I used precisely this example in order to show that even a single `Add` results in undesired behaviour.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11483
https://github.com/root-project/root/issues/11484:301,availability,down,down,301,roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; The test roottest/root/meta/genreflex/ROOT-5768 currently include `boost` header files and thus is disable. This test the `--interpreteronly` flag of genreflex. See https://sft.its.cern.ch/jira/browse/ROOT-5768. The test needs to be trimmed down to no longer include the boost header files OR rewritten without them.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11484
https://github.com/root-project/root/issues/11484:108,energy efficiency,current,currently,108,roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; The test roottest/root/meta/genreflex/ROOT-5768 currently include `boost` header files and thus is disable. This test the `--interpreteronly` flag of genreflex. See https://sft.its.cern.ch/jira/browse/ROOT-5768. The test needs to be trimmed down to no longer include the boost header files OR rewritten without them.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11484
https://github.com/root-project/root/issues/11484:64,safety,test,test,64,roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; The test roottest/root/meta/genreflex/ROOT-5768 currently include `boost` header files and thus is disable. This test the `--interpreteronly` flag of genreflex. See https://sft.its.cern.ch/jira/browse/ROOT-5768. The test needs to be trimmed down to no longer include the boost header files OR rewritten without them.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11484
https://github.com/root-project/root/issues/11484:173,safety,test,test,173,roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; The test roottest/root/meta/genreflex/ROOT-5768 currently include `boost` header files and thus is disable. This test the `--interpreteronly` flag of genreflex. See https://sft.its.cern.ch/jira/browse/ROOT-5768. The test needs to be trimmed down to no longer include the boost header files OR rewritten without them.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11484
https://github.com/root-project/root/issues/11484:276,safety,test,test,276,roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; The test roottest/root/meta/genreflex/ROOT-5768 currently include `boost` header files and thus is disable. This test the `--interpreteronly` flag of genreflex. See https://sft.its.cern.ch/jira/browse/ROOT-5768. The test needs to be trimmed down to no longer include the boost header files OR rewritten without them.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11484
https://github.com/root-project/root/issues/11484:64,testability,test,test,64,roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; The test roottest/root/meta/genreflex/ROOT-5768 currently include `boost` header files and thus is disable. This test the `--interpreteronly` flag of genreflex. See https://sft.its.cern.ch/jira/browse/ROOT-5768. The test needs to be trimmed down to no longer include the boost header files OR rewritten without them.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11484
https://github.com/root-project/root/issues/11484:173,testability,test,test,173,roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; The test roottest/root/meta/genreflex/ROOT-5768 currently include `boost` header files and thus is disable. This test the `--interpreteronly` flag of genreflex. See https://sft.its.cern.ch/jira/browse/ROOT-5768. The test needs to be trimmed down to no longer include the boost header files OR rewritten without them.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11484
https://github.com/root-project/root/issues/11484:276,testability,test,test,276,roottest/root/meta/genreflex/ROOT-5768 needs to be enabled; The test roottest/root/meta/genreflex/ROOT-5768 currently include `boost` header files and thus is disable. This test the `--interpreteronly` flag of genreflex. See https://sft.its.cern.ch/jira/browse/ROOT-5768. The test needs to be trimmed down to no longer include the boost header files OR rewritten without them.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11484
https://github.com/root-project/root/pull/11485:293,availability,redund,redundant,293,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:293,deployability,redundan,redundant,293,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:222,integrability,compon,components,222,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:222,interoperability,compon,components,222,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:222,modifiability,compon,components,222,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:293,reliability,redundan,redundant,293,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:25,safety,test,tests,25,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:108,safety,test,tests,108,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:293,safety,redund,redundant,293,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:20,testability,unit,unit,20,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:25,testability,test,tests,25,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:103,testability,unit,unit,103,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:108,testability,test,tests,108,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/pull/11485:190,usability,custom,custom,190,[RF] More fixes and unit tests related to the RooAddPdf normalization; The commit implements a few new unit tests and also fixes one bug related to the normalization of a RooAddPdf when the custom normalization set of its components is reset. There is also some code improvement by removing a redundant data member of the `RooAddPdf` and `RooAddModel` classes. More details in the commit descriptions.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11485
https://github.com/root-project/root/issues/11486:53,deployability,depend,depend,53,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:311,deployability,depend,depend,311,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:1627,deployability,continu,continue,1627,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:53,integrability,depend,depend,53,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:311,integrability,depend,depend,311,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:53,modifiability,depend,depend,53,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:311,modifiability,depend,depend,311,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:1390,performance,cach,caching,1390,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:53,safety,depend,depend,53,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:311,safety,depend,depend,311,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:455,safety,test,test,455,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:464,safety,test,testRooProdPdf,464,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:53,testability,depend,depend,53,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:311,testability,depend,depend,311,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:450,testability,unit,unit,450,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:455,testability,test,test,455,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:464,testability,test,testRooProdPdf,464,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:595,testability,context,context,595,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:871,testability,verif,verified,871,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:263,usability,behavi,behavior,263,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11486:1211,usability,help,helpful,1211,"[RF] Values of RooProdPdfs in a RooAbsPdf should not depend on its factors `normRange()`; ### Describe the bug. If a RooProdPdf is in a RooAddPdf, its values change if one changes the normalization range of its factors with `RooAbsPdf::normRange()`. ### Expected behavior. The values of a RooProdPdf should not depend on the `normRange()` of its factors, because the RooProdPdf is responsible for normalizing itself. ### To Reproduce. Enable the new unit test in `testRooProdPdf` shipped with https://github.com/root-project/root/pull/11485. ### Setup. ROOT master on Arch Linux. ### Additional context. It is important now to fix the issues related to the `RooAbsPdf::normRange()` feature, because as of https://github.com/root-project/root/pull/11455 it is used in multi-range fits. Thus, we need to make sure it's less fragile. After this issue is fixed, it should be verified with `stressRooFit` that things would still work if one were to set the normalization ranges of all PDFs in the computation graph in [RooAbsOptTestStatistic::initSlave()](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx#L294) not just the top-level PDF:. For debugging, it could be helpful to replace the RooProdPdfs with `RooFixedProdPdf` objects, which explicitly represent the conputation graph of a RooProdPdf for a given normalization set without internal caching:. ```C++. if(auto prodPdf = dynamic_cast<RooProdPdf *>(pdf)) {. auto normalizedPdf = std::make_unique<RooFixedProdPdf>(*prodPdf, currNormSet);. replaceArg(*normalizedPdf, *pdf);. newNodes.emplace_back(std::move(normalizedPdf));. continue;. }. ```.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11486
https://github.com/root-project/root/issues/11487:379,deployability,automat,automatically,379,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:774,integrability,compon,component,774,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:1107,integrability,compon,component,1107,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:774,interoperability,compon,component,774,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:1107,interoperability,compon,component,1107,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:273,modifiability,variab,variable,273,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:621,modifiability,variab,variables,621,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:718,modifiability,variab,variable,718,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:774,modifiability,compon,component,774,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:1051,modifiability,variab,variable,1051,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:1107,modifiability,compon,component,1107,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:1349,safety,compl,completely,1349,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:1378,safety,input,input,1378,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:1349,security,compl,completely,1349,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:159,testability,simul,simultaneous,159,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:379,testability,automat,automatically,379,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:578,testability,simul,simultaneous-template-fit-on-two-different-variables,578,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:1492,testability,context,context,1492,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:318,usability,command,command,318,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:340,usability,user,users,340,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:407,usability,behavi,behavior,407,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/issues/11487:1378,usability,input,input,1378,"[RF] Weights are lost when importing two weighted RooDataSets into one; ### Describe the bug. If one combines two weighted datasets to a new dataset meant for simultaneous fits, the weight information is unexpectedly lost. This can be circumvented by creating a new weight variable and using the `RooFit::WeightVar()` command argument, but users expect that this gets dealt with automatically. ### Expected behavior. The new RooDataSet should also be weighted. ### To Reproduce. Run the code I wrote as an answer to a question on the forum:. https://root-forum.cern.ch/t/roofit-simultaneous-template-fit-on-two-different-variables/51774/3. Replace this part:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooRealVar w(""weight"", ""weight"", 1.0);. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}}),. WeightVar(""weight"")};. ```. with this:. ```c++. // A bit annoying, but we have to create a weight variable ourselves to. // transfer the weights from the component datsets. RooDataSet data{. ""data"",. ""data"",. {x, w},. Index(category),. Import({{""cat1"", data1.get()}, {""cat2"", data2.get()}})};. ```. When the `WeightVar` argument is removed, the combined dataset is not weighted anymore, which is completely unexpected as the input datasets have the same layout and are both weighted. ### Setup. ROOT `master` on Arch Linux. ### Additional context. -",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11487
https://github.com/root-project/root/pull/11488:106,deployability,fail,failing,106,[skip-ci][Windows] Fix root-config.bat; Fix the output of `root-config.bat` that makes several TMVA tests failing due to extra spaces.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11488
https://github.com/root-project/root/pull/11488:106,reliability,fail,failing,106,[skip-ci][Windows] Fix root-config.bat; Fix the output of `root-config.bat` that makes several TMVA tests failing due to extra spaces.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11488
https://github.com/root-project/root/pull/11488:100,safety,test,tests,100,[skip-ci][Windows] Fix root-config.bat; Fix the output of `root-config.bat` that makes several TMVA tests failing due to extra spaces.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11488
https://github.com/root-project/root/pull/11488:100,testability,test,tests,100,[skip-ci][Windows] Fix root-config.bat; Fix the output of `root-config.bat` that makes several TMVA tests failing due to extra spaces.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11488
https://github.com/root-project/root/pull/11490:88,interoperability,platform,platforms,88,Add missing import to TMVA pythonizations; This should fix the breakage seen across all platforms.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11490
https://github.com/root-project/root/issues/11492:43,deployability,fail,fails,43,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:80,deployability,modul,modules,80,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:258,deployability,modul,module,258,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:421,deployability,depend,dependent,421,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:431,deployability,modul,module,431,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:421,integrability,depend,dependent,421,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:186,interoperability,specif,specific,186,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:80,modifiability,modul,modules,80,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:258,modifiability,modul,module,258,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:421,modifiability,depend,dependent,421,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:431,modifiability,modul,module,431,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:43,reliability,fail,fails,43,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:80,safety,modul,modules,80,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:258,safety,modul,module,258,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:421,safety,depend,dependent,421,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:431,safety,modul,module,431,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11492:421,testability,depend,dependent,421,"More Dictionary generation of some classes fails on gcc12 due to hiddne decl in modules; The issue described in https://github.com/root-project/root/issues/11329 was work-around for the specific case of `std::vector<int>` being an hidden decl in the `regex` module (in #11468). However, this same problem can (will?) happen to any arbitrary class whose decl just happens to be already present as a ""hidden"" decl inside a dependent module.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11492
https://github.com/root-project/root/issues/11494:666,availability,state,statement,666,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1298,availability,error,error,1298,", in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1340,availability,error,error,1340,"f exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2986,availability,error,error,2986,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:282,deployability,resourc,resources,282,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:325,deployability,releas,released,325,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:516,deployability,depend,dependent,516,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1022,deployability,contain,contains,1022," function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __lib",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2828,deployability,build,build-foo,2828,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:282,energy efficiency,resourc,resources,282,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1490,energy efficiency,alloc,allocated-when-adding-rresultptr-to-vector,1490,"o be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1667,energy efficiency,optim,optimized,1667,"ent as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1818,energy efficiency,optim,optimized,1818,"86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/c",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2456,energy efficiency,optim,optimized,2456,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2567,energy efficiency,alloc,allocator,2567,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:3014,energy efficiency,core,core,3014,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:516,integrability,depend,dependent,516,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:666,integrability,state,statement,666,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:154,interoperability,specif,specifically,154,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:516,modifiability,depend,dependent,516,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:282,performance,resourc,resources,282,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1298,performance,error,error,1298,", in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1340,performance,error,error,1340,"f exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1667,performance,optimiz,optimized,1667,"ent as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1818,performance,optimiz,optimized,1818,"86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/c",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2456,performance,optimiz,optimized,2456,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2986,performance,error,error,2986,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:282,safety,resourc,resources,282,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:345,safety,except,exception,345,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:458,safety,detect,detected,458,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:516,safety,depend,dependent,516,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:553,safety,avoid,avoided,553,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1298,safety,error,error,1298,", in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1340,safety,error,error,1340,"f exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2234,safety,detect,detected,2234,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2986,safety,error,error,2986,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:458,security,detect,detected,458,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1683,security,sign,signo,1683,". ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1689,security,sign,signo,1689,"iff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1799,security,sign,signo,1799,"g code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /ho",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2234,security,detect,detected,2234,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:282,testability,resourc,resources,282,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:516,testability,depend,dependent,516,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1413,testability,context,context,1413,"_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x0000",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1437,testability,context,context,1437,"e(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___l",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:369,usability,behavi,behavior,369,"[cling] Non-void returning function that throws may cause double free; - [X] Checked for duplicates. ### Describe the bug. A non-void returning function (specifically, returning `std::vector<ROOT::RDF::RResultPtr<TH1D>>`) that throws, causes `cling::Value::~Value()` to try freeing resources that were, in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1298,usability,error,error,1298,", in principle, already released as part of exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:1340,usability,error,error,1340,"f exception handling. See behavior below:. ```c++. root [0] .x pointer_not_allocated_error.cc. free(): double free detected in tcache 2. ```. In principle, this seems to be dependent on NRVO. Crash seems to be avoided either by _(i)_ commenting out. ```c++. histograms.push_back(h);. ```. ; or _(ii)_ changing the `return` statement as follows. ```diff. - return histograms;. + return {h};. ```. ### To Reproduce. The issue can be reproduced with the following code in ArchLinux x86_64 with ROOT master:. ```c++. vector<ROOT::RDF::RResultPtr<TH1D>> pointer_not_allocated_error(){. // Create a data frame with 100 rows. ROOT::RDataFrame rdf(100);. // Define a new column `x` that contains random numbers and create a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11494:2986,usability,error,error,2986,"ate a histogram. ROOT::RDF::RResultPtr<TH1D> h = rdf.Define(""x"", [](){ return gRandom->Rndm(); }).Histo1D(""x"");. // Add the histogram to a vector. vector<ROOT::RDF::RResultPtr<TH1D>> histograms;. histograms.push_back(h);. // Attempt to throw an error. throw std::runtime_error(""intended error throw for debugging"");. return histograms;. }. ```. ### Additional context. For additional context see https://root-forum.cern.ch/t/pointer-not-allocated-when-adding-rresultptr-to-vector/51831/2. Interesting part of the gdb backtrace follows (thanks @eguiraud!):. ```. >>> bt. #0 __pthread_kill_implementation (threadid=<optimized out>, signo=signo@entry=6, no_tid=no_tid@entry=0) at pthread_kill.c:44. #1 0x00007ffff72a1503 in __pthread_kill_internal (signo=6, threadid=<optimized out>) at pthread_kill.c:78. #2 0x00007ffff7251958 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26. #3 0x00007ffff723b53d in __GI_abort () at abort.c:79. #4 0x00007ffff729563e in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff73b4432 ""%s\n"") at ../sysdeps/posix/libc_fatal.c:155. #5 0x00007ffff72ab22c in malloc_printerr (str=str@entry=0x7ffff73b6ff8 ""free(): double free detected in tcache 2"") at malloc.c:5660. #6 0x00007ffff72ad587 in _int_free (av=0x7ffff73f1ba0 <main_arena>, p=0x55555e7134c0, have_lock=have_lock@entry=0) at malloc.c:4469. #7 0x00007ffff72af9f3 in __GI___libc_free (mem=<optimized out>) at malloc.c:3385. #8 0x00007ffff18d07b4 in std::_Vector_base<ROOT::RDF::RResultPtr<TH1D>, std::allocator<ROOT::RDF::RResultPtr<TH1D> > >::~_Vector_base (this=0x55555881f750) at /usr/lib/gcc/x86_64-pc-linux-gnu/12.2.0/../../../../include/c++/12.2.0/bits/stl_vector.h:366. #9 0x00007ffff23aa435 in cling::Value::~Value() () from /home/blue/ROOT/master/cmake-build-foo/lib/libCling.so. #10 0x00007ffff21a1869 in TCling::ProcessLine (this=0x5555555ee950, line=0x5555563e9c60 "".X /tmp/./pointer_not_allocated_error.C"", error=0x7fffffffb600) at ../core/metacling/src/TCling.cxx:2633. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11494
https://github.com/root-project/root/issues/11495:38,availability,error,errors,38,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:102,availability,error,error,102,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:513,availability,error,error,513,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:600,availability,error,error,600,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2774,availability,error,error,2774,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/i",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:4952,availability,error,error,4952,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecu",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7112,availability,error,error,7112,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9284,availability,error,error,9284,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, clas",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12082,availability,error,error,12082,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14884,availability,error,error,14884,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typena",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:17668,availability,error,error,17668,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:50,deployability,build,building,50,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:113,deployability,build,building,113,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:204,deployability,build,building,204,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:706,integrability,Sub,SubC,706,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:768,integrability,Sub,SubC,768,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:1003,integrability,Sub,SubC,1003,"utorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> templa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:1128,integrability,Sub,SubC,1128,"cation with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:1334,integrability,Sub,SubC,1334," Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:1459,integrability,Sub,SubC,1459,"as seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, uns",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:1659,integrability,Sub,SubC,1659,"lt_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:1784,integrability,Sub,SubC,1784," ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no de",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:1993,integrability,Sub,SubC,1993,"e<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2124,integrability,Sub,SubC,2124,"P<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutor",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2340,integrability,Sub,SubC,2340,"mplate<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2444,integrability,Sub,SubC,2444,"ExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2639,integrability,Sub,SubC,2639,": template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2880,integrability,Sub,SubC,2880,"eCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2947,integrability,Sub,SubC,2947,"cutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::T",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:3181,integrability,Sub,SubC,3181,", class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> templa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:3306,integrability,Sub,SubC,3306,"x:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:3512,integrability,Sub,SubC,3512,"eferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:3637,integrability,Sub,SubC,3637,"SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, uns",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:3837,integrability,Sub,SubC,3837,"f<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:3962,integrability,Sub,SubC,3962,", std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no de",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:4171,integrability,Sub,SubC,4171,"e<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:4302,integrability,Sub,SubC,4302,"P<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: n",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:4518,integrability,Sub,SubC,4518,"mplate<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:4622,integrability,Sub,SubC,4622,"ExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:4817,integrability,Sub,SubC,4817,": template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:5058,integrability,Sub,SubC,5058,"eCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typena",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:5116,integrability,Sub,SubC,5116,"ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorC",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:5341,integrability,Sub,SubC,5341,"| template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> templa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:5466,integrability,Sub,SubC,5466,"T/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:5672,integrability,Sub,SubC,5672,", class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:5797,integrability,Sub,SubC,5797,"OT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, uns",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:5997,integrability,Sub,SubC,5997,"name std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:6122,integrability,Sub,SubC,6122,"ap(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no de",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:6331,integrability,Sub,SubC,6331,"e<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> s",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:6462,integrability,Sub,SubC,6462,"P<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.h",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:6678,integrability,Sub,SubC,6678,"mplate<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:6782,integrability,Sub,SubC,6782,"ExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/i",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:6977,integrability,Sub,SubC,6977,": template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7218,integrability,Sub,SubC,7218,"eCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::v",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7282,integrability,Sub,SubC,7282,"ExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExe",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7513,integrability,Sub,SubC,7513,"lass F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> templa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7638,integrability,Sub,SubC,7638,"RTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7844,integrability,Sub,SubC,7844," = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7969,integrability,Sub,SubC,7969,"rCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, uns",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:8169,integrability,Sub,SubC,8169,"sult_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:8294,integrability,Sub,SubC,8294,"unc, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no de",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:8503,integrability,Sub,SubC,8503,"e<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redf",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:8634,integrability,Sub,SubC,8634,"P<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:8850,integrability,Sub,SubC,8850,"mplate<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noRefe",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:8954,integrability,Sub,SubC,8954,"ExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: temp",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9149,integrability,Sub,SubC,9149,": template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9377,integrability,Sub,SubC,9377," = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9448,integrability,Sub,SubC,9448,"ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, clas",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9687,integrability,Sub,SubC,9687,"ss F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TE",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9755,integrability,Sub,SubC,9755,". /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | te",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9967,integrability,Sub,SubC,9967,"nsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:10035,integrability,Sub,SubC,10035,"F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:10241,integrability,Sub,SubC,10241,"17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:10362,integrability,Sub,SubC,10362,"ExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEG",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:10580,integrability,Sub,SubC,10580,"pt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/R",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:10701,integrability,Sub,SubC,10701,"lass F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:10925,integrability,Sub,SubC,10925,"rCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:11046,integrability,Sub,SubC,11046,"uce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/incl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:11273,integrability,Sub,SubC,11273,"lass R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func,",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:11400,integrability,Sub,SubC,11400,". 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_g",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:11634,integrability,Sub,SubC,11634,"pename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,c",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:11734,integrability,Sub,SubC,11734,"or<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.h",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:11947,integrability,Sub,SubC,11947,"class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12175,integrability,Sub,SubC,12175," ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapRed",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12251,integrability,Sub,SubC,12251,"te: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12489,integrability,Sub,SubC,12489,"R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TE",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12557,integrability,Sub,SubC,12557,"06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | te",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12769,integrability,Sub,SubC,12769,". 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12837,integrability,Sub,SubC,12837," | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:13043,integrability,Sub,SubC,13043,"nclude/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:13164,integrability,Sub,SubC,13164,"utorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEG",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:13382,integrability,Sub,SubC,13382,"pt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/R",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:13503,integrability,Sub,SubC,13503,"lass F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:13727,integrability,Sub,SubC,13727,"rCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:13848,integrability,Sub,SubC,13848,"uce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/incl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14075,integrability,Sub,SubC,14075,"lass R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14202,integrability,Sub,SubC,14202,". 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14436,integrability,Sub,SubC,14436,"pename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noRefe",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14536,integrability,Sub,SubC,14536,"or<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14749,integrability,Sub,SubC,14749,"class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14977,integrability,Sub,SubC,14977," ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:15044,integrability,Sub,SubC,15044,"32:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = n",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:15273,integrability,Sub,SubC,15273,"ss INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TE",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:15341,integrability,Sub,SubC,15341,". /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | te",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:15553,integrability,Sub,SubC,15553," unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:15621,integrability,Sub,SubC,15621,"ReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:15827,integrability,Sub,SubC,15827,"26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:15948,integrability,Sub,SubC,15948,"::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEG",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:16166,integrability,Sub,SubC,16166,"pt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/R",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:16287,integrability,Sub,SubC,16287,"lass F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:16511,integrability,Sub,SubC,16511,"rCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:16632,integrability,Sub,SubC,16632,"uce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/incl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:16859,integrability,Sub,SubC,16859,"lass R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, co",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:16986,integrability,Sub,SubC,16986,". 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:17220,integrability,Sub,SubC,17220,"pename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class C",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:17320,integrability,Sub,SubC,17320,"or<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:17533,integrability,Sub,SubC,17533,"class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /op",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:17761,integrability,Sub,SubC,17761," ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F,",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:17834,integrability,Sub,SubC,17834," note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Co",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:18069,integrability,Sub,SubC,18069,"class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TE",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:18137,integrability,Sub,SubC,18137,"v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | te",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:18349,integrability,Sub,SubC,18349,"t, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:18417,integrability,Sub,SubC,18417,"d<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:18623,integrability,Sub,SubC,18623,"TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. similarly for `TSequentialExecutor`",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:18744,integrability,Sub,SubC,18744,"TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. similarly for `TSequentialExecutor`",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:18962,integrability,Sub,SubC,18962,"TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. similarly for `TSequentialExecutor`",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:19083,integrability,Sub,SubC,19083,"TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. similarly for `TSequentialExecutor`",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:19307,integrability,Sub,SubC,19307,"TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. similarly for `TSequentialExecutor`",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:19428,integrability,Sub,SubC,19428,"TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. similarly for `TSequentialExecutor`",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:38,performance,error,errors,38,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:102,performance,error,error,102,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:513,performance,error,error,513,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:600,performance,error,error,600,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2774,performance,error,error,2774,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/i",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:4952,performance,error,error,4952,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecu",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7112,performance,error,error,7112,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9284,performance,error,error,9284,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, clas",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12082,performance,error,error,12082,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14884,performance,error,error,14884,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typena",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:17668,performance,error,error,17668,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:38,safety,error,errors,38,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:102,safety,error,error,102,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:513,safety,error,error,513,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:600,safety,error,error,600,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2774,safety,error,error,2774,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/i",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:4952,safety,error,error,4952,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecu",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7112,safety,error,error,7112,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9284,safety,error,error,9284,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, clas",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12082,safety,error,error,12082,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14884,safety,error,error,14884,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typena",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:17668,safety,error,error,17668,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:38,usability,error,errors,38,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:102,usability,error,error,102,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:513,usability,error,error,513,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:600,usability,error,error,600,"TExecutorCRTP and TSequentialExecutor errors when building application with Kokkos 3.7; I'm seeing an error when building an application with root 6.26.06, gcc 11.2 and Kokkos 3.7. I didn't see this when building the same source against root 6.24.00, Kokkos 3.4 with gcc 9.3. Nothing in the source is explicitly calling TExecutorCRTP. . Before I start playing with all permutations of root / gcc / kokkos to see where the issue starts, I'm wondering if anyone has seen this before or has some advice. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:2774,usability,error,error,2774,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/i",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:4952,usability,error,error,4952,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecu",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:7112,usability,error,error,7112,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:9284,usability,error,error,9284,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, clas",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:12082,usability,error,error,12082,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:14884,usability,error,error,14884,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typena",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11495:17668,usability,error,error,17668,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11495
https://github.com/root-project/root/issues/11496:720,availability,sli,slightly,720,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1617,availability,Operat,Operating,1617,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1692,availability,down,download,1692,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:74,deployability,fail,fails,74,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:683,deployability,fail,fails,683,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1272,deployability,build,build,1272,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1605,deployability,version,version,1605,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1674,deployability,instal,install,1674,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1605,integrability,version,version,1605,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1605,modifiability,version,version,1605,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:74,reliability,fail,fails,74,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:683,reliability,fail,fails,683,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:720,reliability,sli,slightly,720,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1226,safety,input,input,1226,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:739,security,sign,signature,739,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1773,testability,context,context,1773,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1802,testability,context,context,1802,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:472,usability,clear,clear,472,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:520,usability,behavi,behavior,520,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:900,usability,behavi,behavior,900,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:918,usability,clear,clear,918,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1081,usability,behavi,behavior,1081,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/issues/11496:1226,usability,input,input,1226,"[RF] Pythonization of `RooFit::Link` actually calls `RooFit::Import` (and fails); - [x] Checked for duplicates. <!--. Please search in. * [GitHub](https://github.com/root-project/root/issues?q=is%3Aissue). * AND [Jira](https://sft.its.cern.ch/jira/issues/?jql=project %3D ROOT). for existing reports of your issue. If you find one, you are very welcome to add to the existing report, for instance ""issue still exists in today's master"". -->. ### Describe the bug. <!--. A clear and concise description of what the wrong behavior is. -->. If you pass a dictionary to the `Link` argument in the `RooDataSet` constructor, the pythonization actually tries to call `RooFit::Import`, then fails because `RooFit::Import` has a slightly different signature (`Import` takes a map from to string to either `TH1*`, `RooDataSet*` or `RooDataHist*`, `Link` takes a map from string to `RooAbsData*`). ### Expected behavior. <!--. A clear and concise description of what you expected to happen. -->. The pythonization calls the correct `RooCmdArg`. ### To Reproduce. <!--. Steps to reproduce the behavior:. 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves. 2. Don't forget to attach the required input files! 3. How to run your code and / or build it, e.g. `root myMacro.C`, ... -->. ```Python. import ROOT. x = ROOT.RooRealVar('x', '', 0, 1). g = ROOT.RooGaussian('g', '', x, ROOT.RooFit.RooConst(0.5), ROOT.RooFit.RooConst(0.2)). data = g.generate({x}, NumEvents = 1000). data_2 = ROOT.RooDataSet('dataLinked', {x}, Link = {'useless': data}). ```. ### Setup. <!--. 1. ROOT version. 2. Operating system. 3. How you obtained ROOT, such as `dnf install` / binary download / you built it yourself. -->. ROOT master from LCG dev3. ### Additional context. <!--. Add any other context about the problem here. -->",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11496
https://github.com/root-project/root/pull/11499:16,deployability,integr,integrate,16,"[RF] Attempt to integrate xRooFit into RooFit; From https://gitlab.cern.ch/will/xroofit,. commit 5a9064e020abe994f01d31a55ebc127454e0d48e. This is just to see how the CI responds to learn what yet needs to be done upstream in xRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11499
https://github.com/root-project/root/pull/11499:16,integrability,integr,integrate,16,"[RF] Attempt to integrate xRooFit into RooFit; From https://gitlab.cern.ch/will/xroofit,. commit 5a9064e020abe994f01d31a55ebc127454e0d48e. This is just to see how the CI responds to learn what yet needs to be done upstream in xRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11499
https://github.com/root-project/root/pull/11499:16,interoperability,integr,integrate,16,"[RF] Attempt to integrate xRooFit into RooFit; From https://gitlab.cern.ch/will/xroofit,. commit 5a9064e020abe994f01d31a55ebc127454e0d48e. This is just to see how the CI responds to learn what yet needs to be done upstream in xRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11499
https://github.com/root-project/root/pull/11499:16,modifiability,integr,integrate,16,"[RF] Attempt to integrate xRooFit into RooFit; From https://gitlab.cern.ch/will/xroofit,. commit 5a9064e020abe994f01d31a55ebc127454e0d48e. This is just to see how the CI responds to learn what yet needs to be done upstream in xRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11499
https://github.com/root-project/root/pull/11499:16,reliability,integr,integrate,16,"[RF] Attempt to integrate xRooFit into RooFit; From https://gitlab.cern.ch/will/xroofit,. commit 5a9064e020abe994f01d31a55ebc127454e0d48e. This is just to see how the CI responds to learn what yet needs to be done upstream in xRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11499
https://github.com/root-project/root/pull/11499:16,security,integr,integrate,16,"[RF] Attempt to integrate xRooFit into RooFit; From https://gitlab.cern.ch/will/xroofit,. commit 5a9064e020abe994f01d31a55ebc127454e0d48e. This is just to see how the CI responds to learn what yet needs to be done upstream in xRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11499
https://github.com/root-project/root/pull/11499:16,testability,integr,integrate,16,"[RF] Attempt to integrate xRooFit into RooFit; From https://gitlab.cern.ch/will/xroofit,. commit 5a9064e020abe994f01d31a55ebc127454e0d48e. This is just to see how the CI responds to learn what yet needs to be done upstream in xRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11499
https://github.com/root-project/root/pull/11499:182,usability,learn,learn,182,"[RF] Attempt to integrate xRooFit into RooFit; From https://gitlab.cern.ch/will/xroofit,. commit 5a9064e020abe994f01d31a55ebc127454e0d48e. This is just to see how the CI responds to learn what yet needs to be done upstream in xRooFit.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11499
https://github.com/root-project/root/pull/11500:356,safety,test,test,356,"[RF] Fix `RooFit::Link()` pythonization and pythonize RooSimultaneous constructor; Obviously the `Link` pythonization should call the original `_Link`. function. Also, the constructor that takes a map of categories to PDFs should be able to. accept a Python dictionary directly. The RooFit Python tutorials are covering this constructor, acting as a. unit test. Closes https://github.com/root-project/root/issues/11496.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11500
https://github.com/root-project/root/pull/11500:351,testability,unit,unit,351,"[RF] Fix `RooFit::Link()` pythonization and pythonize RooSimultaneous constructor; Obviously the `Link` pythonization should call the original `_Link`. function. Also, the constructor that takes a map of categories to PDFs should be able to. accept a Python dictionary directly. The RooFit Python tutorials are covering this constructor, acting as a. unit test. Closes https://github.com/root-project/root/issues/11496.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11500
https://github.com/root-project/root/pull/11500:356,testability,test,test,356,"[RF] Fix `RooFit::Link()` pythonization and pythonize RooSimultaneous constructor; Obviously the `Link` pythonization should call the original `_Link`. function. Also, the constructor that takes a map of categories to PDFs should be able to. accept a Python dictionary directly. The RooFit Python tutorials are covering this constructor, acting as a. unit test. Closes https://github.com/root-project/root/issues/11496.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11500
https://github.com/root-project/root/pull/11500:362,usability,Close,Closes,362,"[RF] Fix `RooFit::Link()` pythonization and pythonize RooSimultaneous constructor; Obviously the `Link` pythonization should call the original `_Link`. function. Also, the constructor that takes a map of categories to PDFs should be able to. accept a Python dictionary directly. The RooFit Python tutorials are covering this constructor, acting as a. unit test. Closes https://github.com/root-project/root/issues/11496.",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11500
https://github.com/root-project/root/pull/11501:145,deployability,infrastructur,infrastructure,145,Add support for Bulk I/O with SetClusterPrefetch; This fixes #8962. The code pattern is similar to 0987896c2d8d49a0e5723ee2ac792eb33fa3ee34. Add infrastructure for sharing memory in a TBuffer.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11501
https://github.com/root-project/root/pull/11501:21,performance,I/O,I/O,21,Add support for Bulk I/O with SetClusterPrefetch; This fixes #8962. The code pattern is similar to 0987896c2d8d49a0e5723ee2ac792eb33fa3ee34. Add infrastructure for sharing memory in a TBuffer.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11501
https://github.com/root-project/root/pull/11501:172,performance,memor,memory,172,Add support for Bulk I/O with SetClusterPrefetch; This fixes #8962. The code pattern is similar to 0987896c2d8d49a0e5723ee2ac792eb33fa3ee34. Add infrastructure for sharing memory in a TBuffer.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11501
https://github.com/root-project/root/pull/11501:4,usability,support,support,4,Add support for Bulk I/O with SetClusterPrefetch; This fixes #8962. The code pattern is similar to 0987896c2d8d49a0e5723ee2ac792eb33fa3ee34. Add infrastructure for sharing memory in a TBuffer.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11501
https://github.com/root-project/root/pull/11501:172,usability,memor,memory,172,Add support for Bulk I/O with SetClusterPrefetch; This fixes #8962. The code pattern is similar to 0987896c2d8d49a0e5723ee2ac792eb33fa3ee34. Add infrastructure for sharing memory in a TBuffer.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11501
https://github.com/root-project/root/pull/11503:0,safety,Compl,Complete,0,Complete the TPaletteAxis menu; The `TPaletteAxis` context menu was not working and was not complete.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11503
https://github.com/root-project/root/pull/11503:92,safety,compl,complete,92,Complete the TPaletteAxis menu; The `TPaletteAxis` context menu was not working and was not complete.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11503
https://github.com/root-project/root/pull/11503:0,security,Compl,Complete,0,Complete the TPaletteAxis menu; The `TPaletteAxis` context menu was not working and was not complete.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11503
https://github.com/root-project/root/pull/11503:92,security,compl,complete,92,Complete the TPaletteAxis menu; The `TPaletteAxis` context menu was not working and was not complete.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11503
https://github.com/root-project/root/pull/11503:51,testability,context,context,51,Complete the TPaletteAxis menu; The `TPaletteAxis` context menu was not working and was not complete.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11503
https://github.com/root-project/root/pull/11503:26,usability,menu,menu,26,Complete the TPaletteAxis menu; The `TPaletteAxis` context menu was not working and was not complete.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11503
https://github.com/root-project/root/pull/11503:59,usability,menu,menu,59,Complete the TPaletteAxis menu; The `TPaletteAxis` context menu was not working and was not complete.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11503
https://github.com/root-project/root/pull/11504:133,integrability,pub,public,133,"[tree] Move RFriendInfo out of the Internal namespace; As in https://github.com/root-project/root/pull/11465 we would like to have a public getter returning RFriendInfo object. Hence, we move the class out of the Internal namespace (in its own header file).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11504
https://github.com/root-project/root/pull/11505:48,deployability,patch,patches,48,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 22; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11500. Excluding the last commit that only updates the tutorials",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11505
https://github.com/root-project/root/pull/11505:175,deployability,patch,patches,175,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 22; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11500. Excluding the last commit that only updates the tutorials",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11505
https://github.com/root-project/root/pull/11505:343,deployability,updat,updates,343,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 22; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11500. Excluding the last commit that only updates the tutorials",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11505
https://github.com/root-project/root/pull/11505:48,safety,patch,patches,48,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 22; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11500. Excluding the last commit that only updates the tutorials",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11505
https://github.com/root-project/root/pull/11505:175,safety,patch,patches,175,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 22; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11500. Excluding the last commit that only updates the tutorials",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11505
https://github.com/root-project/root/pull/11505:343,safety,updat,updates,343,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 22; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11500. Excluding the last commit that only updates the tutorials",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11505
https://github.com/root-project/root/pull/11505:48,security,patch,patches,48,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 22; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11500. Excluding the last commit that only updates the tutorials",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11505
https://github.com/root-project/root/pull/11505:175,security,patch,patches,175,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 22; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11500. Excluding the last commit that only updates the tutorials",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11505
https://github.com/root-project/root/pull/11505:343,security,updat,updates,343,"[v626][RF] Backports of RooFit PRs to `v6-26-00-patches`: Part 22; This is a backport of all the relevant bugfix RooFit PRs that were recently merged to `master` to `v6-26-00-patches` (in the right order, to not have the commit history diverge too much). 1. https://github.com/root-project/root/pull/11500. Excluding the last commit that only updates the tutorials",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11505
https://github.com/root-project/root/pull/11506:194,deployability,depend,dependencies,194,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:226,deployability,modul,modules,226,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:295,deployability,depend,dependency,295,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:449,deployability,depend,dependencies,449,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:480,deployability,modul,modules,480,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:546,deployability,modul,modules,546,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:614,deployability,build,build,614,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:634,deployability,updat,update,634,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:641,deployability,modul,modules,641,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:666,deployability,modul,modules,666,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:194,integrability,depend,dependencies,194,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:295,integrability,depend,dependency,295,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:449,integrability,depend,dependencies,449,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:54,modifiability,variab,variable,54,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:194,modifiability,depend,dependencies,194,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:226,modifiability,modul,modules,226,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:295,modifiability,depend,dependency,295,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:449,modifiability,depend,dependencies,449,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:480,modifiability,modul,modules,480,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:546,modifiability,modul,modules,546,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:641,modifiability,modul,modules,641,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:666,modifiability,modul,modules,666,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:47,performance,cach,cached,47,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:194,safety,depend,dependencies,194,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:226,safety,modul,modules,226,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:295,safety,depend,dependency,295,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:449,safety,depend,dependencies,449,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:480,safety,modul,modules,480,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:522,safety,test,test,522,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:546,safety,modul,modules,546,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:634,safety,updat,update,634,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:641,safety,modul,modules,641,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:666,safety,modul,modules,666,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:634,security,updat,update,634,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:194,testability,depend,dependencies,194,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:295,testability,depend,dependency,295,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:449,testability,depend,dependencies,449,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:522,testability,test,test,522,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:136,usability,custom,custom,136,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:261,usability,custom,custom,261,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11506:420,usability,custom,custom,420,cmake: Replace ever expanding modules_idx_deps cached variable; We replace it with a combination of a global property and an additional custom target. The global property is used to collect the dependencies created before the modules.idx target is created. The custom target is used as a direct dependency of the custom_command (add_dependencies can not be used on the target of a custom_command). Then we can use. this custom target to collect the dependencies created after the modules.idx target. This fixes #10510. To test:. ```. ls -rtl lib/modules.idx lib/libEve.so. rm lib/*Eve*. ninja # or make or cmake --build ; this should update modules.idx. ls -rtl lib/modules.idx lib/libEve.so. ```.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11506
https://github.com/root-project/root/pull/11507:20,availability,error,error,20,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:120,availability,error,error,120,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:281,integrability,coupl,couple,281,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:281,modifiability,coupl,couple,281,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:20,performance,error,error,20,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:120,performance,error,error,120,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:20,safety,error,error,20,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:120,safety,error,error,120,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:424,safety,test,test,424,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:281,testability,coupl,couple,281,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:424,testability,test,test,424,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:20,usability,error,error,20,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/pull/11507:120,usability,error,error,120,"[RF] Fix copy-paste error in `RooDataSet::binnedClone`; # This Pull request:. ## Changes or fixes:. Due to a copy-paste error, `RooDataSet::binnedClone` was overwriting the name of the clone if no title was provided. This PR fixes that. Since this is my first PR in ROOT, I have a couple of questions:. - since this was a small change I did not open an issue in the repo, should I do that regardless? - do I need to write a test?",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11507
https://github.com/root-project/root/issues/11508:194,energy efficiency,alloc,allocator,194,"[DF] Wrong entries processed with a `Range` with begin+stride; Reproducer:. ```. root [1] *ROOT::RDataFrame(10).Range(1,10,3).Take<ULong64_t>(""rdfentry_""). (std::vector<unsigned long long, std::allocator<unsigned long long> > &) { 2, 5, 8 }. ```. (the expected output is `{1, 4, 7}`).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11508
https://github.com/root-project/root/issues/11508:55,security,stride,stride,55,"[DF] Wrong entries processed with a `Range` with begin+stride; Reproducer:. ```. root [1] *ROOT::RDataFrame(10).Range(1,10,3).Take<ULong64_t>(""rdfentry_""). (std::vector<unsigned long long, std::allocator<unsigned long long> > &) { 2, 5, 8 }. ```. (the expected output is `{1, 4, 7}`).",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11508
https://github.com/root-project/root/pull/11509:9,integrability,event,event,9,[DF] Fix event selection in case of Range with stride; This fixes https://github.com/root-project/root/issues/11508.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11509
https://github.com/root-project/root/pull/11509:47,security,stride,stride,47,[DF] Fix event selection in case of Range with stride; This fixes https://github.com/root-project/root/issues/11508.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11509
https://github.com/root-project/root/pull/11510:9,integrability,event,event,9,[DF] Fix event selection in case of Range with stride (v6.26); This fixes https://github.com/root-project/root/issues/11508.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11510
https://github.com/root-project/root/pull/11510:47,security,stride,stride,47,[DF] Fix event selection in case of Range with stride (v6.26); This fixes https://github.com/root-project/root/issues/11508.,MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/pull/11510
https://github.com/root-project/root/issues/11511:38,availability,error,errors,38,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:124,availability,error,error,124,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:217,availability,error,error,217,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:441,availability,error,error,441,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:453,availability,error,error,453,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:687,availability,error,error,687,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:821,availability,error,error,821,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:908,availability,error,error,908,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:3082,availability,error,error,3082,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/i",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:5260,availability,error,error,5260,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecu",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:7420,availability,error,error,7420,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:9592,availability,error,error,9592,"orCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, clas",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:12390,availability,error,error,12390,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:15192,availability,error,error,15192,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typena",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:17976,availability,error,error,17976,"st<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:19843,availability,error,errors,19843,"plate<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. ### Expected behavior. a clean compilation without errors. ### To Reproduce. ```. setup kokkos (with CUDA backend), root, gcc, cmake. git clone git@github.com:cgleggett/FCS-GPU.git src. mkdir bld; cd bld. cmake ../src/FastCaloSimAnalyzer/ -DENABLE_XROOTD=Off -DENABLE_GPU=on -DINPUT_PATH=/tmp -DCMAKE_CXX_STANDARD=17 -DUSE_KOKKOS=ON -DCMAKE_CXX_EXTENSIONS=Off. make -j. ```. ### Setup. root: v6.24 - v6.26. CUDA: 11.6, 11.7 (OK with 11.5). gcc: 9.3 - 11.2. OS: Centos 7. ROOT was built with:. ```. cmake -DCMAKE_CXX_STANDARD=17 -DCMAKE_CXX_EXTENSIONS=Off -DCMAKE_INSTALL_PREFIX=/opt/root/v6-26-06_gcc112_c17 -Dx11=OFF -Dtbb=OFF -Dopengl=OFF -Dgviz=OFF -Dimt=OFF -Ddavix=OFF -Dvdt=OFF -Dxrootd=OFF ../src. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:50,deployability,build,building,50,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:135,deployability,build,building,135,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:379,deployability,version,version,379,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:610,deployability,version,versions,610,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:19965,energy efficiency,GPU,GPU,19965,"plate<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. ### Expected behavior. a clean compilation without errors. ### To Reproduce. ```. setup kokkos (with CUDA backend), root, gcc, cmake. git clone git@github.com:cgleggett/FCS-GPU.git src. mkdir bld; cd bld. cmake ../src/FastCaloSimAnalyzer/ -DENABLE_XROOTD=Off -DENABLE_GPU=on -DINPUT_PATH=/tmp -DCMAKE_CXX_STANDARD=17 -DUSE_KOKKOS=ON -DCMAKE_CXX_EXTENSIONS=Off. make -j. ```. ### Setup. root: v6.24 - v6.26. CUDA: 11.6, 11.7 (OK with 11.5). gcc: 9.3 - 11.2. OS: Centos 7. ROOT was built with:. ```. cmake -DCMAKE_CXX_STANDARD=17 -DCMAKE_CXX_EXTENSIONS=Off -DCMAKE_INSTALL_PREFIX=/opt/root/v6-26-06_gcc112_c17 -Dx11=OFF -Dtbb=OFF -Dopengl=OFF -Dgviz=OFF -Dimt=OFF -Ddavix=OFF -Dvdt=OFF -Dxrootd=OFF ../src. ```",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:379,integrability,version,version,379,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:610,integrability,version,versions,610,"TExecutorCRTP and TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:1014,integrability,Sub,SubC,1014,"d TSequentialExecutor errors when building application with CUDA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:1076,integrability,Sub,SubC,1076,"DA 11.6+; ### Describe the bug. I'm seeing an error when building an application with root, kokkos and CUDA. The file that's producing the error does not explicitly include any Kokkos or CUDA headers, but the CUDA headers are somehow being pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:1311,integrability,Sub,SubC,1311,"eing pulled in. Kokkos is somehow involved in all this as another version of the code which uses plain CUDA does not throw this error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> templa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:1436,integrability,Sub,SubC,1436,"is error. This error is apparent with root v6-24-00 through v6-26-06 (I haven't tried anything older or newer). It appeared with CUDA 11.6 and beyond- it's fine with older versions (I've tried back to 11.2 and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:1642,integrability,Sub,SubC,1642,"and up to 11.7. I haven't tried 11.8). The error is apparent with gcc 9.3 to 11.2. Nothing in the source is explicitly calling TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:1767,integrability,Sub,SubC,1767,"g TExecutorCRTP or TSequentialExecutor. This is the error I see:. ```. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:191:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, uns",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:1967,integrability,Sub,SubC,1967,"lt_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 191 | auto TExecutorCRTP<SubC>::Map(F func, ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:2092,integrability,Sub,SubC,2092," ROOT::TSeq<INTEGER> args) -> std::vector<typename std::result_of<F(INTEGER)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no de",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:2301,integrability,Sub,SubC,2301,"e<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:2432,integrability,Sub,SubC,2432,"P<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutor",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:2648,integrability,Sub,SubC,2648,"mplate<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&)",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:2752,integrability,Sub,SubC,2752,"ExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:2947,integrability,Sub,SubC,2947,": template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:3188,integrability,Sub,SubC,3188,"eCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:3255,integrability,Sub,SubC,3255,"cutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::T",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:3489,integrability,Sub,SubC,3489,", class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> templa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:3614,integrability,Sub,SubC,3614,"x:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:3820,integrability,Sub,SubC,3820,"eferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:3945,integrability,Sub,SubC,3945,"SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:203:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, uns",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:4145,integrability,Sub,SubC,4145,"f<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 203 | auto TExecutorCRTP<SubC>::Map(F func, std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:4270,integrability,Sub,SubC,4270,", std::initializer_list<T> args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no de",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:4479,integrability,Sub,SubC,4479,"e<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<t",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:4610,integrability,Sub,SubC,4610,"P<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: n",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:4826,integrability,Sub,SubC,4826,"mplate<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:4930,integrability,Sub,SubC,4930,"ExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:5125,integrability,Sub,SubC,5125,": template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:5366,integrability,Sub,SubC,5366,"eCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typena",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:5424,integrability,Sub,SubC,5424,"ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorC",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:5649,integrability,Sub,SubC,5649,"| template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> templa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:5774,integrability,Sub,SubC,5774,"T/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:5980,integrability,Sub,SubC,5980,", class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:6105,integrability,Sub,SubC,6105,"OT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:217:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, uns",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:6305,integrability,Sub,SubC,6305,"name std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 217 | auto TExecutorCRTP<SubC>::Map(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:6430,integrability,Sub,SubC,6430,"ap(F func, std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no de",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:6639,integrability,Sub,SubC,6639,"e<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> s",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:6770,integrability,Sub,SubC,6770,"P<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.h",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:6986,integrability,Sub,SubC,6986,"mplate<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:7090,integrability,Sub,SubC,7090,"ExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/i",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:7285,integrability,Sub,SubC,7285,": template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:7526,integrability,Sub,SubC,7526,"eCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::v",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:7590,integrability,Sub,SubC,7590,"ExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExe",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:7821,integrability,Sub,SubC,7821,"lass F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> templa",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:7946,integrability,Sub,SubC,7946,"RTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:8152,integrability,Sub,SubC,8152," = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:8277,integrability,Sub,SubC,8277,"rCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:230:1: error: no declaration matches std::vector<typename std::result_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, uns",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:8477,integrability,Sub,SubC,8477,"sult_of<F(INTEGER)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 230 | auto TExecutorCRTP<SubC>::Map(F func, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:8602,integrability,Sub,SubC,8602,"unc, const std::vector<T> &args) -> std::vector<typename std::result_of<F(T)>::type>. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:124:72: note: candidates are: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no de",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:8811,integrability,Sub,SubC,8811,"e<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redf",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:8942,integrability,Sub,SubC,8942,"P<SubC>::Map(F, const std::vector<T>&). 124 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:122:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:9158,integrability,Sub,SubC,9158,"mplate<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noRefe",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:9262,integrability,Sub,SubC,9262,"ExecutorCRTP<SubC>::Map(F, std::vector<T>&). 122 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:120:72: note: template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: temp",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:9457,integrability,Sub,SubC,9457,": template<class SubC> template<class F, class T, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, std::initializer_list<T>). 120 | template<class F, class T, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:9685,integrability,Sub,SubC,9685," = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:9756,integrability,Sub,SubC,9756,"ROOT/TExecutorCRTP.hxx:118:84: note: template<class SubC> template<class F, class INTEGER, class Cond> std::vector<typename std::result_of<F(INTEGER, ...)>::type> ROOT::TExecutorCRTP<SubC>::Map(F, ROOT::TSeq<INTEGER>). 118 | template<class F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, clas",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:9995,integrability,Sub,SubC,9995,"ss F, class INTEGER, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TE",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:10063,integrability,Sub,SubC,10063,". /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:116:60: note: template<class SubC> template<class F, class Cond> std::vector<typename std::result_of<F()>::type> ROOT::TExecutorCRTP<SubC>::Map(F, unsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | te",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:10275,integrability,Sub,SubC,10275,"nsigned int). 116 | template<class F, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:10343,integrability,Sub,SubC,10343,"F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:10549,integrability,Sub,SubC,10549,"17/include/ROOT/TExecutorCRTP.hxx:257:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:10670,integrability,Sub,SubC,10670,"ExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 257 | auto TExecutorCRTP<SubC>::MapReduce(F func, ROOT::TSeq<INTEGER> args, R redfunc) -> typename std::result_of<F(INTEGER)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEG",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:10888,integrability,Sub,SubC,10888,"pt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/R",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:11009,integrability,Sub,SubC,11009,"lass F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:11233,integrability,Sub,SubC,11233,"rCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:11354,integrability,Sub,SubC,11354,"uce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/incl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:11581,integrability,Sub,SubC,11581,"lass R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func,",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:11708,integrability,Sub,SubC,11708,". 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_g",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:11942,integrability,Sub,SubC,11942,"pename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,c",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:12042,integrability,Sub,SubC,12042,"or<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.h",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:12255,integrability,Sub,SubC,12255,"class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:12483,integrability,Sub,SubC,12483," ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapRed",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:12559,integrability,Sub,SubC,12559,"te: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:12797,integrability,Sub,SubC,12797,"R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TE",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:12865,integrability,Sub,SubC,12865,"06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | te",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:13077,integrability,Sub,SubC,13077,". 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:13145,integrability,Sub,SubC,13145," | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:13351,integrability,Sub,SubC,13351,"nclude/ROOT/TExecutorCRTP.hxx:270:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:13472,integrability,Sub,SubC,13472,"utorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 270 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::initializer_list<T> args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEG",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:13690,integrability,Sub,SubC,13690,"pt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/R",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:13811,integrability,Sub,SubC,13811,"lass F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:14035,integrability,Sub,SubC,14035,"rCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:14156,integrability,Sub,SubC,14156,"uce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/incl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:14383,integrability,Sub,SubC,14383,"lass R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:14510,integrability,Sub,SubC,14510,". 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:14744,integrability,Sub,SubC,14744,"pename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noRefe",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:14844,integrability,Sub,SubC,14844,"or<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:15057,integrability,Sub,SubC,15057,"class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:15285,integrability,Sub,SubC,15285," ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:15352,integrability,Sub,SubC,15352,"32:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = n",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:15581,integrability,Sub,SubC,15581,"ss INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TE",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:15649,integrability,Sub,SubC,15649,". /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | te",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:15861,integrability,Sub,SubC,15861," unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:15929,integrability,Sub,SubC,15929,"ReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:16135,integrability,Sub,SubC,16135,"26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:284:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:16256,integrability,Sub,SubC,16256,"::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 284 | auto TExecutorCRTP<SubC>::MapReduce(F func, std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEG",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:16474,integrability,Sub,SubC,16474,"pt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/R",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:16595,integrability,Sub,SubC,16595,"lass F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:16819,integrability,Sub,SubC,16819,"rCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:16940,integrability,Sub,SubC,16940,"uce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/incl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:17167,integrability,Sub,SubC,17167,"lass R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, co",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:17294,integrability,Sub,SubC,17294,". 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:17528,integrability,Sub,SubC,17528,"pename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class C",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:17628,integrability,Sub,SubC,17628,"or<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:17841,integrability,Sub,SubC,17841,"class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). 134 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /op",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:18069,integrability,Sub,SubC,18069," ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:132:93: note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F,",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:18142,integrability,Sub,SubC,18142," note: template<class SubC> template<class F, class INTEGER, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, ROOT::TSeq<INTEGER>, R). 132 | template<class F, class INTEGER, class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Co",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:18377,integrability,Sub,SubC,18377,"class R, class Cond = noReferenceCond<F, INTEGER>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TE",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:18445,integrability,Sub,SubC,18445,"v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:130:69: note: template<class SubC> template<class F, class R, class Cond> typename std::result_of<F()>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, unsigned int, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | te",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:18657,integrability,Sub,SubC,18657,"t, R). 130 | template<class F, class R, class Cond = noReferenceCond<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, cl",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:18725,integrability,Sub,SubC,18725,"d<F>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:102:7: note: class ROOT::TExecutorCRTP<SubC> defined here. 102 | class TExecutorCRTP {. | ^~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExec",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:18931,integrability,Sub,SubC,18931,"_c17/include/ROOT/TExecutorCRTP.hxx:296:1: error: no declaration matches typename std::result_of<F(INTEGER)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. ### Expected behavior. a clean compilation without errors. ### To Reproduce. ```. setup kokkos (with CUDA backend), root, gcc, cmake. git clo",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:19052,integrability,Sub,SubC,19052,":TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 296 | auto TExecutorCRTP<SubC>::MapReduce(F func, const std::vector<T> &args, R redfunc) -> typename std::result_of<F(T)>::type. | ^~~~~~~~~~~~~~~~~~~~. /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. ### Expected behavior. a clean compilation without errors. ### To Reproduce. ```. setup kokkos (with CUDA backend), root, gcc, cmake. git clone git@github.com:cgleggett/FCS-GPU.git src. mkdir bld; cd bld. cmake ../src/FastCaloSimAnalyzer/ -DENABLE_XROOTD=Off -DE",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:19270,integrability,Sub,SubC,19270,"pt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:142:70: note: candidates are: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. ### Expected behavior. a clean compilation without errors. ### To Reproduce. ```. setup kokkos (with CUDA backend), root, gcc, cmake. git clone git@github.com:cgleggett/FCS-GPU.git src. mkdir bld; cd bld. cmake ../src/FastCaloSimAnalyzer/ -DENABLE_XROOTD=Off -DENABLE_GPU=on -DINPUT_PATH=/tmp -DCMAKE_CXX_STANDARD=17 -DUSE_KOKKOS=ON -DCMAKE_CXX_EXTENSIONS=Off. make -j. ```. ### Setup. root: v6.24 - v6.26. CUDA: 11.6, 11.7 (OK with 11.5). gcc: 9.3 - 11.2. OS: Centos 7. ROOT was ",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
https://github.com/root-project/root/issues/11511:19391,integrability,Sub,SubC,19391,"lass F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T*>&). 142 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:140:70: note: template<class SubC> template<class F, class T, class Cond> T* ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T*>&). 140 | template<class F, class T,class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:138:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::vector<T>&, R). 138 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:136:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, const std::vector<T>&, R). 136 | template<class F, class T, class R, class Cond = noReferenceCond<F, T>>. | ^ . /opt/root/v6-26-06_gcc112_c17/include/ROOT/TExecutorCRTP.hxx:134:81: note: template<class SubC> template<class F, class T, class R, class Cond> typename std::result_of<F(INTEGER, ...)>::type ROOT::TExecutorCRTP<SubC>::MapReduce(F, std::initializer_list<T>, R). ```. ### Expected behavior. a clean compilation without errors. ### To Reproduce. ```. setup kokkos (with CUDA backend), root, gcc, cmake. git clone git@github.com:cgleggett/FCS-GPU.git src. mkdir bld; cd bld. cmake ../src/FastCaloSimAnalyzer/ -DENABLE_XROOTD=Off -DENABLE_GPU=on -DINPUT_PATH=/tmp -DCMAKE_CXX_STANDARD=17 -DUSE_KOKKOS=ON -DCMAKE_CXX_EXTENSIONS=Off. make -j. ```. ### Setup. root: v6.24 - v6.26. CUDA: 11.6, 11.7 (OK with 11.5). gcc: 9.3 - 11.2. OS: Centos 7. ROOT was built with:. ```. cmake -DCMAKE_CXX_STANDARD=17 -DCMAKE_CXX_EXTENSIONS=Off -DCMAKE_INSTALL_PREFIX=/opt/root/v6-26-06_gcc1",MatchSource.ISSUE,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/issues/11511
